nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12382.0,1177.0,"[H-01] receiveCollateral() can be called by anyone
In StabilityPool.sol, the `receiveCollateral()` function should be called by ActivePool per comments, but anyone can call it passing in `_tokens` and `_amounts` args to update stability pool balances.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";



contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    
    ISortedTroves internal sortedTroves;

    
    uint256 internal totalYUSDDeposits;

    
    
    
    newColls internal totalColl;

    

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; 

    
    mapping(address => Snapshots) public depositSnapshots; 

    mapping(address => FrontEnd) public frontEnds; 
    mapping(address => uint256) public frontEndStakes; 
    mapping(address => Snapshots) public frontEndSnapshots; 

    
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    
    uint128 public currentScale;

    
    uint128 public currentEpoch;

    
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    
    uint256 public lastYETIError;
    
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    

    
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    

    
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        
        
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    

    
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); 
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    


    
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    

    
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    
    
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    
    
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    

    
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    
    
    
    
    
    
    
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            
            compoundedStake = 0;
        }

        
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    

    
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    

    
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    
    
    
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",7250.0,1,0,"Identifying potential vulnerabilities
I’m piecing together potential security issues in the provided Solidity smart contract by examining areas such as reentrancy, integer overflows, access controls, initialization, handling of external calls, event emissions, logic errors, gas usage, and the handling of untrusted inputs.
Evaluating contract structure
I’m analyzing the contract’s imports, inheritance, and state variables. The renunciation of ownership after setting addresses can potentially lead to unalterable contract states.
Navigating withdrawal
Users can withdraw YUSD from the pool, ensuring the frontEnd is registered or the tag is zero. The process involves updating state variables and emitting events post-state update.
Ensuring precision
I’m verifying the steps for partial withdrawal to confirm no under-collateralized troves and accurate YUSDtoWithdraw computation. Secure YETI issuance and event emission are also considered.
Highlighting key functions
I'm mapping out functions like _calculateGains for YETI gains, registerFrontEnd for kickback rate setup, and receiveCollateral to manage collateral from ActivePool.
Examining potential vulnerabilities
I’m noting potential vulnerabilities such as reentrancy, misconfigured initialization from setAddresses, unauthorized access to addCollateralType, and manipulable frontEnd logic affecting stakes and kickback rates.
Identifying potential risks
I’m digging into integer precision issues, gas usage concerns in large arrays, and potential gains manipulation, ensuring calculations like YUSDLoss are accurate to prevent depositor exploitation.
Mitigating risks
I’m noting that relying on SafeERC20 helps against reentrancy, despite some token vulnerabilities. Address setting needs heightened security to prevent maliciously setting addresses before ownership relinquishment.
Assessing reentrancy risk
I'm noting that without a reentrancy guard, the contract might be exposed to reentrancy attacks, especially during token transfers. The lack of a reentrancy guard could leave the contract vulnerable.
Assessing security gaps
I'm focusing on vulnerabilities such as reentrancy risks due to external calls and issues with ownership and initialization, particularly concerning the improper setting of key addresses.
Identifying vulnerabilities
I'm highlighting risks such as reentrancy due to missing guards, ownership mismanagement in setAddresses, potential gas exhaustion in loops, and frontEnd manipulation of kickback rates.
Addressing high rates
High kickback rates, while capped at 100%, could disrupt the Stability Pool's incentives. Additionally, tampered whitelists or calculation rounding errors might open doors for economic exploits.
Assessing compound stakes
I'm investigating the _getCompoundedStakeFromSnapshots function's behavior when scaleDiff > 1, ensuring it doesn't result in unintended benefits for users.
Confirming function consistency
I’m ensuring the consistency of lastYUSDLossError_Offset usage in _computeRewardsPerUnitStaked and _offset, confirming it functions correctly as a single uint256.
Evaluating contract mechanisms
I’m noting the lack of a pausable mechanism, potential input validation issues in token arrays, front-running risks due to function order of operations, and the absence of deposit size limits.
Confirming secure practices
I’m verifying that mappings and structs are utilized without overlaps, all transfers use SafeERC20, and the use of Solidity 0.6.11 is up-to-date with security features.
","Analyzing the provided Solidity smart contract for the `StabilityPool`, several potential vulnerabilities and areas of concern have been identified. Below is a comprehensive list of these vulnerabilities, along with explanations and suggestions for mitigation:

### 1. **Reentrancy Vulnerabilities**

**Description:**
Reentrancy attacks occur when an external contract calls back into the vulnerable contract before the first invocation is finished, potentially manipulating the contract's state in unintended ways.

**Affected Functions:**
- `provideToSP`
- `withdrawFromSP`
- `_sendGainsToDepositor`
- `_sendYUSDToDepositor`
- `offset`

**Issues Identified:**
- **Lack of Reentrancy Guards:** The contract does not implement a reentrancy guard (e.g., the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard`). Although state updates generally occur before external calls, the absence of explicit reentrancy protection increases the risk, especially if any external contracts (like `IWAsset` or `IERC20`) have callback mechanisms.
  
- **External Calls After State Changes:** Functions like `_sendGainsToDepositor` and `_sendYUSDToDepositor` perform external token transfers after updating internal state. If the external token contracts have malicious fallback functions, they could attempt to re-enter the `StabilityPool` contract during these transfers.

**Mitigation:**
- **Implement Reentrancy Guards:** Introduce a reentrancy guard using the `nonReentrant` modifier to critical functions that perform external calls.
  
  ```solidity
  import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";

  contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool, ReentrancyGuard {
      // ...
      
      function provideToSP(uint256 _amount, address _frontEndTag) external override nonReentrant {
          // Function implementation
      }

      function withdrawFromSP(uint256 _amount) external override nonReentrant {
          // Function implementation
      }

      // Similarly, apply nonReentrant to other vulnerable functions
  }
  ```

- **Use Checks-Effects-Interactions Pattern:** Ensure that all state changes (effects) are made before any external interactions (interactions).

### 2. **Ownership and Initialization Risks**

**Description:**
The `setAddresses` function allows the contract owner to set critical contract addresses and then renounces ownership. If misused, this could lead to irreversible misconfiguration.

**Issues Identified:**
- **Single Initialization Opportunity:** The `setAddresses` function can only be called once (since it renounces ownership afterward). If the owner accidentally sets incorrect or malicious addresses, it could compromise the entire system without a way to rectify the mistake.

- **Lack of Initialization Checks:** There are no checks to ensure that `setAddresses` can only be called once, relying solely on the owner renouncing ownership afterward.

**Mitigation:**
- **Implement Initialization Flags:** Use a boolean flag to ensure `setAddresses` can only be called once, preventing accidental multiple initializations.

  ```solidity
  bool private addressesSet = false;

  function setAddresses(
      // parameters
  ) external override onlyOwner {
      require(!addressesSet, ""Addresses already set"");
      // Existing implementation
      addressesSet = true;
      _renounceOwnership();
  }
  ```

- **Separate Initialization and Ownership Renouncement:** Consider separating the initialization logic from ownership renouncement to allow for more flexible and safer deployment processes.

### 3. **Unbounded Loops Leading to Denial of Service (DoS)**

**Description:**
Functions that iterate over dynamic arrays without limits can become prohibitively expensive in terms of gas, potentially leading to DoS if the arrays grow too large.

**Affected Functions:**
- `_sendGainsToDepositor`
- `_calculateGains`
- `addCollateralType` (indirectly via `lastAssetError_Offset`)

**Issues Identified:**
- **Dynamic Array Iterations:** Functions like `_sendGainsToDepositor` loop over arrays of assets and amounts. As the number of collateral types increases, the gas required for these loops also increases, potentially making transactions fail once a gas limit is reached.

- **Growing Storage Arrays:** The `lastAssetError_Offset` array grows indefinitely with each new collateral type added via `addCollateralType`, which could exacerbate gas consumption in related functions.

**Mitigation:**
- **Limit the Number of Collateral Types:** Impose a maximum number of collateral types that can be added to prevent unbounded growth.

  ```solidity
  uint256 public constant MAX_COLLATERAL_TYPES = 100;

  function addCollateralType(address _collateral) external override {
      _requireCallerIsWhitelist();
      require(totalColl.tokens.length < MAX_COLLATERAL_TYPES, ""Max collateral types reached"");
      lastAssetError_Offset.push(0);
      totalColl.tokens.push(_collateral);
      totalColl.amounts.push(0);
  }
  ```

- **Optimize Data Structures:** Use more gas-efficient data structures or algorithms to handle large datasets, potentially leveraging mappings instead of arrays where appropriate.

- **Batch Processing:** Allow operations to be processed in smaller batches to distribute gas costs across multiple transactions.

### 4. **FrontEnd Manipulation and Incentive Risks**

**Description:**
FrontEnds can register with a `kickbackRate` up to `DECIMAL_PRECISION` (1e18), which represents 100%. High kickback rates could potentially lead to economic imbalances or exploitative scenarios.

**Issues Identified:**
- **High Kickback Rates:** While the contract enforces that `kickbackRate <= DECIMAL_PRECISION`, allowing a 100% kickback rate could enable FrontEnds to capture all YETI gains, leaving depositors with no rewards and possibly discouraging participation.

**Mitigation:**
- **Restrict Kickback Rates:** Impose stricter upper limits on `kickbackRate` to ensure FrontEnds cannot capture an excessive portion of rewards.

  ```solidity
  uint256 public constant MAX_KICKBACK_RATE = 5e17; // 50%

  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
      require(
          _kickbackRate <= MAX_KICKBACK_RATE,
          ""SP:Invalid Kickback rate""
      );
  }
  ```

- **Implement Dynamic Adjustment Mechanisms:** Allow the protocol to adjust kickback rates based on economic conditions or governance decisions to maintain balance.

### 5. **Reliance on External Contracts and Interfaces**

**Description:**
The `StabilityPool` relies heavily on external contracts (e.g., `IYUSDToken`, `ICommunityIssuance`, `IActivePool`, `IWhitelist`). If any of these contracts are compromised or behave maliciously, it could adversely affect the `StabilityPool`.

**Issues Identified:**
- **Trust Assumptions:** The security of the `StabilityPool` is contingent upon the correctness and security of all imported interfaces and their implementations.

- **Lack of Version Control:** The contract does not enforce specific versions or interfaces beyond the initial imports, potentially leading to mismatches or vulnerabilities if external contracts are upgraded or changed.

**Mitigation:**
- **Audit External Contracts:** Ensure that all external contracts and interfaces are thoroughly audited and trusted.

- **Use Immutable References:** Where possible, use immutable or fixed references to external contracts to prevent unauthorized changes.

- **Implement Access Controls and Verification:** Incorporate mechanisms to verify the integrity and behavior of external contracts during interactions.

### 6. **Potential Rounding and Precision Errors in Calculations**

**Description:**
The contract performs multiple divisions and multiplications, especially in reward calculations. Even with `SafeMath`, integer division truncates decimals, leading to potential rounding errors that can accumulate over time.

**Issues Identified:**
- **Accumulation of Errors:** Repeated rounding errors in functions like `_computeYETIPerUnitStaked`, `_calculateGains`, and `_getYETIGainFromSnapshots` can lead to significant discrepancies in rewards distribution.

- **Loss of Precision:** Critical financial calculations may lose precision, affecting the fairness and accuracy of rewards and penalties.

**Mitigation:**
- **Use Higher Precision Arithmetic:** Consider using higher precision arithmetic or fixed-point libraries to minimize rounding errors.

- **Implement Error Correction Mechanisms:** Accumulate and distribute rounding errors appropriately to maintain overall system accuracy.

- **Thorough Testing:** Rigorously test all financial calculations under various scenarios to identify and rectify precision-related issues.

### 7. **Unbounded Growth of `lastAssetError_Offset` Array**

**Description:**
Each time a new collateral type is added via `addCollateralType`, the `lastAssetError_Offset` array is appended. Over time, this array can grow indefinitely, increasing gas costs for operations that interact with it.

**Issues Identified:**
- **Gas Consumption:** As the array grows, functions that read or modify it will require more gas, potentially leading to failed transactions or increased operational costs.

**Mitigation:**
- **Limit the Number of Collateral Types:** As previously suggested, impose a maximum limit on collateral types to control array growth.

- **Use Mappings Instead of Arrays:** Replace the array with a mapping to store `lastAssetError_Offset`, which can offer more efficient storage and access patterns.

  ```solidity
  mapping(address => uint256) public lastAssetError_OffsetMap;

  function addCollateralType(address _collateral) external override {
      _requireCallerIsWhitelist();
      require(totalColl.tokens.length < MAX_COLLATERAL_TYPES, ""Max collateral types reached"");
      lastAssetError_OffsetMap[_collateral] = 0;
      totalColl.tokens.push(_collateral);
      totalColl.amounts.push(0);
  }
  ```

### 8. **Potential Front-running Attacks**

**Description:**
Certain operations may be susceptible to front-running, where an attacker can manipulate transaction ordering to gain unfair advantages.

**Issues Identified:**
- **High-Value Transactions:** Functions that involve significant value transfers or state changes (e.g., `provideToSP`, `withdrawFromSP`, `offset`) could be targets for front-running if attackers can predict and manipulate transaction ordering.

**Mitigation:**
- **Implement Commit-Reveal Schemes:** Use commit-reveal patterns to obfuscate sensitive operations until they are executed.

- **Use Time Delays:** Introduce delays between action initiation and execution to reduce the feasibility of front-running.

- **Incentivize Honest Behavior:** Design economic incentives to discourage front-running, making it unprofitable for attackers.

### 9. **Missing Pausable Mechanism**

**Description:**
The contract lacks a mechanism to pause operations in case of an emergency or detected vulnerability, limiting the ability to mitigate issues post-deployment.

**Issues Identified:**
- **Inability to Respond to Emergencies:** Without a pausable feature, the contract cannot be halted to prevent further damage if a vulnerability is exploited.

**Mitigation:**
- **Integrate Pausable Functionality:** Incorporate a pausable mechanism using OpenZeppelin's `Pausable` contract, allowing authorized accounts to pause and unpause critical functions.

  ```solidity
  import ""@openzeppelin/contracts/utils/Pausable.sol"";

  contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool, ReentrancyGuard, Pausable {
      // ...

      function provideToSP(uint256 _amount, address _frontEndTag) external override nonReentrant whenNotPaused {
          // Function implementation
      }

      function withdrawFromSP(uint256 _amount) external override nonReentrant whenNotPaused {
          // Function implementation
      }

      // Similarly, apply whenNotPaused to other critical functions

      // Functions to pause and unpause
      function pause() external onlyOwner {
          _pause();
      }

      function unpause() external onlyOwner {
          _unpause();
      }
  }
  ```

### 10. **Potential Logic Errors in Gain Calculations**

**Description:**
Errors in the logic for calculating gains, losses, and rewards could lead to unfair distributions, financial losses for users, or unintended economic incentives.

**Issues Identified:**
- **Incorrect Gain Calculations:** Functions like `_getGainFromSnapshots` and `_getYETIGainFromSnapshots` involve complex calculations that, if flawed, could misallocate rewards or losses.

- **Compounded Stake Logic:** In `_getCompoundedStakeFromSnapshots`, if `scaleDiff > 1`, the `compoundedStake` is set to 0. Depending on the intended behavior, this could result in unexpected loss of user deposits or incorrect reward allocations.

**Mitigation:**
- **Comprehensive Testing and Auditing:** Thoroughly test all financial logic under various scenarios to ensure correctness and fairness.

- **Simplify Calculations:** Where possible, simplify reward and loss calculations to reduce the risk of logic errors.

- **Implement Safeguards:** Introduce checks and balances within the calculation functions to prevent unintended outcomes.

### 11. **Handling of Wrapped Assets and External Contract Calls**

**Description:**
The contract interacts with wrapped assets through `IWAsset` interfaces, invoking functions like `endTreasuryReward` and `unwrapFor`. These interactions depend on the correct behavior of external contracts.

**Issues Identified:**
- **Untrusted Wrapped Contracts:** If `IWAsset` implementations are malicious or flawed, they could manipulate the `StabilityPool`'s state or drain funds.

- **Reentrancy Through Wrapped Assets:** Even with state updates occurring before external calls, malicious wrapped assets could exploit any residual vulnerabilities.

**Mitigation:**
- **Whitelist and Validate Wrapped Assets:** Ensure that only trusted and audited wrapped assets are allowed within the system.

- **Limit Interactions:** Restrict the contract's interactions with external wrapped assets to only essential functions and validate responses.

- **Implement Interface Checks:** Ensure that external contracts conform strictly to their expected interfaces to prevent unexpected behaviors.

### 12. **Use of Older Solidity Version (0.6.11)**

**Description:**
The contract uses Solidity version 0.6.11, which lacks several security features and optimizations introduced in later versions.

**Issues Identified:**
- **Missed Security Improvements:** Newer Solidity versions include enhanced security checks, better syntax, and more efficient features that can prevent vulnerabilities.

- **Potential Compiler Bugs:** Older compiler versions might have undiscovered bugs or vulnerabilities that have been fixed in newer releases.

**Mitigation:**
- **Upgrade Solidity Version:** Where feasible, migrate the contract to a newer Solidity version (e.g., 0.8.x) to leverage improved security features and optimizations.

  **Note:** Upgrading requires thorough testing and potentially significant code refactoring to accommodate breaking changes.

### 13. **Missing Input Validation on Arrays**

**Description:**
Functions that accept arrays as input (e.g., `offset`, `provideToSP`, `withdrawFromSP`) do not consistently validate the length or contents of these arrays, which could lead to unexpected behavior or vulnerabilities.

**Issues Identified:**
- **Mismatch in Array Lengths:** Inconsistent lengths between `_tokens` and `_amountsAdded` can lead to incorrect mappings and potential loss or misallocation of funds.

**Mitigation:**
- **Consistently Validate Array Lengths:** Ensure that all functions handling multiple arrays validate that corresponding arrays are of equal length.

  ```solidity
  function _sendGainsToDepositor(
      address _to,
      address[] memory assets,
      uint256[] memory amounts
  ) internal {
      uint256 assetsLen = assets.length;
      require(assetsLen == amounts.length, ""SP: Length mismatch"");
      // Function implementation
  }
  ```

- **Sanitize and Validate Inputs:** Beyond length checks, validate the contents of arrays to ensure they contain valid and expected data (e.g., non-zero addresses, positive amounts).

### 14. **Potential Front-End Tag Mismanagement**

**Description:**
The contract allows depositors to associate their deposits with FrontEnds via `frontEndTag`. Mismanagement or malicious behavior by FrontEnds could impact the distribution of rewards.

**Issues Identified:**
- **Forced Association:** Users are required to set a `frontEndTag` during `provideToSP`. If FrontEnds act maliciously, they could manipulate the kickback rates or staking mechanisms to siphon rewards.

**Mitigation:**
- **Allow FrontEnd Association Flexibility:** Permit users to change or remove their `frontEndTag` without requiring them to maintain a deposit, enhancing user control.

- **Implement Verification Mechanisms:** Ensure that FrontEnds meet certain criteria or undergo verification before being allowed to receive `frontEndTag` associations.

### 15. **Potential Mismanagement of YUSDLossError_Offset**

**Description:**
The variable `lastYUSDLossError_Offset` is used to track errors in YUSD loss calculations. Incorrect handling could lead to inconsistent loss distributions.

**Issues Identified:**
- **State Consistency:** Ensuring that `lastYUSDLossError_Offset` accurately tracks rounding errors is critical. Miscalculations could skew loss distributions unfairly.

**Mitigation:**
- **Comprehensive Auditing of Calculation Logic:** Review and test the logic handling `lastYUSDLossError_Offset` to ensure accuracy and consistency.

- **Implement Safeguards Against Overflows/Underflows:** Although `SafeMath` is used, additional checks can prevent unexpected behavior in edge cases.

### 16. **Inadequate Event Emissions**

**Description:**
While the contract emits numerous events, ensuring that all critical state changes are appropriately logged is essential for transparency and auditing.

**Issues Identified:**
- **Missing Events:** Certain state changes, especially those involving complex calculations or multiple state variables, might not emit sufficient events to track changes effectively.

**Mitigation:**
- **Ensure Comprehensive Event Logging:** Review all state-changing functions to confirm that they emit events capturing all relevant information for off-chain monitoring and auditing.

### 17. **Potential for Misaligned Epochs and Scales**

**Description:**
The contract uses `epoch` and `scale` variables to manage reward distributions. Misalignment or incorrect updates to these variables could disrupt the reward mechanism.

**Issues Identified:**
- **Incorrect Epoch/Scale Updates:** Functions that modify `epoch` and `scale` must ensure consistent updates to prevent mismatches in reward calculations.

**Mitigation:**
- **Implement Consistent Update Mechanisms:** Ensure that all functions modifying `epoch` and `scale` follow a strict protocol to maintain alignment across the system.

- **Add Checks to Prevent Mismatches:** Incorporate validation steps to verify that `epoch` and `scale` are updated correctly in relation to other state variables.

### 18. **Missing Fallback or Receive Functions**

**Description:**
The contract does not include fallback or receive functions to handle unexpected Ether transfers.

**Issues Identified:**
- **Accidental Ether Reception:** Without fallback or receive functions, sending Ether to the contract might result in locked funds or failed transactions.

**Mitigation:**
- **Implement Receive and Fallback Functions:** Depending on the intended behavior, add `receive` and/or `fallback` functions to handle or reject Ether transfers gracefully.

  ```solidity
  receive() external payable {
      revert(""SP: No Ether accepted"");
  }

  fallback() external payable {
      revert(""SP: No Ether accepted"");
  }
  ```

### 19. **Potential Misuse of Internal Helper Functions**

**Description:**
Internal functions like `_leftSubColls` and `_leftSumColls` are used to manipulate collateral balances. If these functions contain bugs or are improperly implemented, they could lead to incorrect state updates.

**Issues Identified:**
- **Undefined Implementations:** The implementations of `_leftSubColls` and `_leftSumColls` are not provided, making it unclear whether they handle edge cases correctly.

**Mitigation:**
- **Provide Comprehensive Implementations:** Ensure that all internal helper functions are correctly implemented, thoroughly tested, and handle all possible edge cases.

- **Audit Helper Functions:** Regularly audit these functions to confirm their correctness and security.

### 20. **Potential Gas Limit Exceedance in Complex Operations**

**Description:**
Complex operations involving multiple state changes and external calls can exceed block gas limits, causing transactions to fail.

**Issues Identified:**
- **High Gas Consumption:** Functions like `provideToSP` and `withdrawFromSP` perform multiple operations, including loops and external calls, which can lead to high gas usage.

**Mitigation:**
- **Optimize Gas Usage:** Refactor functions to minimize gas consumption, such as reducing the number of state changes or simplifying logic.

- **Implement Gas-Efficient Patterns:** Utilize gas-efficient programming patterns and data structures to lower overall gas costs.

- **Encourage Batch Processing:** Allow users to perform actions in smaller, more manageable batches to distribute gas costs.

---

**Conclusion:**

While the `StabilityPool` contract incorporates several security best practices, such as using `SafeMath` and `SafeERC20`, it still exhibits multiple potential vulnerabilities that could compromise its integrity and functionality. Addressing the issues outlined above through careful code auditing, implementing recommended mitigations, and adhering to Solidity best practices is crucial to enhancing the contract's security posture.
","### **[H-01] receiveCollateral() can be called by anyone**

**Report Description**:
In `StabilityPool.sol`, the `receiveCollateral()` function should only be called by `ActivePool`, but it can be invoked by anyone. This could lead to unauthorized access, potentially allowing any user to manipulate the stability pool’s collateral balances by passing `_tokens` and `_amounts`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue of improper access control in `receiveCollateral()` is not addressed in the response list. The problem lies in the lack of proper authorization for who can invoke the `receiveCollateral()` function, which can lead to unauthorized state modifications. This issue should be resolved by implementing access control mechanisms such as the `onlyActivePool` modifier to ensure only the intended contract can interact with this function.

**Suggestions**:
- Implement an `onlyActivePool` modifier in the `receiveCollateral()` function to restrict access to only the `ActivePool` contract. Additionally, ensure that the correct role-based access control (RBAC) mechanisms are in place.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-01] Reentrancy Vulnerabilities**

**Response Description**:
The response discusses reentrancy vulnerabilities that can occur when an external contract calls back into the vulnerable contract before the first invocation finishes. This might manipulate the contract state in unintended ways, especially in functions like `provideToSP`, `withdrawFromSP`, and `_sendGainsToDepositor`.

**Assessment**:
**Valid Concern**. While this issue is not directly related to the `receiveCollateral()` problem, the report correctly identifies reentrancy as a potential vulnerability. Given the complexity of interactions and external calls in smart contracts, it's important to apply the ""checks-effects-interactions"" pattern and utilize reentrancy guards like `nonReentrant` to mitigate this risk. This response adds value to the overall security posture of the contract, though it does not directly address the original issue of unauthorized function access.

**Recommendations**:
- Implement reentrancy guards where necessary (e.g., on functions interacting with external contracts).
- Ensure that state changes occur before external calls to prevent reentrancy attacks.

---

**Summary of Matches and Gaps**

**Correct Matches**:
- **None**

**Partially Correct Matches**:
- **[R-01] Reentrancy Vulnerabilities**: Although not related to the issue at hand, the response identifies potential vulnerabilities and suggests relevant security practices, contributing to overall contract security.

**Missed Issues from Issue Report**:
- **[H-01] receiveCollateral() can be called by anyone**: The issue of improper access control in the `receiveCollateral()` function is not addressed in the response list.

**GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Reentrancy Vulnerabilities**: A valid concern for other parts of the contract, though unrelated to the original issue of unauthorized function access in `receiveCollateral()`.
",0,0,1,20,"```
None.
```",0.0
sYetiToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; // Underflow is checked
                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3595.0,338.0,"[H-02] Yeti token rebase checks the additional token amount incorrectly
function `rebuse`, `effectiveYetiTokenBalance`
`yetiToken.balance - effectiveYetiTokenBalance`
The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to effectiveYetiTokenBalance during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.
The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users’ claims. In other words, the contract will be in default if enough users claim after that.
 
[M-01] Wrong `lastBuyBackPrice`
The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:
“function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner “
It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap path parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).",2.0,"pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}












contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    
    
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    
    mapping(address => User) public users;
    
    mapping(address => mapping(address => uint256)) public override allowance;
    
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                users[to].balance = toUser.balance + shares128; 
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    
    
    
    
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    
    
    
    
    
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    
    
    
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    
    
    
    
    
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    
    
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        
        
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        
        

        
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        
        
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    
    
    
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",2343.0,1,1,"Identifying vulnerabilities
I’m parsing the Solidity smart contract for sYETI tokens, focusing on reentrancy and external calls like _burn.
Identifying weaknesses
I’m noting potential issues like malicious contract reentrancy, the accessibility of the setAddresses function, and public mint function risks, which could facilitate unauthorized token creation.
Assessing mint function risks
I'm examining the public mint function, potential rebase disruptions, and the validity of DOMAIN_SEPARATOR and approve front-running prevention. These aspects are essential for contract security.
Assessing minting safety
I'm curious about sendToSYETI, a function that might allow unlimited sYETI minting. Evaluating reentrancy risks in _burn function due to lack of automatic protection in Solidity 0.6.12.
Examining permit function
I’m looking at the permit function's encoding and nonce usage, which might risk signature replay or malleability due to non-compliance with EIP-712. Next, I’m determining the rebase function's potential impact.
Addressing potential issues
I’m noting publicBuyBack functionality, ERC20 approve race condition, and integer division precision in the burn function. Also, division by zero in _getValueOfContract if lastBuybackPrice is set.
Highlighting vulnerabilities
I'm noting the lack of restrictions on transferRatio, absence of fallback or receive functions, and the absence of a pausing mechanism. These issues could lead to various vulnerabilities.
Identifying significant risks
I’m outlining vulnerabilities like reentrancy in _burn and _transfer, division by zero in _getValueOfContract, and the rebase function's unrestricted access. These could impact the contract's security.
","Analyzing Solidity smart contracts for vulnerabilities is crucial to ensure their security and reliability. Below is a comprehensive analysis of the provided `sYETIToken` contract, highlighting potential vulnerabilities and areas of concern:

### 1. **Public `mint` Function Allows Arbitrary Token Minting**

- **Issue**: The `mint` function is marked as `public`, enabling any user to call it. This function allows users to mint `sYETI` tokens by invoking `yetiToken.sendToSYETI(msg.sender, amount)`.
  
- **Potential Exploit**:
  - **Unauthorized Minting**: If the `sendToSYETI` function in the `IYETIToken` interface does not have proper access controls, malicious actors could mint an arbitrary number of `sYETI` tokens, leading to inflation and devaluation of the token.
  
- **Recommendation**:
  - **Restrict Access**: Consider restricting the `mint` function to authorized roles (e.g., only the owner or a designated minter role) using modifiers like `onlyOwner` or a custom role-based access control mechanism.
  - **Validate External Calls**: Ensure that `sendToSYETI` enforces necessary checks, such as verifying that the sender has sufficient `YETI` tokens to back the minted `sYETI` tokens.

### 2. **Incorrect Implementation of EIP-2612 `permit` Function**

- **Issue**: The `permit` function's implementation does not fully comply with the [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612) standard, particularly in the way the digest is constructed for signature verification.

- **Potential Exploit**:
  - **Signature Replay or Forgery**: Improper construction of the message digest can allow attackers to replay or forge permits, potentially setting allowances without the owner's consent.
  
- **Specific Concerns**:
  - **DOMAIN_SEPARATOR**: The `DOMAIN_SEPARATOR` is defined but not correctly integrated into the digest.
  - **Permit Structure**: The encoding used (`abi.encode(PERMIT_SIGNATURE_HASH, ...)`) does not align with the EIP-712 structured data hashing, which could lead to vulnerabilities in signature verification.

- **Recommendation**:
  - **Adhere to EIP-2612**: Reimplement the `permit` function following the EIP-2612 standard. Utilize the `EIP712` library to correctly construct the domain separator and the permit struct for hashing.
  - **Use Existing Libraries**: Leverage well-audited libraries like OpenZeppelin's `ERC20Permit` to ensure compliance and security.

### 3. **Reentrancy Vulnerabilities in `_burn` and `_transfer` Functions**

- **Issue**: Both `_burn` and `_transfer` functions make external calls to the `yetiToken` contract after updating the state.

- **Potential Exploit**:
  - **Reentrancy Attack**: If `yetiToken` is a malicious contract or becomes compromised, it could re-enter the `sYETIToken` contract during the external call, potentially manipulating the state in unintended ways (e.g., double-burning tokens).

- **Recommendation**:
  - **Use Reentrancy Guards**: Implement a reentrancy guard (e.g., using OpenZeppelin's `ReentrancyGuard`) to prevent reentrant calls during sensitive operations.
  - **Follow Checks-Effects-Interactions Pattern**: Ensure that all state changes are completed before making external calls to minimize the risk of reentrancy.

### 4. **Potential Division by Zero in `_getValueOfContract` Function**

- **Issue**: The `_getValueOfContract` function performs a division operation using `lastBuybackPrice`. If `lastBuybackPrice` is zero (which can occur before any buyback has been executed), this will result in a division by zero error, causing the transaction to revert.

- **Potential Exploit**:
  - **Denial of Service**: An attacker could exploit this by calling the `rebase` function before any buyback has occurred, effectively preventing the contract from performing a rebase.

- **Recommendation**:
  - **Initialize `lastBuybackPrice`**: Set an initial non-zero value for `lastBuybackPrice` during contract deployment to avoid division by zero.
  - **Add Checks**: Modify the `_getValueOfContract` function to include a check that ensures `lastBuybackPrice` is not zero before performing the division.

  ```solidity
  function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
      require(lastBuybackPrice > 0, ""lastBuybackPrice is zero"");
      uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
      return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
  }
  ```

### 5. **Unrestricted Access to `rebase` Function**

- **Issue**: The `rebase` function is marked as `external` without any access restrictions, allowing any user to call it.

- **Potential Exploit**:
  - **Gas Consumption**: Malicious actors could repeatedly call `rebase`, leading to unnecessary gas consumption and potentially disrupting contract operations.
  - **State Manipulation**: Although the function is designed to adjust `effectiveYetiTokenBalance`, frequent calls could lead to unintended state changes or economic implications for token holders.

- **Recommendation**:
  - **Restrict Access**: Limit the ability to call `rebase` to specific roles (e.g., only the owner or an authorized rebasing mechanism).
  - **Implement Rate Limiting**: Ensure that the function can only be called at defined intervals, which is partially addressed by the timestamp check but could be further reinforced.

### 6. **Approval Race Condition in `approve` Function**

- **Issue**: The `approve` function allows setting allowances directly, which can lead to the well-known ERC20 approval race condition where an allowance change might be exploited by front-running attacks.

- **Potential Exploit**:
  - **Allowance Exploitation**: An attacker could exploit the race condition by spending the old and new allowance if a user changes their allowance in a way that isn't atomic.

- **Recommendation**:
  - **Use Safe Approve Patterns**: Encourage the use of `increaseAllowance` and `decreaseAllowance` functions to adjust allowances safely.
  - **Emit Events Appropriately**: Ensure that all allowance changes emit events to allow users to track and respond to changes.

### 7. **Unbounded `transferRatio` Manipulation by Owner**

- **Issue**: The `transferRatio` can be set by the owner to any value up to `1e18`. While the contract enforces `transferRatio <= 1e18`, setting it to extreme values (e.g., `0` or `1e18`) can have significant effects on the `rebase` logic.

- **Potential Exploit**:
  - **Economic Manipulation**: The owner could set `transferRatio` to manipulate the proportion of `YETI` tokens rebased, potentially devaluing `sYETI` tokens or disrupting the tokenomics.

- **Recommendation**:
  - **Implement Range Constraints**: Define a more restrictive range for `transferRatio` that aligns with the intended economic model.
  - **Timelock or Multi-Signature for Critical Changes**: Use a timelock or multi-signature mechanism for changing critical parameters like `transferRatio` to prevent unilateral and potentially malicious changes.

### 8. **No Reentrancy Protection in External Calls**

- **Issue**: The contract makes external calls to `yetiToken.sendToSYETI` and `yetiToken.transfer` without reentrancy protection.

- **Potential Exploit**:
  - **Reentrancy Attacks**: If `yetiToken` is malicious or compromised, it could exploit reentrancy to manipulate the contract's state during these external calls.

- **Recommendation**:
  - **Implement Reentrancy Guards**: Use a reentrancy guard to prevent reentrant calls during functions that make external calls.
  - **Follow Checks-Effects-Interactions Pattern**: Ensure all state changes are performed before any external interactions to minimize vulnerability windows.

### 9. **Inadequate Validation of External Router Addresses**

- **Issue**: The `buyBack` and `publicBuyBack` functions rely on `validRouters` to determine if a router address is permitted. However, the management of this mapping is entirely controlled by the owner.

- **Potential Exploit**:
  - **Router Manipulation**: If the owner's private key is compromised, an attacker could add malicious routers to the `validRouters` mapping, enabling unauthorized token swaps or draining funds.

- **Recommendation**:
  - **Decentralize Router Management**: Consider multi-signature approvals or a decentralized governance mechanism for managing valid routers.
  - **Implement Router Verification**: Ensure that added routers adhere to specific standards or originate from a trusted list to prevent the addition of malicious routers.

### 10. **Potential Integer Truncation and Precision Loss**

- **Issue**: The contract performs multiple division and multiplication operations that could result in integer truncation or precision loss, especially when dealing with large or fractional values.

- **Potential Exploit**:
  - **Economic Inconsistencies**: Precision loss can lead to discrepancies in token balances, rebasing amounts, or buyback calculations, affecting the fairness and stability of the token economy.

- **Recommendation**:
  - **Use Higher Precision Arithmetic**: Where possible, use fixed-point libraries or increase the precision of calculations to minimize truncation errors.
  - **Audit Mathematical Operations**: Thoroughly review all mathematical operations to ensure they handle edge cases and maintain the integrity of token balances.

### 11. **Missing `receive` and `fallback` Functions**

- **Issue**: The contract does not implement `receive` or `fallback` functions, which means it cannot handle direct ETH transfers.

- **Potential Impact**:
  - **Unexpected Behavior**: Users attempting to send ETH directly to the contract may have their transactions reverted, leading to confusion or loss of funds if not handled gracefully.

- **Recommendation**:
  - **Implement Fallback Mechanisms**: If the contract is intended to handle ETH, implement appropriate `receive` and/or `fallback` functions. Otherwise, consider explicitly rejecting ETH transfers with a clear error message.

### 12. **Lack of Pausable Mechanism**

- **Issue**: The contract lacks a mechanism to pause critical functions in case of an emergency or detected vulnerability.

- **Potential Exploit**:
  - **Inability to Respond to Attacks**: Without the ability to pause operations, the contract cannot be halted during an attack or exploit, potentially leading to greater damage.

- **Recommendation**:
  - **Integrate Pausability**: Incorporate a pausability feature (e.g., using OpenZeppelin's `Pausable` contract) that allows authorized roles to pause and resume contract operations as needed.

### 13. **No Mechanism to Recover Stuck Tokens**

- **Issue**: The contract does not provide a method to recover tokens that are accidentally sent to it, other than the `burn` functions.

- **Potential Impact**:
  - **Permanent Loss of Tokens**: Users might unintentionally send tokens to the contract address, leading to permanent loss if no recovery mechanism exists.

- **Recommendation**:
  - **Implement Recovery Functions**: Provide functions that allow the contract owner or authorized roles to recover specific tokens sent to the contract, with appropriate safeguards to prevent misuse.

### 14. **Potential Gas Optimization Issues**

- **Issue**: The contract could benefit from gas optimizations to reduce transaction costs and improve efficiency.

- **Potential Impact**:
  - **Higher Operational Costs**: Inefficient code can lead to higher gas usage, making interactions with the contract more expensive for users.

- **Recommendation**:
  - **Optimize Storage Access**: Minimize redundant storage reads and writes.
  - **Use `immutable` or `constant` Where Applicable**: This can save gas by reducing the need to read from storage.

### 15. **Event Emissions May Not Cover All State Changes**

- **Issue**: While the contract emits events for transfers and approvals, not all state-changing functions emit corresponding events (e.g., `mint`, `burn`, `rebase`, `buyBack`).

- **Potential Impact**:
  - **Lack of Transparency**: Without comprehensive event logging, it's harder for users and developers to track and verify state changes, which can hinder auditing and monitoring.

- **Recommendation**:
  - **Emit Events for All State Changes**: Ensure that every function that modifies the state emits appropriate events to facilitate transparency and ease of tracking.

---

### **Summary of Critical Vulnerabilities**

1. **Public `mint` Function**: Allows unauthorized minting of `sYETI` tokens if not properly restricted.
2. **Incorrect `permit` Implementation**: Deviates from EIP-2612, risking signature-related attacks.
3. **Reentrancy Risks**: External calls without protection can be exploited for reentrancy attacks.
4. **Division by Zero in `rebase`**: Potential for transactions to revert if `lastBuybackPrice` is zero.
5. **Unrestricted `rebase` Access**: Allows any user to trigger `rebase`, which could disrupt contract operations.

Addressing these vulnerabilities is paramount to ensuring the security and integrity of the `sYETIToken` contract. It is highly recommended to conduct a thorough security audit and consider integrating industry-standard best practices and libraries to mitigate these risks.
","### **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Report Description**:  
The rebase function checks the token amount incorrectly, leading to the potential inflation of the `effectiveYetiTokenBalance`. If the price of Yeti tokens increases after the rebase, the contract may falsely account for more tokens than it owns, creating a deficit. This could lead to users being over-allocated tokens that cannot be withdrawn, causing a potential contract default.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue regarding incorrect rebase calculations is not addressed in the response list. The vulnerability could lead to financial discrepancies and an eventual loss of user funds, which is a significant risk. The response list does not contain any mention of the rebase logic, token buyback mechanism, or how to properly adjust the `effectiveYetiTokenBalance` to match actual holdings. 

**Suggestions**:  
- Ensure that the rebase logic accurately tracks token balances post-rebase and adjusts for market changes or unexpected discrepancies in token supply.
- Implement a validation check to prevent over-allocation of tokens based on inaccurate token holdings after a rebase.

---

### **[M-01] Wrong `lastBuyBackPrice`**

**Report Description**:  
The `lastBuyBackPrice` is set based on the outcome of a swap that can depend on the path provided. If the swap path is not correctly handled (e.g., different lengths or variations in sorting), the price calculation will be inaccurate, which could lead to incorrect financial calculations in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue regarding the `lastBuyBackPrice` being set incorrectly due to swap path variations is not addressed in the response list. This is a critical issue because incorrect pricing may affect rebase operations or token valuations, leading to incorrect balances or potential exploits if the buyback mechanism is used maliciously.

**Suggestions**:  
- Ensure that the buyback logic uses a consistent and reliable method to calculate the buyback price, regardless of the swap path length.
- Incorporate checks that verify the expected order of tokens in the swap path and provide error handling for unexpected results.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-08] No Reentrancy Protection in External Calls**

**Response Description**:  
The contract makes external calls to `yetiToken.sendToSYETI` and `yetiToken.transfer` without reentrancy protection, making it vulnerable to reentrancy attacks if `yetiToken` is malicious or compromised.

**Assessment**:  
**Valid Concern**. This is a valid issue, though not explicitly mentioned in the original `{issue}`. Reentrancy vulnerabilities are a critical concern in Solidity contracts, especially when interacting with external contracts. The response recommends using a reentrancy guard to protect against this, which is a sound best practice.

**Suggestions**:  
- Apply a reentrancy guard (such as OpenZeppelin's `ReentrancyGuard`) on functions that make external calls to prevent reentrancy attacks.
- Ensure that all external calls are made after state changes following the **Checks-Effects-Interactions** pattern.

---

#### **[R-10] Missing `receive` and `fallback` Functions**

**Response Description**:  
The contract does not implement `receive` or `fallback` functions, meaning it cannot handle direct ETH transfers.

**Assessment**:  
**Valid Concern**. While this issue was not raised in the `{issue}` list, this is a good security and usability consideration. If the contract intends to handle ETH, it is essential to have a fallback mechanism to prevent reverted transactions. The lack of this could confuse users trying to send ETH to the contract, resulting in failed transactions.

**Suggestions**:  
- If the contract is designed to handle ETH, implement the `receive()` or `fallback()` functions.
- Alternatively, explicitly reject ETH transfers with a clear error message if the contract is not intended to accept ETH.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **None**

**Partially Correct Matches**:

- **None**

**Missed Issues from Issue Report**:

- **[H-02] Yeti token rebase checks the additional token amount incorrectly**: This issue is not addressed in the response list.
- **[M-01] Wrong `lastBuyBackPrice`**: This issue is also not addressed in the response list.

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-08] No Reentrancy Protection in External Calls**: A valid concern regarding external calls and reentrancy.
- **[R-10] Missing `receive` and `fallback` Functions**: A valid concern for handling ETH transfers correctly in the contract.

---

### **Suggestions for Improvement**

1. **Address Missing Issues**:  
   The issues regarding the rebase logic and incorrect buyback price handling are not covered in the response list but are critical for the stability of the contract. These should be added with specific recommendations to fix the problems.
   
2. **Additional Security Concerns**:  
   Consider adding fixes for the reentrancy vulnerability in external calls and implementing `receive`/`fallback` functions to prevent potential issues with ETH transfers.

3. **Enhance Mathematical Accuracy**:  
   Ensure that calculations related to token buybacks and rebasing accurately reflect the actual token balances in the contract, without overestimating holdings or underestimating liabilities.


",0,0,2,15,"```
None.
```",0.0
PriceFeed.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7613.0,799.0,"[M-02] Should check return data from Chainlink aggregators
Function `_getCurrentChainlinkResponse`, no checks on `lastRoundData`
The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.
Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";



contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  
    ITellorCaller public tellorCaller;  

    
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    
    uint constant public TIMEOUT = 14400;  

    
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; 

    
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; 

    
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        
        status = Status.chainlinkWorking;

        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    

    
    function fetchPrice() external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                
                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            
            return _storeChainlinkPrice(chainlinkResponse);
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    

    
    function fetchPrice_v() view external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) { 
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
         if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    

    
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.roundId == 0) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        
        try priceAggregator.decimals() returns (uint8 decimals) {
            
            chainlinkResponse.decimals = decimals;
        } catch {
            
            return chainlinkResponse;
        }

        
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        

        
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            
            return prevChainlinkResponse;
        }
    }
}",4598.0,0,1,"Assessing vulnerabilities
I’m analyzing a Solidity smart contract that utilizes Chainlink and Tellor oracles for fetching ETH/USD prices, examining dependencies and functions, and identifying potential security risks.
Identifying vulnerabilities
I’m assessing reentrancy, access control, SafeMath, try/catch usage, timestamp management, block variables, integer overflows/underflows, external calls, and proper initialization, especially after renouncing ownership.
Ensuring proper handling
I'm mapping out the need for accurate implementation of interfaces and the use of try/catch for external calls, especially safeguarding against underflows and preserving data integrity.
Focusing on vulnerabilities
I’m identifying potential risks such as oracle data manipulation, integer scaling issues, lastGoodPrice manipulation, reentrancy, SafeMath use, and lack of pausable functionality, especially if oracles are compromised.
Evaluating limitations
I'm noting the challenges of immediate renouncement of ownership, lack of dynamic function access, and concerns about oracle reliability, which could all potentially hinder contract flexibility and adaptability.
Highlighting potential issues
I’m noting the risks of minor manipulations with block.timestamp, complex oracle switching logic, fixed constants, reliance on lastGoodPrice, and assuming external contracts are secure.
Correcting parameter alignment
I’m addressing a minor issue with parameter names in _bothOraclesLiveAndUnbrokenAndSimilarPrice, ensuring the correct references in both function definition and usage.
Highlighting critical vulnerabilities
The primary concerns include the irreversible renouncement of contract ownership, dependence on potentially compromised external contracts, susceptibility to malicious oracle behavior, and lack of an emergency mechanism for incorrect setups or unresponsive oracles.
Addressing transparency and complexity
Noticing the risk of limited transparency due to the lack of emitted events and the potential for increased bugs due to the complexity of the contract's logic.
Addressing vulnerabilities
I'm mapping out issues like the need for careful initial setup, limited future updates post-ownership renouncement, potential oracle manipulation, and the risk of front-running attacks.
Highlighting structural issues
Revealing vulnerabilities like lack of updatable states, reliance on potentially compromised external contracts, and a complex state machine that might lead to unexpected behaviors.
","Analyzing the provided Solidity smart contract for vulnerabilities involves a thorough examination of its structure, logic, and interactions with external contracts. Below is a detailed analysis highlighting potential vulnerabilities, their implications, and recommendations for mitigation.

### 1. **Ownership Renouncement**

**Issue:**
- The `setAddresses` function, callable only by the owner, sets the addresses for `priceAggregator` and `tellorCaller`. After successful execution, it calls `_renounceOwnership()`, permanently removing the contract’s ownership.

**Implications:**
- **Irreversible Configuration:** Once ownership is renounced, there’s no way to update or change the oracle addresses (`priceAggregator` and `tellorCaller`). If these oracles become compromised, deprecated, or need to be upgraded, the contract cannot adapt.
- **Emergency Response Limitations:** In scenarios where an emergency action is required (e.g., pausing the contract due to detected anomalies), the inability to regain ownership hinders rapid response.

**Recommendations:**
- **Implement a Pausable Mechanism:** Instead of renouncing ownership immediately, consider implementing a `Pausable` contract allowing the owner to pause operations in emergencies.
- **Use Role-Based Access Control:** Utilize more granular access controls (e.g., `AccessControl` from OpenZeppelin) to allow specific roles to perform critical functions without fully renouncing ownership.
- **Delay Ownership Renouncement:** If renouncing ownership is essential, implement a timelock or delay mechanism to allow for potential reversal in case of unforeseen issues.

---

### 2. **Dependence on External Contracts**

**Issue:**
- The contract heavily relies on external contracts/interfaces: `AggregatorV3Interface` (Chainlink), `ITellorCaller` (Tellor), and others like `Ownable`, `SafeMath`, etc.

**Implications:**
- **External Contract Vulnerabilities:** If any of these external contracts have vulnerabilities or are malicious, they can directly impact the security and functionality of the `PriceFeed` contract.
- **Interface Mismatch:** Changes in the external contracts’ interfaces or behaviors (post-deployment) can lead to unexpected behavior or failures in the `PriceFeed` contract.

**Recommendations:**
- **Thoroughly Audit External Contracts:** Ensure that all imported contracts and interfaces are from reputable sources and have been audited for security.
- **Immutable References:** Where possible, lock the external contract addresses to prevent them from being updated to malicious contracts.
- **Fallback Mechanisms:** Implement fallback mechanisms or checks to handle unexpected behaviors or failures from external contracts gracefully.

---

### 3. **Complexity in Status Management**

**Issue:**
- The contract employs an intricate state machine (`Status` enum) to manage the statuses of Chainlink and Tellor oracles, leading to multiple conditional branches in `fetchPrice` and `fetchPrice_v`.

**Implications:**
- **Increased Risk of Logical Flaws:** Complex state management can introduce subtle bugs or unintended behaviors, especially in edge cases, potentially leading to incorrect price feeds or locked states.
- **Maintenance Challenges:** The high complexity makes the contract harder to maintain, audit, and reason about, increasing the likelihood of security oversights.

**Recommendations:**
- **Simplify State Management:** Refactor the state machine to reduce complexity. Consider limiting the number of states or using more straightforward logic to handle oracle statuses.
- **Comprehensive Testing:** Implement extensive unit and integration tests covering all possible state transitions and edge cases to ensure robustness.
- **Formal Verification:** Utilize formal verification tools to mathematically prove the correctness of the state transitions and overall logic.

---

### 4. **Potential Manipulation of `lastGoodPrice`**

**Issue:**
- The contract relies on `lastGoodPrice` as a fallback when both oracles are untrusted or frozen. This value is updated whenever a trusted price is fetched successfully.

**Implications:**
- **Stale Data Risks:** If both oracles become untrusted for an extended period, the contract continues to use `lastGoodPrice`, which might become outdated, leading to inaccurate pricing.
- **Initial `lastGoodPrice` Value:** If `setAddresses` is not called correctly or if both oracles are initially untrusted, `lastGoodPrice` might never be set, potentially defaulting to zero.

**Recommendations:**
- **Implement Data Freshness Checks:** Introduce mechanisms to ensure that `lastGoodPrice` is updated within a reasonable timeframe, or flag the contract as unusable if data becomes too stale.
- **Initialize `lastGoodPrice` Securely:** Ensure that `lastGoodPrice` is initialized with a valid and secure value during deployment or setup to prevent reliance on an uninitialized state.
- **Notify Off-Chain Systems:** Emit events or provide additional interfaces to inform off-chain systems when `lastGoodPrice` is being used, indicating potential issues with oracle data.

---

### 5. **Reliance on `block.timestamp`**

**Issue:**
- The contract uses `block.timestamp` to determine if oracle data is frozen based on a predefined `TIMEOUT`.

**Implications:**
- **Miner Manipulation:** Miners can manipulate `block.timestamp` within a certain range, potentially affecting the perceived freshness of oracle data.
- **Time Synchronization Issues:** Variations in block times across the network can lead to inconsistent evaluations of data freshness.

**Recommendations:**
- **Mitigate Timestamp Manipulation:** Accept minor deviations by setting reasonable margins around `TIMEOUT` values to account for potential miner manipulations.
- **Alternative Freshness Mechanisms:** Explore using block numbers instead of timestamps for measuring data freshness, as block numbers are less susceptible to manipulation.

---

### 6. **Lack of Emergency Mechanisms Post Ownership Renouncement**

**Issue:**
- After renouncing ownership, the contract lacks any emergency mechanisms to halt operations or recover from critical failures.

**Implications:**
- **Inability to Respond to Attacks:** In the event of detected vulnerabilities, oracle failures, or attacks, the contract cannot be paused or modified to mitigate issues.
- **Permanent Operational Constraints:** Any unforeseen issues become irreversible, potentially rendering the contract inoperative or insecure indefinitely.

**Recommendations:**
- **Implement Pausable Functionality Before Renouncing Ownership:** Utilize OpenZeppelin’s `Pausable` contract to allow pausing of critical functions in emergencies.
- **Design for Upgradeability:** Consider using proxy patterns to enable contract upgrades, ensuring that ownership can be retained or transferred if necessary.

---

### 7. **Potential Oracle Coordination Attacks**

**Issue:**
- The contract relies on both Chainlink and Tellor oracles, with complex logic to switch between them based on their statuses and data consistency.

**Implications:**
- **Coordinated Oracle Failures:** If an attacker manages to manipulate both oracles simultaneously, they can influence the price feed or force the contract to rely on outdated `lastGoodPrice`.
- **Price Discrepancy Exploits:** Significant price discrepancies between oracles might be exploited to manipulate the contract’s behavior, potentially affecting downstream applications relying on accurate pricing.

**Recommendations:**
- **Diversify Oracle Sources:** Incorporate additional independent oracles to reduce the risk of simultaneous manipulation.
- **Implement Multi-Signature Verification:** Require multiple independent confirmations before accepting new price data, enhancing resistance against coordinated attacks.
- **Monitor Oracle Health Off-Chain:** Utilize off-chain monitoring systems to detect and respond to oracle anomalies promptly.

---

### 8. **Scaling Function Assumptions and Precision Loss**

**Issue:**
- The contract includes functions `_scaleChainlinkPriceByDigits` and `_scaleTellorPriceByDigits` to adjust price values based on their decimal representations. These functions assume specific relationships between `TARGET_DIGITS`, `TELLOR_DIGITS`, and the oracles’ decimal counts.

**Implications:**
- **Incorrect Scaling:** If an oracle provides data with unexpected decimal places, scaling might be incorrect, leading to inaccurate price feeds.
- **Precision Loss:** Dividing integers can lead to truncation and loss of precision, potentially affecting price accuracy.

**Recommendations:**
- **Dynamic Scaling Validation:** Implement checks to ensure that the scaling factors align with the expected decimal places of the oracles, reverting if discrepancies are detected.
- **Use Higher Precision Arithmetic:** Where possible, use higher precision types or fixed-point arithmetic libraries to minimize precision loss during scaling.
- **Comprehensive Testing:** Rigorously test scaling functions with various decimal configurations to ensure accurate price adjustments under all expected scenarios.

---

### 9. **Error Handling in External Calls**

**Issue:**
- The contract uses `try/catch` blocks to handle external calls to `priceAggregator` and `tellorCaller`. However, in the event of a failed external call, it simply returns default-constructed response structs without explicit error logging.

**Implications:**
- **Silent Failures:** Failures in external calls might go unnoticed, making it harder to diagnose issues or understand the contract’s state transitions.
- **Default Values Usage:** Relying on default values might lead to unintended behavior, such as considering a response successful when it’s actually not.

**Recommendations:**
- **Enhanced Error Logging:** Emit specific events within `catch` blocks to log the nature of failures, aiding in off-chain monitoring and debugging.
- **Explicit Failure Flags:** Clearly differentiate between successful and failed external calls, ensuring that the contract’s logic accurately reflects the success or failure of data retrieval.
- **Fallback Strategies:** Consider implementing more robust fallback strategies or retries for critical external calls to enhance resilience against transient failures.

---

### 10. **Gas Consumption and Efficiency**

**Issue:**
- The `fetchPrice` and `fetchPrice_v` functions contain deeply nested conditional logic, potentially leading to high gas consumption.

**Implications:**
- **High Transaction Costs:** Users interacting with the contract might face high gas fees, deterring usage and impacting the contract’s practicality.
- **Block Gas Limit Risks:** Extremely complex functions risk exceeding block gas limits, making certain operations fail or become unusable under specific conditions.

**Recommendations:**
- **Optimize Conditional Logic:** Refactor and simplify the conditional statements to reduce gas usage. Consider breaking down complex functions into smaller, more manageable ones.
- **Gas Usage Auditing:** Perform gas profiling and optimization to identify and address high gas-consuming parts of the contract.
- **Lazy Evaluation Strategies:** Implement strategies where certain checks or computations are deferred or executed only when necessary to minimize gas costs.

---

### 11. **Potential Reentrancy Concerns**

**Issue:**
- While the contract primarily performs read operations and internal state updates, functions like `fetchPrice` involve external calls which could, in theory, be exploited for reentrancy.

**Implications:**
- **Reentrancy Exploits:** If external contracts (`priceAggregator` or `tellorCaller`) are malicious or compromised, they might attempt to re-enter the `PriceFeed` contract during external calls, potentially manipulating state variables like `status` or `lastGoodPrice`.

**Recommendations:**
- **Use Reentrancy Guards:** Incorporate reentrancy protection mechanisms (e.g., OpenZeppelin’s `ReentrancyGuard`) on functions that perform external calls and modify state.
- **Follow Checks-Effects-Interactions Pattern:** Ensure that all state changes occur before any external interactions to minimize reentrancy risks.
- **Limit External Interactions:** Reduce the number of external calls within sensitive functions or perform them in a way that minimizes reentrancy windows.

---

### 12. **Lack of Comprehensive Access Control**

**Issue:**
- Beyond the `setAddresses` function, the contract lacks additional access controls or administrative functions.

**Implications:**
- **Limited Administrative Flexibility:** In scenarios where administrative intervention is required (e.g., pausing operations, updating configurations), the contract lacks the necessary mechanisms.
- **Potential Misuse:** If additional functions are added in the future without proper access controls, it could introduce vulnerabilities.

**Recommendations:**
- **Implement Role-Based Access Controls:** Utilize OpenZeppelin’s `AccessControl` or similar mechanisms to define specific roles with distinct permissions, enhancing security and flexibility.
- **Design for Future Extensions:** Architect the contract to allow secure addition of administrative functions if needed, ensuring they adhere to strict access control policies.

---

### 13. **Inadequate Event Emission for Transparency**

**Issue:**
- The contract emits events for changes in `lastGoodPrice` and `status`, but lacks events for other significant actions, such as fetching prices or handling failures.

**Implications:**
- **Reduced Observability:** Limited event emission hampers the ability to monitor the contract’s operations effectively, making it harder to track its behavior and diagnose issues.
- **Transparency Gaps:** Off-chain systems and users may lack visibility into the contract’s internal processes, affecting trust and reliability assessments.

**Recommendations:**
- **Expand Event Emission:** Emit events for all critical actions, including successful and failed price fetches, oracle status changes, and scaling operations.
- **Structured Logging:** Use structured and descriptive event names and parameters to facilitate easier monitoring and analysis by off-chain systems and observers.

---

### 14. **Assumptions About Oracle Data Validity**

**Issue:**
- The contract assumes that if either Chainlink or Tellor returns a valid response, the price is trustworthy, subject to the defined deviation checks.

**Implications:**
- **Overreliance on Oracle Trustworthiness:** Even with deviation checks, if one oracle is compromised or feeds malicious data within acceptable deviation limits, the contract might accept incorrect prices.
- **Limited Validation Beyond Oracles:** The contract doesn’t implement additional validation or verification mechanisms beyond the oracles’ data, potentially exposing it to data integrity risks.

**Recommendations:**
- **Implement Multi-Factor Validation:** Incorporate additional validation layers, such as cross-referencing multiple oracles or integrating on-chain and off-chain data sources.
- **Enhanced Deviation Checks:** Tighten deviation thresholds or implement dynamic thresholds based on historical data to better detect anomalies.
- **Regular Oracle Audits:** Continuously monitor and audit the oracles’ performance and reliability to ensure data integrity.

---

### 15. **Potential Gas Limit Exceedance Due to Deeply Nested Conditions**

**Issue:**
- Functions like `fetchPrice` and `fetchPrice_v` contain multiple nested `if` statements, which could lead to deep call stacks and high gas consumption.

**Implications:**
- **Transaction Failures:** Excessive gas usage may cause transactions to fail, especially under high network congestion or gas price fluctuations.
- **User Frustration:** High gas costs can deter users from interacting with the contract, reducing its usability and adoption.

**Recommendations:**
- **Refactor for Gas Efficiency:** Simplify and flatten conditional logic to minimize gas consumption. Break down complex functions into smaller, more efficient ones.
- **Optimize State Updates:** Ensure that state variables are updated efficiently, reducing redundant operations and storage writes.
- **Implement Gas-Optimized Patterns:** Utilize Solidity patterns and optimizations that are known to reduce gas usage, such as using `uint256` over smaller types to leverage EVM's word size.

---

### **Conclusion**

While the `PriceFeed` contract incorporates mechanisms to ensure reliable price data by leveraging both Chainlink and Tellor oracles, several vulnerabilities and areas for improvement have been identified. Addressing these concerns through enhanced access controls, simplified state management, robust error handling, and comprehensive testing will significantly bolster the contract's security and reliability. Additionally, maintaining flexibility for future upgrades and incorporating emergency response mechanisms are crucial for ensuring the contract's long-term resilience against evolving threats and operational challenges.
","### **Issue Analysis and Response Evaluation**

---

**[M-02] Should check return data from Chainlink aggregators**

**Report Description**:
The issue highlights the lack of checks on the `latestRoundData` function from the Chainlink aggregator in the `PriceFeed.sol` contract. Specifically, it discusses the risk of using stale or invalid data if the `roundID` isn't checked, as Chainlink can return `0` when no answer is available, potentially feeding incorrect price data into the system. This poses risks to the liquidity and price calculations, especially in the event of a failure in the external oracle.

**Match in Response List**:
**No match found.**

**Validation**:
**Incorrect**. The issue of checking the return data from Chainlink aggregators is not directly addressed in the provided responses. The response list discusses issues such as dependence on external contracts, manipulation of fallback prices (`lastGoodPrice`), and other concerns, but it doesn't specifically mention the problem of stale or unchecked data from Chainlink aggregators. 

**Suggestions**:
- The response list should mention that Chainlink's `latestRoundData` return values should be checked for validity (e.g., `roundID` should be checked, and proper fallback mechanisms should be implemented if no valid data is returned). 
- Chainlink has a `latestRoundData` function that can return `0` for `roundID` and price. The contract should handle this gracefully to avoid using stale or incorrect data.
  
---

### **GPT-Generated Potential Issues (May Be Incorrect)**

---

**[R-02] Dependence on External Contracts**

**Response Description**:
The response highlights the issue of the contract depending heavily on external contracts like Chainlink and Tellor. The concern is that vulnerabilities in these external contracts can propagate and affect the `PriceFeed` contract. Additionally, changes to the external contracts' interfaces or behaviors can lead to failures or unexpected behavior in the `PriceFeed`.

**Assessment**:
**Valid Concern**. The risk of dependence on external contracts is a legitimate security concern. While this issue wasn't explicitly mentioned in the original report, it’s generally recognized as a best practice to ensure that any external contracts or interfaces used are audited and that fallback mechanisms are in place for handling failures. 

**Recommendations**:
- The response appropriately identifies the risks related to external contract dependencies. This could be supplemented by recommending regular audits of these external dependencies and the use of immutable references to prevent upgrades to potentially malicious versions of these contracts.

---

**[R-12] Potential Gas Limit Exceedance Due to Deeply Nested Conditions**

**Response Description**:
This response suggests that the deeply nested conditional logic in functions like `fetchPrice` and `fetchPrice_v` may result in high gas consumption, potentially causing failures due to exceeding block gas limits. 

**Assessment**:
**Valid Concern**. The concern about high gas usage due to complex conditions is a valid one. While it was not mentioned in the original issue report, this issue could arise in smart contracts with complicated logic, especially if the function contains nested conditionals that require numerous operations or checks. This could lead to excessive gas costs and make the contract impractical for users.

**Recommendations**:
- The response is valid, and refactoring functions to reduce complexity could improve gas efficiency. It could also suggest specific strategies for optimizing gas usage, such as using simpler conditionals, breaking down functions into smaller units, or employing gas profiling tools.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- None.

**Partially Correct Matches**:
- None.

**Missed Issues from Issue Report**:
- **[M-02] Should check return data from Chainlink aggregators**: This critical issue regarding the handling of return data from Chainlink was not addressed in the responses.

**GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-02] Dependence on External Contracts**: The concern about relying on external contracts like Chainlink and Tellor is valid and should be included as a general risk.
- **[R-12] Potential Gas Limit Exceedance Due to Deeply Nested Conditions**: This is a valid concern that could impact contract efficiency but wasn’t initially identified in the issue report.

---

**Recommendations**:
1. **Address Missed Issue (M-02)**: The issue of checking return values from Chainlink aggregators should be included in the response list, as it’s a critical vulnerability related to the accuracy and integrity of the data provided by external oracles.
2. **Supplement GPT-Generated Issues**: While both `Dependence on External Contracts` and `Gas Limit Exceedance` are valid concerns, they should be tied to specific issues in the original issue report to ensure they are clearly actionable.
",0,0,1,15,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
ActivePool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716.0,304.0,"[M-03] Unwhitelisted token can cause disaster
Contract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)
  [M-04] Out of gas.
There is no upper limit on `poolColl.tokens[]`, it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.
Impact: For every call `getVC()` function which computed contain the VC value of a given collateralAddress is listed in `poolColl.tokens[]` array, the gas consumption can be more expensive each time that a new collateral address is appended to the array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.",2.0,"pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";


contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    
    newColls internal poolColl;

    
    uint256 internal YUSDDebt;

    

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    

    

    
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    

    
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); 
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    
    
    
    
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); 
            }
        }
        return true;
    }

    
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); 
        return true;
    }

    
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); 
        }
        return true;
    }

    
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2101.0,0,2,"Mapping out contract structure
I’m examining the ActivePool contract, identifying constants, addresses, and events. This involves analyzing variables such as names, addresses, pool collateral, YUSDDebt, and various events for address changes and updates.
Function analysis and ownership
I’m mapping out functions like setAddresses, getCollateral, and sendCollateral. The setAddresses function is noteworthy due to its ownership renouncement.
Analyzing critical address settings
I’m examining the setAddresses function, noting its one-time use due to ownership renouncement and implications for critical address settings. This leads me to think about future address management.
Identifying risks
I’m working through potential issues like missing access control in addCollateralType, integer overflows under under under under under under Cytosinem et et et et et et et et et et et et Cytosinem et et et et et Cytosinem et et et et et Cytosinem et et Cytosinem et et Cytosinem et et Cytosinem et Cytosinem et Cytosinem et Cytosinem et and missing events for state changes.
Identifying concerns
I’m analyzing potential issues like sensitive access control on sendCollateralsUnwrap, the reliance on a possibly compromised whitelist, lack of an emergency pause function, and potential exposure from showing incomplete events.
Addressing potential issues
I'm thinking through the undefined whitelist variable and ensuring correct function calls, while also confirming variable name consistency and preventing negative YUSDDebt.
Adjusting input validation
I'm noting the need for input validation to prevent duplicate collaterals. Be mindful of setAddresses' single-use ownership renouncement and consider potential ERC20 token transfers without proper whitelist checks.
Tackling contract dependencies
I'm addressing vulnerabilities in contract dependencies and ensuring safeguards for duplicate collateral management. Also, examining mutable poolColl updates and how wrapped tokens are handled with trust in their functions.
","Analyzing the provided Solidity smart contract for the `ActivePool`, several potential vulnerabilities and areas of concern have been identified. Below is a comprehensive list of these vulnerabilities, along with explanations and recommendations to mitigate the associated risks.

---

### 1. **Ownership Renouncement in `setAddresses`**

**Issue:**
- The `setAddresses` function is marked as `onlyOwner` and, after successfully setting the addresses, it calls `_renounceOwnership()`. This permanently relinquishes ownership of the contract.

**Implications:**
- **Single Initialization:** Once ownership is renounced, the `setAddresses` function cannot be called again. This means that if any of the critical addresses need to be updated in the future (e.g., due to upgrades or security breaches), it won’t be possible.
- **Irreversible Action:** Renouncing ownership is irreversible. If `setAddresses` is called with incorrect or malicious addresses before renouncement, it could permanently lock the contract into an insecure state.

**Recommendations:**
- **Separate Initialization and Ownership Renouncement:** Consider separating the address-setting functionality from the ownership renouncement. Introduce a separate function to renounce ownership, allowing flexibility in managing critical addresses.
- **Multisignature Ownership:** Instead of a single owner, use a multisignature wallet for ownership to enhance security and allow for collective decision-making regarding address updates.

---

### 2. **Lack of Reentrancy Protection**

**Issue:**
- Functions like `_sendCollateral` and `sendCollateralsUnwrap` perform external calls (e.g., `IERC20(_collateral).safeTransfer` and `IWAsset(_tokens[i]).unwrapFor`) after updating the internal state.

**Implications:**
- **Reentrancy Attacks:** Although state updates occur before external calls (following the Checks-Effects-Interactions pattern), the absence of explicit reentrancy guards (`ReentrancyGuard`) leaves room for complex attack vectors, especially if interacting contracts are malicious.

**Recommendations:**
- **Implement Reentrancy Guards:** Utilize OpenZeppelin’s `ReentrancyGuard` to protect functions that perform external calls. This adds an additional layer of security against reentrancy attacks.
  
  ```solidity
  import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

  contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase, ReentrancyGuard {
      // ...
      function _sendCollateral(address _to, address _collateral, uint _amount) internal nonReentrant {
          // Function logic
      }
      // ...
  }
  ```

---

### 3. **Unbounded Loops Leading to Gas Limit Issues**

**Issue:**
- Functions like `getVC` and `sendCollaterals` contain loops that iterate over dynamic arrays (`poolColl.tokens` and `_tokens`, respectively).

**Implications:**
- **Gas Consumption:** As the number of collaterals increases, these loops can consume excessive gas, potentially making the functions uncallable due to block gas limits.
- **Denial of Service (DoS):** An attacker could deliberately inflate the number of collateral types to disrupt the functionality of these loops.

**Recommendations:**
- **Limit Array Sizes:** Impose a maximum limit on the number of collateral types that can be added.
  
  ```solidity
  uint256 constant MAX_COLLATERAL_TYPES = 100;

  function addCollateralType(address _collateral) external override {
      _requireCallerIsWhitelist();
      require(poolColl.tokens.length < MAX_COLLATERAL_TYPES, ""AP: Max collateral types reached"");
      poolColl.tokens.push(_collateral);
      poolColl.amounts.push(0);
  }
  ```

- **Use Pagination or External Computation:** For functions like `getVC`, consider allowing external systems to compute the total value by querying individual collateral values, avoiding on-chain loops.

---

### 4. **Potential for Duplicate Collateral Types**

**Issue:**
- The `addCollateralType` function appends new collateral types without checking for duplicates.

**Implications:**
- **Data Integrity:** Duplicate entries can lead to incorrect accounting of collateral amounts and complicate collateral management.
- **Increased Gas Costs:** Redundant data can inflate storage usage, increasing gas costs for operations involving collateral types.

**Recommendations:**
- **Check for Existing Collateral:** Before adding a new collateral type, verify that it hasn't been added already.
  
  ```solidity
  function addCollateralType(address _collateral) external override {
      _requireCallerIsWhitelist();
      require(!whitelist.isWrapped(_collateral), ""AP: Collateral already exists"");
      poolColl.tokens.push(_collateral);
      poolColl.amounts.push(0);
  }
  ```

  *Note: The exact condition to check depends on how `whitelist.isWrapped` or other relevant functions can be utilized to verify uniqueness.*

---

### 5. **Reliance on External Contracts (Whitelist and Others)**

**Issue:**
- The `ActivePool` contract heavily relies on external contracts like `IWhitelist`, `IWAsset`, and others for critical functionality.

**Implications:**
- **Single Point of Failure:** If any of these external contracts have vulnerabilities or are compromised, the security and functionality of the `ActivePool` can be severely impacted.
- **Upgrade Risks:** Changes or upgrades to external contracts can introduce incompatibilities or unexpected behaviors in the `ActivePool`.

**Recommendations:**
- **Audit External Contracts:** Ensure that all external contracts integrated with `ActivePool` are thoroughly audited and trusted.
- **Use Interfaces Carefully:** Rely on well-defined and secure interfaces, minimizing the trust placed in external implementations.
- **Implement Fallback Mechanisms:** Where possible, introduce checks or fallback mechanisms to handle failures or unexpected behaviors from external contracts.

---

### 6. **No Emergency Pausing Mechanism**

**Issue:**
- The contract lacks a mechanism to pause operations in case of detected vulnerabilities or emergencies.

**Implications:**
- **Inability to Mitigate Attacks:** Without a pausing mechanism, it’s challenging to quickly respond to ongoing attacks or discovered vulnerabilities, potentially exacerbating the impact.
- **Limited Control Over Operations:** In scenarios where certain functions need to be halted temporarily, the contract offers no native way to do so.

**Recommendations:**
- **Implement Pausable Functionality:** Incorporate OpenZeppelin’s `Pausable` contract to allow authorized accounts to pause and unpause critical functions.
  
  ```solidity
  import ""@openzeppelin/contracts/security/Pausable.sol"";

  contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase, Pausable {
      // ...

      function sendCollaterals(...) external override whenNotPaused returns (bool) {
          // Function logic
      }

      // Similarly add `whenNotPaused` to other critical functions

      function pause() external onlyOwner {
          _pause();
      }

      function unpause() external onlyOwner {
          _unpause();
      }
  }
  ```

---

### 7. **Potential Mismanagement of `poolColl` Structure**

**Issue:**
- The `poolColl` structure, defined as `newColls internal`, is manipulated through functions like `_sendCollateral` and `receiveCollateral`. However, critical functions like `_leftSumColls` are not defined within the provided code snippet.

**Implications:**
- **Undefined Behavior:** Without visibility into functions like `_leftSumColls`, it’s unclear how collateral amounts are aggregated or subtracted, potentially leading to mismanagement of collateral balances.
- **Data Inconsistency:** Improper handling of `poolColl` can result in inconsistent states, leading to incorrect collateral accounting.

**Recommendations:**
- **Ensure Complete Functionality:** Verify that all functions manipulating `poolColl`, especially `_leftSumColls`, are correctly implemented and audited.
- **Add Access Controls:** Ensure that only authorized functions can modify `poolColl` to prevent unauthorized state changes.

---

### 8. **Event Emissions for All State Changes**

**Issue:**
- Not all state-changing operations emit corresponding events. For instance, in `setAddresses`, events for some address changes (like `troveManagerLiquidationsAddress`, `troveManagerRedemptionsAddress`, and `collSurplusPoolAddress`) are not emitted.

**Implications:**
- **Transparency Issues:** Lack of events can hinder off-chain monitoring and auditing efforts, making it difficult to track all critical state changes.
- **Debugging Challenges:** Missing events complicate the process of debugging and verifying contract behavior.

**Recommendations:**
- **Emit Events for All Critical Changes:** Ensure that every state-changing operation emits appropriate events to maintain transparency and facilitate monitoring.
  
  ```solidity
  emit TroveManagerLiquidationsAddressChanged(_troveManagerLiquidationsAddress);
  emit TroveManagerRedemptionsAddressChanged(_troveManagerRedemptionsAddress);
  emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
  ```

---

### 9. **No Validation on Address Inputs Beyond Contract Checks**

**Issue:**
- While `setAddresses` uses `checkContract` to verify that the provided addresses are contracts, it doesn't validate the roles or trustworthiness of these contracts beyond their being contracts.

**Implications:**
- **Potential for Malicious Contracts:** An attacker could deploy a malicious contract and set it as one of the critical addresses, leading to unauthorized access or funds theft.
- **Insufficient Security Guarantees:** Merely checking that an address is a contract doesn't ensure that it adheres to expected behaviors or interfaces.

**Recommendations:**
- **Role-Based Validation:** Implement stricter validations to ensure that the provided addresses not only are contracts but also adhere to expected interfaces and behaviors.
- **Multisignature Confirmation:** Require multiple confirmations or a governance process to set critical addresses, reducing the risk of a single compromised owner setting malicious addresses.

---

### 10. **Absence of Upgradeability Patterns**

**Issue:**
- The contract does not implement any upgradeability mechanisms, such as proxy patterns, which are common in Solidity contracts to allow for future enhancements or fixes.

**Implications:**
- **Inflexibility:** Once deployed, the contract’s logic cannot be upgraded, limiting the ability to patch vulnerabilities or add new features.
- **Potential for Long-Term Risks:** Any undiscovered vulnerabilities remain exploitable indefinitely without the option to upgrade the contract.

**Recommendations:**
- **Implement Upgradeable Proxies:** Use established upgradeability patterns, such as the Transparent Proxy or UUPS Proxy patterns, to allow for future upgrades.
- **Ensure Secure Upgrade Mechanisms:** When implementing upgradeability, ensure that the upgrade process is secure and restricted to authorized entities to prevent malicious upgrades.

---

### 11. **Insufficient Input Validation in Functions**

**Issue:**
- Some functions, such as `sendCollaterals` and `sendCollateralsUnwrap`, do not perform thorough input validations beyond checking array lengths.

**Implications:**
- **Invalid Data Handling:** Malicious or incorrect inputs could lead to unintended behavior, such as transferring zero amounts, interacting with non-whitelisted tokens, or causing array index mismatches.
- **Potential for Logical Errors:** Without comprehensive input validation, the contract might process invalid or malicious data, leading to security vulnerabilities or loss of funds.

**Recommendations:**
- **Enhance Input Validations:** Implement additional checks to ensure that inputs are valid and conform to expected formats and constraints.
  
  ```solidity
  require(_to != address(0), ""AP: Invalid recipient"");
  for (uint256 i = 0; i < _tokens.length; i++) {
      require(whitelist.isValidCollateral(_tokens[i]), ""AP: Invalid collateral"");
      require(_amounts[i] > 0, ""AP: Amount must be greater than zero"");
  }
  ```

- **Prevent Zero Transfers:** Avoid processing transfers with zero amounts to save gas and prevent unnecessary state changes.

---

### 12. **Potential for State Variables to Grow Indefinitely**

**Issue:**
- The `poolColl.tokens` and `poolColl.amounts` arrays can grow indefinitely as new collateral types are added via `addCollateralType`.

**Implications:**
- **Storage Bloat:** Unlimited growth of these arrays can lead to increased storage costs and gas consumption for operations involving these arrays.
- **Performance Degradation:** Functions that iterate over these arrays may become increasingly gas-intensive, potentially leading to out-of-gas errors.

**Recommendations:**
- **Implement Maximum Limits:** Set a cap on the number of collateral types that can be added to prevent uncontrolled growth.
- **Allow Collateral Removal:** Introduce functionality to remove collateral types that are no longer needed, maintaining manageable array sizes.

---

### 13. **Lack of Comprehensive Testing and Auditing**

**Issue:**
- The analysis is based solely on the provided code snippet, and it's unclear whether comprehensive testing and external audits have been conducted.

**Implications:**
- **Undiscovered Vulnerabilities:** Without thorough testing and third-party audits, hidden vulnerabilities may exist within the contract logic or interactions with external contracts.
- **Reliance on Assumptions:** Assumptions about the behavior and security of external contracts (like `whitelist` and `IWAsset`) can lead to overlooked risks.

**Recommendations:**
- **Conduct Extensive Testing:** Implement unit tests, integration tests, and formal verification methods to ensure the contract behaves as intended under various scenarios.
- **Engage External Auditors:** Have the contract reviewed by reputable third-party security auditors to identify and remediate potential vulnerabilities.

---

### 14. **Potential Misalignment of Access Control Functions**

**Issue:**
- The contract includes multiple internal functions for access control (e.g., `_requireCallerIsBOorTroveMorTMLorSP`, `_requireCallerIsBorrowerOperationsOrDefaultPool`, etc.), which can lead to complexity and potential mistakes in enforcing access controls consistently.

**Implications:**
- **Inconsistent Access Control:** Overlapping or conflicting access control functions can inadvertently grant unauthorized access or restrict legitimate operations.
- **Maintenance Challenges:** Managing and understanding multiple access control functions increases the risk of introducing bugs during future modifications.

**Recommendations:**
- **Simplify Access Control:** Consolidate access control logic where possible to reduce complexity. Consider using role-based access control (RBAC) with OpenZeppelin’s `AccessControl` for more scalable and manageable permissions.
  
  ```solidity
  import ""@openzeppelin/contracts/access/AccessControl.sol"";

  contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase, AccessControl {
      bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

      constructor() {
          _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
          _setupRole(OPERATOR_ROLE, borrowerOperationsAddress);
          // Assign other roles as needed
      }

      modifier onlyOperator() {
          require(hasRole(OPERATOR_ROLE, msg.sender), ""AP: Caller is not an operator"");
          _;
      }

      function sendCollaterals(...) external override onlyOperator returns (bool) {
          // Function logic
      }
      // ...
  }
  ```

- **Audit Access Control Logic:** Regularly review and audit access control mechanisms to ensure they align with the intended security model.

---

### 15. **No Mechanism to Recover or Manage Unexpected Tokens**

**Issue:**
- The contract allows the transfer of any ERC20 token via functions like `sendCollaterals`, but there is no explicit mechanism to recover tokens that might have been accidentally sent directly to the contract.

**Implications:**
- **Asset Loss:** Users or other contracts might inadvertently send tokens to the `ActivePool`, leading to potential asset loss if those tokens are not intended to be managed by the pool.
- **Resource Locking:** Accumulated unexpected tokens can consume storage and potentially impact contract functionality or gas costs.

**Recommendations:**
- **Implement Token Recovery Functions:** Introduce functions that allow authorized entities to recover or manage tokens that are not part of the expected collateral types.
  
  ```solidity
  function recoverToken(address _token, uint256 _amount, address _to) external onlyOwner {
      require(!whitelist.isValidCollateral(_token), ""AP: Cannot recover valid collateral"");
      IERC20(_token).safeTransfer(_to, _amount);
      emit TokenRecovered(_token, _amount, _to);
  }
  ```

- **Emit Events on Token Transfers:** Ensure that all token transfers emit appropriate events to facilitate monitoring and recovery efforts.


","### **Analysis of Issue Report vs. Response List**

---

#### **[M-03] Unwhitelisted Token Can Cause Disaster**

**Report Description**:
The issue describes a vulnerability where the contract can accept and process non-whitelisted tokens if a user calls the `sendCollaterals` function with a token that is not part of the whitelist. This could destabilize the contract and cause financial losses.

**Match in Response List**:
Matches with the issue titled **""Reliance on External Contracts (Whitelist and Others)""**.

**Validation**:
**Correct**. The response correctly identifies the dependency on external contracts like the whitelist, and discusses the potential for a malicious or untrusted contract to disrupt the contract's functionality. This implicitly addresses the issue of unwhitelisted tokens potentially causing issues. The recommendation to ensure external contracts are audited and trusted is relevant.

**Suggestions**:
The response could go further by suggesting specific mitigation techniques for unwhitelisted tokens, such as rejecting transactions with non-whitelisted tokens or implementing a better validation for token types.

---

#### **[M-04] Out of Gas**

**Report Description**:
The issue describes the risk of ""Out of Gas"" errors in functions like `getVC()`, which iterate over the `poolColl.tokens[]` array. This array grows over time, causing increasing gas costs and the eventual risk of hitting the block gas limit.

**Match in Response List**:
Matches with the issue titled **""Unbounded Loops Leading to Gas Limit Issues""**.

**Validation**:
**Correct**. The response highlights the gas consumption issue in functions like `getVC` and proposes solutions such as pagination or moving computations off-chain. This addresses the core concern of excessive gas usage due to unbounded loops and provides a practical mitigation strategy.

**Suggestions**:
The response could add more detail about how to implement pagination or external computation in Solidity, such as using an event to track partial results, or using a separate contract for managing large arrays of collateral.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

---

#### **[R-01] Ownership Renouncement in `setAddresses`**

**Response Description**:
The response identifies a potential problem with ownership renouncement in the `setAddresses` function, where ownership is permanently relinquished after setting critical addresses.

**Assessment**:
**Irrelevant to the Reported Issues**. This response doesn't seem to relate directly to either of the issues from the `{issue}` report. The problems in `{issue}` involve unwhitelisted tokens and gas limit issues, neither of which concerns ownership renouncement.

**Recommendations**:
No action needed, as this issue is not relevant to the provided `{issue}` report.

---

#### **[R-02] Lack of Reentrancy Protection**

**Response Description**:
The response discusses the lack of reentrancy protection in functions that perform external calls, like `_sendCollateral` and `sendCollateralsUnwrap`.

**Assessment**:
**Valid Concern, but Not Mentioned in Issue Report**. This is a valid issue but not one of the problems in the provided `{issue}` report. The potential for reentrancy attacks is always an important concern, particularly in functions that perform external state changes after internal updates.

**Recommendations**:
While this is a good suggestion, it is not directly relevant to the issues at hand. Nonetheless, incorporating a `ReentrancyGuard` to safeguard the contract could improve security.

---

#### **[R-03] Unbounded Loops Leading to Gas Limit Issues**

**Response Description**:
This response addresses the gas issue in functions like `getVC()` and `sendCollaterals`, which involve loops over dynamic arrays.

**Assessment**:
**Correct Match**. This response appropriately addresses the gas consumption problem and provides a viable mitigation strategy by suggesting pagination or external computation. It is directly relevant to the `{M-04}` issue.

**Recommendations**:
No changes needed.

---

#### **[R-12] Insufficient Input Validation in Functions**

**Response Description**:
The response discusses insufficient input validation in functions like `sendCollaterals` and `sendCollateralsUnwrap`, which could allow invalid or malicious inputs to cause errors.

**Assessment**:
**Valid Concern, but Not Mentioned in Issue Report**. This is a valuable point that enhances the contract's robustness, but it wasn't raised in the initial `{issue}` report. Improving input validation is critical to ensure that invalid data does not cause unexpected behavior.

**Recommendations**:
Consider adding detailed input validation to prevent issues related to untrusted or invalid data, such as checking for non-zero amounts and ensuring that tokens are whitelisted.

---

### **Summary of Matches and Gaps**

---

#### **Correct Matches**:

- **[M-03] Unwhitelisted Token Can Cause Disaster**: Addressed by the **""Reliance on External Contracts (Whitelist and Others)""** response.
- **[M-04] Out of Gas**: Addressed by the **""Unbounded Loops Leading to Gas Limit Issues""** response.

#### **Partially Correct Matches**:

- **None**.

#### **Missed Issues from Issue Report**:

- **None**.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-01] Ownership Renouncement in `setAddresses`**: Not relevant to the provided issue report.
- **[R-02] Lack of Reentrancy Protection**: While relevant to general Solidity best practices, it is not part of the `{issue}` report.
- **[R-12] Insufficient Input Validation in Functions**: Although not raised in the `{issue}` report, this is a valid concern.

---

**Overall Assessment**:
The responses in `{response_list}` adequately address the issues in the `{issue}` report, particularly focusing on gas usage and unwhitelisted token vulnerabilities. However, some additional points, such as input validation and reentrancy protection, while valuable, were not explicitly mentioned in the original report. The suggestions provided in the responses align well with Solidity best practices and would enhance the security and efficiency of the contract.
",2,0,0,15,"1. Reliance on External Contracts (Whitelist and Others)  
2. Unbounded Loops Leading to Gas Limit Issues","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Reliance on External Contracts (Whitelist and Others)** appears at rank **5**.
   - **Unbounded Loops Leading to Gas Limit Issues** appears at rank **3**.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank **3**:
     - Number of true positives up to rank 3: **1**
     - Precision at rank 3 (\( P@3 \)): \( \frac{1}{3} \approx 0.333 \)
   - For rank **5**:
     - Number of true positives up to rank 5: **2**
     - Precision at rank 5 (\( P@5 \)): \( \frac{2}{5} = 0.4 \)

3. **Average the precision values**:
   - AP = \( \frac{0.333 + 0.4}{2} = \frac{0.733}{2} \approx 0.3665 \)

**Average Precision (AP)**: **0.3665**"
BorrowerOperations.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, etc. 
 */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        // transfer collateral into ActivePool
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called _after_ collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist and no duplicates
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }


        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // Use the unmodified _YUSDChange here, as we don't send the fee to the user
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        // transfer withdrawn collateral to msg.sender from ActivePool
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     */
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    /* Checks that:
     * 1. _colls contains no duplicates
     * 2. All elements of _colls are active collateral on the whitelist
     */
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    // requires that avax indices are in order
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",9859.0,1116.0,"[M-05] Reentrancy in contracts/BorrowerOperations.sol
There are several potential re-entrant functions in contracts/BorrowerOperations.sol:
=> Function addColl() on line 346 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _adjustTrove() which potentially impacts user debt, collateral top-ups or withdrawals.
Same applies to
-- withdrawColl() on line 373 -- withdrawYUSD() on line 389 -- repayYUSD() on line 406 -- adjustTrove() on line 420
=> Function openTrove() on line 207 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _openTroveInternal() which potentially impacts trove creation, YUSD withdrawals and YUSD gas compensation.
=> Function closeTrove() on line 628 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes troveManagerCached.r",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";



contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    
    
    
    
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, 
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); 

        _requireAtLeastMinNetDebt(vars.netDebt);
        
        
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); 
            _requireNewTCRisAboveCCR(newTCR);
        }

        
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    
    
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    
    
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); 
        _requireNoDuplicateColls(_collsOut);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, 
                params._maxFeePercentage
            );
            
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); 
        }


        
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); 
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        
        
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    
    function claimCollateral() external override {
        
        collSurplusPool.claimColl(msg.sender);
    }

    

    
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); 
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    
    
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); 
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { 
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { 
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    
    
    
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    

    
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    

    
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",8265.0,0,0,"Examining contract vulnerabilities
I’m analyzing the BorrowerOperations contract to pinpoint vulnerabilities, focusing on access control, reentrancy, and integer overflows. The code uses SafeMath-like functions, mitigating overflow risks.
Assessing contract setup
I'm noting the BorrowerOperations contract's use of Solidity 0.6.11, integration with Ownable and LiquityBase, and state variables like troveManager and stabilityPoolAddress. The setAddresses function needs addressing.
Spotlighting vulnerabilities
The setAddresses function, while set as external and onlyOwner, lacks measures to prevent address reassignment, potentially allowing repeated changes by the owner before renouncing ownership.
Wondering about ownership renouncement
The contract might still be secure after the owner renounces ownership. Validating input, actively managing collateral, and creating YUSD tokens seem to keep everything in check.
Risking reentrancy
I'm piecing together external calls in functions like _transferCollateralsIntoActivePool and closeTrove, which might expose reentrancy vulnerabilities, especially if ERC20 token contracts use hooks.
Identifying reentrancy risks
I'm piecing together how closeTrove's external calls, particularly sendCollateralsUnwrap, could potentially lead to reentrancy issues. Interestingly enough, no ReentrancyGuard is triggered in this case.
Mitigating security flaws
I’m addressing vulnerabilities like the unchecked assert in setAddresses, potential risks from a malicious whitelist contract, and the ability to route YUSD tokens to any address via sYETIAddress.
Highlighting security flaws
I'm noting the vulnerability of changing sYETIAddress to any address before ownership is renounced, with unchecked access controls and integer operations presenting further security risks.
Assessing logical vulnerabilities
OK, let me see. I’m piecing together validate collsIn and collsOut in adjustTrove. Ensuring no overlaps or duplicates, I’m digging into addColl and withdrawColl for secure operations.
Reviewing contract safeguards
I’m noting the lack of overlap checks in addColl and withdrawColl, and the potential vulnerability of triggering recoveryMode in openTroveInternal. Trust in collSurplusPool is also essential.
Spotting vulnerabilities
I’m focusing on lack of ReentrancyGuard, repeated address settings before renouncement, and possible front-running. Saw some validation gaps but mostly secure dependencies on external contracts.
Identifying key vulnerabilities
Reentrancy and multiple address calls before renouncement seem crucial. Functions like _transferCollateralsIntoActivePool and adjustTrove show improvements in handling various edge cases. Progress is evident!
Pinpointing key vulnerabilities
I'm digging into potential risks from faulty token transfer implementations, yusdToken access controls, and troveManager vulnerabilities. These dependencies could significantly impact the contract's security.
","Analyzing the provided Solidity smart contract for vulnerabilities involves a thorough examination of its structure, functions, and interactions with external contracts. Below is a comprehensive analysis highlighting potential vulnerabilities and security concerns within the `BorrowerOperations` contract.

### **1. Reentrancy Vulnerabilities**

**Issue:**
The contract performs multiple external calls (e.g., `transferFrom`, `mint`, `burn`, `sendCollateralsUnwrap`) without employing a reentrancy guard. This omission can expose the contract to reentrancy attacks, where an attacker could exploit the contract's state by re-entering functions during these external calls.

**Affected Functions:**
- `_transferCollateralsIntoActivePool`: Calls `transferFrom` on ERC20 tokens, which might have hooks that can trigger reentrant calls.
- `_withdrawYUSD` and `_repayYUSD`: Interact with the `yusdToken` contract's `mint` and `burn` functions, respectively.
- `closeTrove`: Calls external contracts like `activePool.sendCollateralsUnwrap`.

**Potential Exploit:**
An attacker could design a malicious ERC20 token with a `transferFrom` function that re-enters the `BorrowerOperations` contract during the transfer, potentially manipulating the contract’s state or draining funds.

**Recommendation:**
Implement a [Reentrancy Guard](https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard) using a mutex (`nonReentrant` modifier) to prevent multiple simultaneous executions of sensitive functions. For example:

```solidity
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    // ... existing code ...

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override nonReentrant {
        // Function implementation
    }

    // Apply nonReentrant to other external functions as needed
}
```

### **2. Improper Access Control in `setAddresses` Function**

**Issue:**
The `setAddresses` function is protected by the `onlyOwner` modifier, allowing only the contract owner to call it. However, there is no mechanism to restrict how many times it can be called before ownership is renounced. This means the owner can repeatedly call `setAddresses` to change critical addresses such as `troveManager`, `yusdToken`, and `sYETIAddress`.

**Potential Exploit:**
If the owner account is compromised or maliciously acts before ownership is renounced, the attacker can set these critical addresses to malicious contracts. For instance:
- Setting `sYETIAddress` to an attacker-controlled address could allow arbitrary minting of YUSD tokens.
- Redirecting `troveManager` to a malicious contract could disrupt the system's functionality.

**Recommendation:**
Restrict the `setAddresses` function to be callable only once, ensuring that critical addresses cannot be altered multiple times. This can be achieved by adding a state variable that tracks whether the addresses have been set:

```solidity
bool public addressesSet = false;

function setAddresses(
    address _troveManagerAddress,
    address _activePoolAddress,
    address _defaultPoolAddress,
    address _stabilityPoolAddress,
    address _gasPoolAddress,
    address _collSurplusPoolAddress,
    address _sortedTrovesAddress,
    address _yusdTokenAddress,
    address _sYETIAddress,
    address _whitelistAddress
) external override onlyOwner {
    require(!addressesSet, ""Addresses have already been set"");
    addressesSet = true;

    // Existing implementation...
}
```

Alternatively, renouncing ownership immediately after setting addresses ensures that no further changes can be made:

```solidity
function setAddresses(
    // parameters...
) external override onlyOwner {
    // Existing implementation...

    _renounceOwnership();
}
```

### **3. Dependency on External Contracts Without Proper Validation**

**Issue:**
The contract heavily relies on external contracts (e.g., `troveManager`, `activePool`, `yusdToken`, `collSurplusPool`, `whitelist`). While the `checkContract` function ensures that the provided addresses are contracts, it doesn't validate the integrity or expected behavior of these contracts beyond their existence.

**Potential Exploit:**
If any of the external contracts are compromised or behave unexpectedly, they could disrupt the functionality of `BorrowerOperations`. For example, a malicious `yusdToken` contract could bypass access controls, allowing unauthorized minting or burning of tokens.

**Recommendation:**
Ensure that external contracts are thoroughly audited and adhere to their expected interfaces. Additionally, consider implementing interface checks or using immutable variables for critical contract addresses to prevent changes after deployment.

### **4. Lack of Event Emission on Critical State Changes**

**Issue:**
While the contract emits events for certain actions (e.g., `TroveCreated`, `TroveUpdated`, `YUSDBorrowingFeePaid`), it does not emit events for all critical state changes, such as updates to key contract addresses within `setAddresses`.

**Potential Exploit:**
Lack of comprehensive event logging can make it difficult to track and audit state changes, potentially obscuring malicious activities or bugs.

**Recommendation:**
Emit events for all critical state changes, including each update within `setAddresses`, to enhance transparency and facilitate easier auditing.

### **5. Potential for Front-Running and Fee Manipulation**

**Issue:**
Fee calculations and collateral transfers occur based on the state at the time of the transaction. However, without mechanisms to lock certain parameters or prevent rapid state changes, attackers might exploit timing to manipulate fees or collateral values.

**Potential Exploit:**
An attacker could front-run a transaction to adjust the system's state (e.g., influencing the `isRecoveryMode` flag) to benefit from lower fees or to avoid collateral requirements.

**Recommendation:**
Implement mechanisms to mitigate front-running, such as using commit-reveal schemes for sensitive parameters or ensuring atomicity in critical operations to prevent state manipulation between transaction steps.

### **6. Gas Limit Considerations with Dynamic Arrays**

**Issue:**
Functions like `_transferCollateralsIntoActivePool` and `_getNewPortfolio` process dynamic arrays of collaterals and amounts. If these arrays grow too large, the functions might exceed the block gas limit, leading to failed transactions.

**Potential Exploit:**
While not a direct security vulnerability, an attacker could intentionally provide large arrays to cause denial-of-service (DoS) by exhausting gas limits, disrupting legitimate operations.

**Recommendation:**
Implement limits on the size of input arrays to ensure that functions remain gas-efficient. For example:

```solidity
uint256 public constant MAX_COLLATERALS = 10;

function openTrove(
    // parameters...
) external override {
    require(_colls.length <= MAX_COLLATERALS, ""BOps: Too many collaterals"");
    // Existing implementation...
}
```

### **7. Incomplete Input Validation**

**Issue:**
While the contract performs several input validations, certain edge cases might not be fully covered. For instance, the `_getNewPortfolio` function assumes that the subtraction of collaterals won't result in negative values, relying on SafeMath's `sub` to revert on underflows.

**Potential Exploit:**
If the logic inadvertently allows for zero or negative collateral values due to miscalculations or improper handling, it could lead to inconsistencies in the system's state.

**Recommendation:**
Ensure comprehensive input validation across all functions, especially when performing arithmetic operations that could result in underflows or unintended state changes.

### **8. Potential Centralization Risks**

**Issue:**
The contract's critical functions depend on the owner for initial setup via `setAddresses`. Centralization can pose risks if the owner account is compromised or acts maliciously before ownership is renounced.

**Potential Exploit:**
A compromised owner can set malicious contract addresses, leading to loss of funds, unauthorized minting of tokens, or other disruptive actions.

**Recommendation:**
Minimize reliance on a single owner account. Consider using multi-signature wallets for ownership or implementing decentralized governance mechanisms to manage critical functions securely.

### **Conclusion**

The `BorrowerOperations` contract exhibits several potential vulnerabilities, primarily related to reentrancy, improper access control, and dependence on external contracts. Addressing these issues is crucial to ensure the contract's security and reliability. Implementing the recommended safeguards, such as reentrancy guards, restricting critical function calls, and enhancing input validations, will significantly mitigate the identified risks.
","### Analysis of the Issue Report and Response List

---

#### **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Report Description**:
The issue identifies several external functions in `BorrowerOperations.sol` that are potentially vulnerable to reentrancy attacks. Specific functions include `addColl()`, `withdrawColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`. The concern is that these functions are external but lack a reentrancy guard, which can allow an attacker to exploit the contract by re-entering these functions during their execution.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerabilities""**.

**Validation**:
**Correct**. The response appropriately addresses the reentrancy vulnerability by pointing out that several functions perform external calls without a reentrancy guard. Specifically, it highlights the potential reentrancy attack through functions like `_transferCollateralsIntoActivePool`, `_withdrawYUSD`, `_repayYUSD`, and `closeTrove`. The response correctly identifies that such external calls are vulnerable to being exploited if not properly safeguarded.

**Suggestions**:
The response correctly identifies the need for a reentrancy guard in these functions. The report could also suggest using `ReentrancyGuard` from OpenZeppelin or adopting a ""checks-effects-interactions"" pattern to further mitigate these issues.

---

#### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-02] Improper Access Control in `setAddresses` Function**

**Response Description**:
The response points out that the `setAddresses` function is only protected by the `onlyOwner` modifier and that it can be called multiple times, which could allow an attacker (if ownership is compromised) to alter critical contract addresses such as `troveManager`, `yusdToken`, and `sYETIAddress`. The recommendation is to either restrict the function to be called only once or renounce ownership after setting these addresses to prevent further changes.

**Assessment**:
**Valid Concern**. Although this issue was not directly highlighted in the initial report, improper access control and the risks associated with the `setAddresses` function are legitimate concerns. The response suggests making the function callable only once or renouncing ownership after the addresses are set, which would prevent a malicious actor from altering key contract addresses once the contract is initialized.

**Recommendations**:
The recommendation is sound and aligns with best practices for restricting access to critical functions. It is also advisable to consider using a more fine-grained access control model, such as adding specific roles for address management, if needed.

---

**[R-03] Dependency on External Contracts Without Proper Validation**

**Response Description**:
The response raises concerns about the contract's reliance on external contracts without properly validating their integrity. Specifically, it notes that the `checkContract` function only ensures that an address is a contract but does not check if the contract behaves as expected. This could lead to issues if any of the external contracts are compromised or misbehave.

**Assessment**:
**Valid Concern**. This issue was not specifically mentioned in the original report, but it highlights a genuine risk. A contract's dependency on external contracts can become a vector for attacks if these external contracts are compromised. The recommendation to validate external contracts beyond just ensuring they are contracts (e.g., checking interfaces) is valid.

**Recommendations**:
Further validating external contracts by checking their interfaces (or even requiring them to conform to specific standards) is a good practice. The recommendation to make addresses immutable after deployment is also a good measure to ensure the integrity of these external contracts.

---

**[R-06] Lack of Event Emission on Critical State Changes**

**Response Description**:
The response mentions that while the contract emits events for some actions, it fails to emit events for critical state changes, such as updates to important contract addresses in `setAddresses`. This lack of event emission could hinder transparency and auditing, potentially obscuring malicious activity or bugs.

**Assessment**:
**Valid Concern**. This was not directly mentioned in the original issue list but is a valuable addition. Emitting events for all critical state changes is important for contract transparency, tracking, and auditing. This issue highlights a potential gap in the contract's auditing capabilities, which could be exploited in case of an attack or malfunction.

**Recommendations**:
The response rightly recommends emitting events for all state-changing functions. This practice enhances transparency and helps in creating an auditable trail of important contract changes.

---

**[R-07] Potential for Front-Running and Fee Manipulation**

**Response Description**:
The response raises the issue of front-running and fee manipulation, where attackers could exploit timing to influence transaction outcomes (e.g., manipulating fees or collateral values).

**Assessment**:
**Valid Concern**. This is a good addition to the security considerations. While not mentioned in the original issue report, front-running attacks can occur if state variables can be manipulated by quick transactions. The suggestion to implement a commit-reveal scheme or atomic transactions is a well-established strategy to mitigate front-running risks.

**Recommendations**:
The recommendation is valid, and the introduction of commit-reveal schemes or similar methods to lock critical parameters could help prevent these types of attacks.

---

**[R-08] Gas Limit Considerations with Dynamic Arrays**

**Response Description**:
The response highlights the risk of exceeding block gas limits when dealing with dynamic arrays in functions like `_transferCollateralsIntoActivePool` and `_getNewPortfolio`. While not a direct security issue, attackers could exploit this to cause denial-of-service (DoS) by forcing transactions that exceed gas limits.

**Assessment**:
**Valid Concern**. While not identified in the initial issue list, this is a reasonable concern, especially if large arrays are involved. It is a form of resource exhaustion attack, where large inputs can cause transactions to fail due to gas limitations.

**Recommendations**:
The response does not provide a concrete mitigation strategy. However, limiting input sizes, using pagination for large arrays, or implementing checks for gas usage can be ways to handle this issue.

---

#### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-05] Reentrancy in contracts/BorrowerOperations.sol**: Correctly matched with **""Reentrancy Vulnerabilities""**.

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-02] Improper Access Control in `setAddresses` Function**: A valid concern not mentioned in the original report. This issue addresses the risks of compromised ownership and uncontrolled changes to critical addresses.
  
- **[R-03] Dependency on External Contracts Without Proper Validation**: A valid concern that was not raised in the original issue list. It addresses the risks of relying on untrusted external contracts.
  
- **[R-06] Lack of Event Emission on Critical State Changes**: A valid addition that was not covered in the initial report. Event emissions for critical state changes are essential for transparency.
  
- **[R-07] Potential for Front-Running and Fee Manipulation**: A valid concern about state manipulation through front-running, which was not identified in the original issue report.
  
- **[R-08] Gas Limit Considerations with Dynamic Arrays**: A valid concern related to gas limits, which was not explicitly mentioned in the issue report but should be considered to prevent DoS attacks.

---

### **Summary**:
- **Correct Matches**: The **reentrancy vulnerabilities** in the original report are accurately addressed in the response.
- **Missed Issues**: The original report did not mention issues such as **improper access control**, **dependency on external contracts**, **lack of event emission**, **front-running**, and **gas limit concerns**, which were validly raised in the response.

",1,0,0,8,"```
1. Reentrancy Vulnerabilities
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of true positives**:
   - The true positive is ""Reentrancy Vulnerabilities"".
   - In the ranked list of predictions, ""Reentrancy Vulnerabilities"" appears at rank 1.

2. **Calculate precision at the rank of the true positive**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the total number of items up to rank 1.
   - \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - \( AP = 1.0 \).

**Output**:
```
1.0
```"
ThreePieceWiseLinearPriceCurve.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";

/** 
 * This contract is used to calculate the variable fee for an input of tokens. 
 * Uses three linear piecewise functions to calculate the fee, and the average 
 * of the system collateralization by that asset before and after the tx. 
 */
contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    /** 
     * f1 = m1 * x + b1
     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2
     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3
     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages
     * Decimal precision = 1e18
     */

    /** 
     * Function for setting slopes and intercepts of linear functions used for fee calculations. 
     */
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.
        decayTime = 5 days;
    }

    // Set the whitelist address so that the fee can only be updated by whitelistAddress
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    // Set the decay time in seconds
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     * @param _collateralVCInput is how much collateral is being input by the user into the system
     * @param _totalCollateralVCBalance is how much collateral is in the system
     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)
     */
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    // Called only by whitelist. Updates the last fee time and last fee percent
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     */
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        // percent of all VC backed by this collateral * 1e18
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { // use function 1
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { // use function 2
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
        } else { // use function 3
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",2218.0,197.0,"[M-07] Cannot use most piecewise linear functions with current implementation
The `adjustParams function` uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.
 
[M-08] Wrong comment in `getFee()`
The function `getFee` comment states that the total + the input must be less than the cap:
“If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.”
The code only checks if the input is less than the cap.   [M-09] Fee not decayed if past decayTime
The function `calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0` && `decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..",3.0,"pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";


contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    

    
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; 
        decayTime = 5 days;
    }

    
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    
    
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { 
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { 
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            
        } else { 
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",1536.0,0,3,"Inspecting vulnerabilities
I’m analyzing the ThreePieceWiseLinearPriceCurve contract for potential vulnerabilities like reentrancy, access control issues, arithmetic overflows, and improper visibility.
Assessing access controls
I’m verifying the use of Ownable and onlyOwner for critical functions. The whitelistAddress control seems crucial, and its accurate assignment needs confirmation.
Assessing function control
OK, let's think. Functions like setAddresses and adjustParams are controlled by the owner. If compromised, they could misuse the fee parameters or access functions. Solidity's default visibility is internal.
Questioning dependencies
I’m curious if using block.timestamp in calculateDecayedFee introduces subtle logic issues. Initialization and calculations in adjustParams and getFeePoint might also lead to errors.
Ensuring correct scaling
OK, let me see. I’m verifying that division by 1e18 and scaling of m1, m2, m3 values are accurate. Calculations must be precise to prevent functional errors.
Pinpointing crucial function updates
Interestingly enough, ensuring safe updates to lastFeePercent and lastFeeTime in setFeeCapAndTime is critical. Controlling whitelistAddress must be carefully managed to avoid vulnerabilities.
Evaluating access control
I'm noting the restrictions on getFeeAndUpdate and setAddresses to whitelistAddress. If compromised, unauthorized updates to lastFeeTime and lastFeePercent occur. SafeMath ensures no subtraction underflow.
Mitigating division issues
I’m thinking about how setting decayTime to zero can cause division by zero errors in calculateDecayedFee, possibly resulting in a Denial of Service (DoS). This needs an intervention.
Identifying constraints
I'm digging into issues around the lack of constraints on decayTime and potential uninitialized variables. Initial values not set by adjustParams may result in incorrect fee calculations when getFee is called.
Noticing contracting practices
The absence of events in the contract for parameter changes and the gas expense of storing strings come to mind. These aren't security issues, but they are noteworthy.
Spotting vulnerabilities
I'm thinking about how setting decayTime to zero might cause a DoS. Compromised whitelistAddress and potential unintended behavior with adjustParams are also concerns.
","Analyzing the provided Solidity smart contract, several potential vulnerabilities and issues have been identified. These vulnerabilities range from access control weaknesses to potential logic errors that could lead to unintended behavior or security risks. Below is a comprehensive breakdown of these vulnerabilities:

### 1. **Unrestricted `decayTime` Modification Leading to DoS**

- **Issue:** The `setDecayTime` function allows the contract owner to set the `decayTime` parameter without any restrictions on its value. Specifically, the owner can set `decayTime` to zero.
  
- **Impact:** If `decayTime` is set to zero, the `calculateDecayedFee` function will attempt to perform a division by zero:
  
  ```solidity
  fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
  ```
  
  This will cause the transaction to revert, effectively rendering the `getFee` and `getFeeAndUpdate` functions unusable. This results in a **Denial of Service (DoS)**, preventing legitimate users from interacting with the contract as intended.

- **Recommendation:** Add a require statement in the `setDecayTime` function to ensure that `decayTime` cannot be set to zero.

  ```solidity
  function setDecayTime(uint _decayTime) external override onlyOwner {
      require(_decayTime > 0, ""decayTime must be greater than zero"");
      decayTime = _decayTime;
  }
  ```

### 2. **Single Initialization of `whitelistAddress` Without Verification**

- **Issue:** The `setAddresses` function allows the owner to set the `whitelistAddress` only once. However, there's no verification to ensure that the provided `_whitelistAddress` is a valid and intended address.

- **Impact:** If the owner mistakenly sets the `whitelistAddress` to an incorrect or malicious address, or if the owner’s account is compromised before setting this address, the malicious address could gain control over critical functions like `setFeeCapAndTime` and `getFeeAndUpdate`. This could allow an attacker to manipulate fee parameters arbitrarily.

- **Recommendation:** Implement additional checks to verify that the `_whitelistAddress` is valid (e.g., not the zero address) before setting it.

  ```solidity
  function setAddresses(address _whitelistAddress) external override onlyOwner {
      require(!addressesSet, ""addresses already set"");
      require(_whitelistAddress != address(0), ""Invalid whitelist address"");
      whitelistAddress = _whitelistAddress;
      addressesSet = true;
  }
  ```

### 3. **Potential Initialization Issues Leading to Incorrect Fee Calculations**

- **Issue:** The contract relies on the `adjustParams` function to initialize critical parameters like `m1`, `b1`, `cutoff1`, etc. However, there's no mechanism to enforce that `adjustParams` is called before other functions like `getFee` or `getFeeAndUpdate` are invoked.

- **Impact:** If `getFee` or `getFeeAndUpdate` are called before `adjustParams` has been properly executed, the fee calculations may use uninitialized or default values (e.g., zeros). This could lead to incorrect fee computations or unexpected contract behavior.

- **Recommendation:** Introduce an initialization flag that ensures `adjustParams` is called before any fee-related functions can be used.

  ```solidity
  bool private isInitialized;

  function adjustParams(...) external onlyOwner {
      require(!isInitialized, ""Parameters already adjusted"");
      // existing logic
      isInitialized = true;
  }

  function getFee(...) external view returns (uint256 fee) {
      require(isInitialized, ""Contract not initialized"");
      // existing logic
  }

  function getFeeAndUpdate(...) external returns (uint256) {
      require(isInitialized, ""Contract not initialized"");
      // existing logic
  }
  ```

### 4. **Lack of Event Emissions for Critical State Changes**

- **Issue:** The contract does not emit events when critical state changes occur, such as updating parameters or setting the whitelist address.

- **Impact:** Without events, tracking changes becomes difficult, especially for off-chain services or during audits. This lack of transparency can hinder monitoring and debugging efforts.

- **Recommendation:** Emit events in functions that modify the contract’s state.

  ```solidity
  event ParamsAdjusted(string name, uint256 m1, uint256 b1, uint256 m2, uint256 cutoff1, uint256 m3, uint256 cutoff2, uint256 dollarCap);
  event WhitelistAddressSet(address whitelistAddress);
  event DecayTimeSet(uint256 decayTime);
  event FeeCapAndTimeSet(uint256 lastFeePercent, uint256 lastFeeTime);

  function adjustParams(...) external onlyOwner {
      // existing logic
      emit ParamsAdjusted(_name, _m1, _b1, _m2, _cutoff1, _m3, _cutoff2, _dollarCap);
  }

  function setAddresses(address _whitelistAddress) external override onlyOwner {
      // existing logic
      emit WhitelistAddressSet(_whitelistAddress);
  }

  function setDecayTime(uint _decayTime) external override onlyOwner {
      // existing logic
      emit DecayTimeSet(_decayTime);
  }

  function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
      // existing logic
      emit FeeCapAndTimeSet(_lastFeePercent, _lastFeeTime);
  }
  ```

### 5. **No Access Control for Critical Functions Beyond Owner and Whitelist**

- **Issue:** The contract heavily relies on the owner and a single `whitelistAddress` for access control. There are no multi-signature requirements or role-based access controls.

- **Impact:** Centralization of control to a single owner and whitelist address increases the risk. If either account is compromised, an attacker gains significant control over the contract, including the ability to manipulate fee parameters and update critical state variables.

- **Recommendation:** Consider implementing more granular access control mechanisms, such as role-based permissions using OpenZeppelin’s `AccessControl`, or multi-signature wallets for critical operations.

  ```solidity
  import ""@openzeppelin/contracts/access/AccessControl.sol"";

  contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable, AccessControl {
      bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

      constructor() {
          _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
      }

      function setAddresses(address _whitelistAddress) external override onlyOwner {
          require(!addressesSet, ""addresses already set"");
          require(_whitelistAddress != address(0), ""Invalid whitelist address"");
          whitelistAddress = _whitelistAddress;
          _setupRole(WHITELIST_ROLE, _whitelistAddress);
          addressesSet = true;
          emit WhitelistAddressSet(_whitelistAddress);
      }

      function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
          require(hasRole(WHITELIST_ROLE, msg.sender), ""caller must have whitelist role"");
          // existing logic
      }

      // Similarly update getFeeAndUpdate to require WHITELIST_ROLE
  }
  ```

### 6. **Potential Arithmetic Precision Issues**

- **Issue:** The contract performs multiple arithmetic operations involving division by `1e18`. While `SafeMath` is used to prevent overflows and underflows, the precision of these operations can lead to rounding errors.

- **Impact:** Rounding errors can cause fee calculations to be slightly off, which might accumulate over multiple transactions, potentially leading to significant discrepancies in fee amounts.

- **Recommendation:** Ensure that all parameters (`m1`, `m2`, `m3`, `b1`, `b2`, `b3`) are appropriately scaled to maintain precision. Additionally, consider using a higher precision if necessary or implementing rounding mechanisms that align with the intended financial logic.

### 7. **No Mechanism to Update `whitelistAddress` After Initialization**

- **Issue:** The `whitelistAddress` can only be set once via the `setAddresses` function. Once set, it cannot be updated, even if the initial address becomes compromised or needs to be changed for any reason.

- **Impact:** This limits flexibility and poses a risk if the `whitelistAddress` is compromised or if there's a need to change it due to operational requirements.

- **Recommendation:** Implement a function to allow the owner to update the `whitelistAddress`, possibly with a time delay or multi-signature approval to enhance security.

  ```solidity
  event WhitelistAddressUpdated(address oldAddress, address newAddress);

  function updateWhitelistAddress(address _newWhitelistAddress) external onlyOwner {
      require(_newWhitelistAddress != address(0), ""Invalid whitelist address"");
      address oldAddress = whitelistAddress;
      whitelistAddress = _newWhitelistAddress;
      emit WhitelistAddressUpdated(oldAddress, _newWhitelistAddress);
  }
  ```

  Additionally, consider using role-based access controls to manage multiple whitelist addresses for redundancy and security.

### 8. **No Pausable Mechanism to Temporarily Halt Operations**

- **Issue:** The contract lacks a pausable mechanism, which allows the owner to temporarily halt critical operations in case of an emergency or detected vulnerability.

- **Impact:** Without the ability to pause the contract, the owner cannot react to unforeseen issues promptly, potentially exacerbating the impact of any vulnerabilities or attacks.

- **Recommendation:** Incorporate OpenZeppelin’s `Pausable` contract to allow the owner to pause and unpause the contract as needed.

  ```solidity
  import ""@openzeppelin/contracts/utils/Pausable.sol"";

  contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable, Pausable {
      // existing code

      function pause() external onlyOwner {
          _pause();
      }

      function unpause() external onlyOwner {
          _unpause();
      }

      // Add whenNotPaused modifiers to functions that modify state
      function adjustParams(...) external onlyOwner whenNotPaused {
          // existing logic
      }

      // Similarly, add whenNotPaused to other state-changing functions
  }
  ```

### 9. **No Input Validation for `adjustParams` Beyond Cutoff Order**

- **Issue:** The `adjustParams` function enforces that `cutoff1 <= cutoff2` but does not validate other input parameters for logical consistency or expected ranges.

- **Impact:** This can allow the owner to set parameters that might lead to unintended fee curves or behaviors, potentially undermining the contract's financial logic.

- **Recommendation:** Implement additional require statements to validate the ranges and logical relationships between `m1`, `m2`, `m3`, `b1`, `b2`, `b3`, and the cutoff values.

  ```solidity
  function adjustParams(...) external onlyOwner {
      require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
      require(_m1 > 0 && _m2 > 0 && _m3 > 0, ""Slopes must be positive"");
      require(_b1 > 0, ""Intercept b1 must be positive"");
      // Additional validations as per business logic
      // existing logic
  }
  ```

### 10. **Potential Unbounded Gas Consumption in Fee Calculations**

- **Issue:** Although not immediately evident, complex fee calculations involving multiple arithmetic operations could lead to increased gas consumption, especially if the number of steps increases.

- **Impact:** High gas consumption can make transactions more expensive and could deter users from interacting with the contract. In extreme cases, it could lead to transactions failing if the gas limit is exceeded.

- **Recommendation:** Optimize arithmetic operations where possible and ensure that the fee calculation logic is as efficient as possible. Consider simplifying the fee curve if it does not compromise the contract's functionality.

### 11. **Lack of Fallback or Receive Function**

- **Issue:** The contract does not implement a `fallback` or `receive` function, which means it cannot accept Ether.

- **Impact:** If there's an intention for the contract to handle Ether (e.g., for fee payments), the absence of these functions will prevent it from receiving Ether, potentially disrupting intended functionalities.

- **Recommendation:** If the contract is intended to handle Ether, implement appropriate `fallback` and `receive` functions with necessary access controls.

  ```solidity
  receive() external payable {
      // Handle incoming Ether if necessary
  }

  fallback() external payable {
      // Handle fallback
  }
  ```

  If the contract should not accept Ether, explicitly prevent it by reverting transactions that attempt to send Ether.

  ```solidity
  receive() external payable {
      revert(""Contract does not accept Ether"");
  }

  fallback() external payable {
      revert(""Contract does not accept Ether"");
  }
  ```

### 12. **No Mechanism to Renounce Ownership or Update Owner**

- **Issue:** The contract inherits from `Ownable`, but there's no functionality to renounce ownership or transfer ownership securely beyond the standard `transferOwnership` method.

- **Impact:** If the owner’s private key is compromised, there's no way to renounce ownership to prevent further malicious actions. Additionally, if ownership needs to be transferred to a multi-signature wallet or a governance contract, it might require additional steps.

- **Recommendation:** Ensure that ownership can be transferred securely and consider implementing a mechanism to renounce ownership if decentralization is desired.

  ```solidity
  // The Ownable contract already provides transferOwnership and renounceOwnership functions.
  // Ensure to use them appropriately.
  ```

### Summary of Key Vulnerabilities

1. **DoS via Zero `decayTime`:** Owner can set `decayTime` to zero, causing critical functions to revert.
2. **Single Point of Failure for `whitelistAddress`:** If set incorrectly or compromised, attacker gains control over fee parameters.
3. **Uninitialized Parameters Leading to Incorrect Behavior:** Functions can be called before proper initialization.
4. **Lack of Event Emissions:** Hinders transparency and monitoring of critical state changes.
5. **Centralized Access Control:** Reliance on single owner and whitelist address increases risk of control compromise.
6. **Arithmetic Precision Issues:** Potential rounding errors in fee calculations.
7. **Immutable `whitelistAddress`:** No mechanism to update or recover if compromised.
8. **No Pausable Mechanism:** Inability to halt operations during emergencies.
9. **Insufficient Input Validation in `adjustParams`:** Allows setting inconsistent or harmful parameters.
10. **Potential Gas Consumption Issues:** Complex fee calculations may lead to high gas costs.
11. **Missing Fallback or Receive Functions:** Restricts Ether handling capabilities.
12. **Ownership Management Limitations:** Lack of advanced ownership controls for enhanced security.

### Recommendations for Mitigation

To address these vulnerabilities, consider implementing the following best practices:

- **Enhanced Access Control:** Use role-based access control mechanisms and multi-signature wallets for critical functions.
- **Input Validation:** Rigorously validate all inputs in state-changing functions to ensure logical consistency and prevent malicious parameter settings.
- **Event Emissions:** Emit events for all critical state changes to facilitate transparency and monitoring.
- **Pausable Mechanism:** Incorporate the ability to pause and resume contract operations in case of emergencies.
- **Ownership Management:** Implement secure ownership transfer mechanisms and consider ownership renouncement where appropriate.
- **Gas Optimization:** Optimize arithmetic operations and fee calculation logic to minimize gas consumption.
- **Initialization Checks:** Ensure that all necessary parameters are initialized before allowing interaction with fee-related functions.
- **Fallback Protection:** Implement fallback or receive functions as needed, ensuring they are secure and align with the contract’s intended functionality.

By addressing these vulnerabilities and following the recommended best practices, the security and reliability of the `ThreePieceWiseLinearPriceCurve` smart contract can be significantly enhanced.
","### Issue Analysis and Comparison

---

#### **[M-07] Cannot use most piecewise linear functions with current implementation**

**Report Description**:  
The `adjustParams` function uses three functions `f1`, `f2`, `f3`, where `y_i = f_i(x_i)`. It computes the y-axis intercepts (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers, which means these values cannot become negative. This limits the use of a whole class of functions, particularly those that need negative intercepts.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue regarding the limitations imposed by using unsigned integers for negative y-axis intercepts. This is a logical issue about mathematical modeling and input handling, which is not discussed in the responses.

**Suggestions**:  
The issue could be mitigated by using signed integers for the intercepts (`b2`, `b3`) to support a broader class of functions. Additionally, reviewing the function definitions for `f1`, `f2`, and `f3` to ensure flexibility for all potential use cases is recommended.

---

#### **[M-08] Wrong comment in `getFee()`**

**Report Description**:  
The `getFee()` function comment incorrectly suggests that the sum of the total and input must be less than the cap. However, the code only checks if the input is less than the cap.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. This issue relates to incorrect or misleading comments in the contract. None of the responses in the list address the potential risks of misleading comments or mismatched logic and documentation.

**Suggestions**:  
Correcting the comment in the `getFee()` function would align the documentation with the actual code behavior. Consider updating the comment to reflect the correct logic of the function.

---

#### **[M-09] Fee not decayed if past `decayTime`**

**Report Description**:  
In the `calculateDecayedFee` function, the `lastFeePercent` is supposed to decay over time, but when `decay` exceeds `decayTime`, the fee is not decayed and should be set to zero instead.

**Match in Response List**:  
Matches with **""Unrestricted `decayTime` Modification Leading to DoS""**.

**Validation**:  
**Partially Correct**. While the response highlights a **Denial of Service (DoS)** risk due to an unchecked `decayTime` (setting it to zero), it does not directly address the logical error in the fee decay calculation when `decay > decayTime`. The issue in the report is about the behavior of `calculateDecayedFee` rather than a contract-wide DoS issue.

**Suggestions**:  
The response should more explicitly address the logic for fee decay and suggest setting `lastFeePercent` to zero when `decay > decayTime` to fix the issue described in the report.

---

### GPT-Generated Potential Issues (May Be Incorrect)

---

#### **[R-01] Unrestricted `decayTime` Modification Leading to DoS**

**Response Description**:  
The `setDecayTime` function allows the contract owner to set the `decayTime` without any restrictions on its value. Specifically, the owner can set `decayTime` to zero, causing a division by zero error.

**Assessment**:  
**Valid Concern**. While not listed in the original issues, this is a valid concern related to improper modification of critical parameters (`decayTime`) that could lead to system failure (DoS). Setting `decayTime` to zero would cause unintended behavior in the fee decay logic. This should be addressed to prevent such vulnerabilities.

**Recommendations**:  
To mitigate the DoS risk, it's advisable to add a restriction on the `decayTime` setting to prevent it from being set to zero or an impractical value. A minimum value constraint would ensure proper operation.

---

#### **[R-05] No Input Validation for `adjustParams` Beyond Cutoff Order**

**Response Description**:  
The `adjustParams` function enforces that `cutoff1 <= cutoff2`, but it does not validate other parameters for logical consistency.

**Assessment**:  
**Valid Concern**. This issue is relevant but was not mentioned in the original report. Validating input parameters for logical consistency and expected ranges is crucial to prevent unintended or malicious behavior. It is important to ensure that all input parameters in `adjustParams` are within reasonable limits.

**Recommendations**:  
Implement additional checks to validate all input parameters and ensure they follow logical constraints. This would help prevent the manipulation of the fee curve in unexpected ways.

---

#### **[R-06] Lack of Pausable Mechanism to Temporarily Halt Operations**

**Response Description**:  
The contract lacks a pausable mechanism that would allow the owner to halt critical operations in case of emergency or detected vulnerabilities.

**Assessment**:  
**Valid Concern**. While not directly related to any issue in the original report, the suggestion to add a pausable mechanism is a common best practice. It enables quick responses to unforeseen issues, such as security vulnerabilities or operational errors. This concern is important, especially for contracts managing financial transactions.

**Recommendations**:  
Implement the `Pausable` pattern from OpenZeppelin to allow emergency stops for critical functions, preventing further damage in case of an exploit.

---

### **Summary of Matches and Gaps**

---

**Correct Matches**:

- **None**

**Partially Correct Matches**:

- **[M-09] Fee not decayed if past `decayTime`**: The issue is related to fee decay, but the response primarily addresses a DoS risk in the `setDecayTime` function rather than the specific fee decay logic.

**Missed Issues from Issue Report**:

- **[M-07] Cannot use most piecewise linear functions with current implementation**: Not addressed in the response list.
- **[M-08] Wrong comment in `getFee()`**: Not addressed in the response list.

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-01] Unrestricted `decayTime` Modification Leading to DoS**: Valid concern regarding a potential DoS from improper modification of `decayTime`.
- **[R-05] No Input Validation for `adjustParams` Beyond Cutoff Order**: Valid concern about the need for input validation beyond the `cutoff` parameters.
- **[R-06] Lack of Pausable Mechanism to Temporarily Halt Operations**: A valid best practice to introduce an emergency stop mechanism.

---
",0,1,2,12,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and the average of these values is also zero."
,,,,,,,,2,7,,,,3,1,6,85,,
