nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Lock.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",1088.0,145.0,"[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
There are two functions that allow to lock some amount of assets. The first function is Lock.lock which creates a new bond. The second function is the function `extendLock`. This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.
The issue is that the `extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `release` is called.
Therefore only the amount of assets deposited via `lock` can be released again. The amount of assets deposited using `extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.

[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract
When calling the function `claimGovFees()`, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in the function `bondNFT.distribute`.

[M-02] Must approve 0 first
Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved in function `claimGovFees()`. Recommend: Add an approve(0) before approving",3.0,"pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",790.0,1,2,"Itemizing vulnerabilities
I’m examining a Solidity contract for potential issues. Infinite ERC20 token approval and lack of input validation might expose it to external contract exploits and reverts if assets are not properly standardized.
Spotting reentrancy risks
I’m curious about potential reentrancy and external contract issues. The contract lacks measures like ReentrancyGuard to prevent unexpected vulnerabilities. External contract integrity also raises concerns.
Addressing transaction handling
Thinking about scenarios where external calls revert or fail. The contract doesn’t manage IERC20 failures, leading to potential risks with returning false or reverting.
Navigating contract risks
I'm digging into how bondNFT interactions might cause state changes. Constantly resetting allowances without immediate revocation could lead to token losses or stuck contracts.","Below is a detailed analysis of potential vulnerabilities and security concerns in the provided Solidity contract. While not all of these necessarily constitute critical vulnerabilities, they are important to consider during an audit or improvement process. Some points hinge on assumptions about the external contracts (`bondNFT`, `govNFT`, and various ERC20 tokens) and the system as a whole.

**1. Lack of Reentrancy Protection**  
   - Functions like `claim()`, `claimDebt()`, `release()`, and `claimGovFees()` call external contracts (`bondNFT` and `govNFT`), which in turn could call back into `Lock` if maliciously implemented.  
   - Without a `nonReentrant` guard or careful ordering of operations, a malicious external contract could potentially reenter and manipulate state (e.g., call `claimGovFees()` mid-operation or alter `totalLocked` incorrectly).
   - Even though Solidity 0.8.0 introduces checked arithmetic and reduces some reentrancy patterns, reentrancy can still occur due to external calls.

**2. Infinite ERC20 Allowance to External Contract**  
   - In `claimGovFees()`, the contract sets `IERC20(assets[i]).approve(address(bondNFT), type(uint256).max)` on every iteration.  
   - This effectively grants the `bondNFT` contract unlimited access to transfer tokens out of the `Lock` contract. If `bondNFT` or any of its dependencies are compromised, or if `bondNFT` is an upgradeable contract that can be changed after deployment, an attacker could drain the `Lock` contract’s balances.
   - The code never revokes or reduces the allowance, leaving the Lock contract perpetually vulnerable to token drain if `bondNFT` is not fully trusted.

**3. Trust in External Contracts Without Validation**  
   - The addresses for `bondNFT` and `govNFT` are provided in the constructor. If these addresses are not from trusted and immutable sources, a malicious or upgradeable contract could be supplied. This could lead to logic hijacking, draining funds, or reentrancy attacks.
   - `govNFT` is trusted to return NFTs to the owner via `sendNFTs()` and to claim fees in `claimGovFees()`. If `govNFT` is malicious, it might cause unexpected state changes or revert calls in undesirable ways.

**4. No Return Value Checks for ERC20 Transfers**  
   - The contract uses `IERC20(…).transfer(...)` and `IERC20(…).transferFrom(...)` without checking the return values.  
   - While most modern and well-audited ERC20 tokens revert on failure, some tokens simply return `false` on a failed transfer.  
   - If a token returns `false` rather than reverting, the contract would incorrectly assume the transfer succeeded, potentially causing accounting errors or locked funds.  
   - Best practice is to use OpenZeppelin’s `SafeERC20` library to ensure proper handling of ERC20 operations.

**5. Potential for Malicious or Non-Standard Tokens**  
   - The contract relies on `IERC20` for token interactions without enforcing the token standard. A malicious or non-standard token could:  
     - Reenter by calling back into the contract during `transfer` or `transferFrom` if it has a fallback mechanism.  
     - Always fail transfers or drain funds due to unexpected token behavior.  
   - If `allowedAssets[_asset]` is set to true for a malicious token, it could lead to reentrancy or other unexpected behaviors when `lock()` or `extendLock()` are called.

**6. Asset Addition by Owner**  
   - The `editAsset()` function allows the owner to add arbitrary tokens to the `allowedAssets` list. If the owner’s account or key is compromised, a malicious token could be added.  
   - Although this is a governance/privilege risk rather than a strict vulnerability, it still raises a trust and operational security concern.

**7. Incomplete Input Validation for Periods**  
   - While there are checks for `_period` boundaries, there’s no other logic to prevent strange behaviors if a user repeatedly locks and extends locks. This is less a direct vulnerability and more of a logic concern.

**8. No Event Emission**  
   - While not strictly a vulnerability, the contract does not emit events for important state changes (like `lock()`, `extendLock()`, `release()`, `claim()`, etc.). This is a best-practice issue rather than a vulnerability, but lack of events can make it harder to detect malicious behavior or debug issues.

**9. Assumption That `claimGovFees()` is Always Safe**  
   - `claimGovFees()` is called before certain actions to “update state” or “flush fees.” However, the assumption that calling external contracts before your main logic runs does not introduce a vulnerability is risky. If `govNFT` or `bondNFT` misbehaves, it could lead to state inconsistencies.

---

**In Summary:**

- **Critical Concerns:** Possible reentrancy due to unguarded external calls, infinite token allowances to external contracts, and blind trust in external contracts (`bondNFT` and `govNFT`).
  
- **Moderate Concerns:** Lack of safe ERC20 handling (no return checks), potential for malicious tokens via `editAsset()`, and reliance on trusted external addresses without further checks.
  
- **Minor Concerns:** No event emissions for state tracking and incomplete handling of unusual token standards.

These issues highlight the need for reentrancy guards (`ReentrancyGuard`), safe ERC20 functions (`SafeERC20`), careful review of external contracts, and potential logic improvements to ensure the security of the contract and the funds it manages.","---

### **Analysis of Issues and Responses**

---

#### **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Report Description**:  
The `extendLock` function does not update the `totalLocked[_asset]` value when additional assets are locked. This results in an inconsistency where the `release` function reduces `totalLocked[_asset]`, potentially causing an underflow and revert. Consequently, assets deposited via `extendLock` cannot be released, leading to a loss of funds.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. This is a critical logical error that directly impacts the functionality of the contract. The failure to update `totalLocked[_asset]` in `extendLock` violates the principle of maintaining consistent state variables and can lead to asset loss. This issue should have been explicitly addressed in the response list.

**Suggestions**:  
- Modify the `extendLock` function to ensure that `totalLocked[_asset]` is updated whenever `_amount` is increased.
- Add unit tests to verify that assets locked via `extendLock` can be released correctly.

---

#### **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Report Description**:  
The `claimGovFees` function interacts with the `bondNFT.distribute` function. If the asset is not allowed or has no shares in the `BondNFT` contract, the `distribute` function silently fails. This can result in assets being stuck in the `Lock` contract, as the failure is not handled.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. The silent failure of `bondNFT.distribute` is a significant concern, as it can lead to funds being locked in the contract indefinitely. Proper error handling and validation are necessary to ensure that the function behaves as expected.

**Suggestions**:  
- Add checks to ensure that the asset is allowed and has shares in the `BondNFT` contract before calling `distribute`.
- Handle the failure of `bondNFT.distribute` explicitly, either by reverting the transaction or logging an event to indicate the failure.

---

#### **[M-02] Must approve 0 first**

**Report Description**:  
Some tokens, such as USDT, require the allowance to be set to 0 before a new allowance can be approved. The `claimGovFees` function does not account for this behavior, which can cause the function to fail for such tokens.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. This is a known quirk of certain ERC20 tokens and should be handled to ensure compatibility with a wide range of tokens.

**Suggestions**:  
- Update the `claimGovFees` function to first set the allowance to 0 before approving a new allowance.
- Use OpenZeppelin’s `SafeERC20` library, which includes functions to handle such cases.

---

### **Additional Issues from Response List**

#### **1. Lack of Reentrancy Protection**

**Response Description**:  
The response highlights the lack of reentrancy protection in functions like `claim()`, `claimDebt()`, `release()`, and `claimGovFees()`. These functions interact with external contracts (`bondNFT` and `govNFT`), which could potentially reenter the `Lock` contract and manipulate its state.

**Assessment**:  
**Valid Concern.** This is a critical issue that was not mentioned in the original `issue` report. Reentrancy attacks are a well-known vulnerability in Solidity, and the lack of a `nonReentrant` modifier or other safeguards is a significant oversight.

**Suggestions**:  
- Add the `nonReentrant` modifier from OpenZeppelin’s `ReentrancyGuard` library to all functions that interact with external contracts.
- Reorder operations to follow the ""checks-effects-interactions"" pattern, ensuring that state changes are made before external calls.

---

#### **2. Infinite ERC20 Allowance to External Contract**

**Response Description**:  
The `claimGovFees` function sets an infinite allowance for the `bondNFT` contract. This creates a risk of token drain if `bondNFT` is compromised or upgraded maliciously.

**Assessment**:  
**Valid Concern.** This is a moderate issue that was not mentioned in the original `issue` report. Granting unlimited allowances is a common anti-pattern in Solidity and should be avoided unless absolutely necessary.

**Suggestions**:  
- Use the `SafeERC20` library to set allowances only when needed and revoke them immediately after use.
- Consider implementing a mechanism to limit the allowance to the exact amount required for each operation.

---

#### **3. Trust in External Contracts Without Validation**

**Response Description**:  
The contract assumes that `bondNFT` and `govNFT` are trusted and immutable. If these contracts are malicious or upgradeable, they could introduce vulnerabilities such as logic hijacking or fund draining.

**Assessment**:  
**Valid Concern.** This is a critical issue that was not mentioned in the original `issue` report. Blind trust in external contracts is a significant risk, especially if those contracts are upgradeable.

**Suggestions**:  
- Validate the addresses of `bondNFT` and `govNFT` during deployment to ensure they are from trusted sources.
- Consider implementing access control mechanisms to restrict interactions with these contracts.

---

#### **4. No Return Value Checks for ERC20 Transfers**

**Response Description**:  
The contract does not check the return values of `transfer` and `transferFrom` calls. Some ERC20 tokens return `false` on failure instead of reverting, which could lead to accounting errors or locked funds.

**Assessment**:  
**Valid Concern.** This is a moderate issue that was not mentioned in the original `issue` report. Proper handling of ERC20 transfers is essential to ensure the security and reliability of the contract.

**Suggestions**:  
- Use OpenZeppelin’s `SafeERC20` library, which wraps ERC20 functions and ensures proper error handling.

---

#### **5. No Event Emission**

**Response Description**:  
The contract does not emit events for important state changes, such as locking or releasing assets. This makes it difficult to track contract activity and detect malicious behavior.

**Assessment**:  
**Valid Concern.** While not a security vulnerability, this is a best-practice issue that was not mentioned in the original `issue` report. Events are crucial for transparency and debugging.

**Suggestions**:  
- Add events for all major state changes, such as `LockCreated`, `LockExtended`, `AssetsReleased`, etc.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- None.

#### **Missed Issues from Issue Report**:
- **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**
- **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**
- **[M-02] Must approve 0 first**

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
- **Lack of Reentrancy Protection**: Valid concern.
- **Infinite ERC20 Allowance to External Contract**: Valid concern.
- **Trust in External Contracts Without Validation**: Valid concern.
- **No Return Value Checks for ERC20 Transfers**: Valid concern.
- **No Event Emission**: Valid concern.

---",0,0,3,9,"```
None.
```",0.0
BondNFT.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",3270.0,384.0,"[H-05] Malicious user can steal all assets in BondNFT
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
When calling `claim()` for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.

[M-06] BondNFTs can revert when transferred
In the function `_transfer`, `BondNFTs` should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against.

[M-14] BondNFT.sol#claim() needs to correct all the missing epochs
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.

[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch
Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function Lock.lock() first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.

[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT
After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.

[M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called
Calling the following `Trading._handleOpenFees` function does not approve the GovNFT contract for spending any of the Trading contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`.",6.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; 
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; 

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             
                address(0),     
                _asset,         
                _amount,        
                epoch[_asset],  
                block.timestamp,
                expireEpoch,    
                0,              
                shares,         
                _period,        
                false           
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",2608.0,1,5,"Evaluating vulnerabilities in a contract
I’m examining the ERC721 contract for unchecked arithmetic, potential overflow, access control issues, and underflow risks when manipulating and indexing arrays by bond.expireEpoch.
Identifying indexing vulnerability
The claim() function could lead to array index out-of-range errors if bond.expireEpoch is zero, as there's no explicit check for a positive _period during bond creation.
Unraveling the complexity
I'm analyzing the claim function's intricate math with global reward distribution, suspecting it might lead to double counting or mess with the global state upon bond expiration recalculations.
Identifying transfer issues
The claim function directs funds to manager instead of _claimer, revealing a trust issue or potential vulnerability.
Evaluating non-receipt of funds during bond release and transfer constraints
The claim function sends funds to manager, not _claimer, presenting a trust or security risk. Additionally, the transfer function's epoch condition might halt transfers if epochs don't align.
Pinpointing transfer stumbling blocks
The transfer function prevents transfers within 5 minutes of bonding and lacks checks, potentially causing confusion and double counting in debt. No age epoch validation exacerbates these issues.
Unsafe calculations and checks
extendLock() might fail if the epoch is misaligned or absent. Additionally, unchecked arithmetic blocks might overflow when large shares values are calculated.
Addressing unchecked overflow risks
I’m exploring the dangers of unchecked arithmetic, especially when _amount or _period spikes, potentially leading to overflow and falsifying reward distribution, which is a significant issue.
Evaluating unchecked arithmetic risks
Surprisingly enough, unchecked arithmetic in Solidity 0.8.0 still leaves silent overflow issues, making it tricky to spot potential vulnerabilities and weird behavior in computations.
Pinpointing vulnerabilities
The primary issues identified include unchecked math leading to integer overflows, risky array indexing, and tokens being directed to manager rather than the user, which can pose significant security risks.
Examining problematic areas
I'm digging into issues like potentially outdated epochs, complex logic vulnerabilities such as re-entry risks, and insufficient checks for zero values in _amount or _period.
Addressing vulnerabilities
I’m analyzing unchecked math that might cause overflows, the absence of reentrancy guards in distribute(), and the potential issue of negative indexing from the expiration logic.","Below is a detailed analysis of the vulnerabilities and risky design choices found in the given Solidity contract. These issues range from logical/architectural flaws to classic technical pitfalls like unchecked arithmetic and indexing operations.

### 1. Unchecked Arithmetic Leading to Potential Overflow

Throughout the contract, `unchecked` blocks are used when performing arithmetic operations (e.g., in `createLock()`, `extendLock()`, `distribute()`, and elsewhere). While Solidity 0.8.0 and above reverts on overflow by default, wrapping arithmetic in `unchecked` explicitly disables these safety checks. This can lead to silent integer overflows if extremely large values are passed, or if certain calculations accumulate unexpectedly large values.

For example, in `createLock()`:
```solidity
unchecked {
    uint shares = _amount * _period / 365;
    ...
}
```
If `_amount * _period` overflows a `uint256`, it will wrap silently, leading to incorrect shares calculations. Though extremely large values might be needed to trigger this, it still represents a risk. A malicious user or unexpected input could exploit this to manipulate share computations and thus affect reward distribution.

### 2. Indexing with `bond.expireEpoch - 1` Without Bounds Checking

In the `claim()` function, when the bond is expired, the contract references:
```solidity
accRewardsPerShare[bond.asset][bond.expireEpoch-1]
```
There is no guarantee that `bond.expireEpoch` is greater than 0. If `expireEpoch` is 0 or 1, then `bond.expireEpoch - 1` could underflow or index a non-existent element, causing a revert. This could potentially lock the contract's logic if an expired bond with an invalid `expireEpoch` is encountered. A careful validation or a check that `expireEpoch > 0` must be done before using `expireEpoch-1`.

### 3. Funds Are Not Transferred to the User, but to the `manager`

In the `claim()`, `release()`, and `claimDebt()` functions, the tokens that should presumably go to the user (bond owner or claimer) are instead always transferred to the `manager` address:
```solidity
IERC20(tigAsset).transfer(manager, amount);
```
This means users never directly receive their claimed amounts, which is either a severe logic flaw or a deceptive design. The contract effectively grants the `manager` control over all distributions, making user redemption entirely dependent on a trusted third party. This is a major trust and custodial risk.

### 4. Strict Epoch Matching Constraints That Can Freeze Functionality

Several functions, such as `_transfer()` and `extendLock()`, have conditions like:
```solidity
require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
```
If `epoch[bond.asset]` does not match `block.timestamp/DAY` exactly, operations fail. This strict requirement means that if `epoch[bond.asset]` falls out of sync (e.g., because `distribute()` is not called regularly or a time passes without proper updates), users may be unable to transfer or extend their bonds at all. This can lead to a frozen contract state where no one can move or modify their NFTs due to outdated epochs.

### 5. Dependence on External Calls Without Reentrancy Protection

Functions like `distribute()`, `claim()`, and `claimDebt()` involve external ERC20 calls. For example:
```solidity
IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
IERC20(tigAsset).transfer(manager, amount);
```
No reentrancy guards (`ReentrancyGuard`) or checks are in place. A malicious ERC20 token could implement a fallback or `transfer` hook to reenter the contract and manipulate internal state. Although not trivially exploitable in the provided logic, lack of reentrancy protection is a known risk in complex contracts handling external calls.

### 6. Inconsistent and Confusing Reward Accounting Logic

The code attempts to manage reward distribution using `accRewardsPerShare`, `bondPaid`, and periodic epochs. However, the logic in `claim()`—especially when handling expired bonds—is complex and suspicious. It recalculates and updates `accRewardsPerShare` globally during a claim:
```solidity
if (bond.expired) {
    uint _pendingDelta = (... complicated calculation ...);
    if (totalShares[bond.asset] > 0) {
        accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta * 1e18 / totalShares[bond.asset];
    }
}
```
This design allows a single bond claim to retroactively adjust global distribution metrics. Such complexity can introduce subtle vulnerabilities, double-counting, or incorrect global state updates if manipulated cleverly.

### 7. `userDebt` Accounting and Transfer Conditions

When transferring bonds, the contract modifies `userDebt`:
```solidity
userDebt[from][bond.asset] += bond.pending;
bondPaid[_id][bond.asset] += bond.pending;
```
This means that simply transferring the NFT can increase a user’s debt for that asset, potentially trapping them into a situation where they owe more without a clear or fair mechanism to reclaim what is due. The logic here is opaque and may be exploitable or at least highly confusing to users.

### 8. Possible Zero-Period Bonds and Permanent Expiration Issues

The code does not explicitly forbid creating locks with `_period = 0`. If `_period=0`, `expireEpoch = epoch[_asset]`. If conditions shift and `epoch[_asset]` advances, the bond could become instantly expired or cause logic anomalies. When attempting to claim expired rewards, the contract tries to reference `expireEpoch-1`, which would fail if `expireEpoch` equals `epoch[_asset]` and has not advanced properly.

### 9. Manager Authority and Centralization Risks

The `onlyManager` modifier gives the `manager` broad control over critical functions, including `createLock()`, `extendLock()`, `claim()`, and `release()`. Coupled with the fact that all user funds from these operations go to `manager`, this creates a highly centralized and trust-dependent system. The `manager` can effectively gatekeep user access to their funds. If the manager becomes malicious or compromised, user funds could be at risk.

---

### Summary of Vulnerabilities:

1. **Unchecked arithmetic** leading to potential integer overflow in share and reward calculations.
2. **Out-of-bounds array indexing** (e.g., `expireEpoch-1` without ensuring `expireEpoch > 0`).
3. **Funds not going to the user but to a `manager` address**, creating a trust/custodial issue.
4. **Strict epoch matching requirements** that can render the contract unusable if epochs become unsynchronized.
5. **No reentrancy protection** in functions handling external ERC20 calls.
6. **Complex and potentially flawed reward distribution logic**, allowing single claims to retroactively alter global distribution states.
7. **User debt accounting on transfers** is confusing and potentially exploitable.
8. **No safeguards against zero-period locks**, leading to potentially invalid indexing and expired conditions.
9. **Excessive centralization of power in the `manager`**, enabling them to withhold user funds.

All of these issues, individually or combined, pose significant risks to users, fairness, and the correct functioning of the contract.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-05] Malicious user can steal all assets in BondNFT**

**Report Description**:  
The `claim()` function recalculates `accRewardsPerShare` for expired bonds, redistributing rewards to other bonds. This logic flaw allows a malicious user to manipulate the reward distribution mechanism, potentially draining all assets in `BondNFT` and causing other users to lose their rewards.

**Match in Response List**:  
Partially matches with **""6. Inconsistent and Confusing Reward Accounting Logic""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The response identifies issues with the reward distribution logic in `claim()` and highlights the complexity and potential for incorrect global state updates. However, it does not explicitly address the specific exploit scenario where a malicious user could drain all assets. The response should have included a detailed explanation of how the recalculation of `accRewardsPerShare` could be exploited and proposed a mitigation strategy, such as isolating reward calculations for expired bonds or implementing stricter checks.

**Suggestions**:  
- Clearly outline how the recalculation of `accRewardsPerShare` can be exploited.  
- Propose a fix, such as ensuring that expired bonds do not affect the global reward distribution state or implementing a separate mechanism for handling expired bonds.

---

#### **[M-06] BondNFTs can revert when transferred**

**Report Description**:  
The `_transfer` function should allow `BondNFTs` to be transferrable, as per the proposal and sponsor's intent. However, the current implementation may cause reverts, preventing the transfer of `BondNFTs`.

**Match in Response List**:  
No match found.

**Validation**:  
**Unaddressed**.  
The `response_list` does not mention any issues related to the `_transfer` function or the transferability of `BondNFTs`. This is a significant oversight, as the inability to transfer `BondNFTs` contradicts the intended functionality and could severely limit the usability of the contract.

**Suggestions**:  
- Investigate the `_transfer` function for potential causes of reverts (e.g., strict conditions, unhandled edge cases).  
- Ensure that `BondNFTs` can be transferred without restrictions, as intended.

---

#### **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Report Description**:  
The `claim()` function only updates `accRewardsPerShare[bond.asset][epoch[bond.asset]]`, missing all epochs between `bond.expireEpoch-1` and `epoch[bond.asset]`. This results in incorrect reward calculations for those epochs.

**Match in Response List**:  
Partially matches with **""6. Inconsistent and Confusing Reward Accounting Logic""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The response acknowledges flaws in the reward distribution logic but does not specifically address the issue of missing epochs in `claim()`. It fails to propose a solution for ensuring that all relevant epochs are updated correctly.

**Suggestions**:  
- Highlight the specific issue of missing epochs in `claim()`.  
- Propose a fix, such as iterating through all relevant epochs and updating `accRewardsPerShare` for each.

---

#### **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset] == 0**

**Report Description**:  
If `totalShares[tigAsset] == 0`, the `distribute()` function does not update `epoch[tigAsset]`. This causes `createLock()` to set incorrect values for the bond's mint epoch, leading to logical errors in bond creation.

**Match in Response List**:  
No match found.

**Validation**:  
**Unaddressed**.  
The `response_list` does not mention any issues related to `distribute()` or the handling of `epoch[tigAsset]` when `totalShares[tigAsset] == 0`. This is a critical oversight, as it directly impacts the correctness of bond creation.

**Suggestions**:  
- Address the issue in `distribute()` by ensuring that `epoch[tigAsset]` is updated even when `totalShares[tigAsset] == 0`.  
- Add a fallback mechanism to handle cases where `totalShares[tigAsset]` is zero.

---

#### **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**

**Report Description**:  
Unreleased locks prevent `totalShares` from being updated, causing other bonds to receive less than their fair share of rewards. This results in flawed reward distribution.

**Match in Response List**:  
Partially matches with **""6. Inconsistent and Confusing Reward Accounting Logic""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The response identifies general issues with reward distribution logic but does not specifically address the impact of unreleased locks on `totalShares` and reward distribution. It also does not propose a solution for handling unreleased locks.

**Suggestions**:  
- Highlight the specific issue of unreleased locks affecting `totalShares` and reward distribution.  
- Propose a fix, such as automatically releasing expired locks or excluding them from reward calculations.

---

#### **[M-23] Governance NFT holder can lose deserved rewards after Trading._handleOpenFees is called**

**Report Description**:  
The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance, unlike `Trading._handleCloseFees`. This discrepancy causes governance NFT holders to lose rewards.

**Match in Response List**:  
No match found.

**Validation**:  
**Unaddressed**.  
The `response_list` does not mention any issues related to `Trading._handleOpenFees` or the approval of `GovNFT` for spending `_tigAsset`. This is a significant oversight, as it directly impacts the fairness of reward distribution for governance NFT holders.

**Suggestions**:  
- Address the discrepancy between `Trading._handleOpenFees` and `Trading._handleCloseFees`.  
- Ensure that `GovNFT` is approved for spending `_tigAsset` in both functions.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **Unchecked Arithmetic Leading to Potential Overflow**

**Response Description**:  
The use of `unchecked` blocks in arithmetic operations (e.g., in `createLock()`, `extendLock()`, `distribute()`) disables Solidity's default overflow checks, potentially leading to silent overflows.

**Assessment**:  
**Valid Concern**.  
While not explicitly mentioned in the `issue` report, this is a valid concern. Disabling overflow checks can lead to incorrect calculations and vulnerabilities, especially if malicious inputs are used.

---

#### **Dependence on External Calls Without Reentrancy Protection**

**Response Description**:  
Functions like `distribute()`, `claim()`, and `claimDebt()` involve external ERC20 calls without reentrancy protection, exposing the contract to potential reentrancy attacks.

**Assessment**:  
**Valid Concern**.  
This is a recognized best practice in Solidity. Adding reentrancy guards would enhance the contract's security.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- None.

**Partially Correct Matches**:  
- **[H-05] Malicious user can steal all assets in BondNFT**.  
- **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**.  
- **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**.

**Missed Issues from Issue Report**:  
- **[M-06] BondNFTs can revert when transferred**.  
- **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset] == 0**.  
- **[M-23] Governance NFT holder can lose deserved rewards after Trading._handleOpenFees is called**.

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **Unchecked Arithmetic Leading to Potential Overflow**.  
- **Dependence on External Calls Without Reentrancy Protection**.

---",0,3,3,9,"```
None.
```",0.0
Trading.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",9443.0,1055.0,"[H-02] Riskless trades due to delay check
`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.

[H-06] Incorrect calculation of new price while adding position
The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.

[H-09] Users can bypass the `maxWinPercent` limit using a partially closing
Users can bypass the `maxWinPercent` limit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.

[H-11] Not enough margin pulled or burned from user when adding to a position
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.

[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder
Approved operators of owner of Position token can't call several function in Trading.
Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function.

[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations
Formula for `fee paid` in the `_handleOpenFees`  is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.

[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds
The function `initiateCloseOrder()`

[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()
The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.

[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18
In Trading.sol a deposit or withdrawal of tokens with decimals higher than 18 will always revert.

[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred
When `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`.",10.0,"pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); 
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; 
    uint private constant liqPercent = 9e9; 

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; 

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; 
        bool actionType; 
    }
    mapping(uint => Delay) public blockDelayPassed; 
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; 

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    

    
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); 
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, 
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); 
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); 
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); 
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); 

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    

    
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); 
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) 
                / DIVISION_CONSTANT 
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); 
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); 
        }
    }

    
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); 
    }

    
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); 
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    

    
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",7509.0,4,6,"Assessing potential risks
I’m examining the code for these vulnerabilities: reentrancy due to external contract calls and possibly setting limitDelay without proper validation. פאyl_mutex is another potential concern.
Ensuring safety
I’m confirming the limit price range calculation is secure with Solidity 0.8.0. Also, I’ll verify that position.executeLimitOrder accurately uses the updated price and address potential risks with unlimited token allowances.
Evaluating stability vault risks
I'm thinking about potential issues with _handleWithdraw: decimal differences causing miscalculations, and reliance on block numbers for delays due to their manipulability.
Mapping proxy validation
I’m noting that _validateProxy checks for valid proxies up to a set timestamp. An accurately chosen timestamp ensures valid proxy access without extending past the intended period.
Assessing stability vaults
I'm concluding that reliance on trusted vaults and tokens is a vulnerability. If the vault mints excess tokens or fails to burn them, tokens could become stuck due to the pure expectation of vault behavior.
Evaluating discretionary control
The gov contract holds key distribution authority, making it susceptible to manipulation if compromised. This could inadvertently route funds to unauthorized destinations, thereby undermining trust.
Addressing security
I'm noting issues with unchecked ERC20 transferFrom operations and multiple allowances, potentially leading to vulnerabilities if _stableVault is compromised. I'd recommend leveraging SafeERC20 to enhance security.
Assessing vulnerabilities
I’m noting that the lack of ReentrancyGuard and infinite approvals to _stableVault heighten the risk of reentrancy attacks and unauthorized token transfers, especially from untrusted contracts.
Evaluating security concerns
I'm thinking through the risks of users sending Ether to an untrusted _proxy in approveProxy and the safety of trade.price updates in executeLimitOrder due to local variable constraints.
Analyzing critical risks
I’m identifying trust in external contracts like IStableVault and IGovNFT as a major vulnerability. Malicious entities can disrupt trades or cause harmful outcomes, posing significant security threats.
Evaluating external risks
I'm assessing the vulnerabilities stemming from untrusted external calls (reentrancy, unlimited approvals, lack of parameter checks) and time-based logic (block number delays). These issues notably impact security.","Below are several potential vulnerabilities, security risks, and design weaknesses identified in the provided Solidity smart contract code. Note that some issues may depend on the trust assumptions and external dependencies, while others are general best-practice violations or common pitfalls.

### 1. Trust in External Contracts
The contract heavily relies on external contracts and interfaces (e.g., `IPosition`, `IGovNFT`, `IPairsContract`, `ITradingExtension`, `IStableVault`, `IStable`). If these external contracts are malicious, upgraded to malicious versions, or incorrectly implemented, the entire security model breaks. For example:

- **`ITradingExtension`**: Methods like `_closePosition`, `_limitClose`, `getVerifiedPrice`, and others can return manipulated values or allow reentrancy if `tradingExtension` is compromised.
- **`IStableVault` & `IStable`**: If the stable vault or stable token behaves maliciously (e.g., returns bogus balances, never reverts on failures, or reenters the contract), funds can be stolen or logic can be subverted.
- **`IGovNFT`**: Distributing fees via `gov.distribute()` is trusted. A malicious `gov` contract can redirect fees arbitrarily, preventing proper fee distribution and harming users.

**Risk**: All external calls assume honest and correct behavior. There is no sanity checking, and no `ReentrancyGuard` or `try/catch` patterns are used to handle unexpected reverts or malicious behavior.

### 2. Potential Reentrancy Attacks
The contract calls multiple external contracts before finalizing its own state changes, with no `ReentrancyGuard` mechanism in place. For example:

- In `_handleDeposit()` and `_handleWithdraw()`, it calls `IStableVault.deposit()` and `IStableVault.withdraw()` respectively. A malicious vault could reenter the contract or other linked contracts.  
- In `_closePosition()`, `_updateFunding()`, `_handleCloseFees()`, and other areas, external calls are made after partial state updates. If any of these calls allow reentrancy (directly or indirectly), the attacker can reenter the contract’s functions and manipulate states or balances mid-execution.

**Risk**: Without a reentrancy guard, the contract is vulnerable if any called external contract is malicious or can yield control flow.

### 3. Unlimited Token Approvals
In the `_handleDeposit()` function, the contract grants `type(uint).max` token allowance to `_stableVault`. If the stable vault or the token is malicious or compromised, it can drain these tokens at any time.

**Risk**: Unlimited allowances are considered a best-practice violation. If `_stableVault` is not fully trusted, this can lead to token theft.

### 4. Reliance on Off-Chain Signatures and Price Data Without Proper Validation
The contract calls `tradingExtension.getVerifiedPrice()` with `_priceData` and `_signature`, presumably relying on off-chain signed prices. If `tradingExtension` is compromised, or the signing mechanism is not secure, invalid or manipulated prices can be passed in. There is no visible logic to confirm the validity of these signatures beyond relying on `tradingExtension`.

**Risk**: Oracles or external pricing sources can be attacked to manipulate prices and cause user losses.

### 5. Lack of SafeERC20 Usage
The contract directly calls `IERC20.transferFrom()` and `IERC20.transfer()` without verifying return values. While most modern tokens revert on failure, older ERC20 tokens that return `false` could cause silent failures.

**Risk**: Non-standard tokens might not behave as expected, causing silent failures and unexpected outcomes.

### 6. Complex Arithmetic and Fee Calculations Without Overflow Checks
Although Solidity 0.8+ reverts on arithmetic overflow, complex fee calculations and division by `1e18`, `1e10`, etc., can lead to integer truncation or unexpected rounding. Proper rounding checks, especially when dealing with different token decimals, are not present. Misconfigured decimals or fee multipliers can cause unexpected results.

**Risk**: Incorrect fee distributions or rounding errors might harm users.

### 7. Unclear Ownership and Access Control
The contract uses `onlyOwner` in certain setter functions but does not show inheritance from `Ownable` or any code implementing `owner`. We must assume `MetaContext` or another imported file handles it. If `owner` is not properly initialized or if `onlyOwner` is compromised, a malicious party could alter critical parameters.

**Risk**: Improperly defined ownership or access control could allow unauthorized calls to `setFees`, `setTradingExtension`, or other privileged setters, potentially letting attackers manipulate trading parameters and fees.

### 8. Capping User Profits (`maxWinPercent`)
The contract imposes a `maxWinPercent` cap on user payouts. The owner can set `maxWinPercent` to a very low number, effectively rugging traders by limiting their profits unfairly.

**Risk**: A malicious or compromised owner can use `maxWinPercent` to exploit users, causing financial loss and unfair trading conditions.

### 9. Use of Block Number for Delays
The contract uses `block.number` to enforce delays in `_checkDelay()`. Block numbers can be influenced by miners and are not a reliable measure of time. Time-based logic should use `block.timestamp`.

**Risk**: Miners might manipulate block numbers slightly, although this is a minor risk. Still, best practice is to use timestamps for time delays.

### 10. Proxy Approvals and `approveProxy` Function
The `approveProxy` function is `external payable` and sends any received Ether directly to the `_proxy` address. If a user mistakenly calls it with a malicious `_proxy`, they lose their Ether. Also, `proxyApprovals` allow `_proxy` to act on behalf of `_trader` until a certain timestamp. There is no mechanism to revoke or update approvals early.

**Risk**: Poorly designed proxy access control can let proxies trade on behalf of a user for longer than intended, and user funds can be sent to arbitrary addresses.

---

### Summary of Main Vulnerabilities

- **Reentrancy**: No guard against reentrancy when calling external contracts.
- **Trust in External Contracts**: If `tradingExtension`, `position`, `stableVault`, `gov`, or tokens are not trusted, the contract can be exploited.
- **Unlimited Allowances**: Granting `type(uint).max` allowance to external vaults is dangerous.
- **Weak Validation of External Inputs**: Price data, referrals, and proxies rely on correct and honest external sources.
- **Capped Profits and Owner Control**: The owner can manipulate settings (`maxWinPercent`, fees, vaults) to disadvantage users.

In conclusion, while the contract may function as intended in a trustworthy ecosystem, it exhibits several patterns that are generally considered unsafe or risky: no reentrancy protection, reliance on trusted external contracts, infinite approvals, and extensive owner privileges that could be abused.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-02] Riskless trades due to delay check**

**Report Description**:  
The `Trading.limitClose()` function uses `_checkDelay()`, which allows for riskless trades. Traders can exploit this by capturing price rises through increasing the stop-loss while preventing underwater positions from being closed by continuously increasing the delay. This creates an unfair advantage for traders and undermines the integrity of the trading system.

**Match in Response List**:  
Partially matches with **""9. Use of Block Number for Delays""** in `response_list`.

**Validation**:  
**Partially Correct**. The response identifies the use of `block.number` in `_checkDelay()` as a potential issue, highlighting that block numbers are not reliable for time-based logic and can be influenced by miners. However, it does not explicitly address the exploitability of `_checkDelay()` in the context of riskless trades. The response should have included a discussion on how `_checkDelay()` can be manipulated to prevent closing underwater positions or capture price rises unfairly.

**Suggestions**:  
- The response should explicitly address the exploitability of `_checkDelay()` and recommend implementing stricter validation or alternative mechanisms to prevent abuse.
- Replace `block.number` with `block.timestamp` for more reliable time-based logic.

---

#### **[H-06] Incorrect calculation of new price while adding position**

**Report Description**:  
The formula used for calculating `_newPrice` in the `addToPosition()` function of `Trading.sol` is incorrect. This results in users losing part of their funds or profits when using this function, leading to financial harm and undermining user trust.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Unaddressed**. The `response_list` does not mention any issues related to the incorrect calculation of `_newPrice` in the `addToPosition()` function. This is a critical issue as it directly impacts user funds and the accuracy of trading operations.

**Suggestions**:  
- The response should include a detailed analysis of the `_newPrice` calculation formula and recommend corrections to ensure accurate calculations.
- Add test cases to validate the correctness of the formula under various scenarios.

---

#### **[H-09] Users can bypass the `maxWinPercent` limit using a partially closing**

**Report Description**:  
Users can bypass the `maxWinPercent` limit by partially closing their positions. This allows them to receive more funds than the upper limit set by the protocol, leading to potential financial losses for the protocol and unfair advantages for users.

**Match in Response List**:  
Partially matches with **""8. Capping User Profits (`maxWinPercent`)""** in `response_list`.

**Validation**:  
**Partially Correct**. The response highlights the risks associated with the `maxWinPercent` cap, noting that a malicious or compromised owner can set it to an unfairly low value. However, it does not address the specific issue of users bypassing the cap through partial closures. The response should have included a discussion on how to enforce the `maxWinPercent` limit even in cases of partial closures.

**Suggestions**:  
- Implement logic to track cumulative profits from partial closures and enforce the `maxWinPercent` limit accordingly.
- Add tests to ensure the `maxWinPercent` limit cannot be bypassed.

---

#### **[H-11] Not enough margin pulled or burned from user when adding to a position**

**Report Description**:  
When adding to a position, the margin pulled from the user is insufficient, leading to value leakage from the protocol. This reduces the collateralization ratio of `tigAsset`, potentially destabilizing the system.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Unaddressed**. The `response_list` does not mention any issues related to insufficient margin being pulled or burned when adding to a position. This is a significant oversight as it directly impacts the protocol's financial stability.

**Suggestions**:  
- The response should analyze the margin calculation logic and recommend adjustments to ensure the correct amount of margin is pulled or burned.
- Add tests to verify that the margin calculations are accurate and align with the protocol's requirements.

---

#### **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**

**Report Description**:  
Approved operators of the Position token cannot call certain functions in `Trading`, such as `initiateCloseOrder`, due to the `_checkOwner` function only verifying the token owner. This restricts functionality for approved operators and may hinder legitimate use cases.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Unaddressed**. The `response_list` does not address the issue of approved operators being unable to call certain functions. This is a medium-priority issue as it limits the flexibility and usability of the contract.

**Suggestions**:  
- Update the `_checkOwner` function to allow approved operators to call relevant functions.
- Add tests to ensure approved operators can perform actions on behalf of the token owner.

---

#### **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations**

**Report Description**:  
The formula for `_feePaid` in `_handleOpenFees` is incorrect, leading to inaccurate margin calculations. This directly affects traders' margins and associated fees, posing a high risk to the protocol's financial integrity.

**Match in Response List**:  
Partially matches with **""6. Complex Arithmetic and Fee Calculations Without Overflow Checks""** in `response_list`.

**Validation**:  
**Partially Correct**. The response mentions potential issues with complex fee calculations and rounding errors but does not specifically address the incorrect `_feePaid` formula in `_handleOpenFees`. The response should have included a detailed analysis of the formula and its impact on margin calculations.

**Suggestions**:  
- Review and correct the `_feePaid` formula to ensure accurate calculations.
- Add tests to validate the formula under various scenarios.

---

#### **[M-12] Centralization risks: owner can freeze withdrawals and use timelock to steal all funds**

**Report Description**:  
The owner has excessive privileges, including the ability to freeze withdrawals and use the timelock to steal funds. This poses significant centralization risks and undermines user trust.

**Match in Response List**:  
Partially matches with **""7. Unclear Ownership and Access Control""** in `response_list`.

**Validation**:  
**Partially Correct**. The response highlights risks related to unclear ownership and access control but does not specifically address the ability to freeze withdrawals or use the timelock to steal funds. The response should have included recommendations to mitigate these risks, such as implementing multi-signature governance or limiting owner privileges.

**Suggestions**:  
- Implement multi-signature governance for critical functions.
- Add time-locked emergency withdrawal mechanisms to protect user funds.

---

#### **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

**Report Description**:  
The open price of a stop order might change during execution, but the StopLoss/TakeProfit values are not revalidated for the new price. This can lead to incorrect execution and potential losses for users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Unaddressed**. The `response_list` does not mention the need to revalidate StopLoss/TakeProfit values for the new price. This is a medium-priority issue as it affects the accuracy and reliability of order execution.

**Suggestions**:  
- Add logic to revalidate StopLoss/TakeProfit values for the new price during order execution.
- Add tests to ensure the revalidation logic works as expected.

---

#### **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Report Description**:  
The `deposit` and `withdraw` functions revert when handling tokens with decimals higher than 18. This limits the contract's compatibility with certain tokens and may exclude potential users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Unaddressed**. The `response_list` does not address the issue of token compatibility due to decimal limitations. This is a medium-priority issue as it affects the contract's usability.

**Suggestions**:  
- Update the `deposit` and `withdraw` functions to handle tokens with decimals higher than 18.
- Add tests to ensure compatibility with a wide range of tokens.

---

#### **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Report Description**:  
The `_handleOpenFees` calculation is incorrect when a trade is referred, allowing users to open positions with more margin than expected. This creates inconsistencies and potential financial risks for the protocol.

**Match in Response List**:  
Partially matches with **""6. Complex Arithmetic and Fee Calculations Without Overflow Checks""** in `response_list`.

**Validation**:  
**Partially Correct**. The response mentions issues with fee calculations but does not specifically address the incorrect `_handleOpenFees` calculation for referred trades. The response should have included a detailed analysis of this specific scenario.

**Suggestions**:  
- Correct the `_handleOpenFees` calculation for referred trades.
- Add tests to validate the calculation under various scenarios.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

1. **Trust in External Contracts**:  
   The `response_list` highlights risks associated with relying on external contracts like `ITradingExtension`, `IStableVault`, and `IGovNFT`. While this is a valid concern, it is not explicitly mentioned in the `issue` report.  

   **Assessment**: Valid concern. External contract dependencies should be carefully audited, and fallback mechanisms should be implemented to handle unexpected behavior.

2. **Unlimited Token Approvals**:  
   The `response_list` mentions the use of `type(uint).max` allowances in `_handleDeposit()`. This is a valid concern but is not explicitly mentioned in the `issue` report.  

   **Assessment**: Valid concern. Unlimited allowances should be avoided unless absolutely necessary, and mechanisms to revoke allowances should be implemented.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- None.

**Partially Correct Matches**:  
- **[H-02] Riskless trades due to delay check**  
- **[H-09] Users can bypass the `maxWinPercent` limit using a partially closing**  
- **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations**  
- **[M-12] Centralization risks: owner can freeze withdrawals and use timelock to steal all funds**  
- **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Missed Issues from Issue Report**:  
- **[H-06] Incorrect calculation of new price while adding position**  
- **[H-11] Not enough margin pulled or burned from user when adding to a position**  
- **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**  
- **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**  
- **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

---",0,5,5,10,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these precision values is also 0."
,,,,,,,,6,13,,,,0,8,11,28,,
