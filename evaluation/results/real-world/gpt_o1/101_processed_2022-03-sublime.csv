nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
LendingPool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';

/**
 * @title Contract that deals with pooling of capital from lenders
 * @notice Implements the functions related to lender pooling
 * @author Sublime
 **/

contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of savings account
     */
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    /**
     * @notice address of pooled credit line
     */
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    /**
     * @notice address of verification module
     */
    IVerification public immutable VERIFICATION;
    /*
     * @notice Factor with which certain variables/constants are multiplied to maintain precision
     */
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- State variables start --------------------------------//

    /**
     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line
     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender
     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender
     */
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    /**
     * @notice Struct that stores the constants of a pooled credit line
     * @param startTime Timestamp at which pooled credit line starts
     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param collateralAsset address of token that is used as collateral deposited by the borrower
     * @param borrowLimit max tokens that was requested by borrower
     * @param minBorrowAmount min tokens that was requested by borrower
     * @param lenderVerifier address of verifier with which lenders should be verified to lend
     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account
     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable
     */
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    /**
     * @notice Struct that stores the variables of a pooled credit line
     * @param lenders mapping that stores lender specific info for the pooled credit line
     * @param sharesHeld total shares of borrow token held by the pooled credit line
              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit
              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced
              when any amount is repaid sharedHeld is increased.
              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is
              not changed.
     * @param borrowerInterestShares total interest in shares repaid by borrower
     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares
     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together
     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation
     */
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    /**
     * @notice Mapping that stores constants for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    /**
     * @notice Mapping that stores variables for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    /**
     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId
     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here
     */
    mapping(uint256 => uint256) public totalSupply;

    //-------------------------------- State variables end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice Modifier that allows only pooled credit line to call a function
     */
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- LenderPool events start ---------------------------//

    /**
     * @notice Emitted when lender deposits tokens for pooled credit line
     * @param id identifier for the pooled credit line
     * @param user address of the user
     * @param amount amount of tokens lent by user
     */
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares amount of shares of liquidity provided initially by lender withdrawn
     */
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation
     */
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when interest by yield or/and borrower is withdrawn
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower
     */
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when a lender withdraws their share of liquidation
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param collateralShare share of collateral withdrawn by lender from liquidation
     */
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    /**
     * @notice Emitted when a pooled credit line is liquidated by a lender
     * @param id identifier for the pooled credit line
     * @param collateralLiquidated amount of collateral that is received after liquidation
     */
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    //--------------------------- LenderPool events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Init start --------------------------------//

    /**
     * @notice constructor to initialize immutable global variables
     * @param _pooledCreditLine address of pooled credit line contract
     * @param _savingsAccount address of savings account contract
     * @param _verification address of verification contract
     */
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    /**
     * @notice initializes the contract in context of proxy
     */
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    //-------------------------------- Init end --------------------------------//

    //-------------------------------- PCL creation start --------------------------------//

    /**
     * @notice function invoked when creating pooled credit line
     * @dev only pooled credit line can call the create function
     * @param _id identifier for the pooled credit line
     * @param _lenderVerifier address of verifier with which lenders should be verified to lend
     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account
     * @param _borrowLimit max tokens that was requested by borrower
     * @param _minBorrowAmount min tokens that was requested by borrower
     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines
     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable
     */
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    //-------------------------------- PCL creation end --------------------------------//

    //-------------------------------- Lend & accept start --------------------------------//

    /**
     * @notice Function used by lenders to lend to pooled credit line
     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called
     * @param _id identifier for the pooled credit line
     * @param _amount amount of borrow tokens to lend
     */
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    /**
     * @notice function used to start the pooled credit line once the start time is reached
     * @dev this function needs to be called by the borrower
     * @param _id identifier for the pooled credit line
     */
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        // PCL can be started once the collection period is over
        require(block.timestamp >= _startTime, 'LP:S2');
        // PCL cannot be started once it has ended
        // PCL remains in the REQUESTED stage if it is not started
        // check _withdrawLiquidity method to see how these cases are handled
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        // If msg.sender is not borrower, then tx is rejected
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    //-------------------------------- Lend & accept end --------------------------------//

    //-------------------------------- callbacks start --------------------------------//

    /**
     * @notice Function invoked on borrow from the pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesBorrowed amount of shares borrowed
     */
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    /**
     * @notice Function invoked when repayment is done to pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesRepaid shares repaid
     * @param _interestShares interest in shares repaid
     */
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    /**
     * @notice Function invoked when pooled credit line is cancelled
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     */
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.
        delete pooledCLConstants[_id].startTime;

        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'
        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _to address to which all the borrow tokens are transferred
     */
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this is the maximum amount which can be borrowed from the PCL
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        // the borrower has not borrowed this much amount yet
        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI
        // also _notBorrowed == _borrowedLimit when the PCL has not started
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]
            // when the PCL is active totalSupply[_id] == _borrowedLimit
            // but _borrowLimit is some cases can be different than totalSupply[_id]
            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI
            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI
            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds
            // in this case too _borrowedLimit is greater than the totalSupply[_id]
            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit
            // this is done to get the _actualNotBorrowedInShares which might be less than the
            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares
            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because
            // no withdrawal of the principal fund deposited in the PCL can happen when it is active
            // interest withdrawn from the PCL has already been deducted from sharesHeld
            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime
            // borrowInterest is accrued only when PCL is active
            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares
            // any change in the totalSupply[_id] on does affect the interest shares in the PCL
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    //-------------------------------- callbacks end --------------------------------//

    //-------------------------------- Interest start --------------------------------//

    /**
     * @notice Function used to withdraw interest repaid by the borrower and
               the yield interest generated by the borrow assets deposited in the strategy
     * @dev Tokens lent are locked till end of Pooled Credit line. 
            Any interest paid by borrower can be withdrawn by lenders proportional to
            their token balances for that pooled credit line. Partial withdrawal of
            interest is not allowed. Whenever they call the `withdrawInterest` function
            they will get the entire amount of interest that is owed to them by that time
     * @param _id identifier for the pooled credit line
     */
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this checks if the constants are not deleted
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    /*
     * @dev this function updates the interest shares withdrawn by the lender.
            interest shares are of 2 types
            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender
            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender
     */
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    /**
     * @notice Function used to get interest withdrawable by a lender in pooled credit line.
               the interest this function returns is a sum of borrowerInterest + yieldInterest
               borrower interest is the interest paid by the borrower
               yield interest is the interest generated by the yield strategy
     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't 
            make any state changes except for getSharesForTokens and getTokensForShares in yield
     * @param _lender address of lender for whom interest is withdrawn
     */
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // get borrower repayments and yield interest shares
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        // convert total interest shares into tokens and return
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            // _sharesHeld is set in the _accept method
            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate
            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)
            // is the _totalYieldInterest
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    //-------------------------------- Interest end --------------------------------//

    //-------------------------------- Liquidity withdraw start --------------------------------//

    /**
     * @notice Function to withdraw liquidity by lender
     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios
            - pcl is cancelled by the borrower
            - pcl gets cancelled because because desired amount wasn't reached
            - pcl gets cancelled because it was never started by the borrower and endTime has reached
            - pcl is liquidated before the endTime has reached
            - pcl is liquidated after the endTime has reached
            - pcl is closed after all repayments
           in the other cases this function reverts
     * @param _id identifier for the pooled credit line
     */

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            // Case 0:
            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)
            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met
            // &&
            // Case 1: Pooled credit line never started because desired amount wasn't reached
            // _maxToLend is 0 if credit line is accepted so this case is never run

            //transfer liquidity provided
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within
                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL
                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            // all other cases distribute the sharesHeld proportional to their poolToken balances
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    /**
     * @notice Function that can be used to calculate principal withdrawable
     * @param _id identifier for the pooled credit line
     * @param _lender lender whose share of principal is to be withdrawn
     * @return Principal withdrawable
     */
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            // this else if block covers the conditions when PCL was cancelled OR
            // the PCL was in requested stage but never started
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    /*
    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed
           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount
    */
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    //-------------------------------- Liquidity withdraw end --------------------------------//

    //-------------------------------- Liquidation start --------------------------------//

    /**
     * @notice Function used to liquidate a pooled credit line
     * @dev only one of the lenders can liquidate their pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _withdraw flag used to identify if lender's share of
              liquidated collateral and liquidity (amount lent + interest) is also withdrawn
     */
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        // This line would call the liquidate function in the pooledCreditLine contract.
        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            // This function would give the share of the lender who called this function from the total liquidated amount
            // this will withdraw both the _collateralAsset and the borrowAsset
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    /**
     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset
     * @param _id identifier for the pooled credit line
     */
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        // this will withdraw the lender's share of liquidity (amount lent + interest)
        _withdrawLiquidity(_id, true);
    }

    //-------------------------------- Liquidation end --------------------------------//

    //-------------------------------- Pre token transfer start --------------------------------//

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                // cannot transfer to the borrower
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                // cannot transfer to a non verified user
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                // this is the case for minting tokens
                // increase the total supply of lp tokens
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                // this is the case for burn
                // reduce the total supply of lp tokens
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                // case for user to user transfer
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                // we need to transfer the lender info from to the receiving address
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            // if the transfer is from user to user, we will withdraw all the interest for the user
            // this is done because we need to transfer the lender info
            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    //-------------------------------- Pre token transfer end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _lender address of the lender for which query is made
     * @return returns lender info
     */
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    //-------------------------------- getters end --------------------------------//
}",9069,858,"[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee
The `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.

[H-02] PooledCreditLine: termination likely fails because `_principleWithdrawable` is treated as shares
`_principalWithdrawable` is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.

[M-01] Pool Credit Line May Not Able to Start When `_borrowAsset` is Non ERC20 Compliant Tokens
`IERC20(_borrowAsset).transfer(_to, _fee);`
If the USDT token is supported as `_borrowAsset`, the unsafe version of `.transfer(_to, _fee)` may revert as there is no return value in the USDT token contract’s transfer() implementation (but the IERC20 interface expects a return value).
Function `start()` will break when `_borrowAsset` is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.

[M-02] Lack of access control allow anyone to `withdrawInterest()` for any lender
`withdrawInterest()` at a certain time may not be in the best interest of the specific `lender`.
It's unconventional and can potentially cause leak of value for the `lender`. For example, the lender may still want to accrued more interest from the strategy.

[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time
An attacker could keep track of the `totalSupply` of each LenderPool to see if it is more than the `minBorrowAmount`. If so, at startTime, which is pre-announced, the attacker could call `start`, which will trigger `SAVINGS_ACCOUNT.deposit()` of the entire pool assets to mint LP tokens from external strategy, for example, in CompoundYield.
There is potentially a big sum depositing into a known Compound `cToken` contract at a known fixed time. Thus, the attacker could prepare the pool by depositing a fair sum first to lower the exchange rate before calling start in lenderPool. Hence, the deposit of the entire pool could be at a less favourable rate. This also applies to other potential strategies that are yet to be integrated. For example, in Curve pool, the attacker could prime the pool to be very imbalanced first and trigger the deposit and then harvest the arbitrage bonus by bringing the pool back to balance.",5,"pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';



contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    

    
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    
    IVerification public immutable VERIFICATION;
    
    uint256 constant SCALING_FACTOR = 1e18;

    

    

    
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    
    mapping(uint256 => uint256) public totalSupply;

    

    

    
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    

    

    

    
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    

    

    

    
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    

    

    
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    

    

    
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        
        require(block.timestamp >= _startTime, 'LP:S2');
        
        
        
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    

    

    
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        
        delete pooledCLConstants[_id].startTime;

        
        
    }

    
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        
        
        
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            
            
            
            
            
            
            
            
            
            
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            
            
            
            
            
            
            
            
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    

    

    
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            
            
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            
            
            
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    

    

    

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            
            
            
            
            
            

            
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                
                
                
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            
            
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    

    

    
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        
        
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            
            
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        
        _withdrawLiquidity(_id, true);
    }

    

    

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                
                
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                
                
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            
            
            
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    

    

    
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    
}",5453,2,3,"Identifying vulnerabilities
I’m examining the potential vulnerabilities in the contract. It uses SafeMath for arithmetic and includes an initialize() function. No storage clashes appear, but I’m working through the implications of ReentrancyGuard in SAVINGS_ACCOUNT and POOLED_CREDIT_LINE.
Assessing post-deletion use
I'm gradually evaluating _borrowedTokens usage post delete. Reentrancy guard should block reentry. Interest withdrawal and state updates are trackable with block.timestamp.
Assessing collaboration integrity
I'm considering how liquidate interacts with POOLED_CREDIT_LINE. If POOLED_CREDIT_LINE is controlled by an attacker, it could perform malicious actions, which might lead to vulnerabilities.
Assessing external trust
I'm thinking critically about the trustworthiness of IYield, SAVINGS_ACCOUNT, and VERIFICATION contracts, ensuring their integrity to avoid potential vulnerabilities in token transfers and interest calculations.
Evaluating potential risks
I'm mapping out issues such as potential denial-of-service via large _id and the lack of a reentrancy guard in _beforeTokenTransfer, which could lead to complexity and reentrancy risks.
Assessing reentrancy risks
OK, let me see. The _beforeTokenTransfer hook in ERC1155 could cause reentrancy if _withdrawInterest triggers external calls to SAVINGS_ACCOUNT.withdrawShares, which might invoke arbitrary code.
Tackling reentrancy risks
I'm mapping out _beforeTokenTransfer in ERC1155, which could trigger external calls. This might lead to reentrancy with _withdrawInterest, posing significant security concerns in token transfers.
Evaluating reentrancy mechanisms
I’m curious if lend and withdrawLiquidity effectively block malicious reentrant calls via nonReentrant. Code lack of sanitization for borrowAsset, collateralAsset, borrowAssetStrategy, lenderVerifier is noted.
Evaluating token transfer security
I’m thinking about the security of areTokensTransferable. If set to false, transfers are blocked, which is a good precaution. However, malicious tokens or strategies might trigger reentrancy through fallbacks or yield strategy callbacks.
Ensuring trustworthiness
I’m verifying that _beforeTokenTransfer() is secure with the ReentrancyGuard. If POOLED_CREDIT_LINE, SAVINGS_ACCOUNT, IVerification, IYield, or IERC20 contracts are compromised, assumptions could be violated.","Below is a detailed analysis of potential vulnerabilities and risks found in the given Solidity contract. Note that some of these points may depend on the trust model of the external contracts and tokens. If the external contracts (e.g., `ISavingsAccount`, `IYield`, `IPooledCreditLine`, `IVerification`) and tokens are fully trusted, certain issues may be less critical. Nonetheless, these are the key areas of concern:

### 1. External Contract Trust and Validation
The contract makes extensive calls to external contracts such as `POOLED_CREDIT_LINE`, `SAVINGS_ACCOUNT`, `VERIFICATION`, and `IYield`. These dependencies are assumed to be honest and correctly implemented. If any of these external contracts or interfaces are malicious or contain vulnerabilities, the LenderPool can be compromised. For example:

- **`SAVINGS_ACCOUNT` and `IYield`**: The contract relies on these to correctly handle deposits/withdrawals and to return valid share-to-token conversions. A malicious yield strategy could manipulate the shares returned, causing incorrect interest distributions or exploiting arithmetic that assumes correct token-to-share mappings.
- **`POOLED_CREDIT_LINE`**: The contract frequently trusts the `POOLED_CREDIT_LINE` for critical state transitions (like moving from `REQUESTED` to `CANCELLED`, `CLOSED`, or `LIQUIDATED` states) and for principal calculations. A compromised or misbehaving `POOLED_CREDIT_LINE` could lead the `LenderPool` to release funds prematurely, accept incorrect amounts, or fail to handle lifecycle events properly.
- **`VERIFICATION`**: The `lend()` function and token transfers rely on `VERIFICATION.isUser(...)` checks. A malicious or incorrectly implemented `VERIFICATION` contract could allow unauthorized users or disallowed addresses to lend or receive tokens, potentially bypassing lending criteria or KYC checks.

### 2. Reentrancy Risks
The contract uses `ReentrancyGuardUpgradeable` and marks most external entry points as `nonReentrant`, which is good. However, there are some subtle reentrancy concerns:

- **Reentrancy via `_beforeTokenTransfer()`**: The `_beforeTokenTransfer` hook, which is called during minting/burning/transferring of ERC1155 tokens, can trigger state-changing logic, including `_withdrawInterest()` calls. `_withdrawInterest()` can in turn call `SAVINGS_ACCOUNT.withdrawShares()`, which likely performs external calls (e.g., token transfers that may invoke external code if dealing with malicious tokens).

  Although direct external calls may be limited by safeERC20 transfers, if the underlying tokens or yield strategies are malicious, they could attempt reentrancy during these token transfers. This is a non-standard pattern: typically `_beforeTokenTransfer()` should be side-effect minimal to reduce reentrancy and complexity risks. While the `nonReentrant` modifier protects the external functions, it may not fully guard against nuanced reentrancy that could occur through token callbacks invoked in these internal steps.

In essence, the complexity and external calls from within `_beforeTokenTransfer()` could open a subtle attack surface if the tokens or yield strategies behave maliciously.

### 3. Token and Asset Assumptions
- **Malicious or Non-Standard ERC20 Tokens**: If the `borrowAsset` or `collateralAsset` are not standard ERC20 tokens (e.g., they have reentrancy hooks, or they are ERC777 tokens with hooks), or if they impose transfer fees, the logic might break down. Although `SafeERC20` is used, non-standard token behaviors (like tokens that revert conditionally, or yield tokens that trigger callbacks) could lead to unexpected reverts or reentrancy.
  
- **Infinite Approvals**: The contract grants `type(uint256).max` approvals to `POOLED_CREDIT_LINE` when creating pools. If `POOLED_CREDIT_LINE` is not trusted, or if there is any way it can be replaced or misused, this could result in unlimited token withdrawal from the contract. Typically, infinite approval is a common pattern, but it’s a risk if the approved contract is not fully trusted.

### 4. Interest Calculation Complexities
The calculation and distribution of interest involve multiple steps, divisions, and state-dependent logic. Although not necessarily a direct security vulnerability, intricate logic can lead to rounding errors, unintended interest distribution, or situations where a lender or borrower could gain a slight advantage. Attackers might exploit edge cases, especially if they can manipulate the timing of calls or the returned values from `IYield`.

### 5. Lifecycle and State Machine Edge Cases
The contract’s logic depends heavily on transitions in the pooled credit line’s lifecycle: `REQUESTED`, `CANCELLED`, `CLOSED`, `LIQUIDATED`, etc. If an attacker finds a timing exploit—e.g., lending just before `startTime`, or attempting to withdraw liquidity during ambiguous states—they might trigger unexpected behavior. While this seems properly guarded by `require()` statements, any logic oversight or incorrect reliance on `POOLED_CREDIT_LINE` states could be exploited.

### 6. Potential DoS via Large IDs or Gas Manipulation
Since `_id` is user-controlled and there are no explicit checks preventing the use of large or sparse `_id` values, it's possible (though not typically catastrophic) that an attacker could attempt some form of storage DoS by creating large IDs. This is more of a theoretical concern and less likely a critical vulnerability.

---

### Summary of Key Vulnerabilities

1. **Reliance on external untrusted contracts (IYield, ISavingsAccount, etc.)**: If these are not trusted or can be replaced, their malicious behavior could break assumptions and cause loss of funds.

2. **Complex calls in `_beforeTokenTransfer()`**: State changes and external calls inside a transfer hook open the door to subtle reentrancy attacks, especially if underlying tokens or yield strategies are malicious.

3. **Potential infinite approval issues**: Granting unlimited token approvals to external contracts always carries a risk if those contracts are not trustworthy.

4. **Complex interest calculation logic**: While not necessarily an exploit, complexity can lead to unexpected corner cases or subtle rounding exploitation.

5. **State machine complexity and timing assumptions**: Attackers might exploit off-by-one timing conditions, or rely on differences between `block.timestamp` and `getEndsAt()` from the pooled credit line to achieve unexpected results.

---

Overall, the largest concerns hinge on the trustworthiness of external contracts, the complexity of executing external calls from within ERC1155 hooks, and ensuring that all assumptions about external dependencies (verification, yield strategies, pooled credit lines) hold true.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**

**Report Description**:  
The `_principalWithdrawable` is miscalculated when `_start()` is invoked with a non-zero start fee. This is because the borrow limit is reduced by the fee, but `totalSupply[id]` is not adjusted proportionally. This results in `_principalWithdrawable` being more than expected, leading to potential over-withdrawals and financial discrepancies.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. The problem lies in the incorrect calculation of `_principalWithdrawable` due to the mismatch between the borrow limit and `totalSupply[id]`. This is a critical logical error that could lead to financial inconsistencies and should be explicitly addressed.

**Suggestions**:  
- The response should include a fix for the calculation of `_principalWithdrawable` to ensure it accounts for the start fee and maintains a 1:1 relationship with the borrow limit.
- Add tests to verify the correctness of `_principalWithdrawable` under various scenarios, including non-zero start fees.

---

#### **[H-02] PooledCreditLine: Termination likely fails because `_principalWithdrawable` is treated as shares**

**Report Description**:  
The `_principalWithdrawable` is denominated in the borrow asset but is incorrectly treated as the share amount to be withdrawn. This mismatch could cause the termination process to fail, leading to stuck funds or incorrect withdrawals.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. The problem stems from a fundamental misunderstanding of the units of `_principalWithdrawable`, which could lead to failed terminations or incorrect fund handling.

**Suggestions**:  
- The response should include a correction to ensure `_principalWithdrawable` is properly converted to shares before being used in withdrawal logic.
- Add unit tests to validate the termination process under various scenarios.

---

#### **[M-01] Pool Credit Line May Not Be Able to Start When `_borrowAsset` is Non-ERC20 Compliant Tokens**

**Report Description**:  
The `start()` function uses `IERC20(_borrowAsset).transfer(_to, _fee)`. If `_borrowAsset` is a non-standard ERC20 token (e.g., USDT), which does not return a value for `transfer()`, the function will revert. This could prevent the pool from starting, especially for widely used tokens like USDT, leading to a loss of potential users.

**Match in Response List**:  
Partially matches with **""Token and Asset Assumptions""** in the response list.

**Validation**:  
**Partially Correct.** The response list mentions the risks of non-standard ERC20 tokens and their potential to cause reverts or unexpected behavior. However, it does not explicitly address the issue in the `start()` function or suggest a solution, such as using `SafeERC20`'s `safeTransfer()` to handle non-standard tokens.

**Suggestions**:  
- Update the response to explicitly recommend using `SafeERC20.safeTransfer()` for all token transfers to ensure compatibility with non-standard tokens like USDT.
- Add tests to verify the behavior of the `start()` function with non-standard tokens.

---

#### **[M-02] Lack of Access Control Allows Anyone to `withdrawInterest()` for Any Lender**

**Report Description**:  
The `withdrawInterest()` function lacks proper access control, allowing anyone to withdraw interest on behalf of any lender. This could lead to value leakage or suboptimal outcomes for lenders who prefer to accrue more interest.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address this issue. The lack of access control is a significant security vulnerability that could lead to unauthorized withdrawals and financial losses for lenders.

**Suggestions**:  
- Add access control to the `withdrawInterest()` function to ensure only the lender or an authorized entity can withdraw interest.
- Include tests to verify that unauthorized users cannot call `withdrawInterest()`.

---

#### **[M-03] Potentially Depositing at Unfavorable Rate Since Anyone Can Deposit the Entire LenderPool to a Known Strategy at a Pre-Fixed Time**

**Report Description**:  
An attacker can manipulate the exchange rate of an external strategy (e.g., Compound or Curve) by depositing a large sum before the pool's assets are deposited. This could result in the pool depositing at an unfavorable rate, allowing the attacker to profit from arbitrage.

**Match in Response List**:  
Partially matches with **""Lifecycle and State Machine Edge Cases""** in the response list.

**Validation**:  
**Partially Correct.** The response list mentions timing exploits and state machine edge cases but does not explicitly address the risk of depositing at unfavorable rates due to pre-announced start times. It also does not suggest mitigation strategies, such as randomizing deposit times or implementing rate checks.

**Suggestions**:  
- Include a mitigation strategy, such as verifying the exchange rate before depositing or randomizing the deposit time to prevent attackers from predicting it.
- Add tests to simulate and prevent such timing-based attacks.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy via `_beforeTokenTransfer()`**

**Response Description**:  
The response highlights potential reentrancy risks due to state-changing logic and external calls within `_beforeTokenTransfer()`. This could be exploited if malicious tokens or yield strategies are used.

**Assessment**:  
**Valid Concern.** While this issue is not explicitly mentioned in the `issue` report, it is a valid concern. `_beforeTokenTransfer()` should be side-effect minimal to reduce reentrancy risks. This aligns with Solidity best practices.

---

#### **[R-02] Infinite Approvals to External Contracts**

**Response Description**:  
The response mentions the risk of granting `type(uint256).max` approvals to external contracts, which could lead to unlimited token withdrawals if the approved contract is compromised.

**Assessment**:  
**Valid Concern.** While this issue is not explicitly mentioned in the `issue` report, it is a recognized risk. Limiting approvals to the required amount or implementing revocable approvals would mitigate this risk.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- **[M-01] Pool Credit Line May Not Be Able to Start When `_borrowAsset` is Non-ERC20 Compliant Tokens**
- **[M-03] Potentially Depositing at Unfavorable Rate Since Anyone Can Deposit the Entire LenderPool to a Known Strategy at a Pre-Fixed Time**

#### **Missed Issues from Issue Report**:
- **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**
- **[H-02] PooledCreditLine: Termination likely fails because `_principalWithdrawable` is treated as shares**
- **[M-02] Lack of Access Control Allows Anyone to `withdrawInterest()` for Any Lender**

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Reentrancy via `_beforeTokenTransfer()`**
- **[R-02] Infinite Approvals to External Contracts**

---",0,2,3,6,"```
None.
```",0.0
