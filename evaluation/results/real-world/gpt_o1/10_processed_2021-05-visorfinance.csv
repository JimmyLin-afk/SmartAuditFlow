nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Final Findings,Detecting aspects,matchList,MAP
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using `timeUnlockERC721()`. This is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()). Because of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).   [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval.   [H-03] Approval for NFT transfers is not removed after transfer
The `Visor.transferERC721` does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
  [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.
The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time. Recommend using a mapping (e.g., mapping(address=>Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.   [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2. While the contract uses Uniswap’s TransferHelper library function safeTransfer in other places for ERC20 tokens, or OpenZeppelin’s saferTransferFrom for ERC721 tokens (both of which call the token’s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token’s transferFrom() call without checking for its return value.
The impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.
  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).   [M-03] `timelockERC721Keys` could exceed the block size limit
On line 504 of Visor.sol, looping through the `timelockERC721Keys` could exceed the block size limit",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";


contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

   
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

   
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }


    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }


    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }


    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }


    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }


    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }


    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }


    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,"This Solidity contract appears to be a vault that handles ERC-20 and ERC-721 token management, including functionalities like locking/unlocking tokens, time-locks, and delegation for transfers. While the contract employs various safety mechanisms such as `SafeMath` for arithmetic operations and checks for balances, there are several potential vulnerabilities and areas of improvement to highlight. Below are the main vulnerabilities and issues identified:

### 1. **Reentrancy Attack Risk**
   - **Functions Involved**: `transferERC20`, `transferERC721`, `timeUnlockERC20`, `timeUnlockERC721`, and others that interact with external contracts.
   - **Vulnerability**: While the contract uses `safeTransfer` methods for transferring ERC-20 and ERC-721 tokens, there are still potential risks for reentrancy attacks, especially when calling external contracts (e.g., when calling `safeTransferFrom` for ERC-721 or transferring ERC-20 tokens). Reentrancy attacks can occur if the recipient of a token transfer is a contract, and that contract calls back into the vault, potentially modifying the vault’s state.
   - **Fix**: To mitigate this, the **checks-effects-interactions** pattern should be used more strictly. Specifically, modify state variables before calling external contracts or add a `ReentrancyGuard` modifier (from OpenZeppelin).

### 2. **Lack of proper `timelockERC20` and `timelockERC721` handling**
   - **Functions Involved**: `timeLockERC20`, `timeUnlockERC20`, `timeLockERC721`, `timeUnlockERC721`
   - **Vulnerability**: The time-locking functions rely on the assumption that the `expires` timestamp provided is in the future. While there’s a check for that (`require(expires > block.timestamp)`), there are no checks for the `expires` timestamp being reasonable (i.e., not too far in the future). This could lead to undesirable lock durations, which could tie up assets for long periods.
   - **Fix**: Add a sensible upper limit for the `expires` timestamp to prevent excessively long lock durations (e.g., 10 years).

### 3. **Gas Limit on `rageQuit` Function**
   - **Function Involved**: `rageQuit`
   - **Vulnerability**: The `rageQuit` function relies on an external contract (`IRageQuit`) with a fixed gas limit of `RAGEQUIT_GAS`. If the contract being called is complex, this gas limit might not be sufficient to complete the operation, leading to failed transactions or unexpected results.
   - **Fix**: Consider making the gas limit dynamic or allowing users to specify an adequate amount based on the complexity of the target contract.

### 4. **Unauthorized Access to Sensitive Functions**
   - **Functions Involved**: `approveTransferERC20`, `approveTransferERC721`, `timeLockERC20`, `timeLockERC721`
   - **Vulnerability**: While the contract uses `onlyOwner` modifiers for several functions, the `delegatedTransferERC20` function allows anyone to transfer ERC-20 tokens if they are ""approved."" This can potentially lead to misuse if the approval system is compromised.
   - **Fix**: Implement a stricter control mechanism for delegation, such as requiring multi-signature or multi-party approval for delegated actions. In addition, recheck if the approval mechanism allows for excessive delegation that could be exploited.

### 5. **Integer Overflow/Underflow Risks**
   - **Functions Involved**: `lock`, `unlock`, `timeLockERC20`, `timeUnlockERC20`, etc.
   - **Vulnerability**: Even though the contract uses `SafeMath` for arithmetic operations, there are still places where the logic might not correctly account for cases like underflows (e.g., subtracting from a balance that would result in a negative value). This could cause unexpected behavior when performing operations like unlocking or transferring tokens.
   - **Fix**: Always validate balances and ensure that proper checks are in place before performing arithmetic. Consider adding explicit checks for underflow and overflow situations.

### 6. **Missing Input Validation in `getNftIdByTokenIdAndAddr`**
   - **Function Involved**: `getNftIdByTokenIdAndAddr`
   - **Vulnerability**: The function has a `require(false, ""Token not found"");` statement, which is unsafe and could lead to confusing error handling. If the provided NFT is not found, it will always fail without providing a useful error message.
   - **Fix**: Replace the `require(false)` with a more informative error message and potentially return a `bool` or `-1` to indicate failure in finding the token.

### 7. **Unrestricted `setURI` Function**
   - **Function Involved**: `setURI`
   - **Vulnerability**: The `setURI` function is only protected by `onlyOwner`, which means that only the owner of the contract can modify the URI. While this might be intended, there could be cases where such a change should be controlled more strictly or logged with more transparency.
   - **Fix**: If this change is critical to the contract’s behavior, consider adding more access controls, such as requiring multiple parties to approve it, or at least emitting an event for better transparency.

### 8. **Potential Issue with `nftApprovals`**
   - **Function Involved**: `approveTransferERC721`, `transferERC721`
   - **Vulnerability**: The approval system for ERC-721 transfers is stored in `nftApprovals` via a hash. This could lead to confusion if the same NFT is approved multiple times by different delegates or owners.
   - **Fix**: Ensure that approvals are checked and cleared properly. It might also be useful to allow revoking or modifying approvals, and verifying that the same token isn't accidentally approved multiple times.

### 9. **Inefficient NFT Removal Logic in `_removeNft`**
   - **Function Involved**: `_removeNft`
   - **Vulnerability**: The `_removeNft` function iterates through the entire `nfts` array to find and remove a specific NFT, which could become inefficient as the number of NFTs grows. This could lead to higher gas costs in the future.
   - **Fix**: Consider using a mapping or other more efficient data structure to manage NFTs, such as a mapping of `nftContract` to `tokenId` or using an `EnumerableSet`.

### 10. **Approval Logic for ERC-20 Transfers**
   - **Functions Involved**: `approveTransferERC20`, `delegatedTransferERC20`
   - **Vulnerability**: The approval logic for ERC-20 tokens in `approveTransferERC20` and `delegatedTransferERC20` doesn’t ensure that the owner of the vault can review or revoke approvals at any time. This could lead to accidental transfers if approvals aren’t actively managed.
   - **Fix**: Allow for the owner to revoke or update approvals, and keep track of delegated amounts more transparently.

### 11. **Inefficient Gas Usage**
   - **General**: 
   - **Vulnerability**: Functions like `getBalanceLocked`, which iterate through the `_lockSet` to sum balances, could incur significant gas costs as the number of locks grows. This may make these functions prohibitively expensive as the system scales.
   - **Fix**: Consider optimizing storage for balances or providing cached values that update when necessary to reduce repetitive calculations.","### **Analysis of Alignment between the Issue Report and Response List**

---

### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:
This issue occurs when an NFT, previously timelocked by `timeLockERC721()`, is transferred out by a delegate but without unlocking. The `transferERC721()` function doesn't delete the timelock entry for that NFT, leading to the contract mistakenly thinking the NFT is still timelocked if it is deposited again, causing issues with the timelock recipient validation check.

**Match in Response List**:
Matches with the issue titled **""Missing Input Validation in `getNftIdByTokenIdAndAddr`""**. 

**Validation**:
**Incorrect match**. The issue described in the report specifically involves the failure to delete timelock entries for NFTs in the `transferERC721` function, whereas the response addresses a different function (`getNftIdByTokenIdAndAddr`) related to input validation errors. Therefore, there is no alignment with the actual issue reported.

**Suggestions**:
The response should focus on addressing the need for cleaning up stale timelock entries when an NFT is transferred, and adding an appropriate check in the `transferERC721` function to prevent further issues.

---

### **[H-02] NFT transfer approvals are not removed and cannot be revoked, thus leading to loss of NFT tokens**

**Report Description**:
The report identifies that once an NFT transfer approval is granted via `approveTransferERC721()`, there is no way to revoke this approval, leading to a potential loss of control over the NFT.

**Match in Response List**:
Matches with the issue titled **""Potential Issue with `nftApprovals`""**.

**Validation**:
**Correct match**. The response correctly addresses the issue of approvals not being removed or revoked in the `approveTransferERC721` function, suggesting that the approval system could lead to confusion and improper transfers if not managed properly. The solution provided focuses on ensuring that approvals are properly checked and cleared.

**Suggestions**:
The response could be improved by explicitly recommending that revoking approvals should be implemented as a function and that there should be checks to ensure an NFT is not approved multiple times by different parties.

---

### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:
The issue describes that the approval for NFT transfers is not cleared after a successful transfer, which could allow a delegate to move the NFT out again even after it has been transferred to someone else.

**Match in Response List**:
Matches with the issue titled **""Potential Issue with `nftApprovals`""**.

**Validation**:
**Correct match**. The response addresses the failure to reset approvals after transfers, highlighting that the system should check and clear approvals, preventing unauthorized multiple transfers.

**Suggestions**:
The response could include more specific guidance on where to reset approvals within the `transferERC721` function or after the transfer operation to ensure approval is removed immediately after use.

---

### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:
This issue explains the vulnerability caused by an unbounded loop in the `_removeNft` function, which could result in excessive gas consumption or transaction failure if a malicious actor adds a large number of NFTs to the vault, especially if those NFTs belong to a malicious contract.

**Match in Response List**:
Matches with the issue titled **""Inefficient NFT Removal Logic in `_removeNft`""**.

**Validation**:
**Correct match**. The response accurately identifies that iterating over the `nfts` array can lead to inefficient gas usage. It suggests using a mapping or a more efficient data structure to track NFTs, which would resolve the vulnerability by eliminating the need for an unbounded loop.

**Suggestions**:
The response can be further detailed by providing concrete code examples for implementing mappings or other optimized data structures to handle NFT storage.

---

### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:
This issue explains the risk that the `transferFrom()` call in the `timeLockERC20()` function does not handle the return value, which could result in failed token transfers being silently ignored, potentially leading to discrepancies in accounting.

**Match in Response List**:
Matches with the issue titled **""Missing Input Validation in `getNftIdByTokenIdAndAddr`""**.

**Validation**:
**Incorrect match**. The issue described in the report pertains to unhandled return values from ERC20 `transferFrom()` calls, which is a different concern than the one mentioned in the response about `getNftIdByTokenIdAndAddr`. There is no alignment between the two.

**Suggestions**:
The response should focus on handling the return value of the `transferFrom()` function by wrapping it in a `require()` statement or using a safer wrapper like `TransferHelper.safeTransferFrom`.

---

### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:
The issue describes that the `transferERC721` function does not delete the `timelockERC721s` entry for the transferred NFT, leading to a stale entry that could cause problems if the NFT is transferred back into the vault.

**Match in Response List**:
Matches with the issue titled **""Lack of proper `timelockERC20` and `timelockERC721` handling""**.

**Validation**:
**Partially correct match**. The response discusses potential issues with the handling of `timelockERC20` and `timelockERC721` without directly addressing the failure to delete entries in `timelockERC721s` when NFTs are transferred. It correctly points out the vulnerability in handling these time-locks, but the specific issue of not deleting the entry is not mentioned.

**Suggestions**:
The response should explicitly mention that `transferERC721` needs to include logic for deleting the `timelockERC721s` entry to prevent stale data from causing issues.

---

### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:
This issue notes that the function `timelockERC721Keys` may exceed the block size limit if the number of keys grows too large, potentially causing out-of-gas errors.

**Match in Response List**:
No match found.

**Validation**:
**No match**. The response list does not address this specific issue. There is no mention of concerns regarding excessive gas usage or block size limits when dealing with `timelockERC721Keys`.

**Suggestions**:
The response should consider optimizing the storage and access patterns for `timelockERC721Keys`, possibly by using pagination, indexing, or batch processing to avoid potential block size issues.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-01] Reentrancy Attack Risk**

**Response Description**:
The response identifies a reentrancy risk with functions like `transferERC20`, `transferERC721`, `timeUnlockERC20`, and `timeUnlockERC721`, recommending the use of the checks-effects-interactions pattern or a `ReentrancyGuard`.

**Assessment**:
**Valid Concern**. While not mentioned in the original issue list, this is a legitimate security concern in contracts that interact with external addresses or tokens. Ensuring that state changes are made before interacting with external contracts is a standard best practice to prevent reentrancy attacks.

**Suggestions**:
The response should provide more specific examples or code snippets on how to properly apply the checks-effects-interactions pattern in the identified functions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] NFT transfer approvals are not removed and cannot be revoked**
- **[H-03] Approval for NFT transfers is not removed after transfer**
- **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Partially Correct Matches**:

- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Missed Issues from Issue Report**:

- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault**
- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()`**
- **[M-03] `timelockERC721Keys` could exceed the block size limit**

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-01] Reentrancy Attack Risk**: A valid security concern, although not directly relevant to the issues reported.",3,1,3,2,7,11,"```
1. Potential Issue with `nftApprovals`
2. Potential Issue with `nftApprovals`
3. Inefficient NFT Removal Logic in `_removeNft`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Potential Issue with `nftApprovals`"" appears at rank 8.
   - ""Inefficient NFT Removal Logic in `_removeNft`"" appears at rank 9.

2. **Calculate the precision at each rank**:
   - At rank 8, there is 1 true positive out of 8 predictions: \( P@8 = \frac{1}{8} = 0.125 \).
   - At rank 9, there are 2 true positives out of 9 predictions: \( P@9 = \frac{2}{9} \approx 0.222 \).

3. **Average the precision values**:
   - \( AP = \frac{0.125 + 0.222}{2} \approx 0.1735 \).

**Average Precision (AP)**: 0.1735"
