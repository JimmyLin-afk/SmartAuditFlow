nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTMarketReserveAuction.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797.0,677.0,"[H-01] NFT owner can create multiple auctions
function `createReserveAuction()`
NFT owner can permanently lock funds of bidders.

[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`
The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();

error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);

error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();

error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);

error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();

error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);

error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();

error NFTMarketReserveAuction_Not_Matching_Seller(address seller);

error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();


abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  
  struct ReserveAuction {
    
    address nftContract;
    
    uint256 tokenId;
    
    address payable seller;
    
    uint256 duration;
    
    uint256 extensionDuration;
    
    
    uint256 endTime;
    
    
    address payable bidder;
    
    
    uint256 amount;
  }

  
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  
  
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  
  uint256[5] private __gap_was_config;

  
  uint256 private immutable DURATION;

  
  
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          

          if (auction.seller != originalAddress) {
            
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    
    _transferToEscrow(nftContract, tokenId);

    
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, 
      payable(0), 
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  
  
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;

        
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      

      if (auction.amount > amount) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      
      unchecked {
        
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        
        
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        

        if (auction.seller != seller) {
          
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        
        _finalizeReserveAuction(auctionId, false);

        
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      
      _finalizeReserveAuction(auctionId, true);
    }
  }

  
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  
  uint256[1000] private __gap;
}",3541.0,1,1,"Assessing contract security
I'm evaluating potential vulnerabilities in the Solidity smart contract, particularly focusing on reentrancy and logic flaws. The contract utilizes OpenZeppelin's ReentrancyGuardUpgradeable for protection.
Analyzing bid handling
I'm examining how the contract manages bids, ensures secure refunds, and validates account migrations. Signature verification and the secure implementation of AccountMigrationLibrary are critical here.
Assessing auction safeguards
I'm thinking through mechanisms to prevent premature auction finalization by verifying auction.endTime < block.timestamp and scrutinizing _transferToEscrow to avoid unintended finalizations. Potential vulnerabilities are being pinpointed.
Evaluating contract integrity
I'm assessing potential issues with feth.marketWithdrawFrom for reentrancy or external calls, and ensuring safety with nonReentrant. _sendValueWithFallbackWithdraw securely transfers ETH, protecting against reentrancy.
Examining control mechanisms
I'm analyzing Solidity's overflow checks with unchecked, the secure management of _getNextAndIncrementAuctionId(), and potential vulnerabilities like lacking NFT ownership validation before listing.
Assessing auction dynamics
I'm exploring potential confusion from updateReserveAuction allowing reserve price changes post-listing and before bidding. Assessing feth.marketWithdrawFrom's external contract risks.
Evaluating auction procedures
OK, let's think it through: _finalizeReserveAuction needs to confirm auction.bidder isn't a zero address before calling _distributeFunds(), ensuring funds are distributed correctly or the process is properly canceled.
Assessing feature safety
I'm examining the account migration feature for exploitation risks due to signature verification flaws, and noting the NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason() error's logical enforcement.
Examining auction dynamics
Wondering about time-based vulnerabilities, fallback mechanisms in _sendValueWithFallbackWithdraw, and the admin's ability to intervene in auctions, mainly focusing on trust model risks.
Contemplating finalization dynamics
Interestingly enough, anyone can finalize auctions, which aids in ensuring they are completed. There's a potential governance risk if specific roles are required for this process.
Analyzing external calls
I'm exploring how external calls influence security, considering reliance on feth for additional funds and the use of block timestamps for transaction validity. Trust in these components is crucial.
Assessing auction accuracy
I'm digging into how block.timestamp can be adjusted by miners, influencing finalization times. External reliance on feth calls also leads to risks of reentrancy or unexpected reverts.
","Below is a detailed analysis of potential vulnerabilities or concerns in the provided Solidity contract. These issues range from well-known theoretical vulnerabilities to trust assumptions that may be considered less critical in practice, depending on the overall environment and intended trust model of the application.

1. **Use of `block.timestamp` for Auction Timing**:  
   The contract uses `block.timestamp` to determine when auctions end and whether bids are still valid. Although this is a common practice, it’s well-known that `block.timestamp` can be slightly manipulated by miners within the acceptable timestamp drift. This can potentially allow miners to influence the outcome of auctions by a small margin. While generally considered a minor concern, it’s still a recognized vulnerability in time-dependent logic.

2. **Reliance on External Contracts (`feth` and `AccountMigrationLibrary`)**:  
   The contract calls external contracts and libraries:
   - `feth.marketWithdrawFrom(msg.sender, delta)` is used to handle situations where a bidder wants to top-up their bid with additional funds not sent as direct `msg.value`. If `feth` is not trusted, is compromised, or contains reentrancy vulnerabilities, it might pose a security risk. That said, `nonReentrant` should help mitigate reentrant calls, but the trust model still places external calls as a risk.
   - `AccountMigrationLibrary` is used for verifying account migrations. If the signature verification is flawed or `AccountMigrationLibrary` is compromised, it may allow unauthorized transfers of auction ownership from an original seller to a malicious actor.

3. **Dependency on Proper Implementation of Parent Contracts and Inherited Hooks**:  
   The contract inherits from and relies on several parent contracts (e.g., `NFTMarketCore`, `SendValueWithFallbackWithdraw`). If any of these inherited contracts contain bugs or unexpected behavior, this contract could inherit those vulnerabilities. For example:
   - `_transferFromEscrow` and `_transferToEscrow` are from `NFTMarketCore`. If these functions do not correctly handle NFT transfers or have logic flaws, attackers might exploit them to claim NFTs without proper payment or bypass intended checks.
   - `SendValueWithFallbackWithdraw` is used to send ETH refunds safely. If it is incorrectly implemented, it could be susceptible to reentrancy or fail to handle revert scenarios properly.

4. **Administrative Privileges and Cancellation**:  
   - The `adminCancelReserveAuction` function allows a Foundation admin to cancel any auction, returning the NFT to the seller and the funds to the bidder. If the administrator account is compromised or acts maliciously, auctions can be canceled arbitrarily. This is a trust model vulnerability rather than a strict technical exploit, but it’s still a point of centralization risk.
   - Similarly, `adminAccountMigration` allows a privileged account (the Foundation operator) to move auctions from one seller to another given a valid signature. If the operator keys are compromised or if signature checks are flawed, an attacker could reroute auctions to addresses they control.

5. **Potential Miner Extractable Value (MEV) Attacks**:  
   Since bidding and finalization depend on publicly visible state, miners or frontrunners could attempt MEV attacks. For instance, a miner might reorder transactions to place a winning bid at the last moment or finalize an auction in a way that benefits them. While this is a known limitation of public blockchain systems rather than a specific coding vulnerability, it’s worth noting.

6. **Assumptions About Token Standards**:  
   The contract assumes standard-compliant ERC-721 implementations. If the NFT contract does not adhere to the standard or behaves unexpectedly (for example, always reverting on transfers, or not implementing `ownerOf` properly), it can create denial-of-service conditions or logic inconsistencies. Although not a direct vulnerability in this contract’s code, the reliance on third-party NFT contracts is a trust and compatibility risk.

7. **Complex Business Logic and Attack Surface**:  
   The contract includes many features—reserve price auctions, extension durations, and direct fund transfers. The complexity increases the chances of subtle logic bugs. For instance:
   - If a scenario arises where `_finalizeReserveAuction` is called under unusual conditions (e.g., a partial migration scenario or a re-entrance via `feth`), unexpected states could result.
   - Auction invalidation logic and the assumption that `endTime == 0` means “not started” must consistently hold true. Any logic oversight here might allow a seller or bidder to manipulate auction states unexpectedly.

---

**Conclusion**:  
The code provided appears to follow many best practices, such as using `nonReentrant` guards, reverting with specific custom errors, and carefully managing state changes before external calls. Still, the potential vulnerabilities include reliance on external contracts, trust in privileged administrative functions, slight manipulation of `block.timestamp`, and the inherent risk of miner extractable value scenarios. Most of these issues are standard considerations in any complex on-chain marketplace rather than outright flaws in the given code.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-01] NFT owner can create multiple auctions**

**Report Description**:  
The `createReserveAuction()` function allows an NFT owner to create multiple auctions for the same NFT. This could lead to a situation where bidders' funds are permanently locked, as the contract may not properly handle overlapping auctions for the same NFT. This creates a denial-of-service (DoS) condition for bidders and undermines the integrity of the auction process.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The `response_list` does not address the issue of allowing multiple auctions for the same NFT. This is a critical vulnerability as it can lead to locked funds and disrupt the auction process. The response list should have included a discussion on ensuring that only one active auction can exist for a given NFT at any time. This could be achieved by maintaining a mapping of active auctions and checking for existing auctions before creating a new one.

**Suggestions**:  
- Add a validation check in the `createReserveAuction()` function to ensure that no active auction exists for the same NFT before creating a new one.
- Use a mapping like `mapping(uint256 => bool) activeAuctions` to track active auctions for each NFT.

---

#### **[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`**

**Report Description**:  
The `adminAccountMigration()` function is used by the operator role to update all sellers' auctions when an account migration occurs. However, while the `auction.seller` is updated to the new address, the `buyPrice.seller` is not updated. This creates a deadlock where the new account cannot cancel the auction or withdraw the NFT without the compromised account first canceling the buy price. This issue can only be resolved by migrating back to the compromised account and calling `cancelBuyPrice()` before migrating again, which is impractical and insecure.

**Match in Response List**:  
Partially matches with **""Administrative Privileges and Cancellation""**.

**Validation**:  
**Partially Correct.** The response list mentions the `adminAccountMigration` function and highlights the risks associated with administrative privileges and account migrations. However, it does not specifically address the issue of failing to update `buyPrice.seller`, which is the core of the problem. The response should have explicitly discussed the need to update all relevant state variables, including `buyPrice.seller`, during account migration to avoid deadlock scenarios.

**Suggestions**:  
- Update the `adminAccountMigration()` function to include logic for updating `buyPrice.seller` to the new address.
- Add comprehensive tests to ensure that all state variables related to the seller are correctly updated during account migration.

---

### **Issues in `response_list` Not Mentioned in `issue`**

#### **[R-01] Use of `block.timestamp` for Auction Timing**

**Response Description**:  
The contract uses `block.timestamp` to determine auction end times and bid validity. While this is common, `block.timestamp` can be slightly manipulated by miners within the acceptable drift range, potentially influencing auction outcomes.

**Assessment**:  
**Valid Concern.** This is a recognized vulnerability in time-dependent logic. Although it is not a critical issue, it is worth addressing to ensure fair auction outcomes. The use of `block.timestamp` could be replaced with a more deterministic mechanism, such as block numbers, to mitigate this risk.

---

#### **[R-02] Reliance on External Contracts (`feth` and `AccountMigrationLibrary`)**

**Response Description**:  
The contract relies on external contracts like `feth` and `AccountMigrationLibrary`. If these external contracts are compromised or contain vulnerabilities, they could pose security risks. For example, `feth` could introduce reentrancy vulnerabilities, and `AccountMigrationLibrary` could allow unauthorized account migrations if signature verification is flawed.

**Assessment**:  
**Valid Concern.** Reliance on external contracts is a common risk in Solidity development. While the contract uses `nonReentrant` to mitigate reentrancy, the trust model for external contracts should be carefully evaluated. Additionally, the integrity of `AccountMigrationLibrary` should be ensured through audits and robust signature verification.

---

#### **[R-03] Dependency on Proper Implementation of Parent Contracts and Inherited Hooks**

**Response Description**:  
The contract inherits from multiple parent contracts, such as `NFTMarketCore` and `SendValueWithFallbackWithdraw`. If these parent contracts contain bugs or unexpected behavior, the vulnerabilities could propagate to this contract.

**Assessment**:  
**Valid Concern.** Inherited contracts can introduce hidden vulnerabilities if not thoroughly audited. The response correctly identifies this risk and emphasizes the importance of ensuring the correctness of parent contracts.

---

#### **[R-04] Potential Miner Extractable Value (MEV) Attacks**

**Response Description**:  
The contract is susceptible to MEV attacks, where miners or frontrunners could reorder transactions to place winning bids or finalize auctions in their favor.

**Assessment**:  
**Valid Concern.** MEV attacks are an inherent risk in public blockchains. While this is not a specific vulnerability in the contract code, it is a valid consideration for auction-based systems.

---

#### **[R-05] Assumptions About Token Standards**

**Response Description**:  
The contract assumes that all NFTs comply with the ERC-721 standard. If an NFT contract deviates from the standard, it could cause denial-of-service conditions or logic inconsistencies.

**Assessment**:  
**Valid Concern.** This is a common risk when interacting with third-party contracts. The response correctly highlights the importance of verifying token standard compliance.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- **[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`** (Partially Correct Match)

#### **Partially Correct Matches**:
- **[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`**

#### **Missed Issues from Issue Report**:
- **[H-01] NFT owner can create multiple auctions**

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Use of `block.timestamp` for Auction Timing**
- **[R-02] Reliance on External Contracts (`feth` and `AccountMigrationLibrary`)**
- **[R-03] Dependency on Proper Implementation of Parent Contracts and Inherited Hooks**
- **[R-04] Potential Miner Extractable Value (MEV) Attacks**
- **[R-05] Assumptions About Token Standards**

---

### **Conclusion**

The `response_list` addresses several valid concerns that were not explicitly mentioned in the `issue` report, such as the use of `block.timestamp` and reliance on external contracts. However, it fails to address the critical issue of allowing multiple auctions for the same NFT and only partially addresses the issue with `adminAccountMigration()`. The responses could be improved by explicitly addressing all state variables affected by account migration and ensuring that only one auction can exist per NFT at a time.",0,1,1,7,"```
None.
```",0.0
NFTMarketCreators.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363.0,268.0,"[H-02] Creators can steal sale revenue from owners' sales
In the function `_getCreatorPaymentInfo()`
All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.
Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.

[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array
The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and catch statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a try statement, the revert is actually not handled and it will not fall through to the empty catch statement.

[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns
Based on our research, `getRoyalties()` is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.
However, in the current implementation, it always assumes that `getRoyalties()` return in terms of BPS.",3.0,"pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();


abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable 
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  
  
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    

    
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch 
      {
        
      }
    }

    
    
    
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          

          
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch 
            {
              
            }
          }

          
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch 
            {
              
            }
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch 
          {
            
          }
        }
      } catch 
      {
        
      }
    }

    
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          
          recipients = new address payable[](1);
          recipients[0] = _creator;
          
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch 
    {
      
    }

    
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch 
    {
      
    }

    
  }

  
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  
  uint256[500] private __gap;
}",1579.0,1,2,"Assessing contract risk
I'm evaluating a Solidity contract's _getCreatorPaymentInfo function. It calls external contracts, handles reverts, and manages royalty recipients from various interfaces. The READ_ONLY_GAS_LIMIT constant appears secure.
Identifying potential issues
I’m thinking through interface support, fallback scenarios returning empty arrays, and potential randomness or malicious address returns from IOwnable. These aspects warrant further examination.
Assessing security threats
If a malicious nftContract provides a false owner() address or tricks _getCreatorPaymentInfo, it could lead to incorrect royalty distributions by identifying arbitrary recipients as sellers or creators.
Identifying trust risks
I’m curious about potential trust issues with _getCreatorPaymentInfo. If _getCreatorPaymentInfo relies on isCreator for accuracy or trusts external calls, it might lead to incorrect royalty distributions or fund misdirection.
Spotting ironic risks
I'm curious about _getCreatorPaymentInfo trusting external contract interfaces. Malicious contracts could return false data, leading to incorrect royalty calculations and potential misdirection of funds.
Assessing potential risks
I'm examining the reliance on IRoyaltyRegistry and the use of unchecked for gas optimization. Malicious or manipulated registries could endanger royalty calculations, while unchecked primarily affects gas efficiency.
Assessing potential risks
The code handles mismatched arrays and out-of-gas issues and checks only that a contract supports ITokenCreator and IOwnable without ERC165 confirmation, which could introduce trust problems.
Spotting vulnerabilities
I'm thinking through the trust in external contract scenarios and absent interface validation. Malicious contracts could redirect royalties if interfaces aren't confirmed, leading to incorrect payments.","Below are the key potential vulnerabilities and issues in the given Solidity smart contract. While some may be situational or context-dependent, they are points of concern that a security reviewer would highlight.

1. **Trust in External Interfaces and Calls**:  
   The contract relies on external calls to obtain royalty and creator information from various contracts (`IRoyaltyInfo`, `IGetRoyalties`, `IGetFees`, `ITokenCreator`, `IOwnable`).  
   - **No Robust Authentication of Counterparties**: If `nftContract` is malicious or does not actually implement the stated interfaces correctly, it can return arbitrary data.  
   - **Misleading ERC165 Claims**: A malicious contract can claim support for interfaces it doesn’t truly implement (e.g., always returning `true` for `supportsInterface`). The contract attempts `try/catch` calls that only protect against reverts, not against incorrect return data or logic.

2. **Insufficient Validation of Returned Data**:  
   The contract attempts to match `_recipients.length` with `recipientBasisPoints.length` in some cases (for `IGetRoyalties` and `IGetFees`), which is good, but otherwise trusts the returned addresses as long as they are not zero. A malicious contract could:  
   - Return arbitrary recipients to funnel royalties elsewhere.  
   - Return the `seller` address as a recipient to incorrectly set `isCreator = true`.

3. **Fallback Logic Without Interface Checks for `IOwnable` and `ITokenCreator`**:  
   Towards the end of the `_getCreatorPaymentInfo` function, it attempts to call `tokenCreator()` (from `ITokenCreator`) and `owner()` (from `IOwnable`) without first confirming support via ERC165 or another reliable mechanism.  
   - If the `nftContract` simply does not revert but returns random or crafted addresses, the code will trust these as valid creators or owners.  
   - Since `try/catch` only prevents reverts, a contract that returns misleading data could pass the checks and cause erroneous outcomes.

4. **No Final Check for Failure Conditions**:  
   If all attempts fail to retrieve meaningful royalty data, the function may return empty arrays. Depending on how the caller handles these empty results, this could lead to unexpected behavior. While not inherently a security exploit, it may cause logical vulnerabilities in systems that assume at least one royalty recipient.

5. **Unverified Royalty Registry Assumptions**:  
   The constructor checks that `_royaltyRegistry` supports `IRoyaltyRegistry`, but beyond that, the contract fully trusts the `royaltyRegistry.getRoyaltyLookupAddress` result. If the registry is compromised or malicious, it can direct lookups to malicious contracts, causing incorrect royalty distributions.

6. **Reliance on `READ_ONLY_GAS_LIMIT`**:  
   If `READ_ONLY_GAS_LIMIT` is too low (not shown in the snippet), calls may revert unintentionally. While caught by `try/catch`, it can cause valid royalty info retrieval attempts to fail and fallback to less correct methods or default logic. This is not a direct exploit but a quality-of-service issue.

7. **Unchecked Arithmetic**:  
   The code uses `unchecked` blocks when iterating through recipients. While not a direct vulnerability in this context (the code is only iterating over arrays whose length it checks), it should still be noted as a potential risk if the logic or array bounds checks ever change.

---

**In summary**, the main vulnerabilities lie in the contract’s trust model: it trusts external contracts to truthfully implement interfaces and provide correct royalty/creator data, and it has limited validation of returned data beyond basic checks. A malicious or non-standard NFT contract could exploit these assumptions to manipulate the perceived royalties and creator information.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-02] Creators can steal sale revenue from owners' sales**

**Report Description**:  
The `_getCreatorPaymentInfo()` function allows creators to manipulate royalty information via the Royalty Registry right before a sale is completed. This could result in creators stealing revenue from owners' sales by altering the royalty distribution. The issue highlights the lack of safeguards against last-minute changes to royalty data, which could lead to unfair or malicious revenue distribution.

**Match in Response List**:  
Partially matches with **""Unverified Royalty Registry Assumptions""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The response in `response_list` identifies the trust issue with the Royalty Registry, noting that the contract fully trusts the `royaltyRegistry.getRoyaltyLookupAddress` result. However, it does not explicitly address the specific risk of creators manipulating royalty information right before a sale. The response could be improved by explicitly discussing the timing of royalty changes and suggesting mitigations, such as caching royalty data at the time of listing or implementing a time delay for updates.

**Suggestions**:  
- Implement a mechanism to cache royalty information at the time of listing to prevent last-minute changes.  
- Introduce a time delay for royalty updates to ensure changes cannot be made immediately before a sale.  
- Add validation to ensure that royalty updates are authorized and consistent with the original intent of the NFT contract.

---

#### **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**

**Report Description**:  
The `_getCreatorPaymentInfo()` function uses `try/catch` to handle bad API endpoints. However, if the function reverts while iterating over an unbounded `_recipients` array, the revert is not properly handled, and the catch block does not execute. This could result in NFTs being locked in the contract, as the function fails to distribute funds.

**Match in Response List**:  
Partially matches with **""Reliance on `READ_ONLY_GAS_LIMIT`""** and **""Insufficient Validation of Returned Data""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The `response_list` mentions the risk of calls reverting due to gas limits (`READ_ONLY_GAS_LIMIT`) and the lack of robust validation for returned data. However, it does not explicitly address the issue of unbounded `_recipients` arrays causing reverts during iteration. The response should have explicitly discussed the need for array size limits or alternative mechanisms to handle large arrays safely.

**Suggestions**:  
- Introduce a limit on the size of the `_recipients` array to prevent excessive gas consumption.  
- Use a batching mechanism to process large arrays in smaller chunks.  
- Enhance the `try/catch` block to handle reverts more comprehensively, ensuring that funds are not locked in the contract.

---

#### **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Report Description**:  
The `getRoyalties()` function is not a standardized API for NFT contracts, and its return values may vary. The current implementation assumes that `getRoyalties()` returns values in terms of Basis Points (BPS). This assumption could lead to incorrect or unfair royalty distributions if the function returns data in a non-standard format.

**Match in Response List**:  
Partially matches with **""Trust in External Interfaces and Calls""** and **""Insufficient Validation of Returned Data""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The `response_list` highlights the risks of trusting external interfaces and the lack of robust validation for returned data. However, it does not specifically address the assumption that `getRoyalties()` returns data in BPS format. The response should have explicitly discussed the need for standardization or additional validation to handle non-standard return formats.

**Suggestions**:  
- Implement a validation mechanism to verify the format of data returned by `getRoyalties()`.  
- Use a standardized interface for royalty information, such as EIP-2981, to ensure consistency.  
- Add fallback logic to handle cases where `getRoyalties()` returns data in an unexpected format.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Lack of Standardization for Royalty Interfaces**

**Response Description**:  
The `response_list` does not explicitly mention the lack of standardization for royalty interfaces, but this is a recurring theme in the issues discussed. The reliance on non-standard APIs like `getRoyalties()` and `getFees()` introduces risks of incorrect or inconsistent behavior.

**Assessment**:  
**Valid Concern**.  
The lack of standardization for royalty interfaces is a significant issue that affects the reliability and security of the contract. Adopting a standardized interface, such as EIP-2981, would mitigate many of the risks identified in the `issue` report.

---

#### **[R-02] Overreliance on `try/catch` for Error Handling**

**Response Description**:  
The `response_list` mentions the use of `try/catch` to handle reverts but does not discuss the limitations of this approach. Overreliance on `try/catch` can lead to silent failures and unexpected behavior if errors are not properly logged or handled.

**Assessment**:  
**Valid Concern**.  
While `try/catch` is useful for handling reverts, it should not be the sole mechanism for error handling. The contract should include additional safeguards, such as logging errors and implementing fallback logic to handle failures gracefully.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- **[H-02] Creators can steal sale revenue from owners' sales**: Partially addressed by **""Unverified Royalty Registry Assumptions""**.  
- **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**: Partially addressed by **""Reliance on `READ_ONLY_GAS_LIMIT`""** and **""Insufficient Validation of Returned Data""**.  
- **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**: Partially addressed by **""Trust in External Interfaces and Calls""** and **""Insufficient Validation of Returned Data""**.

#### **Missed Issues from Issue Report**:
- None explicitly missed, but the responses lack specificity and depth in addressing the identified issues.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Lack of Standardization for Royalty Interfaces**: Valid concern.  
- **[R-02] Overreliance on `try/catch` for Error Handling**: Valid concern.

---",0,3,0,7,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
NFTMarketOffer.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149.0,404.0,"[H-03] An offer made after auction end can be stolen by an auction winner
An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.
This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.

[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it
If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.
I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.
This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of setBuyPrice or createReserveAuction, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();

error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);

error NFTMarketOffer_Offer_Expired(uint256 expiry);

error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);

error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();


abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  
  struct Offer {
    
    
    uint32 expiration;
    
    uint96 amount;
    

    
    
    address buyer;
  }

  
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        
      }
    }
  }

  
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      

      
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      

      if (amount < _getMinIncrement(offer.amount)) {
        
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      
      
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    
    offer.buyer = msg.sender;
    
    offer.expiration = uint32(expiration);
    
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    
    delete nftContractToIdToOffer[nftContract][tokenId];
    
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) 
    {
      
    } catch {
      
      
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      
      _invalidateOffer(nftContract, tokenId);
    }
    
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      
      delete nftContractToIdToOffer[nftContract][tokenId];
      
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    
    return 1;
  }

  
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      
      return (address(0), 0, 0);
    }

    
    return (offer.buyer, offer.expiration, offer.amount);
  }

  
  uint256[1000] private __gap;
}",1815.0,1,1,"Testing vulnerabilities
I deep dive into the contract's reverted errors, considering unchecked blocks, reentrancy risks, expired responses, and Solidity-specific bugs. This identifies unprotected flaws.
Analyzing internal transfers and dependencies
I'm thinking through possible reentrancy in _transferFromEscrow, the accuracy of event states, and the contract's reliance on the undefined feth variable.
Evaluating _autoAcceptBuyPrice
I'm noting that _autoAcceptBuyPrice can set a price, manipulating minAmount or amount. This potential vulnerability depends on the logic's correctness in handling these parameters.
Shielding against feth
I'm figuring out how feth needs to be ReentrancyGuard safe or well-trusted to prevent reentrancy issues. Ensuring amount and expiration values stay within range is also crucial.
Weighing feth dependencies
I’m pulling together insights on potential vulnerabilities linked to feth calls, especially if feth is compromised or can reenter. Ensuring no state-changing internal calls are left unprotected is crucial.
Assessing design strategy
I’m evaluating the design, which might result in partial states upon revert from feth. This adds partial cancellation scenarios and external call failures to potential vulnerabilities.
Assessing transfer risks
I’m analyzing potential vulnerabilities in feth. If compromised, it could trigger reentrancy through repeated _transferFromEscrow() calls. This might lock up funds if nftContract isn't an ERC721 contract.
Evaluating _transferFromEscrow
If _transferFromEscrow fails after fund withdrawal, the transaction reverts, ensuring atomicity. This makes me think the system handles partial states with precision.","Below is a detailed analysis of potential vulnerabilities and issues in the provided Solidity smart contract code. Some points may hinge on assumptions about the larger system context (e.g., how `feth`, `_autoAcceptBuyPrice`, and `_isInActiveAuction` are implemented, and what guarantees the environment provides). Nonetheless, these are the key vulnerabilities and concerns that stand out:

### 1. Reliance on External Contracts (the `feth` contract) Without Explicit Trust or Validation

The contract makes frequent calls to an external contract `feth` (e.g. `feth.marketUnlockFor`, `feth.marketWithdrawLocked`, `feth.marketLockupFor`, and `feth.marketChangeLockup`).  
**Potential issues include:**
- **Reentrancy risk** if `feth` is not trusted or if it calls back into this contract. Although `nonReentrant` is applied to external entry points of this contract, malicious code within `feth` could attempt callback attacks. The code relies on `feth` being safe and not calling back into this contract in a harmful way.
- **Lack of validation of returned values:** The contract assumes `feth` returns sensible values for `expiration` and that it will always handle lockups and withdrawals properly. If `feth` behaves maliciously or unexpectedly (e.g., returns manipulated `expiration` values), it could exploit the logic here.

### 2. Integer Downcasting Leading to Potential Truncation

In the `makeOffer` function and `_acceptOffer` function, the expiration and amount are stored in truncated forms:
- `offer.expiration` is a `uint32`
- `offer.amount` is a `uint96`

If `feth.marketLockupFor` or `feth.marketChangeLockup` returns very large `expiration` values, they will be silently truncated when stored in a `uint32`, possibly resulting in nonsensical or extremely short/long expirations. Similarly, a large `amount` could be truncated to `uint96`.  
This truncation might cause logic errors and unintended behavior, such as offers appearing to never expire or minimum increments not functioning correctly.

### 3. Lack of Interface Checks on `nftContract`

The contract calls `IERC721(nftContract).transferFrom(...)` without verifying if `nftContract` truly supports the ERC-721 interface. If an attacker supplies a contract that does not implement ERC-721 as expected (or has non-standard behavior), this could lead to reverts or unexpected behavior. While this may cause the transaction to fail, it could also result in a situation where funds are locked or logic is disrupted.

### 4. Unexpected Behavior on Failing NFT Transfers

When `_acceptOffer` attempts to transfer the NFT directly with `IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId)` and it fails, it falls back to `_transferFromEscrow`. If `_transferFromEscrow` also fails for some reason (e.g., a non-standard NFT or escrow contract), this could lead to repeated failures and a potential denial-of-service scenario where offers cannot be accepted.

While this is not a direct financial vulnerability, it is a stability and availability concern.

### 5. Partial State Updates in `adminCancelOffers`

The `adminCancelOffers` function uses an `unchecked` loop to process multiple offers, deleting them and calling `feth.marketUnlockFor`. If for some reason `marketUnlockFor` reverts mid-iteration (such as for one of the later offers), earlier offers would have been deleted while later ones remain, potentially leaving the system in a partially updated state. This is not a traditional security vulnerability but can lead to inconsistent state and operational complexity.

### 6. Auction Interaction Logic Assumptions

The contract relies on `_isInActiveAuction` and `_autoAcceptBuyPrice` (not shown here) as well as `_afterAuctionStarted` from a parent contract. If the logic in these inherited or referenced functions can be manipulated, it could lead to acceptance or invalidation of offers at unexpected times, or prevent `_invalidateOffer` from working as intended. These are potential logical vulnerabilities depending on how these functions and inherited behaviors are implemented.

### 7. Externality and Trust Boundaries Not Clearly Defined

It’s unclear from this snippet whether `onlyFoundationAdmin` is properly enforced in the inherited contracts. If not properly restricted, `adminCancelOffers` could be called by unauthorized users, allowing malicious cancellation of valid offers.

Additionally, the trust model toward `feth` and `nftContract` is not stated. If `feth` is a known, trusted contract and `nftContract` addresses are verified ERC-721 contracts, some of these issues may be mitigated. Without such assumptions, the contract is vulnerable to malicious external contracts and return values.

---

**Summary of Key Vulnerabilities and Concerns:**

1. **Potential reentrancy and unexpected callbacks** via external `feth` calls if `feth` is not trusted or is compromised.
2. **Integer truncation issues** (downcasting `expiration` and `amount`) that can cause offers to behave unexpectedly.
3. **Lack of ERC-721 validation checks** on `nftContract` before calling `transferFrom`.
4. **Fallback transfer logic complexity** may cause denial-of-service scenarios if NFT transfers consistently fail.
5. **Partial state update risks** in `adminCancelOffers` if external calls revert partway through processing.
6. **Logical dependencies on inherited methods** that may be unsafe if those methods are not trustworthy or properly implemented.
7. **No explicit trust assumptions or checks** are made on `feth` or `nftContract`, leaving the contract vulnerable if these external contracts are malicious or non-standard.

These represent the main categories of vulnerabilities and concerns present in the given code snippet.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-03] An offer made after auction end can be stolen by an auction winner**

**Report Description**:  
The issue describes a vulnerability where an offer made for an NFT after an auction has ended can be exploited by the auction winner. The `_transferFromEscrow` function, called by `_acceptOffer`, transfers the NFT to the auction winner, finalizing the auction. However, the user who made the offer does not receive the NFT, allowing the auction winner to obtain both the NFT and the offer amount (after fees) at no additional cost. This results in a loss for the user who made the offer.

**Match in Response List**:  
**No match found.**

**Validation**:  
The `response_list` does not explicitly address this issue. While the response mentions auction interaction logic assumptions (Point 6 in the response list), it does not specifically address the scenario where an offer made after the auction ends can be exploited by the auction winner. This is a critical oversight, as the issue directly impacts the integrity of the auction process and user funds.

**Suggestions**:  
- The response should explicitly address this issue by suggesting a fix, such as adding a check to ensure that offers made after the auction ends cannot be accepted or processed until the auction winner has claimed the NFT.
- The `_acceptOffer` function should include logic to verify that the auction has been fully settled before processing any new offers.

---

#### **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

**Report Description**:  
The issue highlights a vulnerability where an NFT in escrow without an active `buyPrice` or auction can be stolen. A malicious user can exploit the `makeOffer` and `acceptOffer` functions to obtain the NFT for free. This is particularly concerning for NFTs mistakenly sent to the contract, as they are not protected by the `buyPrice` or auction structures. The severity is medium because normal usage assumes that either a `buyPrice` or auction is initialized, but mistakenly sent assets remain exposed.

**Match in Response List**:  
**No match found.**

**Validation**:  
The `response_list` does not explicitly address this issue. While the response mentions fallback transfer logic complexity (Point 4) and auction interaction logic assumptions (Point 6), it does not address the specific scenario where an NFT in escrow without an active `buyPrice` or auction can be stolen. This is a significant gap, as the issue directly relates to the security of escrowed NFTs.

**Suggestions**:  
- The response should propose a solution to prevent unauthorized access to NFTs in escrow. For example:
  - Implement a mechanism to reject `makeOffer` and `acceptOffer` calls for NFTs without an active `buyPrice` or auction.
  - Add a fallback mechanism to return mistakenly sent NFTs to their original owners.
- The contract should include a safeguard to ensure that NFTs in escrow are always associated with a valid `buyPrice` or auction structure.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reliance on External Contracts (the `feth` contract) Without Explicit Trust or Validation**

**Response Description**:  
The response highlights potential reentrancy risks and lack of validation when interacting with the external `feth` contract. It notes that the contract assumes `feth` behaves as expected and does not validate return values, which could lead to vulnerabilities if `feth` is malicious or behaves unexpectedly.

**Assessment**:  
**Valid Concern.** While this issue is not explicitly mentioned in the `issue` report, it is a valid concern. Interactions with external contracts should always include proper validation and safeguards against reentrancy. The response correctly identifies the risks and aligns with Solidity best practices.

---

#### **[R-02] Integer Downcasting Leading to Potential Truncation**

**Response Description**:  
The response identifies potential issues with integer downcasting in the `makeOffer` and `_acceptOffer` functions. Specifically, it notes that large values for `expiration` and `amount` could be truncated when stored as `uint32` and `uint96`, respectively, leading to unintended behavior.

**Assessment**:  
**Valid Concern.** This issue is not mentioned in the `issue` report but is a valid concern. Truncation of large integers can lead to logic errors and unexpected behavior, such as offers appearing to never expire. The response correctly identifies the problem and aligns with Solidity best practices.

---

#### **[R-03] Lack of Interface Checks on `nftContract`**

**Response Description**:  
The response notes that the contract does not verify whether `nftContract` supports the ERC-721 interface before calling `transferFrom`. This could lead to reverts or unexpected behavior if a non-standard or malicious contract is used.

**Assessment**:  
**Valid Concern.** This issue is not mentioned in the `issue` report but is a valid concern. Verifying that `nftContract` implements the ERC-721 interface is a best practice to ensure compatibility and prevent unexpected behavior.

---

#### **[R-04] Partial State Updates in `adminCancelOffers`**

**Response Description**:  
The response highlights a potential issue with partial state updates in the `adminCancelOffers` function. If an external call to `feth.marketUnlockFor` reverts mid-iteration, the function could leave the system in a partially updated state.

**Assessment**:  
**Valid Concern.** This issue is not mentioned in the `issue` report but is a valid concern. Partial state updates can lead to inconsistencies and operational complexity. The response correctly identifies the problem and aligns with Solidity best practices.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- None.

#### **Missed Issues from Issue Report**:
1. **[H-03] An offer made after auction end can be stolen by an auction winner**: Not addressed in the `response_list`.
2. **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**: Not addressed in the `response_list`.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **[R-01] Reliance on External Contracts (the `feth` contract) Without Explicit Trust or Validation**: Valid concern.
2. **[R-02] Integer Downcasting Leading to Potential Truncation**: Valid concern.
3. **[R-03] Lack of Interface Checks on `nftContract`**: Valid concern.
4. **[R-04] Partial State Updates in `adminCancelOffers`**: Valid concern.

---",0,0,2,7,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**.

### Explanation:
- The list of **true positives** is empty (`None`), meaning there are no relevant items to evaluate in the ranked list of predictions.
- Since there are no true positives, the precision at any rank is **0**, and the average of these precision values is also **0**.

Thus, the **Average Precision (AP)** is **0.0**."
NFTMarketPrivateSale.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896.0,205.0,"[M-01] EIP-712 signatures can be re-used in private sales
Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call the function `buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.
The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.

[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT
The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.

[M-12] Private sale spoofing
function buyFromPrivateSaleFor()
Similar to spoofing in finance, users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.
No funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature.It's also frustrating for the users if they try to accept the private sale but their transaction fails.",3.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();


abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  
  
  
  bytes32 private immutable DOMAIN_SEPARATOR;

  
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  
  
  string private constant NAME = ""FNDNFTMarket"";

  
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      
      

      
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    
    
    address payable seller = payable(nftContract.ownerOf(tokenId));

    
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    
    nftContract.transferFrom(seller, msg.sender, tokenId);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  
  uint256[1000] private __gap;
}",888.0,0,3,"• Importing contracts and verifying market address
via AddressUpgradeable.isContract(). • Examining security via signature verification with ecrecover and hash, focusing on chain ID and verifying contract.
Evaluating domain separators
OK, let me see. This involves checking if the domain separator aligns with the EIP-712 recommendation. The concern is if the chain ID is not recomputed during upgrades, which could pose security risks.
Spotting logical errors
I’m noticing that the code's error message and the actual checking condition for deadlines are out of sync, allowing loopholes relating to the intended 2-day limit.
Evaluating modifiers
I’m curious about nonReentrant, payable, and onlyOwner. Without them, NFTMarketPrivateSale might face re-entrancy risks. Modular functions use transferFrom without safeTransferFrom. Funding further highlights potential vulnerabilities.
Checking buyer validation
OK, let's verify that the contract doesn't confirm the buyer's identity through _distributeFunds. Additionally, it doesn't ensure that the token is owned by the seller at the designated time.
Ensuring signature alignment
The code verifies token ownership with ecrecover just before signature checks. This guarantees the seller's identity is current, preventing issues if the token changes hands.
Tackling potential sale discrepancies
It's interesting, the code allows a 2-day sale window, which could be a bug or a deliberate design choice to prevent overpayment, maintaining sale consistency.
Assessing replay attack risks
Interestingly enough, changes in marketProxyAddress or chain forks could invalidate the DOMAIN_SEPARATOR, leading to a high likelihood of replay attacks from other networks or chain IDs.
Assessing vulnerabilities:
We’re noticing logic inconsistencies with the deadline. Additionally, the domain separator is a fixed value and could cause issues post-upgrade or chain split, potentially leading to signature verification errors.","Below is an in-depth analysis of potential issues and vulnerabilities in the provided Solidity code. Some points may depend on the behavior of inherited contracts (e.g., `NFTMarketFees`, `feth`, and modifiers not defined here), but we will focus on what can be inferred directly:

1. **Mismatched Duration Check vs. Error Message**  
   The code enforces a maximum `deadline` constraint but does so inconsistently:
   ```solidity
   else if (deadline > block.timestamp + 2 days) {
       revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
   }
   ```
   - The error message says the private sale can only be offered for a maximum of ""24Hrs"" (24 hours), but the code checks for `2 days` (48 hours).
   - This discrepancy is misleading. An attacker or participant could leverage the confusion to set a deadline farther out than intended. Although not strictly a technical exploit, it is a logical vulnerability that can cause trust and expectation issues.

2. **No Verification of `feth` Contract Behavior**  
   The code calls:
   ```solidity
   feth.marketWithdrawFrom(msg.sender, delta);
   ```
   However, the snippet does not show what `feth` is, nor is there any safety check around it. Some potential issues:
   - If `feth` is an untrusted external contract, `feth.marketWithdrawFrom` may introduce re-entrancy or unexpected state changes. Without a `nonReentrant` guard or careful checks, this could be exploited if `feth` callback functions lead to re-entrant calls.
   - If `feth` is controlled or influenced by an attacker, it could revert unexpectedly, lock funds, or perform malicious actions.  
   
   (Note: The presence of `nonReentrant` in the code comment suggests it may be inherited from `NFTMarketFees` or a related contract, which could mitigate re-entrancy if implemented correctly. Still, it's not shown here.)

3. **Reliance on `ecrecover` Without Additional Checks**  
   The code uses `ecrecover` to verify the seller's signature:
   ```solidity
   if (ecrecover(digest, v, r, s) != seller) {
       revert NFTMarketPrivateSale_Signature_Verification_Failed();
   }
   ```
   While this is a standard approach, potential issues to consider:
   - There is no `require(seller != address(0))` check before or after `ecrecover`. If the signature or parameters are malformed in a way that returns the zero address, it will simply fail the check. While this currently leads to a revert, some might consider adding explicit zero-address checks for clarity.
   - If the EIP-712 domain separator is ever changed in a future upgrade (which might happen in upgradeable contracts), old signatures might become invalid or open to replay under certain conditions. Given this is declared `immutable` here, this is less likely an immediate vulnerability, but something to be aware of.

4. **Fixed Domain Separator for EIP-712**  
   The `DOMAIN_SEPARATOR` is computed once in the constructor using the chain ID and `marketProxyAddress`:
   ```solidity
   DOMAIN_SEPARATOR = keccak256(
       ...
       chainId,
       marketProxyAddress
   );
   ```
   If the contract is upgradeable or if the chain ID changes (e.g., due to a fork or upgrade scenario), the `DOMAIN_SEPARATOR` may no longer match the intended verification domain. Typically, this would not be an immediate ""vulnerability"" but can cause signatures to fail verification after certain governance actions or deployments. If not clearly communicated, it could cause confusion or result in unexpected behavior in the future.

5. **Strict Overpayment Rejection**  
   If a buyer sends more `msg.value` than `amount`, the function reverts:
   ```solidity
   if (amount < msg.value) {
       revert NFTMarketPrivateSale_Too_Much_Value_Provided();
   }
   ```
   While not inherently a vulnerability, it reduces flexibility and may cause user experience issues. A malicious user cannot exploit this directly to steal funds, but they could cause transactions to fail if someone attempts to overpay (intentionally or by mistake). This design choice might not be a vulnerability but worth noting as it is somewhat unusual behavior.

6. **Token Transfer Without Safety Checks**  
   The contract uses:
   ```solidity
   nftContract.transferFrom(seller, msg.sender, tokenId);
   ```
   This does not use `safeTransferFrom`. As a result:
   - If the receiving address `msg.sender` is a contract that does not implement `onERC721Received`, the transfer might get stuck if the NFT requires safe transfers. However, standard ERC-721 behavior allows direct `transferFrom` to Externally Owned Accounts (EOAs) without issue. It's not necessarily a vulnerability if the contract’s intended environment allows this.
   - Not a typical ""exploit,"" but less safe compared to `safeTransferFrom`. Still, it's standard in many marketplaces, so probably not a direct vulnerability.

7. **Lack of Explicit Ownership Checks Pre-Signature**  
   The verification process checks `seller = nftContract.ownerOf(tokenId)` and then expects the signature to match `seller`. This is a good check. A subtle concern (not necessarily a vulnerability) is if a malicious seller signs a message and then quickly transfers the NFT away before the buyer calls `buyFromPrivateSale`. In that case:
   - The signature becomes invalid because `ecrecover(...)` must match the current owner. This is good from a safety perspective since it prevents stale signatures from old owners.
   - Not a vulnerability, rather a positive security measure.


**Summary of Potential Vulnerabilities and Issues:**

- **Major Logic Discrepancy**: The biggest clear issue is the mismatch between the error message (24-hour max) and the enforced limit (2 days). This can lead to confusion and unintended behavior.
- **Dependency on External `feth` Contract**: Possible re-entrancy or security issues if `feth` is not trusted, though this cannot be confirmed without seeing `feth`’s implementation.
- **Domain Separator Stability**: If the contract is ever upgraded or the chain environment changes, the fixed `DOMAIN_SEPARATOR` may lead to signature verification issues or potential replay attacks in edge scenarios, though this is more of a design consideration than an immediate exploit.

No other straightforward, commonly known vulnerabilities (like integer overflows, unchecked external calls, or direct re-entrancy known from this snippet alone) are evident. The contract appears to follow a fairly standard EIP-712 signing approach and ensures that the current owner is the one who has signed. However, the logic vs. messaging discrepancy for the deadline stands out as a clear issue that should be addressed.","---

### **Analysis of Issues and Responses**

---

#### **[M-01] EIP-712 signatures can be re-used in private sales**

**Report Description**:  
The `buyFromPrivateSaleFor` function allows buyers to purchase NFTs using EIP-712 signatures provided by sellers. However, the contract does not track whether a signature has already been used. This allows a seller to reclaim ownership of the NFT and reuse the same signature to sell the NFT again, leading to potential double sales or misuse of the signature.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address the lack of signature replay protection. This is a critical vulnerability because it allows the same signature to be reused maliciously or unintentionally, violating the integrity of the private sale mechanism. Best practices dictate that signatures should be tracked (e.g., using a mapping of used signatures or a nonce system) to prevent replay attacks.

**Suggestions**:  
- Implement a mechanism to track used signatures, such as a mapping of message hashes to a boolean flag (`usedSignatures`).
- Alternatively, include a nonce in the signed message and ensure that each nonce is used only once.

---

#### **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Report Description**:  
If a buyer has an open offer on the same NFT, their funds may be locked, preventing them from completing a private sale. The `buyFromPrivateSaleFor` function attempts to withdraw the difference from the buyer's unlocked balance, but locked funds from the open offer make this impossible, causing the transaction to fail.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address the issue of locked funds due to open offers. This is a significant usability issue that can frustrate users and disrupt the private sale process. While not a direct security vulnerability, it impacts the functionality and user experience of the contract.

**Suggestions**:  
- Modify the logic to prioritize private sales over open offers, or provide a mechanism for users to unlock funds tied to open offers.
- Clearly document the behavior to inform users of potential conflicts between private sales and open offers.

---

#### **[M-12] Private sale spoofing**

**Report Description**:  
A malicious user can create a private sale with a valid signature and then transfer the NFT to another wallet they control before the buyer completes the transaction. This causes the buyer's transaction to fail, as the signature no longer matches the current owner. While no funds are lost, this can disrupt third-party marketplaces or frustrate users.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The response list does not address the potential for private sale spoofing. While this issue does not result in direct financial loss, it can harm the user experience and disrupt off-chain marketplaces that rely on the private sale mechanism.

**Suggestions**:  
- Include a mechanism to lock the NFT during the private sale period, preventing the seller from transferring it to another wallet.
- Alternatively, provide clear documentation to warn users and third-party marketplaces about this behavior.

---

#### **[R-01] Mismatched Duration Check vs. Error Message**

**Response Description**:  
The code enforces a maximum `deadline` constraint of 48 hours but uses an error message that states the limit is 24 hours. This discrepancy can cause confusion and lead to unintended behavior.

**Validation**:  
**Correct.** The response accurately identifies the mismatch between the error message and the enforced limit. This is a logical error that could lead to user confusion but does not pose a direct security risk.

**Suggestions**:  
- Update the error message to reflect the correct limit (48 hours) or adjust the code to enforce a 24-hour limit, depending on the intended behavior.

---

#### **[R-02] No Verification of `feth` Contract Behavior**

**Response Description**:  
The `feth.marketWithdrawFrom` function is called without verifying the behavior of the `feth` contract. If `feth` is untrusted, it could introduce reentrancy or other unexpected state changes.

**Validation**:  
**Partially Correct.** The response highlights the potential risks of interacting with an external contract (`feth`) but does not confirm whether the `nonReentrant` modifier is implemented. If `nonReentrant` is used, reentrancy risks are mitigated. However, the response does not address other potential issues, such as unexpected reverts or malicious behavior by the `feth` contract.

**Suggestions**:  
- Confirm whether the `nonReentrant` modifier is implemented. If not, add it to prevent reentrancy attacks.
- Add checks to handle unexpected reverts or malicious behavior by the `feth` contract.

---

#### **[R-03] Reliance on `ecrecover` Without Additional Checks**

**Response Description**:  
The code uses `ecrecover` to verify signatures but does not include additional checks, such as ensuring the recovered address is not the zero address.

**Validation**:  
**Correct.** The response correctly identifies the lack of a zero-address check. While the current implementation reverts if the signature is invalid, adding an explicit check for the zero address would improve clarity and robustness.

**Suggestions**:  
- Add a `require(seller != address(0))` check after `ecrecover` to ensure the recovered address is valid.

---

#### **[R-04] Fixed Domain Separator for EIP-712**

**Response Description**:  
The `DOMAIN_SEPARATOR` is computed once in the constructor and does not account for potential changes in the chain ID or contract address.

**Validation**:  
**Correct.** The response highlights a potential issue with the fixed `DOMAIN_SEPARATOR`. While this is not an immediate vulnerability, it could cause issues in the future if the contract is upgraded or the chain environment changes.

**Suggestions**:  
- Consider implementing a dynamic `DOMAIN_SEPARATOR` that updates based on the current chain ID and contract address.

---

#### **[R-05] Strict Overpayment Rejection**

**Response Description**:  
The function reverts if the buyer sends more `msg.value` than the required amount, which may cause user experience issues.

**Validation**:  
**Correct.** The response identifies a design choice that could frustrate users but does not pose a security risk.

**Suggestions**:  
- Allow overpayments and refund the excess to the buyer to improve user experience.

---

#### **[R-06] Token Transfer Without Safety Checks**

**Response Description**:  
The contract uses `transferFrom` instead of `safeTransferFrom`, which may cause issues if the recipient is a contract that does not implement `onERC721Received`.

**Validation**:  
**Correct.** The response correctly identifies the potential issue with using `transferFrom`. However, this is a common practice in marketplaces and does not pose a significant risk if the intended environment allows it.

**Suggestions**:  
- Use `safeTransferFrom` to ensure compatibility with contracts that implement `onERC721Received`.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- **[R-01] Mismatched Duration Check vs. Error Message**
- **[R-03] Reliance on `ecrecover` Without Additional Checks**
- **[R-04] Fixed Domain Separator for EIP-712**
- **[R-05] Strict Overpayment Rejection**
- **[R-06] Token Transfer Without Safety Checks**

#### **Partially Correct Matches**:
- **[R-02] No Verification of `feth` Contract Behavior**

#### **Missed Issues from Issue Report**:
- **[M-01] EIP-712 signatures can be re-used in private sales**
- **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**
- **[M-12] Private sale spoofing**

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

No additional issues were identified beyond those already discussed.

---",0,0,3,7,"```
1. Mismatched Duration Check vs. Error Message
2. Reliance on `ecrecover` Without Additional Checks
3. Fixed Domain Separator for EIP-712
4. Strict Overpayment Rejection
5. Token Transfer Without Safety Checks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - The ranked list of predictions is provided in the text, and the true positives are:
     ```
     1. Mismatched Duration Check vs. Error Message
     2. Reliance on `ecrecover` Without Additional Checks
     3. Fixed Domain Separator for EIP-712
     4. Strict Overpayment Rejection
     5. Token Transfer Without Safety Checks
     ```

   - From the text, the ranks of the true positives are:
     - **Mismatched Duration Check vs. Error Message**: Rank 1
     - **Reliance on `ecrecover` Without Additional Checks**: Rank 3
     - **Fixed Domain Separator for EIP-712**: Rank 4
     - **Strict Overpayment Rejection**: Rank 5
     - **Token Transfer Without Safety Checks**: Rank 6

2. **Calculate the precision at each rank where a true positive appears**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).

   - For each true positive:
     - **Rank 1**: \( P@1 = \frac{1}{1} = 1.0 \)
     - **Rank 3**: \( P@3 = \frac{2}{3} \approx 0.6667 \)
     - **Rank 4**: \( P@4 = \frac{3}{4} = 0.75 \)
     - **Rank 5**: \( P@5 = \frac{4}{5} = 0.8 \)
     - **Rank 6**: \( P@6 = \frac{5}{6} \approx 0.8333 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.6667 + 0.75 + 0.8 + 0.8333}{5} \)
   - \( AP = \frac{4.05}{5} \)
   - \( AP = 0.81 \)

**Output**:
```
0.81
```"
SendValueWithFallbackWithdraw.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802.0,94.0,"***[M-02] `withdrawFor` function may fail to withdraw ether recorded in pendingWithdrawals***
The `NFTMarketFees` contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.",1.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();


abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  
  mapping(address => uint256) private pendingWithdrawals;

  
  event WithdrawPending(address indexed user, uint256 amount);
  
  event Withdrawal(address indexed user, uint256 amount);

  
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    
    
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      
      
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  
  uint256[499] private __gap;
}",353.0,0,1,"Assessing potential risks
I’m thinking through the contract's security. The nonReentrant modifier helps prevent re-entrancy. The absence of onlyOwner might be minor. Automatic overflow protection is present in Solidity 0.8.0+
Evaluating overflow risks
unchecked raises overflow concerns if pendingWithdrawals[user] becomes too large. No automatic reversion on failed calls might open another vulnerability.
Clarifying vulnerabilities
The fallback system stores pending withdrawals temporarily. The nonReentrant guard prevents re-entrancy, but potential issues arise from unchecked arithmetic and lack of initializer configuration in upgradeable proxies.
Assessing potential risks
If nonReentrant isn't properly initialized, re-entrancy protection may fail. The unchecked block might lead to integer overflow, and withdrawFor()'s design allows withdrawals on behalf of others.
Wrestling with access control
OK, let me see. The lack of internal access control in _sendValueWithFallbackWithdraw might lead to unintended fund additions. Possible integer overflow from unchecked arithmetic remains a concern, but they aren't vulnerabilities, just design choices.
Ensuring safety
The reversion of sendValue upon failure is actually a good thing. It means pendingWithdrawals[user] isn't cleared prematurely, maintaining a reliable flow.
Assessing potential points of failure
OK, let me see. The unchecked block increases pendingWithdrawals[user], leading to an integer overflow risk. Also, the code lacks innovative elements, sticking to standard practices with some weak points.","Below are the key vulnerabilities and concerns present in the given smart contract code:

1. **Unchecked Arithmetic on `pendingWithdrawals`**:  
   The contract uses an `unchecked` block when incrementing `pendingWithdrawals[user]`:
   ```solidity
   unchecked {
       pendingWithdrawals[user] += amount;
   }
   ```
   Under Solidity ^0.8.0, arithmetic overflow and underflow revert by default. By explicitly using `unchecked`, these safety checks are bypassed. This introduces a risk of integer overflow if `pendingWithdrawals[user]` and `amount` are large enough. Although this may require extreme conditions (given the large maximum value of `uint256`), it remains a theoretical vulnerability. An overflow could reset the user's pending balance to a smaller number than intended, potentially resulting in a loss of funds for the user.

2. **Potential Misuse of `withdrawFor()` by Arbitrary Callers**:  
   The `withdrawFor()` function is `public` and can be called by anyone, not just the user who is withdrawing. While the withdrawn funds still go to `user`, it could lead to unexpected behavior or confusion. For example, a malicious actor could front-run a user’s intended withdrawal transaction, triggering `withdrawFor()` first. Although this does not result in misdirected funds (the funds still go to `user`), it removes the user's direct control and clarity over the timing of their own withdrawal. This may or may not be considered a vulnerability depending on the intended design, but it is at least a design weakness or unintended behavior.

3. **Reliance on `gasLimit` in Fallback Call**:  
   The `_sendValueWithFallbackWithdraw()` function attempts to send funds using a call with a specified `gasLimit`. If this `gasLimit` is poorly chosen or manipulated, it could cause calls to fail unnecessarily, pushing funds into the `pendingWithdrawals` mapping. While this is not a direct vulnerability in terms of losing funds (as the funds remain claimable via `withdraw()`), it can cause funds to become temporarily stuck, negatively impacting user experience and potentially creating complexity for the integrator.

4. **Lack of Initialization Checks (In an Upgradeable Context)**:  
   Since this contract is `abstract` and uses `ReentrancyGuardUpgradeable` from OpenZeppelin, it is meant for use in an upgradeable environment. It is expected that the inheriting contract will properly initialize and call the necessary initializers (such as `__ReentrancyGuard_init()`). If this step is overlooked, the `nonReentrant` functionality may not be properly established, potentially introducing reentrancy risks. Although this is not a flaw in the snippet itself, it is a pitfall for integrators if they fail to follow the proper upgradeable contract patterns.

---

**Summary**: The primary concrete vulnerability here is the use of `unchecked` arithmetic, which can potentially lead to integer overflow in `pendingWithdrawals`. Additionally, the public `withdrawFor()` function and reliance on external `gasLimit` parameters can introduce design-level issues. Finally, care must be taken in the upgradeable environment to ensure proper initialization and reentrancy protections are activated.","---

### **Analysis of Issues and Responses**

---

#### **[M-02] `withdrawFor` function may fail to withdraw ether recorded in `pendingWithdrawals`**

**Report Description**:  
The `NFTMarketFees` and `NFTMarketReserveAuction` contracts use the `_sendValueWithFallbackWithdraw` function to send Ether to various recipients. If the recipient fails to receive the Ether (e.g., due to exceeding the gas limit or the recipient contract being unable to accept Ether), the Ether is recorded in the `pendingWithdrawals` mapping. This mechanism ensures that funds are not lost but may result in funds being temporarily stuck in the contract.

**Match in Response List**:  
The issue is partially addressed in the following responses:  
1. **Unchecked Arithmetic on `pendingWithdrawals`**  
2. **Reliance on `gasLimit` in Fallback Call**

**Validation**:  
- **Unchecked Arithmetic on `pendingWithdrawals`**:  
  This response highlights the use of an `unchecked` block when incrementing `pendingWithdrawals[user]`. While this is a valid concern, it does not directly address the issue described in the report, which focuses on the failure of Ether transfers and the subsequent recording of funds in `pendingWithdrawals`. The response instead focuses on the potential for integer overflow in the `unchecked` block.  
  **Partially Correct**: The response identifies a related issue (unchecked arithmetic) but does not address the core problem of Ether transfer failures and their impact on `pendingWithdrawals`.

- **Reliance on `gasLimit` in Fallback Call**:  
  This response directly addresses the issue of Ether transfer failures due to gas limit constraints. It acknowledges that funds may become temporarily stuck in the `pendingWithdrawals` mapping if the `gasLimit` is poorly chosen or manipulated. This aligns with the issue described in the report.  
  **Correct**: The response appropriately identifies the root cause of the problem and its impact on user experience.

**Suggestions**:  
- For the **Unchecked Arithmetic** response, explicitly link the unchecked arithmetic to the broader issue of Ether transfer failures and the `pendingWithdrawals` mechanism.  
- For the **Reliance on `gasLimit`** response, suggest implementing a more dynamic or user-configurable gas limit to reduce the likelihood of transfer failures.

---

#### **[Additional Issues in Response List]**

1. **Potential Misuse of `withdrawFor()` by Arbitrary Callers**:  
   This response highlights that the `withdrawFor()` function is `public` and can be called by anyone, potentially leading to unexpected behavior or confusion. While this does not result in a loss of funds, it could allow malicious actors to front-run legitimate withdrawal transactions, removing the user's control over the timing of their withdrawal.  
   **Relevance**: This is a valid concern that was not explicitly mentioned in the original issue report. It highlights a design weakness that could impact user experience and trust in the system.  
   **Assessment**: **Valid Concern**. This issue should be addressed to improve the contract's design and user experience.

2. **Lack of Initialization Checks (In an Upgradeable Context)**:  
   This response points out the potential for reentrancy risks if the inheriting contract fails to properly initialize the `ReentrancyGuardUpgradeable` functionality. While this is not a direct vulnerability in the provided code, it is a valid concern in the context of upgradeable contracts.  
   **Relevance**: This issue is tangentially related to the original report, as it pertains to the proper use of upgradeable contract patterns. However, it does not directly address the `withdrawFor` function or the `pendingWithdrawals` mechanism.  
   **Assessment**: **Valid Concern**. This is a best practice recommendation for integrators using the contract in an upgradeable environment.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

1. **Unchecked Arithmetic on `pendingWithdrawals`**:  
   This issue is valid but does not directly address the core problem described in the original issue report. It highlights a separate vulnerability related to unchecked arithmetic, which could theoretically lead to integer overflow.  
   **Assessment**: **Valid Concern**. While not directly related to the original issue, this is a legitimate vulnerability that should be addressed.

2. **Potential Misuse of `withdrawFor()` by Arbitrary Callers**:  
   This issue was not mentioned in the original report but is a valid concern. It highlights a design weakness that could lead to unexpected behavior or confusion for users.  
   **Assessment**: **Valid Concern**. This issue should be addressed to improve the contract's design and user experience.

3. **Lack of Initialization Checks (In an Upgradeable Context)**:  
   This issue is a best practice recommendation for integrators using the contract in an upgradeable environment. While not directly related to the original issue, it is a valid concern.  
   **Assessment**: **Valid Concern**. This recommendation should be included in the documentation for integrators.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **Reliance on `gasLimit` in Fallback Call**: This response directly addresses the issue of Ether transfer failures and their impact on the `pendingWithdrawals` mechanism.

**Partially Correct Matches**:  
- **Unchecked Arithmetic on `pendingWithdrawals`**: This response identifies a related issue (unchecked arithmetic) but does not address the core problem of Ether transfer failures.

**Missed Issues from Issue Report**:  
- None. All aspects of the original issue are addressed, either directly or tangentially, in the response list.

**Additional Issues Identified in Response List**:  
- **Potential Misuse of `withdrawFor()` by Arbitrary Callers**: A valid concern that highlights a design weakness.  
- **Lack of Initialization Checks (In an Upgradeable Context)**: A best practice recommendation for integrators using the contract in an upgradeable environment.

---",0,1,0,4,"```
1. Reliance on `gasLimit` in Fallback Call
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - The true positive is: ""Reliance on `gasLimit` in Fallback Call"".
   - This appears at rank 3 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Average the precision values**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 0.333 \).

**Output**:
```
0.333
```"
FETH.sol,"/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670.0,779.0,"[M-03] Approve race condition in FETH
Front running attack in `approve()` function.

[M-09] Missing receiver validation in withdrawFrom
The `FETH.withdrawFrom` function does not validate its to parameter.Funds can be lost if `to` is the zero address.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();

error FETH_Insufficient_Allowance(uint256 amount);

error FETH_Insufficient_Available_Funds(uint256 amount);

error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();


contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  
  struct AccountInfo {
    
    uint96 freedBalance;
    
    uint32 lockupStartIndex;
    
    LockedBalance.Lockups lockups;
    
    mapping(address => uint256) allowance;
  }

  
  mapping(address => AccountInfo) private accountToInfo;

  
  
  uint256 private immutable lockupDuration;
  
  uint256 private immutable lockupInterval;

  
  address payable private immutable foundationMarket;

  
  
  uint8 public constant decimals = 18;
  
  string public constant name = ""Foundation Wrapped Ether"";
  
  string public constant symbol = ""FETH"";

  
  
  event Approval(address indexed from, address indexed spender, uint256 amount);
  
  event Transfer(address indexed from, address indexed to, uint256 amount);

  
  
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  
  receive() external payable {
    depositFor(msg.sender);
  }

  
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  
  function deposit() external payable {
    depositFor(msg.sender);
  }

  
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      
      if (escrow.expiration == 0) {
        break;
      }

      
      unchecked {
        
        ++escrowIndex;
      }

      
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  
  
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    
    unchecked {
      
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    
    
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      
      revert FETH_Too_Much_ETH_Provided();
    }

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  
  
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      
      while (true) {
        
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    
    uint256 lockedCount;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          
          ++lockedCount;
        }
      }
    }

    
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    
    uint256 i;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function totalSupply() external view returns (uint256 supply) {
    
    return address(this).balance;
  }
}",3357.0,0,2,"Examining contract risks
I’m scanning the solidity code for overflow/underflow and reentrancy risks. Solidity 0.8's arithmetic checks are covered, but 'unchecked' statements need scrutiny. Potential reentrancy might stem from calls to sendValue.
Vulnerability discovery
I'm digging into the sendValue function, which uses a regular call with no fixed gas stipend, making reentrancy feasible. The contract updates state before calls, lacking proper safeguards.
Examining further risks
There’s potential reentrancy if the to address is an attacker contract. The complex while(true) loop might lead to gas exhaustion. Unlocked balances are at risk of gas racing, but it’s a consideration.
Evaluating transfer effects
I’m mapping out if the code's transfer failures for to == address(0) or to == address(this) are vulnerabilities or features. Also, I’m noting the absence of nonReentrant modifiers around sendValue calls.
Assessing arithmetic limits
I'm curious about uint32, uint256, and unchecked arithmetic for expiration times and balance increments. Given constraints, these should be safe, though large user deposits might risk uint96 overflow.
Addressing potential concerns
Evaluating foundationMarket's security, handling freed balances for safety, and examining _freeFromEscrow costs and DOS risks. Progress is steady and promising.
Assessing potential issues
Large lockup arrays might cause a gas Denial-of-Service scenario. Also, an infinite loop in _freeFromEscrow could block fund transfers.
Evaluating reentrancy risk
I'm thinking the absence of Checks-Effects-Interactions and ReentrancyGuard around state-changing calls like sendValue exposes the contract to potential reentrancy attacks, despite using OpenZeppelin's sendValue.
Pinpointing reentrancy risk
I’m concluding that the primary vulnerability is reentrancy, as sendValue is called post-state mutation without a reentrancy guard or adhere to the checks-effects-interactions pattern.","Below are the primary vulnerabilities and issues in the provided Solidity smart contract:

### 1. Reentrancy Vulnerability

**Description:**  
The contract uses `sendValue` from OpenZeppelin’s `AddressUpgradeable` library to send Ether. While `sendValue` reverts on failure, it does not inherently prevent reentrancy. The contract makes external calls (`payable(msg.sender).sendValue(amount)` and `to.sendValue(amount)`) after updating internal state without any form of reentrancy guard or checks-effects-interactions pattern. This means that a malicious recipient could potentially re-enter the contract during these calls, possibly manipulating state and extracting additional funds.

**Impact:**  
An attacker could reenter state-changing functions (e.g., by triggering callbacks in their fallback function) and potentially drain funds or bypass intended logic.

**Recommended Mitigation:**  
- Add a reentrancy guard (e.g., using `ReentrancyGuard`) around functions that send Ether.
- Follow the checks-effects-interactions pattern strictly: first verify conditions and update state, then do external calls last (or utilize a pull-payment pattern).

### 2. Potential Denial-of-Service (DoS) via Unbounded Loops

**Description:**  
Functions like `_freeFromEscrow` iterate over lockups in a loop until a certain condition is met. If the user has a large number of lockups, this could cause a very long-running operation. Since there’s no apparent limit on how many lockups can accumulate, a scenario with a large number of lockups might lead to running out of gas, effectively locking users out of normal operations.

**Impact:**  
Users with a large number of lockups may be unable to process transactions successfully, resulting in a DoS scenario where their funds remain locked.

**Recommended Mitigation:**  
- Limit the number of lockups per user or implement pagination.
- Consider more gas-efficient data structures or break large operations into smaller, user-executed steps.

### 3. Integer Size and Arithmetic Concerns

**Description:**  
The contract stores balances in `uint96` fields. Although extremely large values are unlikely in practice (since `2^96 - 1` is enormous), in a theoretical scenario of exceedingly large Ether inflow, this could overflow. There are also several `unchecked` blocks used for arithmetic. While Solidity 0.8+ checks for arithmetic overflow, `unchecked` blocks remove these checks, which must be carefully justified.

**Impact:**  
Under extreme, impractical conditions, overflow could occur. More realistically, it’s a design concern rather than an immediate vulnerability.

**Recommended Mitigation:**  
- Avoid `unchecked` unless absolutely necessary and well-reasoned.
- Consider using larger integer types (e.g., `uint256`) for balances if scalability or unusual scenarios are anticipated.

### 4. Trust Model with `foundationMarket`

**Description:**  
The contract designates a `foundationMarket` address as trusted and allows it to lock and unlock funds. If the `foundationMarket` contract is malicious or compromised, it could manipulate user balances. This is not a flaw in code per se but a trust assumption that could be a vulnerability if the trusted party is not actually trustworthy.

**Impact:**  
User funds can be arbitrarily locked/unlocked by the trusted `foundationMarket` contract. If `foundationMarket` is compromised or hostile, users’ funds could be effectively seized or manipulated.

**Recommended Mitigation:**  
- Only set `foundationMarket` to a well-audited contract that is trusted by users.
- Consider additional governance or upgrade patterns that reduce trust in a single address.

### 5. Possible Gas-Related Vulnerabilities in Loops for Views

**Description:**  
Functions such as `balanceOf` and `totalBalanceOf` iterate through lockups. For a large number of lockups, these calls might become very expensive. While not a direct security vulnerability, it can lead to gas inefficiencies and potential DoS on view functions if the dataset is large enough.

**Impact:**  
High gas costs or inability to retrieve data once the number of lockups becomes large.

**Recommended Mitigation:**  
- Use indexed data structures or batch queries.
- Impose logic to limit lockups growth or regularly prune expired entries.

---

**Overall Key Vulnerability:**  
The most critical issue is the lack of a reentrancy guard around Ether-sending operations, which can be exploited by a malicious recipient’s fallback function. This should be addressed immediately in a production environment.","---

### **Analysis of Issues and Responses**

---

#### **[M-03] Approve race condition in FETH**

**Report Description**:  
The `approve()` function in the FETH contract is vulnerable to a front-running attack. This occurs when a malicious actor observes a pending transaction to approve a certain allowance and submits their own transaction to exploit the race condition. This can lead to unauthorized transfers or manipulation of allowances.

**Match in Response List**:  
**No match found.**

**Validation**:  
The issue is **unaddressed** in the `response_list`. None of the responses explicitly mention the `approve()` function or the associated race condition vulnerability. This is a critical oversight, as the `approve()` race condition is a well-documented vulnerability in Solidity and should be mitigated by using safer patterns like `increaseAllowance`/`decreaseAllowance` or by implementing a permit-based system (e.g., EIP-2612).

**Suggestions**:  
- Implement `increaseAllowance` and `decreaseAllowance` functions instead of relying on `approve()`.
- Alternatively, adopt the EIP-2612 permit standard to eliminate the need for separate approval transactions.

---

#### **[M-09] Missing receiver validation in withdrawFrom**

**Report Description**:  
The `withdrawFrom` function in the FETH contract does not validate the `to` parameter. If the `to` address is the zero address, funds could be irretrievably lost. This is a critical issue as it directly impacts the safety of user funds.

**Match in Response List**:  
**No match found.**

**Validation**:  
The issue is **unaddressed** in the `response_list`. None of the responses discuss the `withdrawFrom` function or the lack of validation for the `to` parameter. This is a significant gap, as failing to validate critical parameters like recipient addresses is a common source of fund loss in Solidity contracts.

**Suggestions**:  
- Add a check to ensure that the `to` address is not the zero address (`require(to != address(0), ""Invalid recipient address"");`).
- Consider implementing additional input validation to ensure the integrity of other parameters.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy Vulnerability**

**Response Description**:  
The response highlights a reentrancy vulnerability in Ether-sending operations (`sendValue`) due to the lack of a reentrancy guard or adherence to the checks-effects-interactions pattern.

**Assessment**:  
**Valid Concern.** While this issue is not explicitly mentioned in the `issue` report, it is a critical vulnerability in Solidity contracts. The lack of a reentrancy guard or proper ordering of operations (checks-effects-interactions) can lead to severe exploits, such as draining funds or bypassing intended logic. This issue should be addressed immediately.

**Suggestions**:  
- Use OpenZeppelin’s `ReentrancyGuard` to protect functions that involve external calls.
- Follow the checks-effects-interactions pattern to minimize reentrancy risks.

---

#### **[R-02] Potential Denial-of-Service (DoS) via Unbounded Loops**

**Response Description**:  
The response identifies a potential DoS vulnerability in functions like `_freeFromEscrow`, which iterate over user lockups in an unbounded loop. If a user has a large number of lockups, the function could run out of gas, effectively locking the user out of normal operations.

**Assessment**:  
**Valid Concern.** This issue is not mentioned in the `issue` report but is a legitimate risk. Unbounded loops in Solidity can lead to gas exhaustion, especially in scenarios with large datasets. This can result in a DoS condition for affected users.

**Suggestions**:  
- Impose a limit on the number of lockups per user.
- Implement pagination or batch processing to handle large datasets more efficiently.

---

#### **[R-03] Integer Size and Arithmetic Concerns**

**Response Description**:  
The response notes that the contract uses `uint96` for balances, which could theoretically overflow in extreme scenarios. It also highlights the use of `unchecked` blocks for arithmetic operations, which bypass Solidity’s built-in overflow checks.

**Assessment**:  
**Valid Concern.** While this issue is not mentioned in the `issue` report, it is a valid design consideration. Using smaller integer types like `uint96` can save gas but introduces a risk of overflow in edge cases. Similarly, the use of `unchecked` blocks should be carefully justified and limited to scenarios where overflow is provably impossible.

**Suggestions**:  
- Use `uint256` for balances to future-proof the contract and eliminate overflow risks.
- Avoid `unchecked` blocks unless absolutely necessary and well-documented.

---

#### **[R-04] Trust Model with `foundationMarket`**

**Response Description**:  
The response highlights a trust assumption with the `foundationMarket` address, which is allowed to lock and unlock user funds. If the `foundationMarket` contract is compromised or malicious, it could manipulate user balances.

**Assessment**:  
**Valid Concern.** This issue is not mentioned in the `issue` report but is a critical consideration. Trusting a single address or contract with significant control over user funds introduces a centralization risk. If the trusted party is compromised, users could lose their funds.

**Suggestions**:  
- Implement a governance mechanism to oversee the `foundationMarket` address.
- Use a multi-signature wallet or decentralized governance to reduce reliance on a single trusted entity.

---

#### **[R-05] Possible Gas-Related Vulnerabilities in Loops for Views**

**Response Description**:  
The response identifies gas inefficiencies in view functions like `balanceOf` and `totalBalanceOf`, which iterate through user lockups. For users with a large number of lockups, these functions could become prohibitively expensive or fail due to gas limits.

**Assessment**:  
**Valid Concern.** While this issue is not mentioned in the `issue` report, it is a legitimate design flaw. Gas inefficiencies in view functions can degrade the user experience and make it difficult to retrieve data in large datasets.

**Suggestions**:  
- Use indexed data structures or batch queries to improve gas efficiency.
- Regularly prune expired lockups to reduce the size of the dataset.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- **None**

#### **Partially Correct Matches**:
- **None**

#### **Missed Issues from Issue Report**:
1. **[M-03] Approve race condition in FETH**
2. **[M-09] Missing receiver validation in withdrawFrom**

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **[R-01] Reentrancy Vulnerability** - **Valid Concern**
2. **[R-02] Potential Denial-of-Service (DoS) via Unbounded Loops** - **Valid Concern**
3. **[R-03] Integer Size and Arithmetic Concerns** - **Valid Concern**
4. **[R-04] Trust Model with `foundationMarket`** - **Valid Concern**
5. **[R-05] Possible Gas-Related Vulnerabilities in Loops for Views** - **Valid Concern**

---",0,0,2,5,"```
None.
```",0.0
NFTMarketFees.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867.0,219.0,"[M-08] Primary seller can avoid paying the primary fee
A primary seller can circumvent the 15% fee and pay 5% as a secondary seller.

[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low
The creator payouts are capped at `MAX_ROYALTY_RECIPIENTS_INDEX`. It's currently set to 4 and only 5 creators are paid out.Other creators are ignored.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  
  uint256[3] private __gap_was_fees;

  
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; 
  
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; 
  
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; 

  
  
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        
        uint256 totalShares;
        unchecked {
          
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              
              maxCreatorIndex = 0;
              break;
            }
            
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        
        creatorRev = price - foundationFee;
      } else {
        
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  
  uint256[1000] private __gap;
}",1195.0,0,2,"Evaluating contract safety
OK, let me see. The contract's use of pragma solidity ^0.8.0 ensures integer arithmetic safety, and external calls like _sendValueWithFallbackWithdraw are thoughtfully considered. Reentrancy is a potential concern.
Evaluating external calls
Taking a closer look, SendValueWithFallbackWithdraw is probably safe from reentrancy. Keep in mind, not checking if creatorRecipients is empty could be an issue.
Ensuring safety
Interestingly enough, the code smartly handles scenarios where creatorRecipients is empty, preventing out-of-bounds errors by checking lengths and setting maxCreatorIndex accordingly.
Assessing reentrancy risk
OK, let me see. Reentrancy could happen if getFoundationTreasury() or creatorRecipients[i] calls re-enter _distributeFunds, but SendValueWithFallbackWithdraw likely manages this risk effectively.
Addressing reentrancy
Reentrancy risk is tackled by sending funds to an escrow and setting _nftContractToTokenIdToFirstSaleCompleted at the start or adding a reentrancy guard. This minimizes potential double payouts.
Identifying vulnerabilities
Hmm, I’m thinking about potential reentrancy attacks and the code’s method for distributing invalid shares, which might inadvertently enable a malicious input to disrupt the intended logic.
Identifying risks
OK, let's think through potential vulnerabilities like fallback function exploits, logic flaws with large or invalid input arrays, and state reliance issues post-reentrancy. Upgrading hazards also come to mind.
Evaluating reentrancy
I'm thinking about reentrancy risks from external calls and fallback at NFT contracts, particularly without a nonReentrant modifier, which could open the door to potential attacks.
Highlighting vulnerabilities
OK, let’s identify three main areas: reentrancy risks from _sendValueWithFallbackWithdraw calls, input validation issues with creatorShares, and potential problems with integer division rounding in share and fee calculations.","**Summary of Potential Vulnerabilities**

1. **Reentrancy Attacks**:  
   - The `_distributeFunds` function makes multiple external calls to `_sendValueWithFallbackWithdraw`, which in turn attempts to send ETH to various external addresses such as the foundation treasury and creator/owner recipients.
   - Because these calls forward some gas, the called external addresses could be malicious smart contracts with fallback functions designed to reenter the current contract’s logic.
   - There are no `nonReentrant` modifiers or other explicit reentrancy guards visible in this contract snippet. Without proper safeguards, a malicious recipient could trigger reentrancy, possibly causing the function to run multiple times or manipulate internal state before it is finalized.
   - The state variable `_nftContractToTokenIdToFirstSaleCompleted` is only updated to `true` after all funds have been distributed. In a reentrant scenario, the attacker might cause multiple fund distributions before the first sale completion flag is set.

2. **Reliance on External Data Without Full Validation**:
   - The `_getCreatorPaymentInfo` function (not shown here) presumably returns `creatorRecipients` and `creatorShares`. The current code trusts that these arrays are well-formed and aligned (same length, etc.).
   - There is logic that attempts to handle invalid `creatorShares` values (if any share exceeds `BASIS_POINTS`, it resets distribution to just the first recipient). However, it does not revert or prevent further execution. This could lead to unexpected or unfair distributions if the data returned by `_getCreatorPaymentInfo` is manipulated.

3. **No Explicit Checks on Array Length Mismatches**:
   - The code expects `creatorShares` and `creatorRecipients` to have corresponding indices. It does not explicitly check if both arrays have the same length. It’s likely guaranteed by `_getCreatorPaymentInfo`, but if not, it could lead to out-of-bound reads or unexpected behavior.
   - The fallback logic when multiple recipients are present relies on looping up to `maxCreatorIndex`. If `creatorShares` and `creatorRecipients` arrays are not as expected, this could cause subtle distribution errors.

4. **Rounding and Distribution Fairness**:
   - Calculations for share distributions use integer division, potentially leading to rounding down and leftover fractions of funds.
   - Any remainder is given entirely to the first recipient (`creatorRecipients[0]`). While not a direct security vulnerability, this may create fairness issues if attackers can influence these calculations.

**Primary Concern**:  
**Reentrancy** is the main and most critical vulnerability. Without a reentrancy guard (e.g., the OpenZeppelin `ReentrancyGuard`), malicious recipients can attempt to exploit fallback functions to reenter the contract’s logic during `_distributeFunds`. This could allow them to receive multiple distributions or influence the contract state in unintended ways before `_nftContractToTokenIdToFirstSaleCompleted` is set.

**In Summary**:  
- The absence of a `nonReentrant` mechanism in a function that calls arbitrary external addresses and updates state is the key vulnerability.  
- Potential logical issues with handling unexpected `creatorShares` values and lack of explicit array length checks may also lead to unexpected behaviors, though these are secondary to the reentrancy risk.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[M-08] Primary seller can avoid paying the primary fee**

**Report Description**:  
The issue highlights that a primary seller can circumvent the 15% fee and instead pay only 5% as a secondary seller. This creates a financial loophole that undermines the intended fee structure, potentially leading to revenue loss for the platform.

**Match in Response List**:  
**No match found.**

**Validation**:  
The `response_list` does not address this issue. There is no mention of fee circumvention or any mechanism to ensure that primary sellers cannot bypass the 15% fee. This is a critical oversight, as it directly impacts the platform's revenue model and fairness.

**Suggestions**:  
- Implement a mechanism to differentiate between primary and secondary sales explicitly, such as tracking the sale history of tokens or using a flag to enforce the correct fee structure.
- Add tests to ensure that primary sellers cannot exploit this loophole.

---

#### **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Report Description**:  
The issue points out that the `MAX_ROYALTY_RECIPIENTS_INDEX` is set to 4, which limits payouts to only 5 creators. If there are more than 5 creators, the additional creators are ignored, leading to unfair distribution and potential disputes.

**Match in Response List**:  
**No match found.**

**Validation**:  
The `response_list` does not address this issue. There is no mention of the `MAX_ROYALTY_RECIPIENTS_INDEX` or the limitation on the number of creators who can receive payouts. This is a significant gap, as it directly affects the fairness and functionality of the royalty distribution mechanism.

**Suggestions**:  
- Increase the `MAX_ROYALTY_RECIPIENTS_INDEX` to accommodate more creators or make it configurable.
- Implement a mechanism to handle cases where the number of creators exceeds the limit, such as prorating payouts or providing clear error messages.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy Attacks**

**Response Description**:  
The `_distributeFunds` function makes multiple external calls to `_sendValueWithFallbackWithdraw`, which forwards gas to external addresses. Without a `nonReentrant` modifier or similar safeguards, malicious contracts could exploit fallback functions to reenter the contract's logic. This could lead to multiple fund distributions or manipulation of internal state before the `_nftContractToTokenIdToFirstSaleCompleted` flag is set.

**Assessment**:  
**Valid Concern.**  
Reentrancy is a well-known vulnerability in Solidity, and the absence of a `nonReentrant` modifier or equivalent safeguard is a critical issue. The response correctly identifies the risk and provides a detailed explanation of how it could be exploited. However, this issue is not mentioned in the original `issue` report.

---

#### **[R-02] Reliance on External Data Without Full Validation**

**Response Description**:  
The `_getCreatorPaymentInfo` function is trusted to return well-formed arrays (`creatorRecipients` and `creatorShares`). However, if these arrays are manipulated or malformed, it could lead to unexpected or unfair distributions. The fallback logic for invalid `creatorShares` values does not revert or prevent further execution, which could exacerbate the issue.

**Assessment**:  
**Valid Concern.**  
Relying on external data without proper validation is a common source of vulnerabilities in Solidity. The response highlights a potential issue with the integrity of the data returned by `_getCreatorPaymentInfo`. While this is not a direct security vulnerability, it could lead to logical errors and unfair outcomes. This issue is not mentioned in the original `issue` report.

---

#### **[R-03] No Explicit Checks on Array Length Mismatches**

**Response Description**:  
The code assumes that `creatorShares` and `creatorRecipients` arrays are aligned in length but does not explicitly check this. If the arrays are mismatched, it could lead to out-of-bound reads or unexpected behavior during fund distribution.

**Assessment**:  
**Valid Concern.**  
Array length mismatches can cause serious issues in Solidity, including runtime errors and incorrect logic execution. The response correctly identifies this as a potential problem. This issue is not mentioned in the original `issue` report.

---

#### **[R-04] Rounding and Distribution Fairness**

**Response Description**:  
Integer division during share calculations may result in rounding down, leaving leftover fractions of funds. These remainders are given entirely to the first recipient, which could create fairness issues if attackers can influence the calculations.

**Assessment**:  
**Valid Concern.**  
While not a direct security vulnerability, this issue could lead to disputes among recipients and undermine trust in the platform. The response highlights a valid concern that was not mentioned in the original `issue` report.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- *None*

#### **Partially Correct Matches**:
- *None*

#### **Missed Issues from Issue Report**:
1. **[M-08] Primary seller can avoid paying the primary fee**  
   - Not addressed in the `response_list`.
2. **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**  
   - Not addressed in the `response_list`.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

1. **[R-01] Reentrancy Attacks**  
   - Valid concern. Not mentioned in the original `issue` report.

2. **[R-02] Reliance on External Data Without Full Validation**  
   - Valid concern. Not mentioned in the original `issue` report.

3. **[R-03] No Explicit Checks on Array Length Mismatches**  
   - Valid concern. Not mentioned in the original `issue` report.

4. **[R-04] Rounding and Distribution Fairness**  
   - Valid concern. Not mentioned in the original `issue` report.

---

### **Recommendations**

1. Address the missed issues from the `issue` report, particularly the fee circumvention and royalty recipient limitations.
2. Incorporate the valid concerns identified in the `response_list`, such as reentrancy protection, data validation, and fairness in fund distribution.
3. Conduct a comprehensive review of the contract to ensure alignment with Solidity best practices and security standards.

---",0,0,2,4,"```
None.
```",0.0
,,,,,,,,3,12,,,,0,5,10,41,,
