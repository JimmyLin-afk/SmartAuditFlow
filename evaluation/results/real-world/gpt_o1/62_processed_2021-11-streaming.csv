nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Locke.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6655,856,"[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users “uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.
As a result:
- When the protocol governance calls `claimFees()` and `claim` accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken.
- Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.
  [H-02] Tokens can be stolen when `depositToken == rewardToken`
The `Streaming` contract allows the deposit and reward tokens to be the same token.
The reward and deposit balances are also correctly tracked independently in depositTokenAmount and rewardTokenAmount. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:
“function recoverTokens(address token, address recipient) public lock {}”
  [H-03] Reward token not correctly recovered
The Streaming contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.
However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:
“function recoverTokens(address token, address recipient) public lock {“
 
[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets
Function `arbitraryCall`
“function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {“
When an incentiveToken is claimed after `endStream`, `incentives[who]` will be 0 for that `incentiveToken`.
If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as who and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.
  [H-05] Possible incentive theft through the arbitraryCall() function
The `Locke.arbitraryCall()` function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).
However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().
  [H-06] Creating rewardTokens without streaming depositTokens function `updateStreamInternal`
`stake` and `withdraws` can generate rewardTokens without streaming depositTokens. It does not matter whether the stream is a sale or not.
The following lines can increase the reward balance on a `withdraw` some time after `stake`:   [H-07] Business logic bug in `_abdicate()` function - 2 Bugs
The `_abdicate()` function at  is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the ""gov"" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.
 
[H-08] ts.tokens sometimes calculated incorrectly
Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.
Now after some time he stakes some tokens again. At the second stake `updateStream()` is called and the following if condition is false because `ts.tokens==0`
“if (acctTimeDelta > 0 && ts.tokens > 0) {“
Thus `ts.lastUpdate` is not updated and stays at the value from the first withdraw. Now he does a second withdraw. `updateStream()` is called an calculates the updated value of `ts.tokens`. However it uses `ts.lastUpdate`, which is the time from the first withdraw and not from the second stake. So the value of `ts.token` is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.
  [H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max
reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.
 
[H-10] recoverTokens doesn't work when isSale is true
In `recoverTokens` function, the logic to calculate the excess number of deposit tokens in the contract is:
""uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.
  [M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens
Any airdrop gathered with arbitraryCall will be immediately lost as an attacker can track arbitraryCall transactions and back run them with calls to recoverTokens, which doesn't track any tokens besides reward, deposit and incentive tokens, and will give the airdrop away.
 
[M-04] arbitraryCall() can get blocked by an attacker
`arbitraryCall()` use case is to claim airdrops by ""gov"". If the address ""who"" is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable, because on L735 there is a `require(incentives[who] == 0, ""inc"");` that reverts if a ""who"" token was received as an incentive.
In this case the the `incentives[who]` can be set to 0 by the stream creator by calling claimIncentive() but only after the stream has ended according to require(block.timestamp >= endStream, ""stream""); (L520)
If the airdrop is only claimable before the end of the stream, then the airdrop can never be claimed.
If ""gov"" is not the stream creator then the stream creator must become also the ""gov"" because claimIncentive() only can be called by the stream creator and the arbitraryCall() only by ""gov"". If resetting incentives\[who] to 0 by calling claimIncentive() and arbitraryCall() for the ""who"" address doesn't happen atomic, an attacker can send between those two calls again a ""who"" token.",12,"pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";


contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    
    
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    
    
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}


contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    
    
    
    uint32 private immutable startTime;
    
    uint32 private immutable streamDuration;
    
    uint32 private immutable depositLockDuration;
    
    uint32 private immutable rewardLockDuration;

    
    uint32 private immutable endStream;
    
    uint32 private immutable endDepositLock;
    
    uint32 private immutable endRewardLock;

    
    address public immutable rewardToken;
    
    address public immutable depositToken;

    
    uint64 public immutable streamId;

    
    uint16 private immutable feePercent;
    
    bool private immutable feeEnabled;

    
    bool public immutable isSale;

    
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    

    
    
    uint112 private rewardTokenAmount;
    
    uint112 private depositTokenAmount;
    

    
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    

    
    uint256 private cumulativeRewardPerToken;
    

    
    uint256 private totalVirtualBalance;
    

    
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    

    
    mapping (address => TokenStream) public tokensNotYetStreamed;

    
    mapping (address => uint112) public incentives;

    
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    
    modifier updateStream(address who) {
        
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            
            cumulativeRewardPerToken = rewardPerToken();

            
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                
                
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) 
        public 
    {
        
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        
        require(feePercent < 10000, ""fee"");
    
        
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        
        streamId = _streamId;

        
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        
        if (feeEnabled) {
            
            
            
            
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

     
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        

        
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

     
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

     
    function exit() public updateStream(msg.sender) {
        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

     
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

     
    function claimIncentive(address token) public lock {
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

     
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        
        
        require(amount > 0, ""amt"");

        
        require(block.timestamp > endDepositLock, ""lock"");

        
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

     
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        
        cumulativeRewardPerToken = rewardPerToken();

        
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

     
    function creatorClaimSoldTokens(address destination) public lock {
        
        require(isSale, ""!sale"");

        
        require(!claimedDepositTokens, ""claimed"");
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

     
    function claimFees(address destination) public lock externallyGoverned {
        
        require(block.timestamp >= endStream, ""stream"");

        
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    

     
    function recoverTokens(address token, address recipient) public lock {
        
        
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            
            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            
            
            
            
            
            

            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        
        
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; 

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        
        require(incentives[who] == 0, ""inc"");
        
        require(who != depositToken && who != rewardToken, ""erc"");

        
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; 

    
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        
        
        
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",4772,10,2,"Analyzing imports

I’m examining the code's Solidity imports, assuming implementation safety, and then exploring the Governed and ExternallyGoverned contracts, which manage governance and call functionalities.

Spotting vulnerabilities

I’m focusing on pitfalls like reentrancy, access control breaches, improper external calls, front-running, input validation gaps, logical bugs, and gas limit issues within the Stream and StreamFactory contracts.

Ensuring protection

I’m looking into how the 'lock' modifier shields against reentrancy during external calls in flashloan and arbitraryCall functions, ensuring the system remains secure and functionality is maintained.

Evaluating function security

Ensuring reentrancy protection is key. The 'arbitraryCall' function leverages the 'lock' modifier, while 'updateStreamInternal' handles storage updates without external calls—vital to safeguarding against vulnerabilities.

Ensuring access control

I’m mapping out that functions in the Governed and ExternallyGoverned contracts are strictly accessible by authorized users only, while Stream contract functions are safeguarded by specific modifiers like 'lock'.

Spotting centralization risks

I’m identifying potential risks, including the 'arbitraryCall' function granting governors access to execute any code in the Stream contract, alarming potential for centralization. External calls like 'SafeTransferLib' are generally safe.

Assessing security constraints

I’m analyzing the 'arbitraryCall' function's ability to execute any operation. While it’s supposed to prevent reentrancy by adjusting token balances, the risk of abuse remains high with a compromised or malicious governor.

Confirming input validation

It’s worth noting that the functions in the Stream and StreamFactory contracts robustly validate input parameters, safeguarding against invalid transactions and potential security flaws.

Verifying arithmetic accuracy

Ensuring all arithmetic in 'updateStreamInternal' is precise, accounting for potential overflow and division by zero. Also, ensuring accurate token recovery in 'recoverTokens' and 'rewardPerToken' functions.

Assessing front-running potential

I’m noting that timeliness-sensitive operations in the Stream contract might invite front-running. The 'flashloan' function ensures repayments, yet vigilant attention to ERC20 token interaction remains crucial.

Assessing security measures

I’m evaluating the 'arbitraryCall' and 'StreamFactory' for centralization risks due to the high-level trust needed, while acknowledging potential issues with ERC20 token decimal handling in the 'Stream' constructor.

Addressing token safety

I’m examining 'recoverTokens' for potential token balance mismatches and considering the security of inherited libraries and contracts, assuming standard practices ensure their safety.

Assessing governance risks

I'm looking at how 'StreamFactory' restricts stream parameters and the 'governed' contract's emergency governor. Also, verifying that user withdrawals and token management are accurately implemented.

Assessing code integrity

OK, let me see. The 'lock' modifier is checked throughout most 'Stream' contract functions. The potential compromise of 'arbitraryCall' remains a risk, despite 'externallyGoverned' protection.

Addressing key concerns

I’m noting the centralization risk from the 'arbitraryCall' function, potential integer truncations in 'rewardPerToken' calculations, and verifying secure inheritance of 'LockeERC20' functionality.

Examining security measures

Assessing the 'flashloan' function's potential misuse due to the fee structure, analyzing 'Incentives' mapping stability, and examining 'ExternallyGoverned' interface dependencies for safeguarding the contract's integrity.
","Analyzing the provided Solidity smart contract reveals several potential vulnerabilities and areas of concern. Below is a comprehensive breakdown of these issues, categorized by their nature and impact:

---

## **1. Centralization Risks**

### **a. `arbitraryCall` Function**

- **Description**: The `arbitraryCall` function allows the **governor** or **emergency governor** to execute arbitrary calls on any address (`who`), provided that `incentives[who] == 0` and `who` is not the `depositToken` or `rewardToken`.
  
- **Risk**:
  - **High Privilege**: This function grants significant control to the governors, enabling them to interact with external contracts or perform actions that could manipulate the `Stream` contract's state or behavior.
  - **Potential Exploitation**: If the governor's private key is compromised, an attacker could leverage this function to execute malicious operations, drain funds, or alter contract logic.
  
- **Mitigation**:
  - **Restrict Functionality**: Limit the scope of what `arbitraryCall` can execute. For instance, restrict it to specific trusted contracts or predefined actions.
  - **Multisignature Governance**: Implement a multisig mechanism for governors to execute such critical functions, reducing the risk associated with a single point of failure.
  - **Timelocks**: Introduce timelocks for executing arbitrary calls to provide a window for community oversight and response.

---

## **2. Governance and Access Control Issues**

### **a. Absence of Timelocks in Governance Changes**

- **Description**: The `Governed` contract allows immediate changes to governance roles through functions like `setPendingGov` and `acceptGov` without any delay.

- **Risk**:
  - **Sudden Control Transfer**: An attacker or malicious actor with access to the current governor could instantly transfer governance to themselves, gaining full control over the contract.
  
- **Mitigation**:
  - **Implement Timelocks**: Introduce a delay between proposing and accepting governance changes to allow for community review and potential intervention.
  - **Proposal Mechanism**: Require governance changes to pass through a proposal and voting process, ensuring decentralized decision-making.

### **b. `ExternallyGoverned` Dependency on `IGoverned`**

- **Description**: The `ExternallyGoverned` contract relies on the `IGoverned` interface to verify governance, which in turn depends on the correct implementation of the `Governed` contract.

- **Risk**:
  - **Interface Mismatch**: If the `Governed` contract's implementation deviates from the `IGoverned` interface, it could lead to incorrect access control, potentially granting unauthorized access.
  
- **Mitigation**:
  - **Interface Enforcement**: Ensure that the `Governed` contract strictly adheres to the `IGoverned` interface.
  - **Comprehensive Testing**: Rigorously test interactions between `ExternallyGoverned` and `Governed` to confirm consistent behavior.

---

## **3. Reentrancy and State Management Concerns**

### **a. Reentrancy Protection via `lock` Modifier**

- **Description**: Many functions in the `Stream` contract use a `lock` modifier to prevent reentrancy by toggling the `unlocked` state variable.

- **Risk**:
  - **Incomplete Protection**: While the `lock` modifier is applied to several critical functions, not all state-mutating functions or external calls are covered, potentially leaving openings for reentrancy attacks.
  
- **Mitigation**:
  - **Comprehensive Modifier Application**: Ensure that **all** functions that modify state or involve external calls are protected by the `lock` modifier or equivalent reentrancy guards.
  - **Use OpenZeppelin's `ReentrancyGuard`**: Consider leveraging well-audited libraries like OpenZeppelin's `ReentrancyGuard` for standardized and tested reentrancy protection.

### **b. External Calls in `arbitraryCall` and `flashloan`**

- **Description**: Functions like `arbitraryCall` and `flashloan` perform external calls, which can be vectors for reentrancy if not properly managed.

- **Risk**:
  - **Reentrancy Attacks**: Although the `lock` modifier is intended to prevent reentrancy, any oversight in its application could allow attackers to exploit these external calls to manipulate contract state.
  
- **Mitigation**:
  - **Follow Checks-Effects-Interactions Pattern**: Ensure that all state changes occur **before** any external interactions.
  - **Audit External Interactions**: Carefully review and test how external calls are handled, especially in functions dealing with token transfers and callbacks.

---

## **4. Token Handling and Arithmetic Operations**

### **a. Fee Calculations and Type Casting**

- **Description**: The contract performs fee calculations using `uint112` types and unchecked arithmetic in certain areas.

- **Risk**:
  - **Overflow/Underflow**: Although Solidity 0.8+ includes built-in overflow checks, using smaller data types like `uint112` increases the risk of exceeding their limits, especially with unchecked arithmetic.
  - **Precision Loss**: Operations involving division and multiplication with `uint112` may lead to precision loss, potentially affecting fee distributions and rewards calculations.
  
- **Mitigation**:
  - **Use Larger Data Types**: Consider using `uint256` for critical financial calculations to minimize overflow risks.
  - **Explicit Overflow Checks**: Even though Solidity 0.8+ reverts on overflows, being explicit in critical areas can enhance code clarity and safety.
  - **Precision Handling**: Implement mechanisms to handle or compensate for any precision loss in financial computations.

### **b. `depositDecimalsOne` Initialization**

- **Description**: The `depositDecimalsOne` variable is initialized as `10**ERC20(depositToken).decimals()` in the constructor.

- **Risk**:
  - **Non-Standard ERC20 Tokens**: If `depositToken` does not implement the `decimals` function as expected, or if it returns an unexpected value, it could lead to incorrect calculations and potential vulnerabilities.
  
- **Mitigation**:
  - **Validate `decimals`**: Ensure that the `depositToken` conforms to the ERC20 standard, particularly regarding the `decimals` function.
  - **Fallback Mechanism**: Implement fallback logic or default values if `decimals` returns an unexpected result.

---

## **5. Incentives and Fee Management**

### **a. Incentives Mapping Management**

- **Description**: The `incentives` mapping tracks incentives per token, and functions like `createIncentive` and `claimIncentive` manipulate this mapping.

- **Risk**:
  - **Incorrect Incentive Tracking**: Mismanagement of the `incentives` mapping could lead to incorrect incentive distributions, either by overpaying or underpaying participants.
  - **Double Claims**: Without proper checks, there's a risk of users claiming incentives multiple times.
  
- **Mitigation**:
  - **State Updates Before Transfers**: Update the `incentives` mapping **before** transferring tokens to prevent reentrancy-related double claims.
  - **Access Controls**: Ensure that only authorized entities can modify the `incentives` mapping.

### **b. Fee Parameters in `StreamFactory`**

- **Description**: The `StreamFactory` allows updating fee parameters with a maximum fee cap (`MAX_FEE_PERCENT`).

- **Risk**:
  - **Fee Manipulation**: If fee parameters are not adequately capped or controlled, governors could set excessively high fees, negatively impacting users.
  
- **Mitigation**:
  - **Strict Caps and Validation**: Enforce strict maximum limits on fee percentages and validate them during updates.
  - **Transparency**: Make fee parameters transparent and auditable by users to maintain trust.

---

## **6. Flashloan Functionality**

### **a. Flashloan Implementation**

- **Description**: The `flashloan` function allows users to borrow `depositToken` or `rewardToken`, execute arbitrary operations, and repay the loan with a fee.

- **Risk**:
  - **Abuse Potential**: While flashloans can be useful, they can also be exploited to manipulate market conditions, execute sandwich attacks, or exploit other contract vulnerabilities.
  - **Insufficient Fee Coverage**: If the fee (`0.1%`) is too low, it might not sufficiently deter abuse or compensate for the risk taken by the contract.
  
- **Mitigation**:
  - **Dynamic Fee Adjustment**: Consider implementing dynamic fees based on usage patterns or risk assessments.
  - **Usage Limits**: Introduce limits on the number or size of flashloans to mitigate potential abuse.
  - **Comprehensive Auditing**: Ensure that all interactions possible during a flashloan are secure and do not expose additional vulnerabilities.

---

## **7. Dependency on External Contracts and Libraries**

### **a. `LockeERC20` and Solmate Libraries**

- **Description**: The `Stream` contract inherits from `LockeERC20` and utilizes Solmate's `SafeTransferLib` and `ERC20` implementations.

- **Risk**:
  - **External Vulnerabilities**: Any vulnerabilities in the `LockeERC20` contract or Solmate libraries can propagate to the `Stream` contract.
  - **Upgrade Risks**: If these dependencies are upgradable or can be modified post-deployment, they might introduce security risks.
  
- **Mitigation**:
  - **Use Well-Audited Libraries**: Ensure that all external contracts and libraries are thoroughly audited and widely trusted within the community.
  - **Immutable Dependencies**: Where possible, use immutable versions of external libraries to prevent post-deployment changes.
  - **Regular Updates**: Stay updated with the latest versions of dependencies to benefit from security patches and improvements.

---

## **8. Potential Denial of Service (DoS) Vectors**

### **a. Gas Consumption in Loops and State Updates**

- **Description**: Functions like `updateStreamInternal` perform multiple state updates and calculations, which could be gas-intensive.

- **Risk**:
  - **Gas Limit Exceedance**: If the number of users or complexity increases, these functions might exceed block gas limits, rendering them uncallable.
  - **DoS Through Gas Consumption**: Attackers could intentionally increase state complexity to hinder legitimate operations.
  
- **Mitigation**:
  - **Optimize Gas Usage**: Refactor functions to minimize gas consumption, possibly by limiting state updates or breaking them into smaller transactions.
  - **Implement Rate Limits**: Introduce mechanisms to limit the frequency or complexity of operations that can be performed in a single transaction.

---

## **9. Token Recovery Mechanism**

### **a. `recoverTokens` Function**

- **Description**: Allows the `streamCreator` to recover excess tokens after specific lock periods.

- **Risk**:
  - **Incorrect Excess Calculation**: Miscalculations in determining what constitutes ""excess"" tokens could either drain legitimate funds or fail to recover genuinely excess tokens.
  - **Unauthorized Access**: If access controls are flawed, unauthorized users might recover tokens they shouldn't have access to.
  
- **Mitigation**:
  - **Thorough Testing**: Rigorously test the excess calculation logic under various scenarios to ensure accuracy.
  - **Access Control Auditing**: Ensure that only authorized entities (specifically `streamCreator`) can execute token recovery, and that conditions are strictly enforced.

---

## **10. Miscellaneous Concerns**

### **a. Stream Duration Constraints**

- **Description**: The `StreamFactory` enforces that `streamDuration` is between `minStreamDuration` and `maxStreamDuration`.

- **Risk**:
  - **Inflexibility**: Strict duration constraints might limit the contract's usability for certain use cases.
  - **Parameter Misconfiguration**: If `minStreamDuration` and `maxStreamDuration` are not set appropriately, they could inadvertently restrict legitimate streams.
  
- **Mitigation**:
  - **Flexible Parameterization**: Allow for a broader range of durations or implement dynamic constraints based on governance decisions.
  - **Community Input**: Engage with the community to determine optimal duration limits that balance flexibility and security.

### **b. Event Emissions and Transparency**

- **Description**: The contract emits various events for state changes, which is good for transparency.

- **Risk**:
  - **Event Overload**: Excessive event emissions can lead to bloated transaction logs, making it harder to track essential events.
  
- **Mitigation**:
  - **Selective Emission**: Ensure that only critical state changes emit events, maintaining a balance between transparency and efficiency.
  - **Comprehensive Documentation**: Clearly document the purpose and structure of each event to aid in monitoring and auditing.

---

## **Conclusion**

While the provided smart contract incorporates several best practices, such as using the `lock` modifier for reentrancy protection and leveraging well-known libraries like Solmate's `SafeTransferLib`, it also presents notable vulnerabilities, primarily centered around centralized control mechanisms and the potential for misuse of powerful functions like `arbitraryCall`. Addressing these vulnerabilities requires a combination of enhanced access controls, thorough input validation, secure governance practices, and meticulous state management.

**Recommendations:**

1. **Enhance Governance Security**: Implement multisignature wallets, timelocks, and transparent proposal mechanisms to decentralize and secure governance actions.

2. **Restrict Arbitrary Operations**: Limit the scope of functions that allow arbitrary calls or external interactions to minimize potential abuse vectors.

3. **Audit External Dependencies**: Ensure that all inherited contracts and utilized libraries are secure, up-to-date, and free from known vulnerabilities.

4. **Comprehensive Testing and Auditing**: Conduct extensive unit tests, integration tests, and third-party security audits to identify and rectify potential issues before deployment.

5. **Implement Emergency Safeguards**: Incorporate mechanisms to pause or halt critical contract functions in the event of detected anomalies or attacks.

By addressing these areas, the contract's security posture can be significantly strengthened, ensuring safer interactions for all participants.
","### **Analysis of Issue Report vs. Response List**

---

### **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users**

**Report Description**:
The issue describes a flaw in the calculation of excess depositToken in a contract, which results in the potential for the stream creator to recover `depositTokenFlashloanFeeAmount` (an unintended token amount) if present. This can lead to two possible outcomes: failure to claim accumulated fees or loss of user funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue of incorrectly calculating excess depositToken is not explicitly addressed in the response list. The response does discuss fee calculations and incentives mapping, but it does not mention the specific concern of recovering unintended amounts due to an incorrect excess balance calculation in the context of `depositTokenFlashloanFeeAmount`.

**Suggestions**:
The response should be updated to specifically address the incorrect calculation of excess tokens, particularly in scenarios involving fees or flash loan fees. To mitigate this, the recovery logic needs careful verification, especially to exclude amounts related to fees during recovery calculations.

---

### **[H-02] Tokens can be stolen when `depositToken == rewardToken`**

**Report Description**:
This issue describes a flaw in the contract where the depositToken and rewardToken are the same, causing the contract to double-recover tokens when calling `recoverTokens()`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. This issue is not addressed in the response list. The response talks about general governance and reentrancy concerns, but it does not touch on the potential issue of token recovery being performed twice when `depositToken == rewardToken`.

**Suggestions**:
The response should recommend ensuring that the `recoverTokens()` function is equipped with checks to prevent recovery of the same token twice if `depositToken` and `rewardToken` are the same. This could be mitigated by validating whether the tokens are identical before triggering the recovery logic.

---

### **[H-03] Reward token not correctly recovered**

**Report Description**:
The issue describes an incorrect calculation for the recovery of reward tokens, particularly when determining the excess amount. The recovery calculation does not properly account for the fee amounts.

**Match in Response List**:
Matches with **""Token Handling and Arithmetic Operations"" → Fee Calculations and Type Casting**.

**Validation**:
**Partially correct**. The response mentions issues with fee calculations and overflow risks, particularly in relation to using smaller data types like `uint112`. However, it does not specifically address the incorrect recovery of reward tokens in the context described in the issue. This problem could be mitigated by improving the calculation logic to ensure that all tokens (including fees) are excluded when determining the excess amount for recovery.

**Suggestions**:
The response could be more directly focused on recovery issues and ensure the calculation takes into account all fees and balances before recovery is allowed.

---

### **[H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets**

**Report Description**:
The report describes a severe vulnerability in the `arbitraryCall()` function, where malicious or compromised protocol governance could abuse this function to transfer funds from user wallets by exploiting the `transferFrom()` functionality.

**Match in Response List**:
Matches with **""Centralization Risks"" → `arbitraryCall` Function**.

**Validation**:
**Correct**. The response accurately identifies the high privileges associated with the `arbitraryCall()` function, which could potentially be exploited by malicious governance. The recommended mitigations—such as restricting functionality, implementing multisig governance, and adding timelocks—are appropriate for reducing the risks associated with this issue.

**Suggestions**:
The response is adequate and provides good mitigation strategies. No additional suggestions.

---

### **[H-05] Possible incentive theft through the `arbitraryCall()` function**

**Report Description**:
This issue describes the possibility for a malicious `arbitraryCall()` to set an allowance for an incentive token before it has been received, enabling an attacker to steal tokens.

**Match in Response List**:
Matches with **""Centralization Risks"" → `arbitraryCall` Function**.

**Validation**:
**Correct**. This issue is related to the same function discussed in **H-04** and is similarly addressed. The response highlights the centralization risks associated with `arbitraryCall()`, where the ability to manipulate incentives and allowances can lead to theft. The suggested mitigations (e.g., restricting functionality, multisig, timelocks) are appropriate for addressing this issue as well.

**Suggestions**:
As with **H-04**, the response is accurate and provides useful mitigation measures.

---

### **[H-06] Creating rewardTokens without streaming depositTokens**

**Report Description**:
This issue describes how reward tokens can be generated without corresponding deposit tokens, creating a potential mismatch between rewards and actual deposits.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue is not directly addressed in the response list. The response discusses incentive management and fee calculations but does not address the issue where reward tokens are created without the corresponding streaming of deposit tokens.

**Suggestions**:
The response should include checks to ensure that reward tokens are only created if there is a valid corresponding deposit token in the system. This could be done by verifying the deposit conditions before minting or awarding reward tokens.

---

### **Issue Report Analysis and Response Evaluation**

---

**[H-07] Business Logic Bug in `_abdicate()` function - 2 Bugs**

**Report Description**:  
The `_abdicate()` function has logic flaws that don't account for emergency and pending governors, leaving a backdoor for a malicious actor to regain governance. The function only sets the main governor (`gov`) to the zero address, but the emergency and pending governors remain active.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue directly. The issue describes a specific flaw in governance logic where the abdication doesn't consider all governor states (emergency and pending). A proper response should highlight this as a critical access control flaw, which could allow unauthorized users to regain control over the contract.

**Suggestions**:  
The response should discuss how to mitigate this issue by ensuring that all governance roles are properly handled during the abdication process, including nullifying both pending and emergency governors when the main governor abdicates. A robust solution might involve removing or resetting all governance states, not just the `gov`.

---

**[H-08] `ts.tokens` Sometimes Calculated Incorrectly**

**Report Description**:  
The calculation of `ts.tokens` fails in certain scenarios where a user withdraws and then stakes tokens again. Specifically, when `ts.tokens == 0`, it causes incorrect calculations because `ts.lastUpdate` does not get updated.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. There is no response addressing the issue of incorrect token calculation when `ts.tokens == 0`. The contract’s logic for updating `ts.lastUpdate` and calculating `ts.tokens` in certain staking scenarios is flawed, and this issue could lead to users withdrawing more tokens than they should.

**Suggestions**:  
The response should cover input validation for these edge cases. Specifically, `updateStream()` should ensure that the last update time is correctly refreshed when tokens are re-staked, even if the balance is initially 0. A possible solution would be to add a check to ensure the correct handling of these edge cases.

---

**[H-09] Denial of Service (DOS) While Dealing with ERC20 for High Values**

**Report Description**:  
The contract fails when users interact with ERC20 tokens that have high values (but less than `type(uint112).max`), resulting in a revert due to overflow in the `exit` or `withdraw` functions.

**Match in Response List**:  
Matches with the issue titled **""Fee Calculations and Type Casting""**.

**Validation**:  
**Partially Correct**. The response acknowledges potential issues with type casting and overflow risks, though it mainly focuses on fee calculations and `uint112` overflow. However, the root cause in this scenario is a token amount overflow in the ERC20 interaction, which is not specifically addressed. The response should explicitly mention the overflow in the token handling logic and propose mitigation.

**Suggestions**:  
The response should emphasize the importance of correctly handling large token amounts, especially with respect to ERC20 tokens. Consider using `uint256` for amounts to avoid overflow and ensure proper handling of larger values.

---

**[H-10] `recoverTokens` Doesn't Work When `isSale` Is True**

**Report Description**:  
The `recoverTokens` function fails to work properly when the `isSale` flag is true, and tokens have already been claimed, leading to incorrect logic in the calculation of excess tokens.

**Match in Response List**:  
Matches with the issue titled **""Token Recovery Mechanism""**.

**Validation**:  
**Correct**. The response directly addresses the issue with `recoverTokens`, recognizing that incorrect excess token calculation can prevent the recovery of tokens. It correctly emphasizes the need for thorough testing to ensure that excess tokens are calculated accurately.

**Suggestions**:  
No further suggestions are needed for this response, as it correctly identifies the issue and suggests appropriate mitigation.

---

**[M-02] Any `arbitraryCall` Gathered Airdrop Can Be Stolen with `recoverTokens`**

**Report Description**:  
An attacker could track `arbitraryCall` transactions and back-run them with `recoverTokens`, potentially stealing airdropped tokens since `recoverTokens` does not track these tokens.

**Match in Response List**:  
Matches with **""Incentives and Fee Management""** under the section titled **""Incentives Mapping Management""**.

**Validation**:  
**Partially Correct**. The response identifies the potential issue with `recoverTokens` but does not delve into how the `arbitraryCall` function specifically interacts with this issue. More specific attention should be paid to how airdropped tokens are handled separately and not tracked by `recoverTokens`.

**Suggestions**:  
The response should propose a mechanism to track and secure airdropped tokens, ensuring that they cannot be stolen through the `recoverTokens` function. A possible solution could be maintaining a separate mapping of airdropped tokens that `recoverTokens` will not be able to access.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-01] Centralization Risks in `arbitraryCall`**

**Response Description**:
The response outlines the centralization risks associated with the `arbitraryCall()` function, specifically how the protocol governor could misuse it to execute arbitrary operations.

**Assessment**:
**Valid Concern**. This is a valid concern and is directly related to the issues highlighted in **H-04** and **H-05**. The response accurately identifies the potential exploitation of the `arbitraryCall()` function by a compromised or malicious governance actor. The proposed mitigations (restricting function scope, implementing multisig, and introducing timelocks) are appropriate.

**Recommendations**:
The issue is valid, and the mitigation strategies proposed in the response are well-formed and should be implemented to address the risks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets**
- **[H-05] Possible incentive theft through the `arbitraryCall()` function**
- **[H-10] `recoverTokens` Doesn't Work When `isSale` Is True** — Fully addressed in the response.
- **[M-04] `arbitraryCall()` Can Get Blocked by an Attacker** — Fully addressed in the response.

**Partially Correct Matches**:
- **[H-03] Reward token not correctly recovered**: Fee and type casting issues are mentioned but the specific recovery logic for reward tokens is not fully addressed.
- **[H-09] Denial of Service (DOS) While Dealing with ERC20 for High Values** — Mentioned, but needs more focus on token overflow in ERC20 transactions.

**Missed Issues from Issue Report**:
- **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`**
- **[H-02] Tokens can be stolen when `depositToken == rewardToken`**
- **[H-06] Creating rewardTokens without streaming depositTokens**
- **[H-07] Business Logic Bug in `_abdicate()` Function** — Not addressed in the response.
- **[H-08] `ts.tokens` Sometimes Calculated Incorrectly** — Not addressed in the response.
- **[M-02] Any `arbitraryCall` Gathered Airdrop Can Be Stolen with `recoverTokens`** — Partially addressed but requires more specific mitigation suggestions.

**GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Centralization Risks in `arbitraryCall`**: A valid concern, with well-formed mitigation strategies.

---
",4,2,6,10,"1. Centralization Risks → `arbitraryCall` Function  
2. Token Recovery Mechanism","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - **True Positive 1**: ""Centralization Risks → `arbitraryCall` Function"" appears at rank 1.
   - **True Positive 2**: ""Token Recovery Mechanism"" appears at rank 9.

2. **Calculate precision at each rank**:
   - **Precision at rank 1 (P@1)**: \( \frac{1}{1} = 1.0 \)
   - **Precision at rank 9 (P@9)**: \( \frac{2}{9} \approx 0.222 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.222}{2} = 0.611 \)

**Average Precision (AP)**: 0.611"
