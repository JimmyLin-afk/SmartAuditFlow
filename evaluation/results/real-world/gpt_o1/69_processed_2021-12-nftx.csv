nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Thought,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5808.0,615.0,"[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets
In the NFTXMarketplaceZap.sol contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
“require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance”);""
A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAndSwap721WETH() should return unused weth/eth back to `msg.sender` instead of `to`
function `buyAndSwap721WETH`   [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address
`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] `buyAndSwap1155WETH` Does Not Work As Intended
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873.0,2,4,"Evaluating functionalities
I’m starting with a comprehensive review of the NFTXMarketplaceZap smart contract, which handles minting, selling, buying, and swapping NFTs, while engaging with WETH, NFTXLPStaking, NFTXVaultFactory, and UniswapV2Router01.
Examining contract facets
I’m analyzing the constructor for WETH approval risks, ensuring critical functions are guarded. Public functions are nonReentrant, and mintAndSell721 demands valid parameters.
Spotting potential risks
I'm noting issues in _mint721's balance manipulation, mintAndSell721WETH's consistency, and buyAndSwap721's reliance on 'call' for sending ETH, which might pose security vulnerabilities. Progress is key.
Charting internal functions
I'm noting ERC721 and ERC1155 token actions, interactions with Uniswap/Sushiswap, and token transfers. Discovering potential security gaps in internal function handling is crucial.
Assessing approval dynamics
I'm thinking through potential reentrancy risks in functions, but they appear minimal due to state variables. Additionally, scrutinizing approval race conditions linked to sushiRouter allowances.
Assessing transfer methods
I'm examining transferFromERC721 for potential issues with hardcoding addresses and CryptoPunks' unique interface, which might lead to unexpected outcomes. This necessitates thorough verification.
Assessing mathematical precision
I’m considering how inaccurate floating-point or integer math can skew balances in _mint721 and _mint1155, potentially causing function failures due to unit mismatches.
Assessing vulnerabilities
I'm noting unverified sushiRouter return values and reliance on block.timestamp, which might enable front-running. Additionally, input validation in some functions needs thorough review.
Evaluating ERC1155 functionality
I'm examining how the code interacts with ERC1155 tokens, ensuring transfers and approvals are standard. Any non-standard behavior could lead to unexpected results.
Identifying potential flaws
I'm noting the contract's reliance on hardcoded addresses and conflicting upgradeable patterns with constructors, which could introduce flexibilities and initialization issues if the collection structure changes.
Ensuring contract resilience
I'm noting the importance of internal function review for reentrancy risks, managing gas by optimizing loops, and the need for accurate immutable addresses to avoid functionality issues.
Assessing low-level calls
I'm looking at the risks of low-level 'payable' calls, considering gas consumption and fallback function vulnerabilities. For enhanced analysis, more events and phishing protections are recommended.
Spotting variable shadowing
I’ve identified variable shadowing in mintAndSell1155, where the same parameter 'amounts' is redefined within the function, potentially leading to unexpected behavior or bugs.
Addressing function visibility
I'm thinking through internal functions' visibility, noting transferFromERC721 and approveERC721's internal virtual status without overrides, leading to potential logic errors due to integer division and scaling issues.
Checking address accuracy
I'm verifying the hardcoded Uniswap pair init code hash for pairFor, ensuring its correctness matches the intended network. Incorrectness might result in incorrect pair addresses.
Evaluating function constraints
I'm thinking about the absence of 'maxWethIn' or 'maxTokenIn' limits in buy functions, which could lead to excessive inputs. Additionally, swap functions lack checks on 'path' array validity.
Assessing external dependencies
I'm evaluating the contract's reliance on external contracts and ensuring WETH and ETH are managed correctly to prevent unauthorized transactions or service disruptions.
Ensuring accurate input handling
I’m verifying that function arguments, especially minTokenOut and maxWethIn, are correctly passed. Also, checking for variable shadowing issues that could lead to potential bugs.
Spotting variable shadowing
I'm identifying variable shadowing in mintAndSell1155, particularly with the 'amounts' parameter, which could lead to misalignment in loop indices and potential unexpected behavior in Swap function returns.
Spotting vulnerabilities
I’m mapping out upgradeable pattern misuse, variable shadowing issues, and hardcoded address handling in the NFTXMarketplaceZap smart contract, leading to potential security or operational problems.
Pinpointing vulnerabilities
I’m identifying issues like miscalculations of fees and balances, sudden errors in swap functions' path handling, reentrancy risks despite safeguards, and approval risks due to the initial WETH approval to sushiRouter.
","The provided Solidity smart contract, `NFTXMarketplaceZap`, is designed to interact with various interfaces and perform operations such as minting, selling, buying, and swapping NFTs (both ERC721 and ERC1155) using WETH and interacting with Uniswap/Sushiswap routers. While the contract includes several safeguards like `ReentrancyGuard` and `Ownable`, it contains multiple vulnerabilities that could be exploited. Below is a comprehensive analysis of these vulnerabilities:

---

### 1. **Upgradeable Pattern Misuse**

**Issue:**
- **Inheritance from Upgradeable Contracts with a Constructor:** The contract inherits from `ERC721HolderUpgradeable`, `ERC1155HolderUpgradeable`, and `OwnableUpgradeable` but utilizes a constructor for initialization. Upgradeable contracts typically use an initializer function instead of constructors to set up state variables.

**Implications:**
- **Storage Collisions:** Constructors are not called when deploying upgradeable proxies, potentially leaving the contract uninitialized or misconfigured.
- **Security Risks:** If the contract is intended to be upgradeable, failing to use initializer functions can leave it vulnerable to attacks or unauthorized access.

**Recommendation:**
- **Use Initializer Functions:** Replace the constructor with an `initialize` function and utilize OpenZeppelin's `initializer` modifier to properly set up the contract's state when using proxies.

---

### 2. **Variable Shadowing**

**Issue:**
- **Shadowing Function Parameters:** In functions like `mintAndSell1155`, the parameter `amounts` is shadowed by a local variable with the same name.

  ```solidity
  function mintAndSell1155(
      uint256 vaultId, 
      uint256[] memory ids, 
      uint256[] memory amounts, // Parameter
      uint256 minWethOut, 
      address[] calldata path,
      address to
  ) public nonReentrant {
      // ...
      uint256[] memory amounts = _sellVaultTokenETH(...); // Shadowing
      // ...
  }
  ```

**Implications:**
- **Confusion and Bugs:** Shadowing can lead to confusion about which variable is being referenced, potentially causing logic errors or unintended behavior.
- **Maintenance Challenges:** Future developers might misinterpret the code, increasing the risk of introducing vulnerabilities during updates.

**Recommendation:**
- **Use Distinct Variable Names:** Ensure that local variables have unique names that do not conflict with function parameters or state variables to maintain clarity and prevent bugs.

---

### 3. **Hardcoded Address Handling for Specific NFTs**

**Issue:**
- **Special Handling for CryptoKitties and CryptoPunks:** The `transferFromERC721` and `approveERC721` functions contain hardcoded addresses for CryptoKitties (`0x06012c8cf97BEaD5deAe237070F9587f8E7A266d`) and CryptoPunks (`0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB`).

  ```solidity
  address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
  ```

**Implications:**
- **Limited Flexibility:** The contract is only equipped to handle these two specific NFT contracts, making it incompatible with other ERC721 tokens.
- **Potential Failures:** If the hardcoded addresses are incorrect for the deployed network (e.g., testnets), functions will fail.
- **Misaligned Interfaces:** CryptoPunks do not fully adhere to the ERC721 standard, leading to potential failures or unexpected behaviors when interacting with their contract.

**Recommendation:**
- **Generalize NFT Handling:** Remove hardcoded addresses and implement a more flexible mechanism to handle various ERC721 contracts. Utilize interfaces and standard ERC721 functions to ensure compatibility across different NFT contracts.

---

### 4. **Incorrect Calculation of Fees and Balances**

**Issue:**
- **Assumptions on Fee Scaling:** Functions like `_mint721` and `_mint1155` calculate balances using the formula `(count * BASE) - (count * mintFee)`. This assumes that `mintFee` is scaled appropriately relative to `BASE` (which is `10^18`).

  ```solidity
  uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee());
  ```

**Implications:**
- **Precision Errors:** If `mintFee` is not scaled to match `BASE`, the calculation could result in incorrect balance values.
- **Reversion Issues:** The `require` statement checking the balance may fail unexpectedly, causing legitimate transactions to revert.
- **Financial Loss:** Miscalculations could lead to discrepancies in token balances, potentially resulting in financial losses or exploitation opportunities.

**Recommendation:**
- **Clarify Fee Scaling:** Ensure that `mintFee` is consistently scaled relative to `BASE`. Consider using fixed-point arithmetic libraries or clearly documenting the expected units.
- **Implement Safe Calculations:** Use OpenZeppelin's `SafeMath` (although Solidity ^0.8.0 has built-in overflow checks) and add additional checks to verify that fee calculations are accurate.

---

### 5. **Improper Handling of Swap Paths**

**Issue:**
- **Lack of Validation on `path` Arrays:** Swap functions accept a `path` array without validating its length or ensuring it starts and ends with expected tokens.

  ```solidity
  uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
  );
  ```

**Implications:**
- **Failed Swaps:** Invalid or malicious paths can cause swap operations to fail or behave unpredictably.
- **Security Risks:** Incorrect paths might route tokens through unintended contracts, potentially exposing the contract to front-running or other attacks.

**Recommendation:**
- **Validate Swap Paths:** Implement checks to ensure that the `path` array has a minimum length (e.g., at least two addresses) and starts with the expected input token (e.g., WETH) and ends with the desired output token.
- **Restrict Paths:** If possible, restrict the permissible paths to known, safe routes to minimize risk.

---

### 6. **Approval Risks with Unlimited Allowance**

**Issue:**
- **Unlimited WETH Approval to SushiRouter:** In the constructor, the contract approves the `sushiRouter` to spend an unlimited amount of WETH.

  ```solidity
  IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  ```

**Implications:**
- **Potential for Abuse:** If the `sushiRouter` contract is compromised or malicious, it could drain all WETH from the `NFTXMarketplaceZap` contract.
- **Upgrade Risks:** If the `sushiRouter` address needs to be updated (e.g., due to a migration), the immutable approval cannot be revoked or changed.

**Recommendation:**
- **Use Limited Allowances:** Instead of approving `type(uint256).max`, approve only the necessary amount required for each operation.
- **Implement Approval Management:** Consider mechanisms to update or revoke allowances if the router address needs to change, enhancing flexibility and security.

---

### 7. **Hardcoded INIT_CODE_PAIR_HASH in `pairFor` Function**

**Issue:**
- **Static INIT_CODE_PAIR_HASH:** The `pairFor` function uses a hardcoded `INIT_CODE_PAIR_HASH`, which is specific to UniswapV2 on certain networks.

  ```solidity
  hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'
  ```

**Implications:**
- **Network Mismatch:** Deploying the contract on a network where the `INIT_CODE_PAIR_HASH` differs (e.g., testnets, other blockchains) will result in incorrect pair address calculations.
- **Incompatibility with SushiSwap:** While SushiSwap often shares the same `INIT_CODE_PAIR_HASH` as UniswapV2 on Ethereum mainnet, this might not hold true across all networks or future updates.

**Recommendation:**
- **Dynamic Initialization:** Allow the `INIT_CODE_PAIR_HASH` to be set dynamically during contract deployment or initialization based on the target network.
- **Verify Hash Accuracy:** Ensure that the hash corresponds correctly to the deployed factory's pair creation code on the intended network.

---

### 8. **Potential Miscalculations Due to Integer Arithmetic**

**Issue:**
- **Integer Division and Rounding Errors:** Solidity performs integer division, which can lead to truncation and rounding errors. Calculations like `(count * BASE) - (count * INFTXVault(vault).mintFee())` might not account for fractional values accurately.

**Implications:**
- **Balance Mismatches:** Rounding errors can cause `balance` to differ from `IERC20Upgradeable(vault).balanceOf(address(this))`, leading to unexpected reverts.
- **Financial Discrepancies:** Small inaccuracies can accumulate, potentially leading to significant financial discrepancies over multiple transactions.

**Recommendation:**
- **Use Fixed-Point Arithmetic:** Implement fixed-point arithmetic libraries to handle fractional values more accurately.
- **Add Buffer Tolerances:** Allow for small tolerances in balance checks to accommodate minor discrepancies due to integer arithmetic.

---

### 9. **Insufficient Validation in `buyAndRedeem` Functions**

**Issue:**
- **Potential Overestimation of `minTokenOut`:** In functions like `buyAndRedeem`, the parameter `(amount * BASE) + totalFee` is used as `minTokenOut` in `_buyVaultToken`.

  ```solidity
  uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
  ```

**Implications:**
- **Failed Transactions:** If `(amount * BASE) + totalFee` exceeds what the swap can provide, the transaction will revert, potentially blocking legitimate operations.
- **Slippage Vulnerabilities:** Attackers might manipulate fees or amounts to cause swaps to fail, leading to denial-of-service conditions.

**Recommendation:**
- **Dynamic Slippage Control:** Allow users to specify acceptable slippage levels or implement more nuanced calculations for `minTokenOut` based on current market conditions.
- **Error Handling:** Provide more informative error messages or fallback mechanisms when swaps fail due to `minTokenOut` being too high.

---

### 10. **Potential Denial of Service (DoS) via External Contract Failures**

**Issue:**
- **Reliance on External Contracts:** The contract heavily interacts with external contracts like `WETH`, `sushiRouter`, and various NFTX vaults. If any of these contracts malfunction or behave maliciously, it could disrupt the `NFTXMarketplaceZap` operations.

**Implications:**
- **Service Interruptions:** Malfunctioning external contracts can halt the execution of critical functions, leading to a denial of service.
- **Security Exploits:** If an external contract is compromised, it could potentially be used to exploit the `NFTXMarketplaceZap` contract.

**Recommendation:**
- **Implement Circuit Breakers:** Introduce mechanisms to pause operations if interactions with external contracts fail consistently.
- **Use Trusted Contracts:** Ensure that all external contracts are audited and trusted. Regularly review and update the addresses of external contracts if necessary.

---

### 11. **Lack of Comprehensive Input Validation**

**Issue:**
- **Partial Input Checks:** While some functions check for conditions like `to != address(0)` and `ids.length != 0`, other critical inputs like `path` arrays, `vaultId`, and specific IDs are not thoroughly validated.

**Implications:**
- **Unexpected Behavior:** Invalid or malicious inputs can cause functions to behave unpredictably, potentially leading to failed transactions or security breaches.
- **Exploitation Opportunities:** Attackers might craft specific inputs to exploit the contract's logic, especially in swap and minting functions.

**Recommendation:**
- **Comprehensive Input Validation:** Implement thorough checks for all input parameters, ensuring they meet expected formats, lengths, and value ranges.
- **Use Modifiers and Libraries:** Utilize Solidity's modifiers or external validation libraries to enforce input constraints consistently across functions.

---

### 12. **Improper Handling of ERC1155 Operations**

**Issue:**
- **Assumption of ERC1155 Compliance:** Functions interacting with ERC1155 tokens assume full compliance with the ERC1155 standard, such as successful `safeBatchTransferFrom` and `setApprovalForAll` operations.

**Implications:**
- **Compatibility Issues:** Non-standard or malicious ERC1155 tokens might not behave as expected, leading to failed transfers or unintended state changes.
- **Security Risks:** Improper handling could expose the contract to reentrancy or other attack vectors if the ERC1155 token's callback functions are exploited.

**Recommendation:**
- **Implement Safe Checks:** After ERC1155 operations, verify the success of transfers and approvals, possibly by checking return values or implementing interface checks.
- **Limit Interactions:** Restrict interactions to trusted ERC1155 tokens or implement whitelisting mechanisms to prevent unauthorized token interactions.

---

### 13. **Use of Low-Level Calls Without Comprehensive Checks**

**Issue:**
- **Low-Level `call` Usage:** The contract uses low-level `call` for transferring ETH and interacting with NFT contracts without exhaustive checks on return data.

  ```solidity
  (bool success, bytes memory result) = address(assetAddr).call(data);
  require(success, string(result));
  ```

**Implications:**
- **Reentrancy Risks:** While guarded by `nonReentrant`, improper handling of low-level calls can still introduce vulnerabilities, especially if return data is misinterpreted.
- **Failure Handling:** Relying solely on `success` without validating `result` can lead to ambiguous error states or mismanagement of funds.

**Recommendation:**
- **Use High-Level Interfaces:** Whenever possible, use interface-based function calls instead of low-level `call` to benefit from Solidity's type safety and error handling.
- **Validate Return Data:** Ensure that the return data from low-level calls is properly decoded and validated to confirm successful execution.

---

### 14. **Potential Gas Consumption and Loop Risks**

**Issue:**
- **Unbounded Loops:** Functions like `_mint721`, `_mint1155`, and various swap functions contain loops that iterate over arrays without enforcing a maximum length.

**Implications:**
- **Gas Exhaustion:** Extremely large arrays can cause functions to consume excessive gas, leading to transaction failures.
- **Denial of Service:** Attackers might exploit this by submitting transactions with large input arrays, intentionally causing gas depletion.

**Recommendation:**
- **Limit Input Sizes:** Impose maximum limits on the lengths of input arrays to prevent excessive gas consumption.
- **Batch Processing:** Consider processing inputs in smaller batches or implementing pagination mechanisms to handle large data sets efficiently.

---

### 15. **Incorrect Assumptions About External Contract Behavior**

**Issue:**
- **Assumed Functionality of External Contracts:** The contract assumes that external contracts like `INFTXVault` and `IUniswapV2Router01` behave as expected, without accounting for potential deviations or updates.

**Implications:**
- **Compatibility Issues:** If external contracts are updated or replaced with non-compliant versions, the `NFTXMarketplaceZap` contract may malfunction.
- **Security Risks:** Malicious updates to external contracts can introduce vulnerabilities or unauthorized behaviors into the `NFTXMarketplaceZap` contract.

**Recommendation:**
- **Implement Compatibility Checks:** Verify that external contracts adhere to expected interfaces and behaviors before interacting with them.
- **Monitor External Dependencies:** Regularly audit and monitor external contracts for changes or vulnerabilities, updating the `NFTXMarketplaceZap` contract accordingly.

---

### Summary of Vulnerabilities

1. **Upgradeable Pattern Misuse:** Incompatibility between constructor and upgradeable inheritance patterns.
2. **Variable Shadowing:** Overlapping variable names leading to potential logic errors.
3. **Hardcoded Address Handling:** Limited and potentially incorrect handling of specific NFT contracts.
4. **Incorrect Calculation of Fees and Balances:** Potential miscalculations due to improper fee scaling.
5. **Improper Handling of Swap Paths:** Lack of validation on swap path arrays.
6. **Approval Risks with Unlimited Allowance:** Excessive WETH approval to external routers.
7. **Hardcoded INIT_CODE_PAIR_HASH:** Potential inaccuracies in pair address calculations across networks.
8. **Potential Miscalculations Due to Integer Arithmetic:** Rounding and precision errors in financial computations.
9. **Insufficient Validation in Buy and Redeem Functions:** Overestimation of `minTokenOut` leading to failed transactions.
10. **Potential Denial of Service via External Contract Failures:** Reliance on external contracts that might malfunction or be compromised.
11. **Lack of Comprehensive Input Validation:** Partial checks on critical inputs, leading to unexpected behaviors.
12. **Improper Handling of ERC1155 Operations:** Assumptions about ERC1155 compliance without safeguards.
13. **Use of Low-Level Calls Without Comprehensive Checks:** Potential vulnerabilities from unchecked low-level `call` operations.
14. **Potential Gas Consumption and Loop Risks:** Unbounded loops leading to gas exhaustion.
15. **Incorrect Assumptions About External Contract Behavior:** Trusting external contracts without validation.

---

### Recommendations for Mitigation

To enhance the security and reliability of the `NFTXMarketplaceZap` contract, consider implementing the following measures:

1. **Adopt Proper Upgradeable Patterns:** Use initializer functions instead of constructors when inheriting from upgradeable contracts.
2. **Avoid Variable Shadowing:** Use unique variable names to prevent confusion and potential bugs.
3. **Generalize NFT Handling:** Remove hardcoded addresses and implement flexible mechanisms for interacting with various ERC721 contracts.
4. **Ensure Accurate Fee Calculations:** Clarify and consistently apply fee scaling relative to base units.
5. **Validate Swap Paths:** Implement checks to ensure swap paths are valid and secure.
6. **Limit Approvals:** Use limited allowances for token approvals and manage them dynamically as needed.
7. **Dynamic Pair Hash Initialization:** Allow `INIT_CODE_PAIR_HASH` to be set based on the deployment network.
8. **Handle Integer Arithmetic Carefully:** Use fixed-point libraries and add tolerances to account for rounding errors.
9. **Enhance Input Validation:** Implement comprehensive checks for all function inputs to ensure they meet expected criteria.
10. **Secure External Interactions:** Introduce circuit breakers and monitor external contracts to prevent DoS and other attacks.
11. **Use High-Level Interfaces:** Prefer interface-based calls over low-level `call` to leverage Solidity's type safety.
12. **Limit Input Sizes:** Impose maximum lengths on input arrays to prevent gas exhaustion.
13. **Monitor External Dependencies:** Regularly audit and verify the behavior of external contracts interacting with `NFTXMarketplaceZap`.

By addressing these vulnerabilities and implementing the recommended safeguards, the `NFTXMarketplaceZap` contract can achieve enhanced security, reliability, and compatibility across various use cases and deployment environments.
","### **Analysis of Issue Report vs. Response List**

---

#### **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**

**Report Description**:
The `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, `msg.value` is used instead of `maxWethIn`. Since `msg.value` is 0, the call will fail.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The problem outlined here relates to the incorrect usage of `msg.value` instead of `maxWethIn`, which will cause the function to fail when no ETH is sent. This is a critical issue that needs to be fixed, as it prevents the function from working as intended.

**Suggestions**:
The response list should include a recommendation to correctly pass `maxWethIn` to `_buyVaultToken` instead of relying on `msg.value`.

---

#### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:
A malicious user can lock the functionalities of the `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` contracts by transferring a non-zero amount of vTokens to the marketplace. This would disable the contract's functionality for all users.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not mention this issue. This is a severe vulnerability that allows an attacker to lock the contract by maliciously transferring vTokens to the contract. No response addresses the vulnerability of unauthorized users being able to lock the vault.

**Suggestions**:
The response list should include a fix for proper access control, preventing unauthorized transfers of vTokens to the contract or ensuring that only legitimate transfers are allowed to change the contract’s state.

---

#### **[M-01] Missing non-reentrancy modifier**

**Report Description**:
Several functions are missing the `nonReentrant` modifier, although some other public/external functions do use it. While no exploit was found, it is best practice to ensure all functions interacting with external calls are properly guarded.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the absence of the `nonReentrant` modifier. Functions interacting with external contracts should be consistently protected by reentrancy guards, especially when dealing with state changes that could be exploited.

**Suggestions**:
The response list should recommend adding the `nonReentrant` modifier to all appropriate functions to prevent potential reentrancy attacks.

---

#### **[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**

**Report Description**:
The function `buyAndSwap721WETH` incorrectly returns unused WETH/ETH to the `to` address instead of the `msg.sender`.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. This issue is not addressed in the response list. Returning unused ETH/WETH to the wrong address could lead to user funds being locked or lost.

**Suggestions**:
The response list should recommend ensuring that unused ETH/WETH is returned to `msg.sender`, ensuring the correct return path for the user's funds.

---

#### **[M-04] `NFTXStakingZap` and `NFTXMarketplaceZap`'s `transferFromERC721` transfer Cryptokitties to the wrong address**

**Report Description**:
The `transferFromERC721` function incorrectly transfers Cryptokitties to `address(this)` instead of the intended `to` address. This mistake causes NFTs to be missed in the vault.

**Match in Response List**:
Matches with **[R-03] Hardcoded Address Handling for Specific NFTs**.

**Validation**:
**Partially Correct**. The issue related to handling specific NFTs like Cryptokitties is addressed in the response list. However, the response does not fully explain the consequence of the incorrect transfer logic when interacting with Cryptokitties. The specific bug regarding Cryptokitties being sent to the wrong address should be more explicitly highlighted, with a focus on correcting the address logic.

**Suggestions**:
The response list should focus more on correcting the transfer logic for Cryptokitties (and other NFTs) rather than just identifying the hardcoded address. A fix for this should involve ensuring that the `to` address is respected in all cases.

---

#### **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Report Description**:
The `buyAndSwap1155WETH` function fails because it uses `msg.value` instead of the `maxWethIn` value, which is crucial to making the function work.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. This issue, which results in the function failing unless both ETH and WETH are provided, is not addressed in the response list. This is a logic error that should be corrected by ensuring the correct parameter is used when interacting with the `_buyVaultToken` function.

**Suggestions**:
The response list should recommend using `maxWethIn` instead of `msg.value` in the function to ensure the function works as intended.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

---

#### **[R-05] Recommendation to Implement Circuit Breaker Pattern**

**Response Description**:
The response suggests implementing a circuit breaker pattern to halt contract operations in case of detected anomalies or emergencies, enhancing the contract's ability to respond to unforeseen issues.

**Assessment**:
**Valid Concern**. Although this was not mentioned in the original issue report, implementing a circuit breaker pattern is a valid best practice to provide an emergency stop for the contract in case of serious errors, security breaches, or external contract failures.

**Recommendations**:
Consider implementing a circuit breaker to halt operations when certain conditions (e.g., external contract failure or critical vulnerabilities) are met. This can enhance the contract’s resiliency during security incidents.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **None**

**Partially Correct Matches**:

- **[M-04] `NFTXStakingZap` and `NFTXMarketplaceZap`'s `transferFromERC721` transfer Cryptokitties to the wrong address**

**Missed Issues from Issue Report**:

- **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**
- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**
- **[M-01] Missing non-reentrancy modifier**
- **[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**
- **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-05] Recommendation to Implement Circuit Breaker Pattern**: A valid concern, though not explicitly mentioned in the issue report, provides a good security enhancement.
",0,1,5,15,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672.0,172.0,"[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the `_sendForReceiver` function.
In the `_sendForReceiver` function, when `_receiver` is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
 
[M-02] `addReceiver()`: Failure to check for existing receiver
The `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
  [M-10] `_sendForReceiver` doesn't return success if receiver is not a contract
Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in `_sendForReceiver`
The `_sendForReceiver()` function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
  [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the `_sendForReceiver` function to distribute the fee In the `_sendForReceiver` function, when the `_receiver` is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605.0,1,5,"Battling vulnerabilities
I’m piecing together the smart contract code, identifying functions like token distribution and updating fee receivers. The aim is to mitigate risks such as reentrancy and access control issues.
Identifying potential risks
I’m digging into functions like distribute and addReceiver, ensuring access control and reentrancy protections. There’s a need to tackle issues such as missing definitions and ownership security.
Evaluating smart contract actions
I’m assessing the RescueTokens function and the approve use in _sendForReceiver. Despite the ReentrancyGuard, _sendForReceiver might have issues warranting safeApprove for token security.
Taking a closer look
I’m identifying the inefficiency in fund distribution due to leftover balances, the redundancy of SafeMath, and the security implications of setting crucial addresses by the owner.
Evaluating critical functions
I’m thinking through the security implications of owner actions in setNFTXVaultFactory, the potential token drain via rescueTokens, reorder effects from removeReceiver, and scalability concerns from distribute.
Evaluating distribution flows
I’m assessing potential issues in changeReceiverAlloc, the upgradeable contract’s storage layout, missing checks in distribute, and the security of using nftxVaultFactory functions.
Navigating contract concerns
Evaluating the addReceiver function's scalability impact, noting the absence of allocation limits, assessing rescueTokens potential for token drainage, and examining _addReceiver's allocation unit type.
Identifying key vulnerabilities
Taking a closer look: rescueTokens can drain funds, approve in _sendForReceiver risks front-running, distribute might exhaust gas, owner control over critical addresses is also risky.
Refining security implications
OK, let me see. The rescueTokens function's vulnerability, approve in _sendForReceiver risks, owner's control over addresses, and potential gas exhaustion in distribute are the main security issues identified.
","The provided Solidity smart contract `NFTXSimpleFeeDistributor` is designed to distribute tokens from a vault to various fee receivers based on allocation points. While the contract incorporates several security best practices, such as using `ReentrancyGuardUpgradeable` and `SafeERC20Upgradeable`, there are multiple vulnerabilities and potential issues that need to be addressed to ensure the contract's security and functionality. Below is a comprehensive analysis of the vulnerabilities identified in the contract:

### 1. **Owner-Controlled Rescue Function (`rescueTokens`)**

**Issue:**
The `rescueTokens` function allows the contract owner to transfer **any** ERC20 tokens from the contract to their own address.

```solidity
function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
}
```

**Vulnerability:**
- **Unauthorized Fund Drain:** If the owner’s private key is compromised, an attacker can call this function to drain all tokens held by the contract, including those meant to be distributed to fee receivers or held in the treasury.
- **Lack of Restrictions:** There's no restriction on which tokens can be rescued. This means even critical tokens intended for the contract’s operation can be maliciously withdrawn.

**Recommendation:**
- **Restrict Rescues:** Limit the `rescueTokens` function to only allow rescuing tokens that are **not** part of the core functionality (e.g., exclude the vault tokens).
- **Multi-Signature Control:** Implement multi-signature requirements for sensitive functions like `rescueTokens` to reduce the risk associated with a single point of failure.

### 2. **Improper Use of `approve` in `_sendForReceiver`**

**Issue:**
The `_sendForReceiver` function uses the `approve` method before calling an external contract, which can lead to unintended behaviors.

```solidity
function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
        IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
        
        bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
        (bool success, ) = address(_receiver.receiver).call(payload);

        return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
        IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
}
```

**Vulnerabilities:**
- **Race Condition (Front-Running):** An attacker could potentially front-run the transaction to manipulate the allowance or perform unauthorized actions before the intended call completes.
- **Approval Reset Check:** The function checks if the allowance is reset to zero after the call, which might not hold true for all ERC20 tokens, especially those with non-standard implementations.

**Recommendation:**
- **Use `safeApprove` with Zero First:** To mitigate the race condition, first set the allowance to zero before setting it to the desired amount.
  
  ```solidity
  IERC20Upgradeable(_vault).safeApprove(_receiver.receiver, 0);
  IERC20Upgradeable(_vault).safeApprove(_receiver.receiver, amountToSend);
  ```

- **Consider Using `transfer` Instead of `approve`:** If possible, use `safeTransfer` to send tokens directly without needing to set allowances.

### 3. **Centralization Risks Due to Owner Privileges**

**Issue:**
Multiple functions grant significant control to the contract owner, including setting critical addresses and managing fee receivers.

**Key Functions:**
- `setNFTXVaultFactory`
- `setTreasuryAddress`
- `setLPStakingAddress`
- `setInventoryStakingAddress`
- `addReceiver`, `removeReceiver`, `changeReceiverAlloc`, `changeReceiverAddress`

**Vulnerabilities:**
- **Single Point of Failure:** If the owner account is compromised, an attacker can:
  - Redirect funds to malicious addresses.
  - Add unauthorized fee receivers.
  - Pause distributions indefinitely.
  - Modify allocation points to favor the attacker.
  
- **Trust Assumptions:** The security of the entire system heavily relies on the trustworthiness and security of the owner’s private key.

**Recommendation:**
- **Implement Multi-Signature Ownership:** Use multi-signature wallets for owner-controlled functions to distribute authority and reduce the risk of single-key compromise.
- **Introduce Time Delays:** For critical administrative actions, introduce time delays to allow for community review or intervention in case of malicious actions.
- **Role-Based Access Control:** Instead of a single owner, implement role-based permissions to distribute administrative responsibilities among multiple trusted parties.

### 4. **Potential Denial of Service (DoS) via Excessive `feeReceivers`**

**Issue:**
The `distribute` function iterates through the `feeReceivers` array to distribute tokens. An excessively large number of fee receivers can cause the function to run out of gas.

```solidity
function distribute(uint256 vaultId) external override virtual nonReentrant {
    // ... [omitted for brevity]
    uint256 length = feeReceivers.length;
    for (uint256 i = 0; i < length; i++) {
        // Distribution logic
    }
    // ... [omitted for brevity]
}
```

**Vulnerability:**
- **Gas Limit Exceeded:** If the number of fee receivers grows beyond a manageable limit, the `distribute` function could fail due to exceeding the block gas limit, effectively halting distributions.
- **Blocked Operations:** Legitimate distributions could be blocked, leading to financial discrepancies and loss of trust in the system.

**Recommendation:**
- **Limit the Number of Fee Receivers:** Impose a maximum limit on the number of fee receivers to prevent the array from growing uncontrollably.
- **Batch Processing:** Implement a mechanism to process fee receivers in batches, allowing the distribution to be split across multiple transactions.
- **Alternative Data Structures:** Use more efficient data structures or patterns that reduce the computational complexity of the distribution process.

### 5. **Initialization Parameters and Initial Fee Receiver Allocation**

**Issue:**
During initialization, the contract adds a fee receiver with an allocation point of `0.8 ether`.

```solidity
function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
}
```

**Vulnerability:**
- **Misuse of Allocation Points:** Allocation points are typically unit-less values representing relative weights. Using `0.8 ether` (which equals `8 * 10^17`) could lead to unintended distribution ratios, especially if other allocation points are significantly smaller or not properly scaled.
  
- **Potential Precision Errors:** If allocation points are intended to represent proportions, using large or fractional values can introduce precision errors or inconsistencies in distribution calculations.

**Recommendation:**
- **Standardize Allocation Points:** Use consistent and appropriately scaled allocation points (e.g., integers) to represent distribution weights.
- **Validate Allocation Points:** Implement validation to ensure that allocation points are within expected ranges and formats during initialization and updates.

### 6. **Redundant Use of `SafeMathUpgradeable` with Solidity ^0.8.0**

**Issue:**
The contract imports and uses `SafeMathUpgradeable` for arithmetic operations.

```solidity
import ""./util/SafeMathUpgradeable.sol"";
...
using SafeMathUpgradeable for uint256;
```

**Vulnerability:**
- **Redundancy:** Solidity version ^0.8.0 includes built-in overflow and underflow checks, making `SafeMath` unnecessary. Using it can lead to increased gas costs without providing additional security benefits.

**Recommendation:**
- **Remove `SafeMathUpgradeable`:** Eliminate the use of `SafeMathUpgradeable` to optimize gas usage and simplify the codebase.

### 7. **Lack of Event Emission for Critical Actions**

**Issue:**
Certain critical actions, such as initializing the contract or updating important state variables, do not emit events.

**Example:**
- The `initializeVaultReceivers` function does not emit any events after performing its operations.

**Vulnerability:**
- **Reduced Transparency:** Without event logs, it becomes harder to track and audit critical state changes, which can impede debugging and monitoring efforts.
  
- **Auditability Issues:** Events are essential for off-chain services and users to track contract behavior. Missing events can hinder these processes.

**Recommendation:**
- **Emit Events for All Critical Actions:** Ensure that every state-changing function emits appropriate events to provide transparency and facilitate auditing.

### 8. **Potential Storage Layout Issues in Upgradeable Contracts**

**Issue:**
The contract inherits from multiple upgradeable contracts (`ReentrancyGuardUpgradeable`, `PausableUpgradeable`) but does not show the complete inheritance and storage layout.

**Vulnerability:**
- **Storage Collisions:** In upgradeable contracts, improper ordering or gaps in storage can lead to storage collisions, causing unexpected behaviors or vulnerabilities.
  
- **Upgradeability Risks:** If not carefully managed, upgrades can introduce new vulnerabilities or disrupt existing functionalities.

**Recommendation:**
- **Follow Upgradeable Contract Best Practices:** Ensure that storage layouts are meticulously managed and that inheritance is ordered correctly to prevent storage collisions.
- **Use Proxy Patterns Carefully:** If using proxy patterns for upgradeability, ensure that the implementation and proxy contracts are correctly aligned.

### 9. **Lack of Input Validation in `changeReceiverAlloc` and `changeReceiverAddress`**

**Issue:**
Functions `changeReceiverAlloc` and `changeReceiverAddress` allow updating fee receivers without comprehensive input validation.

```solidity
function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    // ...
}

function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    // ...
}
```

**Vulnerability:**
- **Out-of-Bounds Access:** Although `removeReceiver` checks for index bounds, `changeReceiverAlloc` and `changeReceiverAddress` do not explicitly validate `_receiverIdx`, potentially leading to out-of-bounds array access and unexpected behavior.
  
- **Invalid Addresses:** There's no check to ensure that the new receiver address (`_address`) is valid (e.g., not zero address), which could lead to tokens being sent to unintended recipients.

**Recommendation:**
- **Add Index Validation:** Ensure that `_receiverIdx` is within the bounds of the `feeReceivers` array in both functions.
  
  ```solidity
  require(_receiverIdx < feeReceivers.length, ""Invalid receiver index"");
  ```

- **Validate Receiver Addresses:** Check that the new receiver address is not the zero address and, if applicable, that it adheres to expected contract standards.

  ```solidity
  require(_address != address(0), ""Receiver address cannot be zero"");
  ```

### 10. **Missing Functionality to Retrieve Fee Receiver Details**

**Issue:**
While the contract allows adding, removing, and updating fee receivers, there is no function to retrieve detailed information about each fee receiver beyond their array index.

**Vulnerability:**
- **Lack of Transparency:** Users and external contracts may find it difficult to query and verify fee receiver details, potentially leading to trust issues.

**Recommendation:**
- **Implement Getter Functions:** Provide functions to retrieve fee receiver details by index or address, enhancing transparency and usability.

  ```solidity
  function getFeeReceiver(uint256 index) external view returns (FeeReceiver memory) {
      require(index < feeReceivers.length, ""Index out of bounds"");
      return feeReceivers[index];
  }
  ```

### Summary of Vulnerabilities

1. **Owner-Controlled Rescue Function:** Allows the owner to withdraw any tokens, posing a risk of fund drain.
2. **Improper Use of `approve`:** Potential for race conditions and unintended allowances.
3. **Centralization Risks:** Extensive owner privileges can lead to abuse if the owner is compromised.
4. **Denial of Service via Excessive Receivers:** Large `feeReceivers` array can cause `distribute` to fail.
5. **Initialization Parameter Misuse:** Using `0.8 ether` as an allocation point may lead to distribution inaccuracies.
6. **Redundant `SafeMath`:** Unnecessary usage increases gas costs.
7. **Lack of Event Emission:** Reduces transparency and auditability.
8. **Upgradeable Storage Layout Risks:** Potential for storage collisions and upgrade vulnerabilities.
9. **Insufficient Input Validation:** Risks of out-of-bounds access and invalid receiver addresses.
10. **Missing Getter Functions:** Limits transparency and user trust.

### Recommendations for Mitigation

- **Restrict and Secure Owner Privileges:** Implement multi-signature wallets and restrict rescue functions to non-critical tokens.
- **Correct Approval Mechanism:** Follow the checks-effects-interactions pattern and use `safeApprove` properly.
- **Limit Fee Receivers:** Impose caps on the number of fee receivers and consider batch processing.
- **Enhance Initialization and Allocation Handling:** Use standardized allocation points and validate inputs rigorously.
- **Optimize Code for Solidity 0.8.x:** Remove redundant libraries like `SafeMathUpgradeable`.
- **Increase Transparency:** Emit events for all critical actions and implement getter functions for fee receivers.
- **Ensure Safe Upgradeability Practices:** Carefully manage storage layouts and follow best practices for upgradeable contracts.
- **Implement Comprehensive Input Validation:** Validate all inputs in state-changing functions to prevent misuse and errors.

By addressing these vulnerabilities and following the recommended best practices, the `NFTXSimpleFeeDistributor` contract can achieve a higher level of security, reliability, and trustworthiness.
","### **Analysis of Issue Report vs. Response List**

---

### **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**

**Report Description**:
The issue explains that the `_sendForReceiver` function in the `NFTXSimpleFeeDistributor.sol` contract does not set a return value when the `_receiver` is not a contract. This causes the distribute function to incorrectly assume that the fee transfer has failed, which results in the distribution of more fees in subsequent transactions.

**Match in Response List**:
**No match found**.

**Validation**:
The issue described is related to a missing return value in the `_sendForReceiver` function, leading to incorrect behavior in the `distribute` function. While some responses in the report address issues with contract interactions (e.g., race conditions or contract failures), none specifically address the problem of return value handling in `_sendForReceiver`. This issue is not explicitly addressed.

**Suggestions**:
The response list should have included a mention of how to correctly handle the return value of `_sendForReceiver` when `_receiver` is not a contract. The solution could involve ensuring that the function always returns a boolean value (e.g., `true` when successful and `false` when not) to avoid misinterpretation by the `distribute` function.

---

### **[M-01] Missing non-reentrancy modifier**

**Report Description**:
Certain functions are missing the `nonReentrant` modifier, which is used to prevent reentrancy attacks, even though other functions in the contract do use it. The concern here is that although no immediate exploit is identified, it is a best practice to apply the modifier consistently.

**Match in Response List**:
**No match found**.

**Validation**:
The response list does not address reentrancy concerns. The absence of the `nonReentrant` modifier in critical functions should be identified as a potential vulnerability. Missing reentrancy protection in specific functions could lead to attacks if external calls are made, allowing attackers to re-enter and manipulate the contract state. The response list should have included a recommendation to apply the `nonReentrant` modifier to relevant functions.

**Suggestions**:
The response list should have emphasized adding the `nonReentrant` modifier to the relevant functions to prevent potential reentrancy vulnerabilities.

---

### **[M-02] `addReceiver()`: Failure to check for existing receiver**

**Report Description**:
The `addReceiver()` function fails to check if the receiver already exists, potentially leading to duplicate entries. This results in erroneous fee distributions, with a receiver receiving more than expected.

**Match in Response List**:
**No match found**.

**Validation**:
This issue is not addressed in the response list. Adding a receiver without checking for duplicates is a logical flaw that could lead to erroneous fee distribution. The response list does not suggest any validation or checks to ensure that duplicate receivers are not added.

**Suggestions**:
The response list should include a validation mechanism to check for existing receivers before adding a new one. A solution could involve maintaining a mapping of receivers or checking the `feeReceivers` array for existing addresses before adding new ones.

---

### **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**

**Report Description**:
The issue is related to the `_sendForReceiver` function, which does not return a success value when the receiver is not a contract, leading to double-spending of fees in the distribution process.

**Match in Response List**:
Matches with **""Improper Use of `approve` in `_sendForReceiver`""**.

**Validation**:
**Partially correct**. While the response discusses a different issue (related to the `approve` method and race conditions), the broader context of handling external calls and return values is relevant to this problem. However, the response does not directly address the absence of return value handling in `_sendForReceiver`, which is the root cause of the fee distribution issue described in the report.

**Suggestions**:
The response should have more directly addressed the return value issue in `_sendForReceiver` and its impact on the distribution function, as this is the core issue in the report.

---

### **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Report Description**:
The `_sendForReceiver()` function does not set a return value in the `else` block, which may lead to issues with the `distribute()` function, as the return value is implicitly set to `false`. This results in leftover fees and incorrect fund allocation.

**Match in Response List**:
**No match found**.

**Validation**:
The issue is not explicitly addressed in the response list. The return value handling in `_sendForReceiver()` is critical to ensure that the function behaves correctly. The report points out a logical flaw, where the return value is not set in the `else` block, leading to unintended outcomes. 

**Suggestions**:
The response should have emphasized fixing the return value handling in `_sendForReceiver()` by ensuring that it always returns a boolean value (`true` or `false`) based on the transfer's success. This would prevent unintended logic failures in the `distribute()` function.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:
The `distribute()` function is vulnerable to a DoS attack if a malicious receiver executes a `revert()` in their `receiveRewards()` function.

**Match in Response List**:
Matches with **""Potential Denial of Service (DoS) via Excessive `feeReceivers`""**.

**Validation**:
**Partially correct**. While the response identifies a potential DoS issue related to gas limits (due to excessive fee receivers), it does not explicitly address the specific risk from malicious receivers. The report describes how a malicious contract could cause a DoS by invoking `revert()`, which is not mentioned in the response.

**Suggestions**:
The response should have addressed the potential DoS attack caused by malicious contracts and included recommendations such as input validation, limiting the number of fee receivers, or using a try/catch block for external calls.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

---

### **[R-02] Improper Use of `approve` in `_sendForReceiver`**

**Response Description**:
The response highlights the risk of front-running due to the use of `approve` in the `_sendForReceiver` function, suggesting the use of `safeApprove` or switching to `safeTransfer`.

**Assessment**:
**Valid Concern**. This is a valid concern regarding ERC20 `approve` usage. Using `approve` before an external contract interaction opens the door for front-running attacks. The response accurately identifies this issue but does not address the primary issue with return value handling in `_sendForReceiver`.

**Recommendations**:
While the concern about `approve` is valid, the response could benefit from focusing more on fixing the return value issue first, as this directly affects the contract’s functionality. The response should suggest switching to direct `transfer` calls instead of using `approve` in `_sendForReceiver`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract** (partially addressed under a different context)

**Partially Correct Matches**:

- **[M-16] Malicious receiver can make `distribute` function denial of service** (partially addressed in the response about excessive fee receivers)

**Missed Issues from Issue Report**:

- **[H-02] The return value of the `_sendForReceiver` function is not set**.
- **[M-01] Missing non-reentrancy modifier**.
- **[M-02] `addReceiver()` function fails to check for existing receiver**.
- **[M-14] Return variable can remain unassigned in `_sendForReceiver`**.

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-02] Improper Use of `approve` in `_sendForReceiver`**: A valid concern related to the use of `approve`, but not directly addressing the core issues in the report.

---


",1,1,4,10,"```
None.
```",0.0
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750.0,561.0,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock
The default value of `inventoryLockTime` in NFTXStakingZap is 7 days while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in XTokenUpgradeable.
The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in NFTXInventoryStaking`",2.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033.0,0,2,"Analyzing the contract
I’m beginning by reviewing the NFTXVaultUpgradeable smart contract, focusing on reentrancy, access control, integer overflows, require statements, external calls, state variable management, logical errors, and upgradeability issues, given the use of Solidity ^0.8.0.
Mapping out the contract
I’m analyzing the NFTXVaultUpgradeable contract, focusing on its upgradeable nature, NFTs, ERC20 tokens, and interactions with contracts like vaultFactory and feeDistributor. Initializer and finalizeVault are under scrutiny for potential issues.
Highlighting key steps
I’m noting the focus on privileged functions, centralization risks from hardcoded dev addresses, and dependencies on vaultFactory security for setting and disabling vault fees.
Evaluating minting and redeeming
I’m reviewing minting and redeeming processes, focusing on reentrancy prevention, paused state handling, and fee charging. Attention is given to the receiveNFTs and withdrawNFTsTo functions.
Swapping and flash loan actions
I'm examining swap and flash loan actions, ensuring non-reentrancy, paused state logic, safe NFT transfers, and eligibility storage handling are properly addressed.
Navigating NFT transfers
I’m mapping out NFT transfers, focusing on validity, transfer methods, holding adjustments, and interactions like receiveNFTs and withdrawNFTsTo. Ensuring safeBatchTransferFrom and transferERC721 functions are correctly implemented.
Ensuring secure transfers
I'm focusing on handling token transfers, reentrancy risks, proper checks, and considering safe transfer methods to minimize vulnerability exposure.
Evaluating token handling
I’m mapping out the transferFromERC721 and getRandomTokenIdFromVault functions, noting potential vulnerabilities like blocking transfers and insecure randomness influenced by block variables. קעI’m analyzing security aspects like privileged access and paused state logic.
Highlighting vulnerabilities
I’m focusing on secure randomness, external call risk, centralized control, and potential token locking. These areas require careful attention to mitigate exposure to various threats.
Clarifying fee validation
I'm thinking through the importance of consistently validating fees based on the correct user address across various contract functions to avoid potential discrepancies and security risks.
Ensuring alignment
I’m ensuring proper sequence of storage variables for future upgrades, highlighting potential vulnerabilities due to mismanagement of storage layouts.
Identifying key vulnerabilities
I'm honing in on predictable randomness in getRandomTokenIdFromVault, external call risks in transferERC721 and transferFromERC721, and the centralization issue from a hardcoded dev address.
Centralization risk
I’m examining the centralization risk from a hardcoded developer address, the potential for NFT loss from locked NFTs in transferFromERC721, and the dependency on vaultFactory security.
","Analyzing the provided Solidity smart contract, `NFTXVaultUpgradeable`, reveals several potential vulnerabilities. Below is a comprehensive breakdown of these vulnerabilities, categorized by their nature and potential impact:

### 1. **Predictable Randomness in `getRandomTokenIdFromVault`**

**Issue:**
The `getRandomTokenIdFromVault` function generates randomness using block variables such as `blockhash`, `block.coinbase`, `block.difficulty`, and `block.timestamp`. These sources are inherently predictable and can be manipulated by miners or adversaries.

**Impact:**
Attackers can influence the selection of NFTs during random redemption or swapping, potentially allowing them to extract specific NFTs or disrupt the vault's operations.

**Recommendation:**
Use a more secure randomness source, such as Chainlink VRF (Verifiable Random Function), to ensure unpredictability and resist manipulation.

---

### 2. **Unsafe External Calls in `transferERC721` and `transferFromERC721`**

**Issue:**
Both `transferERC721` and `transferFromERC721` functions perform low-level `call` operations to the `assetAddr`. The construction of `data` is based on the `assetAddr`, which could point to malicious contracts.

**Impact:**
If `assetAddr` is a malicious contract, it can execute arbitrary code during these calls. Although the contract uses `ReentrancyGuard`, malicious contracts might exploit other aspects, such as draining funds or locking NFTs.

**Recommendation:**
- **Restrict `assetAddr`:** Ensure that only trusted and verified contracts can be set as `assetAddr`.
- **Use Interface Contracts:** Instead of constructing low-level calls, interact with asset contracts via well-defined interfaces to reduce the risk of executing unintended functions.
- **Implement Checks-Effects-Interactions Pattern:** Ensure state changes are made before external calls to minimize reentrancy risks further.

---

### 3. **Centralization Risk with `assignDefaultFeatures`**

**Issue:**
The `assignDefaultFeatures` function is restricted to a hardcoded developer address (`0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a`). This introduces a single point of control and potential abuse.

**Impact:**
If the developer's private key is compromised, an attacker could manipulate vault features, potentially disrupting the vault's functionality or extracting funds.

**Recommendation:**
- **Use Multi-Signature Wallets:** Instead of a single address, require multiple signatures to perform sensitive operations.
- **Decentralize Control:** Implement role-based access control with multiple trusted parties to reduce centralization risks.
- **Remove Hardcoded Addresses:** Allow the owner or a governance mechanism to set privileged addresses dynamically.

---

### 4. **Potential for Locked NFTs in `transferFromERC721`**

**Issue:**
In the `transferFromERC721` function, if the contract already owns the NFT (`ownerOf(tokenId) == address(this)`) and `holdings` contains the `tokenId`, the function returns without transferring the NFT.

**Impact:**
This scenario can lead to NFTs being permanently locked within the contract, rendering them inaccessible and potentially causing loss of assets.

**Recommendation:**
- **Handle All Cases Appropriately:** Ensure that every NFT transfer attempt results in the NFT being either correctly transferred or an informative error is thrown.
- **Implement Safety Checks:** Add checks to prevent scenarios where NFTs can be inadvertently locked, and provide mechanisms to recover or manage such NFTs.

---

### 5. **Dependency on `vaultFactory` Security**

**Issue:**
The contract heavily relies on the `vaultFactory` for critical functionalities like setting fees, distributing fees, and managing vault states. If `vaultFactory` is compromised or contains vulnerabilities, it directly affects the security of `NFTXVaultUpgradeable`.

**Impact:**
A compromised `vaultFactory` can lead to unauthorized fee manipulation, incorrect fee distributions, or even complete control over the vault's operational parameters.

**Recommendation:**
- **Audit `vaultFactory`:** Ensure that the `vaultFactory` contract is thoroughly audited and follows best security practices.
- **Implement Fail-safes:** Introduce mechanisms within the vault to detect and respond to abnormal behaviors from `vaultFactory`.
- **Minimize Trust Assumptions:** Where possible, reduce the dependency on external contracts or implement fallback mechanisms.

---

### 6. **Inconsistent Fee Handling in `_chargeAndDistributeFees`**

**Issue:**
The `_chargeAndDistributeFees` function checks if `msg.sender` is excluded from fees, but the fee is charged to a potentially different `user` address.

**Impact:**
This inconsistency can lead to scenarios where fees are not correctly applied or bypassed, resulting in financial discrepancies or exploitation opportunities.

**Recommendation:**
- **Consistent Fee Checks:** Ensure that the fee exclusion check aligns with the address being charged (`user`).
- **Review Fee Logic:** Audit the fee-related functions to verify that fees are applied consistently and securely across all operations.

---

### 7. **Lack of Storage Gap for Upgradeability**

**Issue:**
While the contract is designed to be upgradeable, it lacks a storage gap, which is crucial for maintaining storage layout compatibility across different contract versions.

**Impact:**
Future upgrades could unintentionally overwrite storage variables, leading to corrupted state, loss of funds, or malfunctioning of the contract.

**Recommendation:**
- **Implement Storage Gaps:** Introduce reserved storage slots (e.g., `uint256[50] private __gap;`) to ensure that future upgrades do not interfere with existing storage variables.
- **Follow Upgradeable Contract Best Practices:** Adhere to established guidelines for upgradeable contracts to maintain security and functionality during upgrades.

---

### 8. **Potential Denial of Service (DoS) via Large `holdings`**

**Issue:**
Functions like `allHoldings`, `receiveNFTs`, and `withdrawNFTsTo` iterate over the `holdings` set. As the number of holdings grows, these functions could consume more gas than the block gas limit, leading to DoS scenarios.

**Impact:**
Attackers or legitimate users might prevent the execution of these functions by causing them to run out of gas, disrupting the vault's operations.

**Recommendation:**
- **Limit Holdings Size:** Implement mechanisms to cap the number of holdings or paginate operations.
- **Optimize Data Structures:** Use more gas-efficient data structures or algorithms to manage large sets of holdings.
- **Introduce Off-Chain Processes:** Where feasible, handle large iterations off-chain and submit proofs or summaries on-chain.

---

### 9. **Access Control via `onlyOwnerIfPaused`**

**Issue:**
The `onlyOwnerIfPaused` modifier allows the contract owner to bypass certain paused states. If the owner's private key is compromised, an attacker could override paused mechanisms, enabling malicious operations.

**Impact:**
Unauthorized actors could perform restricted actions during emergency scenarios, potentially leading to financial loss or contract misbehavior.

**Recommendation:**
- **Enhance Access Controls:** Use multi-signature wallets or time-locked mechanisms for critical operations.
- **Implement Pausing Safeguards:** Ensure that pausing mechanisms are robust and cannot be easily bypassed, even if the owner is compromised.
- **Regularly Review Privileged Access:** Continuously audit and monitor privileged roles to ensure they adhere to the principle of least privilege.

---

### 10. **General Best Practices Not Fully Followed**

**Issue:**
Some functions lack detailed error messages or comprehensive input validations, which can obscure the root cause during failures or be exploited under specific conditions.

**Impact:**
This can lead to difficulties in diagnosing issues, increased susceptibility to exploitation, or unintended behaviors.

**Recommendation:**
- **Detailed Error Handling:** Provide specific and informative error messages to aid in debugging and security audits.
- **Comprehensive Input Validation:** Rigorously validate all inputs to functions to prevent edge-case exploits or unintended behaviors.
- **Adhere to Solidity Best Practices:** Regularly review and follow established Solidity development guidelines to enhance security and reliability.

---

### Conclusion

While the `NFTXVaultUpgradeable` contract incorporates several security measures like `ReentrancyGuard` and role-based access control, it exhibits critical vulnerabilities that could be exploited by malicious actors. Addressing the issues related to predictable randomness, unsafe external calls, centralization risks, and dependency on external contracts is paramount to ensure the vault's security and reliability. Additionally, adhering to upgradeable contract best practices and enhancing access controls will further strengthen the contract against potential threats.
","### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:
The issue highlights a potential front-running attack in the Pool Manager, where an attacker (the admin) could set the entry fee to 100% (i.e., `uint(1 ether)` or `10**18`), causing users to lose all their deposits. This situation arises because the admin can manipulate the fee before a user deposits, draining the funds.

**Match in Response List**:
**No match found.**

**Validation**:
The response list does not address this issue directly. The problem of front-running entry fees is not covered in the provided responses. A missing safeguard is preventing the admin from manipulating the fee after a deposit is made, which is a critical concern for maintaining trust and preventing abuse.

**Suggestions**:
- Introduce a mechanism that limits fee changes within a specific timeframe or requires multiple signatures (e.g., multi-sig wallet) to approve fee changes.
- Implement a cap or a progressive fee structure to prevent sudden changes that could exploit the system.
- Consider using time-based locks or commit-reveal schemes to avoid front-running attacks.

---

### **[M-09] Bypass zap timelock**

**Report Description**:
The issue outlines a vulnerability in the interaction between `NFTXStakingZap` and `NFTXInventoryStaking`, where a user can bypass a long timelock (7 days) by exploiting the shorter timelock value of 2 ms in `NFTXInventoryStaking`. This could allow a user to rapidly deposit and withdraw assets, circumventing the intended delay.

**Match in Response List**:
**No match found.**

**Validation**:
The response list does not address this issue. The problem with the inconsistent timelock values between the two contracts (`NFTXStakingZap` and `NFTXInventoryStaking`) and the ability to bypass a longer timelock is not mentioned. This could lead to unintended behaviors, such as users circumventing the intended delay and withdrawing or minting tokens prematurely.

**Suggestions**:
- Synchronize the timelock values across contracts to ensure consistent behavior.
- Implement a mechanism to ensure that if one contract’s timelock is bypassed, the corresponding contract enforces the intended lock time.
- Consider using a commit-reveal or delayed function to ensure that actions are not immediately executable after deposit.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Predictable Randomness in `getRandomTokenIdFromVault`**

**Response Description**:
The response identifies an issue with predictable randomness in the `getRandomTokenIdFromVault` function, where randomness is derived from block variables such as `blockhash`, `block.coinbase`, `block.difficulty`, and `block.timestamp`. These sources can be manipulated by miners or attackers, potentially allowing them to influence the selection of NFTs.

**Assessment**:
**May Be Incorrect**. While the issue of predictable randomness is indeed a concern, it is not directly related to the original `{issue}` report, which focuses on front-running and timelock bypass issues. This is a valid concern in smart contracts, but it does not align with the issues presented in the original report.

**Recommendations**:
- This is a legitimate concern that should be addressed, but it does not seem to directly relate to the issues in `{issue}`. If randomness is being used in other parts of the contract, consider replacing block variables with a more secure randomness source, such as Chainlink VRF.

#### **[R-02] Unsafe External Calls in `transferERC721` and `transferFromERC721`**

**Response Description**:
This response describes the risk associated with low-level external calls in the `transferERC721` and `transferFromERC721` functions, where the `assetAddr` could point to a malicious contract, potentially leading to arbitrary code execution and fund draining or NFT locking.

**Assessment**:
**May Be Incorrect**. While this is a valid issue in smart contracts, it does not directly relate to the original `{issue}` report, which does not mention ERC-721 transfers or unsafe external calls.

**Recommendations**:
- This is a valid general security concern but should be considered separately. If interacting with ERC-721 tokens, ensure that all external calls are checked for success and that reentrancy attacks are prevented.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **None**: No issues in the original `{issue}` report were fully addressed.

**Partially Correct Matches**:
- **None**

**Missed Issues from Issue Report**:
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**
- **[M-09] Bypass zap timelock**

**GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-01] Predictable Randomness in `getRandomTokenIdFromVault`**: A valid concern regarding predictable randomness, but not relevant to the original issue.
- **[R-02] Unsafe External Calls in `transferERC721` and `transferFromERC721`**: A security issue concerning external calls, but it is not related to the original `{issue}` report.

---

The provided response list does not address the core issues in the original report, specifically the front-running attack related to fee manipulation and the timelock bypass. The GPT-generated responses bring up valid concerns about randomness and external calls, but these issues are unrelated to the primary concerns in the `{issue}` report. The report would benefit from addressing these identified vulnerabilities in the response list to ensure a more comprehensive analysis.
",0,0,2,10,"```
None.
```",0.0
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4828.0,479.0,"[M-08] Low-level call return value not checked
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,0,1,"Assessing vulnerabilities
I’m analyzing a Solidity smart contract to identify common vulnerabilities like reentrancy, access control issues, and token mishandling. The contract uses OpenZeppelin's ownable and reentrancy guard contracts, and initializes key variables like WETH and sushiRouter.
Managing liquidity
I’m thinking about functions that handle liquidity with ETH and NFTs, ensuring security with OpenZeppelin's ReentrancyGuard. The owner has control over rescuing tokens.
Evaluating access controls
OK, let me see. Only the owner can set lock times or rescue tokens. Allowing maximum token approvals could risk sushiRouter abuse. Let's think it through.
Assessing risks
I'm thinking through the use of calldata and CREATE2 for pair addresses. The rescue function's owner control raises funds security concerns if compromised.
Evaluating contract security
I'm assessing the accuracy of vault balances, the implications of the _addLiquidityAndLock function, and the use of SafeERC20 to prevent transfer errors and ensure token safety.
Examining transfer methods
Wondering about error handling in token transfers and the possibility of manipulation with block.timestamp. Solidity ^0.8.0 should already manage overflow risks.
Ensuring security measures
OK, let's address gas exhaustion in looped functions and front-running risks. Immutable variables enhance security, while specific functions handle ERC721 approvals with careful attention to details.
Addressing specific vulnerabilities
I'm thinking through unchecked math in xToken minting, mismatched arrays in vault calls, and risks from compromised staking contracts after liquidity is added.
Assessing token transfer
Evaluating the risks of WETH and vault token approvals to sushiRouter, along with potential issues from direct ERC20 transfers and the vault's balance management.
Evaluating token allowances
I'm digging into the risks of approving maximum token allowances to external contracts, the absence of SafeERC20 for token transfers, and potential front-running attacks on liquidity parameters.
Managing vulnerabilities
Mapping out key vulnerabilities: ERC20 token theft via the rescue function, CryptoKitties and CryptoPunks mishandling, vault.mintTo data issues, and front-running attacks on liquidity parameters.
","Analyzing the provided Solidity smart contract, several potential vulnerabilities and areas of concern have been identified. Below is a comprehensive breakdown of these issues:

### 1. **Unrestricted Token Approvals**

**Issue:**
- The contract approves the `sushiRouter` to spend an **unlimited** amount of WETH (`IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);`) in the constructor.
- Similarly, in the `_addLiquidityAndLock` function, it approves the `sushiRouter` to spend `vault` tokens with an unlimited allowance (`IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);`).

**Risks:**
- **Unlimited Allowance:** Granting unlimited approval can be risky. If the `sushiRouter` or any of its dependencies are compromised, an attacker could drain all approved tokens from the contract.
- **Token Theft:** Malicious actors could exploit the approved permissions to transfer tokens without further consent.

**Recommendation:**
- Use **finite allowances** tailored to specific transaction amounts.
- Alternatively, utilize the [ERC20 `permit`](https://eips.ethereum.org/EIPS/eip-2612) functionality if supported, to allow approvals without granting unlimited access.

### 2. **Lack of Safe ERC20 Operations**

**Issue:**
- The contract directly uses `transfer`, `transferFrom`, and `approve` functions from the ERC20 standard without leveraging OpenZeppelin’s `SafeERC20` library.

**Risks:**
- **Non-standard ERC20 Tokens:** Some tokens do not return a boolean value on these operations. Direct calls without checking return values can lead to silent failures, causing the contract to behave unexpectedly.
- **Reentrancy via ERC20 Tokens:** Although the contract employs `ReentrancyGuard`, improper handling of token operations can still open avenues for subtle reentrancy attacks, especially with non-standard tokens.

**Recommendation:**
- Integrate OpenZeppelin’s [`SafeERC20`](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20) library to safely handle ERC20 operations. This ensures that all token interactions revert on failure and handle non-standard implementations gracefully.

### 3. **Owner-Only Rescue Function**

**Issue:**
- The `rescue` function allows the contract owner to withdraw **any** ERC20 tokens held by the contract (`IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));`).

**Risks:**
- **Centralization Risk:** The owner has unrestricted access to withdraw all tokens, which can be abused if the owner’s private key is compromised.
- **User Trust:** Users interacting with the contract might be exposed to risks if they hold tokens within it, knowing that the owner can withdraw them at any time.

**Recommendation:**
- **Minimize Privileges:** Limit the scope of rescue functions to only specific tokens if necessary.
- **Multi-Signature Ownership:** Employ multi-signature wallets for ownership to reduce the risk associated with single-key compromises.
- **Time Locks:** Implement time delays for critical functions like `rescue` to provide a window for potential intervention in case of misuse.

### 4. **Improper Handling of Specific ERC721 Tokens**

**Issue:**
- The `transferFromERC721` and `approveERC721` functions contain hardcoded addresses and specialized logic for handling CryptoKitties (`0x06012c8cf97BEaD5deAe237070F9587f8E7A266d`) and CryptoPunks (`0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB`).

**Risks:**
- **Interface Assumptions:** The contract assumes specific interfaces and behaviors for these tokens. If these assumptions are incorrect or if the token contracts are updated, it could lead to failed transfers or approvals.
- **Limited Flexibility:** Handling only specific tokens reduces the contract’s versatility and could lead to vulnerabilities when interacting with other ERC721-compliant tokens.

**Recommendation:**
- **Generalize Token Handling:** Implement a more flexible approach to handle ERC721 tokens without hardcoding specific addresses or behaviors.
- **Interface Verification:** Use standardized interfaces and ensure that interactions are compatible with the ERC721 standard to avoid unexpected behaviors.

### 5. **Potential Issues with Minting Functions**

**Issue:**
- In `provideInventory721`, an empty `amounts` array is created and passed to `vault.mintTo(tokenIds, amounts, address(xToken));`. Similarly, `provideInventory1155` handles `mint` operations with potentially mismatched arrays.

**Risks:**
- **Array Mismatch:** If `vault.mintTo` expects the `amounts` array to have specific lengths or values corresponding to `tokenIds`, passing an empty array could cause the function to fail or behave unexpectedly.
- **Unchecked Return Values:** Relying on external `mint` functions without thorough checks can introduce inconsistencies or vulnerabilities based on the vault’s implementation.

**Recommendation:**
- **Ensure Array Consistency:** Verify that the `amounts` array matches the expected structure and length required by `vault.mintTo`.
- **Validate Minting Results:** Implement additional checks to confirm that minting operations behave as intended, beyond just verifying the token balance.

### 6. **Use of `call` for ETH Transfers**

**Issue:**
- The contract uses low-level `call` for transferring ETH (`payable(to).call{value: msg.value - amountEth}("""");`) without specifying a gas limit or handling potential reentrancy beyond the `nonReentrant` modifier.

**Risks:**
- **Reentrancy Attacks:** Although the `nonReentrant` modifier provides protection, using `call` without careful handling can still introduce vulnerabilities, especially if future code changes remove protections.
- **Failed Transfers:** ETH transfers using `call` can fail if the receiving address is a contract that reverts, leading to stuck funds.

**Recommendation:**
- **Prefer `transfer` or `send`:** Where appropriate, use `transfer` or `send` for ETH transfers, which limit gas and provide built-in protections.
- **Handle Transfer Failures Gracefully:** Implement fallback mechanisms or retries in case of transfer failures to prevent funds from being locked indefinitely.

### 7. **Assumption of External Contract Security**

**Issue:**
- The contract heavily relies on external contracts like `sushiRouter`, `nftxFactory`, `lpStaking`, and others for critical operations.

**Risks:**
- **Dependency Risks:** If any of these external contracts contain vulnerabilities or are malicious, it can directly impact the security and functionality of `NFTXStakingZap`.
- **Upgrade Risks:** If external contracts are upgradeable and receive malicious updates, the integrity of `NFTXStakingZap` could be compromised.

**Recommendation:**
- **Audit External Dependencies:** Ensure that all external contracts are thoroughly audited and trusted.
- **Minimize Dependencies:** Reduce reliance on external contracts where possible or implement additional checks to validate their behavior.
- **Use Interface Contracts:** Rely on well-defined interfaces to interact with external contracts, reducing the risk associated with unexpected behaviors.

### 8. **Missing Fallback Functionality**

**Issue:**
- The contract includes a `receive()` function but lacks a `fallback()` function.

**Risks:**
- **Unintentional Rejections:** Sending data along with ETH to the contract will result in a failed transaction since there's no `fallback()` to handle such cases.
- **Limited Flexibility:** This restricts the contract's ability to handle arbitrary calls, which might be necessary for certain interactions.

**Recommendation:**
- **Implement a `fallback()` Function:** If the contract is expected to handle calls with data, implement a `fallback()` function to manage such scenarios gracefully.

### 9. **Potential Front-Running in Liquidity Addition**

**Issue:**
- Functions like `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` use parameters like `minWethIn` and `minEthIn` to determine acceptable slippage.

**Risks:**
- **Front-Running:** Attackers could manipulate transaction ordering to exploit favorable conditions, leading to suboptimal liquidity additions or financial losses.
- **Slippage Exploits:** If slippage parameters are not set appropriately, users might receive less favorable rates than intended.

**Recommendation:**
- **Adjust Slippage Parameters:** Encourage users to set appropriate slippage limits based on current market conditions.
- **Implement Transaction Ordering Protections:** Where feasible, incorporate mechanisms to mitigate front-running, such as committing to parameters before revealing them.

### 10. **Event Emissions and Transparency**

**Issue:**
- While some functions emit events (e.g., `UserStaked`), others perform critical operations without emitting corresponding events.

**Risks:**
- **Lack of Transparency:** Missing events can hinder the ability to track important state changes, making auditing and monitoring more challenging.
- **Reduced Trust:** Users and auditors rely on events to verify contract behavior; missing events can reduce trust in the contract’s operations.

**Recommendation:**
- **Comprehensive Event Logging:** Ensure that all critical state changes and operations emit appropriate events to facilitate transparency and auditing.

---

### **Summary of Recommendations**

1. **Use SafeERC20:** Replace direct ERC20 interactions with OpenZeppelin’s `SafeERC20` to handle non-standard tokens safely.
2. **Limit Token Approvals:** Avoid granting unlimited allowances; instead, use finite approvals tailored to specific transaction needs.
3. **Secure Rescue Functions:** Restrict rescue functionalities to essential tokens and consider implementing multi-signature controls.
4. **Generalize Token Handling:** Remove hardcoded token addresses and implement flexible ERC721 handling mechanisms.
5. **Validate External Interactions:** Ensure that all external contract interactions are secure, audited, and behave as expected.
6. **Enhance ETH Transfer Safety:** Use safer methods for ETH transfers and handle potential failures gracefully.
7. **Emit Comprehensive Events:** Ensure all critical operations emit events to maintain transparency and facilitate auditing.
8. **Implement Fallback Functions:** Add fallback mechanisms to handle unexpected calls gracefully.
9. **Mitigate Front-Running Risks:** Incorporate strategies to reduce the impact of transaction ordering manipulations.

By addressing these vulnerabilities and following the recommended best practices, the security and robustness of the `NFTXStakingZap` contract can be significantly enhanced.
","### **Analysis of Alignment between Issue Report and Response List**

---

#### **[M-08] Low-level call return value not checked**

**Report Description**:
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` (`payable(to).call{value: msg.value-amountEth}`) but does not check the return value if the call succeeded.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The issue from the report regarding the low-level `.call` operation and lack of return value checking is not explicitly addressed in any of the responses. The responses discuss various other concerns like reentrancy, token approvals, and ERC20 operations, but none address this particular issue of unchecked return values from a low-level call, which is crucial for ensuring the success of external function calls. This oversight can lead to silent failures, such as when an external contract fails without notification, leaving funds stranded or operations incomplete.

**Suggestions**:
- The response should discuss the risks of using low-level calls without proper error handling and emphasize the importance of checking the return value (or using `require` for revert behavior). Alternatively, using higher-level functions like `transfer` or `send` where appropriate would be safer.
- Recommend using Solidity’s built-in `require(success)` after each external call to validate the return value.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

---

#### **[R-06] Use of `call` for ETH Transfers**

**Response Description**:
The contract uses low-level `call` for transferring ETH (`payable(to).call{value: msg.value - amountEth}("""")`) without specifying a gas limit or handling potential reentrancy beyond the `nonReentrant` modifier.

**Assessment**:
**Valid Concern**. Although this issue is not directly related to the `NFTXStakingZap.addLiquidity721ETHTo` function mentioned in the original issue report, the response brings up an important point regarding the use of `call` for transferring ETH. The `call` method is generally considered riskier than `transfer` or `send` because it does not limit gas usage, and it bypasses some protections against reentrancy. 

The response suggests that while the contract uses the `nonReentrant` modifier, `call` might still lead to vulnerabilities if this modifier is removed or other parts of the code are modified in the future.

**Recommendations**:
- Consider switching to `transfer` or `send` when transferring ETH to mitigate reentrancy and gas-related issues. If `call` is required, always check for success with `require(success)`.
- The response is relevant and valid, though it doesn't match the specific issue regarding the low-level `.call` in `NFTXStakingZap.addLiquidity721ETHTo`, but it touches on the same general concern about safe ETH transfers.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **None**

**Partially Correct Matches**:
- **[R-06] Use of `call` for ETH Transfers**: Although it addresses a similar concern regarding low-level `call`, it doesn't directly address the specific issue from the report.

**Missed Issues from Issue Report**:
- **[M-08] Low-level call return value not checked**: The issue regarding the lack of return value checking for low-level `.call` is completely unaddressed in the response list.

**GPT-Generated Potential Issues (May Be Incorrect)**:
- **[R-06] Use of `call` for ETH Transfers**: A valid concern about the risks of using `call` for ETH transfers, although it does not match the original report's issue directly.

---

### **Conclusion**:
The primary concern in the original issue report — failure to check the return value of a low-level `.call` — is not adequately addressed in the provided responses. This represents a significant gap, as the lack of return value validation can lead to undetected transaction failures, which is a serious issue in smart contract security.

The GPT-generated concern about the use of `call` for ETH transfers (R-06) is valid and closely related but does not directly address the issue in the original report. It is, however, an important point for improving contract safety when interacting with external addresses.

### **Recommendations**:
- **Response Improvement**: The response list should include specific guidance on handling the return values of low-level calls (e.g., using `require(success)` to verify successful execution).
- **Additional Validation**: Ensure that all return values from external calls, especially low-level calls, are properly checked to prevent unexpected contract behavior and loss of funds.
",0,0,1,10,"```
None.
```",0.0
,,,,,,,,3,12,,,,1,2,12,45,,
