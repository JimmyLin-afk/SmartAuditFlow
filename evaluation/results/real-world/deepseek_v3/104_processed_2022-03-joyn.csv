nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTXStakingZap.sol,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,428.0,"[H-01] ERC20 transferFrom return values not checked
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,1,0,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Risk in ETH Handling**
   - **Location**: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`
   - **Issue**: After withdrawing excess ETH using `WETH.withdraw`, the contract uses `payable(to).call{value: msg.value-amountEth}` to send ETH back to the user. This external call can potentially trigger a reentrancy attack, even though the `nonReentrant` modifier is used. A malicious contract in the `to` address could re-enter the function before the state is updated.
   - **Impact**: Funds could be drained or the contract state could be manipulated.

---

### 2. **Lack of Input Validation**
   - **Location**: `provideInventory721`, `provideInventory1155`, `addLiquidity721`, `addLiquidity1155`
   - **Issue**: The functions do not validate the length of `tokenIds` and `amounts` arrays. If these arrays are empty or mismatched, it could lead to unexpected behavior or runtime errors.
   - **Impact**: Potential loss of funds or contract malfunction.

---

### 3. **Hardcoded Addresses**
   - **Location**: `transferFromERC721`, `approveERC721`
   - **Issue**: The contract hardcodes addresses for CryptoKitties (`0x06012c8cf97BEaD5deAe237070F9587f8E7A266d`) and CryptoPunks (`0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB`). This reduces flexibility and could cause issues if these contracts are upgraded or deprecated.
   - **Impact**: The contract may not work with newer versions of these NFTs or other NFT standards.

---

### 4. **Unbounded Loops**
   - **Location**: `provideInventory721`, `provideInventory1155`, `_addLiquidity721WETH`, `_addLiquidity1155WETH`
   - **Issue**: These functions loop over `tokenIds` and `amounts` arrays without checking their length. If the arrays are too large, the transaction could run out of gas and fail.
   - **Impact**: Denial of service (DoS) or failed transactions.

---

### 5. **Insufficient Approval Checks**
   - **Location**: `_addLiquidityAndLock`
   - **Issue**: The contract approves the `sushiRouter` to spend `minTokenIn` tokens, but it does not verify if the approval was successful or if the router has sufficient allowance.
   - **Impact**: Potential loss of funds if the approval fails or is insufficient.

---

### 6. **Improper Handling of ERC721 Approvals**
   - **Location**: `approveERC721`
   - **Issue**: For non-CryptoKitties and non-CryptoPunks NFTs, the function simply returns without performing any approval. This could lead to issues when interacting with NFTs that require explicit approvals.
   - **Impact**: Transactions could fail if the NFT contract requires approvals.

---

### 7. **Lack of Error Handling in External Calls**
   - **Location**: `transferFromERC721`, `approveERC721`
   - **Issue**: The contract uses low-level `call` to interact with external contracts but does not handle errors properly. If the external call fails, the error message is not descriptive, making debugging difficult.
   - **Impact**: Poor user experience and potential loss of funds.

---

### 8. **Unsafe Use of `call` for ETH Transfers**
   - **Location**: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`
   - **Issue**: The contract uses `payable(to).call{value: msg.value-amountEth}` to send ETH. This is unsafe because it does not check the return value of the `call` and could fail silently.
   - **Impact**: ETH could be lost if the transfer fails.

---

### 9. **Potential Front-Running in Liquidity Provision**
   - **Location**: `_addLiquidityAndLock`
   - **Issue**: The contract does not use mechanisms like slippage protection or deadlines to prevent front-running when adding liquidity to the SushiSwap pool.
   - **Impact**: Users could receive less liquidity than expected due to price manipulation.

---

### 10. **Uninitialized Upgradable Contracts**
   - **Issue**: The contract inherits from `ERC721HolderUpgradeable` and `ERC1155HolderUpgradeable`, which are upgradable contracts, but it does not call their `initialize` functions. This could lead to unexpected behavior.
   - **Impact**: Contract functionality may not work as intended.

---

### 11. **Lack of Event Emission for Critical Actions**
   - **Issue**: Functions like `setLPLockTime` and `setInventoryLockTime` do not emit events when the lock times are updated. This makes it difficult to track changes in the contract state.
   - **Impact**: Reduced transparency and auditability.

---

### 12. **Unrestricted `rescue` Function**
   - **Location**: `rescue`
   - **Issue**: The `rescue` function allows the owner to withdraw any ERC20 token from the contract. This could be abused to drain funds if the owner's private key is compromised.
   - **Impact**: Loss of user funds.

---

### 13. **No Slippage Protection**
   - **Location**: `_addLiquidityAndLock`
   - **Issue**: The contract does not enforce slippage protection when adding liquidity to the SushiSwap pool. This could result in users receiving less liquidity than expected due to price fluctuations.
   - **Impact**: Loss of funds for users.

---

### 14. **Potential Integer Overflow/Underflow**
   - **Issue**: The contract does not use SafeMath or similar libraries to prevent integer overflow/underflow, especially in calculations involving `BASE` (10^18).
   - **Impact**: Incorrect calculations and potential loss of funds.

---

### 15. **Missing `require` Checks**
   - **Location**: `provideInventory721`, `provideInventory1155`
   - **Issue**: The functions do not check if the `vault` address is valid or if the `vaultId` exists before interacting with it.
   - **Impact**: Transactions could fail or funds could be lost if the vault does not exist.

---

These vulnerabilities and issues should be addressed to ensure the security and reliability of the smart contract.","### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:
The `transferFrom()` function in the contract returns a boolean value indicating success. This parameter needs to be checked to ensure the transfer has been successful. While the `transfer()` function calls were checked, the `transferFrom()` function calls were not. This oversight could lead to silent failures in token transfers, especially when dealing with untrusted tokens supplied by users. This could result in discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked `transferFrom` return values. This is a critical oversight, as failing to validate the return value of `transferFrom` can lead to silent failures in token transfers, which is a significant security risk. Solidity best practices emphasize the importance of checking return values from external calls to ensure the intended behavior of the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] ERC20 transferFrom return values not checked**

---

### **Analysis of Gaps**

The response list provided does not address the issue of unchecked `transferFrom` return values, which is a significant security concern. This gap indicates a need for additional scrutiny and remediation in the contract to ensure that all external calls, including `transferFrom`, are properly validated to prevent silent failures and potential vulnerabilities.",0,0,1,15,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and the average of these values is also zero."
Splitter.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162.0,293.0,"[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract
In general, the Splitter contract's `incrementWindow` function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the `incrementWindow` function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or `claimForAllWindows ` functions to steal the tokens in the contract.
  [H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker
When the value of currentWindow is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.
currentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.
Furthermore, an attacker can continually increment currentWindow by calling `incrementWindow()`. An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.
  [M-02] Fixed Amount of Gas Sent in Call May Be Insufficient
The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the receive() function. As a result the user would be unable to receive funds from this function.",3.0,"pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract Splitter is SplitStorage {
    
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    
    event TransferETH(
        
        address account,
        
        uint256 amount,
        
        bool success
    );

    
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    

    
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        
        return (amount * percent) / 100;
    }

    
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        
        
        
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    
    
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        
        return computedHash == root;
    }
}",1136.0,2,1,"The provided smart contract has several potential vulnerabilities. Below is a list of the identified issues:

---

### 1. **Reentrancy Risk**
   - The `transferSplitAsset` function uses `IERC20.transfer` to send tokens to the recipient. While `transfer` is generally safe from reentrancy, the `attemptETHTransfer` function (not used in the contract but present) uses a low-level `call` with a fixed gas limit. If this function were used, it could be vulnerable to reentrancy attacks if the recipient is a malicious contract.
   - **Location**: `transferSplitAsset` and `attemptETHTransfer`.

---

### 2. **Integer Overflow/Underflow**
   - The contract uses Solidity 0.8.4, which includes built-in overflow/underflow checks. However, the `scaleAmountByPercentage` and `amountFromPercent` functions perform arithmetic operations. If these functions were used in a version of Solidity prior to 0.8.0, they could be vulnerable to integer overflow/underflow.
   - **Location**: `scaleAmountByPercentage` and `amountFromPercent`.

---

### 3. **Merkle Proof Verification Issues**
   - The `verifyProof` function does not enforce a minimum proof length, which could lead to unexpected behavior if an empty proof is provided. Additionally, the function assumes the proof is correctly ordered and does not validate the structure of the Merkle tree.
   - **Location**: `verifyProof`.

---

### 4. **Insufficient Gas for ETH Transfer**
   - The `attemptETHTransfer` function uses a fixed gas limit of 30,000 for the `call` operation. This may not be sufficient for complex recipient contracts, leading to failed transfers or unexpected behavior.
   - **Location**: `attemptETHTransfer`.

---

### 5. **Lack of Access Control**
   - The `incrementWindow` function does not have proper access control. It only checks that the caller is a supported `IRoyaltyVault` contract and that the splitter address matches the contract address. However, it does not restrict who can call this function, potentially allowing unauthorized parties to manipulate the window.
   - **Location**: `incrementWindow`.

---

### 6. **Potential Front-Running**
   - The `claim` and `claimForAllWindows` functions do not include mechanisms to prevent front-running. An attacker could monitor the mempool and submit a transaction with a higher gas fee to claim funds before the legitimate user.
   - **Location**: `claim` and `claimForAllWindows`.

---

### 7. **Uninitialized Storage Variables**
   - The contract inherits from `SplitStorage`, but the provided code does not show how storage variables like `merkleRoot`, `splitAsset`, and `balanceForWindow` are initialized. If these variables are not properly set, the contract may behave unexpectedly or fail.
   - **Location**: Inherited storage variables.

---

### 8. **Incorrect Event Emission**
   - The `TransferETH` event is emitted in the `transferSplitAsset` function, but the function transfers ERC20 tokens, not ETH. This could lead to confusion or incorrect off-chain event handling.
   - **Location**: `transferSplitAsset`.

---

### 9. **Lack of Input Validation**
   - The `claim` and `claimForAllWindows` functions do not validate the `scaledPercentageAllocation` or `percentageAllocation` inputs. If these values are too large, they could result in incorrect calculations or unintended behavior.
   - **Location**: `claim` and `claimForAllWindows`.

---

### 10. **Potential Division Precision Loss**
   - The `scaleAmountByPercentage` and `amountFromPercent` functions perform division, which could lead to precision loss if the numerator is small relative to the denominator.
   - **Location**: `scaleAmountByPercentage` and `amountFromPercent`.

---

### 11. **Unused Constant**
   - The `PERCENTAGE_SCALE` constant is defined but never used in the contract, which could indicate incomplete or incorrect implementation.
   - **Location**: `PERCENTAGE_SCALE`.

---

### 12. **Incorrect Error Message**
   - The `transferSplitAsset` function emits an error message stating ""Failed to transfer ETH"" when it is actually transferring ERC20 tokens. This could cause confusion during debugging or error handling.
   - **Location**: `transferSplitAsset`.

---

These vulnerabilities should be carefully addressed to ensure the security and correctness of the smart contract.","### **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Report Description**:
The `incrementWindow` function in the Splitter contract lacks proper access control, allowing anyone to call it. An attacker can impersonate a `IRoyaltyVault` contract and call `incrementWindow`, causing the `balanceForWindow` to exceed the actual contract balance. This discrepancy allows verified users to claim tokens they are not entitled to, leading to potential theft of funds.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control""**.

**Validation**:
**Correct**. The response accurately identifies the lack of access control in the `incrementWindow` function. It correctly explains the risk of unauthorized manipulation of the window, which aligns with the issue described in the report.

---

### **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**

**Report Description**:
The `claimForAllWindows` function can be rendered unusable if the `currentWindow` value is raised sufficiently high, exceeding the block gas limit. An attacker can repeatedly call `incrementWindow` to increase `currentWindow`, potentially causing the function to fail due to excessive gas consumption. This could prevent legitimate users from claiming their funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of `claimForAllWindows` becoming unusable due to an attacker incrementing `currentWindow`. This is a critical oversight, as the issue poses a significant denial-of-service risk.

---

### **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Report Description**:
The `attemptETHTransfer` function uses a fixed gas limit of 30,000 for the `call` operation. If the recipient is a contract, this amount of gas may be insufficient to process the `receive()` function, resulting in failed transfers and users being unable to receive funds.

**Match in Response List**:
Matches with the issue titled **""Insufficient Gas for ETH Transfer""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the fixed gas limit in the `attemptETHTransfer` function. It correctly explains the risk of insufficient gas leading to failed transfers, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**
- **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**

---

The response list effectively addresses some of the issues in the report, particularly those related to access control and gas limits. However, it misses a critical denial-of-service vulnerability related to the `claimForAllWindows` function, which should be addressed to ensure comprehensive security coverage.",2,0,1,12,"```
1. Lack of Access Control
2. Insufficient Gas for ETH Transfer
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Lack of Access Control"" appears at rank 5.
   - ""Insufficient Gas for ETH Transfer"" appears at rank 4.

2. **Calculate the precision at each rank where a true positive appears**:
   - For ""Insufficient Gas for ETH Transfer"" at rank 4:
     \[
     P@4 = \frac{\text{Number of true positives up to rank 4}}{\text{Rank}} = \frac{1}{4} = 0.25
     \]
   - For ""Lack of Access Control"" at rank 5:
     \[
     P@5 = \frac{\text{Number of true positives up to rank 5}}{\text{Rank}} = \frac{2}{5} = 0.4
     \]

3. **Average the precision values**:
   \[
   AP = \frac{P@4 + P@5}{2} = \frac{0.25 + 0.4}{2} = 0.325
   \]

**Output**:
```
0.325
```"
CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331.0,310.0,"[H-04] CoreCollection can be reinitialized
Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.
Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.
However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.
  [H-07] Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it
The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the payableToken is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply check`. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.
  [H-08] Funds cannot be withdrawn in CoreCollection.withdraw
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the withdraw function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.",3.0,"pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    

    
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    

    
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    

    
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",1528.0,3,0,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Vulnerability**
   - The `withdraw` function transfers tokens directly using `transferFrom` without using the **Checks-Effects-Interactions (CEI)** pattern. This could allow a reentrancy attack if the `payableToken` is a malicious contract that calls back into the contract before the state is updated.

---

### 2. **Uninitialized State Variables**
   - The `initialize` function sets `initialized` to `true`, but there is no check to ensure that all critical state variables (e.g., `_name`, `_symbol`, `_baseUri`, `maxSupply`, etc.) are properly initialized before marking the contract as initialized. This could lead to an inconsistent state.

---

### 3. **Unrestricted `setStartingIndex` Function**
   - The `setStartingIndex` function is public and can be called by anyone. This could allow an attacker to manipulate the starting index, potentially affecting the fairness of token distribution.

---

### 4. **Lack of Input Validation**
   - The `initialize` function does not validate the `_collectionName`, `_collectionSymbol`, or `_collectionURI` inputs. Empty or invalid strings could cause issues in the contract's functionality.
   - The `setCollectionMeta` function also lacks input validation for `_collectionName` and `_collectionSymbol`.

---

### 5. **Potential Integer Overflow**
   - The `mintToken` function calculates `totalSupply() + amount` without checking for potential overflow. While Solidity 0.8.x has built-in overflow checks, this could still cause unexpected behavior if `totalSupply()` is close to `maxSupply`.

---

### 6. **Unrestricted `setHashedProof` Function**
   - The `setHashedProof` function allows the owner to set `HASHED_PROOF` only once, but there is no validation on the input `_proof`. This could lead to setting an invalid or malicious proof.

---

### 7. **Inconsistent Access Control**
   - The `setRoyaltyVault` function allows both the `splitFactory` and the `owner` to initialize the royalty vault. However, the `splitFactory` is not validated to ensure it is a trusted address, which could lead to unauthorized access.

---

### 8. **Unused or Unimplemented Modifiers**
   - The `onlyVaultUninitialized` and `onlyNotClaimableSet` modifiers are referenced in the code but not defined in the provided contract. This could lead to compilation errors or unexpected behavior.

---

### 9. **Potential Front-Running in `setStartingIndex`**
   - The `setStartingIndex` function uses `block.number` to generate a random starting index. This could be manipulated by miners or attackers through front-running.

---

### 10. **Unhandled ERC20 Transfer Failures**
   - The `_handlePayment` function (not shown in the code) likely handles ERC20 token transfers. If it does not handle transfer failures (e.g., insufficient balance or allowance), the contract could fail silently or behave unexpectedly.

---

### 11. **Unclear Ownership Transfer**
   - The contract inherits `Ownable`, but there is no explicit mechanism to transfer ownership. This could lead to issues if the owner needs to be changed.

---

### 12. **Inconsistent Event Emission**
   - The `batchMint` function emits the `NewClaim` event only if `_isClaim` is true. However, there is no event emitted for non-claim mints, which could make it difficult to track all minting activities.

---

### 13. **Potential Gas Limit Issues**
   - The `batchMint` function loops over `_amount` to mint tokens. If `_amount` is large, this could exceed the gas limit and cause the transaction to fail.

---

### 14. **Uninitialized `payableToken`**
   - The `payableToken` is initialized in the `initialize` function, but there is no validation to ensure it is a valid ERC20 token address. This could lead to runtime errors.

---

### 15. **Unrestricted `setRoyaltyVault`**
   - The `setRoyaltyVault` function allows the `splitFactory` or owner to set the `royaltyVault` address. However, there is no validation to ensure the address is a valid `IRoyaltyVault` contract, which could lead to unexpected behavior.

---

### 16. **Unclear State Transition**
   - The `initialized` state variable is set to `true` in the `initialize` function, but there is no mechanism to reset it or ensure the contract can only be initialized once.

---

### 17. **Lack of Token URI Validation**
   - The `_baseUri` is set in the `initialize` function, but there is no validation to ensure it is a valid URI. This could lead to issues when fetching token metadata.

---

### 18. **Unrestricted `batchMint` Function**
   - The `batchMint` function is private and called only by `mintToken`, but it does not validate the `_to` address. This could lead to tokens being minted to invalid or unintended addresses.

---

### 19. **Unclear Dependency on External Contracts**
   - The contract depends on external contracts like `IRoyaltyVault` and `IERC20`, but there is no validation or fallback mechanism if these contracts are malicious or behave unexpectedly.

---

### 20. **Lack of Error Messages**
   - Some `require` statements (e.g., in `setStartingIndex`) do not include error messages, making it difficult to debug or understand why a transaction failed.

---

These vulnerabilities and issues should be carefully addressed to ensure the contract is secure and functions as intended.","### **[H-04] CoreCollection can be reinitialized**

**Report Description**:  
The `initialize` function in `CoreCollection` sets the `initialized` flag but does not check if the contract has already been initialized. This allows the function to be rerun multiple times, potentially resetting critical variables like `payableToken`. While the function is `onlyOwner`, the risk of an owner-initiated reset (either by mistake or malicious intent) remains, leading to system-breaking consequences.

**Match in Response List**:  
Matches with the issue titled **""Uninitialized State Variables""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with the `initialize` function not ensuring all critical state variables are properly initialized. However, it misses the specific risk of reinitialization and the potential reset of critical variables like `payableToken`. The response focuses more on the lack of initialization checks rather than the reinitialization vulnerability.

---

### **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

**Report Description**:  
The `mintToken()` function in `CoreCollection` allows users to mint NFTs by either providing a merkle proof or paying a fee in `payableToken`. If `payableToken` has a callback attached, a reentrancy attack can occur before `totalSupply()` is updated. This allows a user to bypass the `totalSupply() + amount <= maxSupply` check and mint duplicate NFTs, especially if they mint the last token and reenter the function.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in the `withdraw` function, which is similar to the issue in `mintToken()`. Both scenarios involve external calls that could lead to reentrancy attacks. The response aligns with Solidity best practices for preventing reentrancy by using the Checks-Effects-Interactions (CEI) pattern.

---

### **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Report Description**:  
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens. However, `transferFrom` requires that `allowance[from][msg.sender] >= amount`. Since `allowance[CoreCollection][CoreCollection] == 0`, the call will revert, locking the funds in the contract permanently.

**Match in Response List**:  
Matches with the issue titled **""Unhandled ERC20 Transfer Failures""**.

**Validation**:  
**Correct**. The response correctly identifies the issue with unhandled ERC20 transfer failures, which aligns with the problem in `CoreCollection.withdraw`. The response highlights the risk of not handling transfer failures, which is the core issue in this case.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**
- **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Partially Correct Matches**:

- **[H-04] CoreCollection can be reinitialized**

**Missed Issues from Issue Report**:

- *None*

--- 

The response list covers most of the issues in the report, but some responses could be more specific to the exact vulnerabilities described. For example, the reinitialization issue in `CoreCollection` could have been more explicitly addressed. Overall, the response list is comprehensive and aligns well with the issues reported.",2,1,0,20,"```
1. Reentrancy Vulnerability
2. Unhandled ERC20 Transfer Failures
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reentrancy Vulnerability"" appears at rank 1.
   - ""Unhandled ERC20 Transfer Failures"" appears at rank 10.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 10: \( P@10 = \frac{2}{10} = 0.2 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.2}{2} = 0.6 \)

**Output**:
```
0.6
```"
RoyaltyVault.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751.0,104.0,"[H-01] ERC20 transferFrom return values not checked
The transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
  [H-05] Centralisation RIsk: Owner Of RoyaltyVault Can Take All Funds
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.
As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.
  [H-09] ERC20 tokens with no return value will fail to transfer
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.",3.0,"pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",627.0,3,0,"Here are the vulnerabilities identified in the provided smart contract:

---

### 1. **Lack of Input Validation**
   - **Description**: The `setPlatformFee` and `setPlatformFeeRecipient` functions do not validate the inputs. For example:
     - `_platformFee` could be set to a value greater than 10000 (100%), which would result in an incorrect calculation of the platform share in `sendToSplitter`.
     - `_platformFeeRecipient` could be set to `address(0)`, which would cause transfers to fail in `sendToSplitter`.
   - **Impact**: This could lead to unintended behavior, such as incorrect fee calculations or failed transfers.

---

### 2. **Reentrancy Risk**
   - **Description**: The `sendToSplitter` function makes external calls to `IERC20.transfer` and `ISplitter.incrementWindow`. If the `royaltyAsset` or `splitterProxy` contracts are malicious or compromised, they could re-enter the `sendToSplitter` function before its state is fully updated.
   - **Impact**: This could lead to reentrancy attacks, allowing an attacker to drain funds or manipulate the contract's state.

---

### 3. **Integer Overflow/Underflow**
   - **Description**: The calculation `uint256 splitterShare = balanceOfVault - platformShare` could underflow if `platformShare` is greater than `balanceOfVault`. This is unlikely due to the division by 10000, but it is still a potential risk if `platformFee` is not properly validated.
   - **Impact**: An underflow could result in incorrect calculations and unexpected behavior.

---

### 4. **Lack of Event Emission for Critical State Changes**
   - **Description**: The `setPlatformFee` and `setPlatformFeeRecipient` functions emit events, but other critical state changes (e.g., setting `splitterProxy`) are not logged. This makes it difficult to track changes to the contract's state.
   - **Impact**: Reduced transparency and auditability of the contract.

---

### 5. **Hardcoded Denominator for Fee Calculation**
   - **Description**: The platform fee calculation uses a hardcoded denominator of 10000 (`(balanceOfVault * platformFee) / 10000`). This assumes that `platformFee` is in basis points (e.g., 100 = 1%). However, this is not explicitly documented, and the contract does not enforce this assumption.
   - **Impact**: Misunderstanding or misuse of the `platformFee` value could lead to incorrect fee calculations.

---

### 6. **Dependence on External Contracts**
   - **Description**: The contract relies on external contracts (`IERC20`, `ISplitter`) for critical functionality. If these contracts are not implemented as expected (e.g., they revert or return incorrect values), the `sendToSplitter` function will fail.
   - **Impact**: The contract's functionality is tightly coupled with external contracts, increasing the risk of failure.

---

### 7. **No Zero-Check for Transfers**
   - **Description**: The `sendToSplitter` function does not check if `splitterShare` or `platformShare` is zero before transferring funds. This could result in unnecessary gas consumption or failed transfers.
   - **Impact**: Inefficient use of gas and potential errors in edge cases.

---

### 8. **No Fail-Safe Mechanism**
   - **Description**: The contract does not have a fail-safe mechanism (e.g., a pause function or emergency withdrawal) to handle unexpected situations, such as a compromised `splitterProxy` or `platformFeeRecipient`.
   - **Impact**: In case of an emergency, the owner may not be able to stop or recover funds.

---

### 9. **Lack of Access Control for `sendToSplitter`**
   - **Description**: The `sendToSplitter` function can be called by any external account. While this may be intentional, it could lead to abuse if the function is called repeatedly or maliciously.
   - **Impact**: Potential for spamming or manipulation of the contract's state.

---

### 10. **Incomplete ERC165 Implementation**
   - **Description**: The `supportsInterface` function only checks for `IRoyaltyVault` but does not include other interfaces (e.g., `IERC20`, `ISplitter`) that the contract interacts with. This could lead to compatibility issues with other contracts.
   - **Impact**: Reduced interoperability with other contracts.

---

### 11. **Uninitialized Storage Variables**
   - **Description**: The contract inherits from `VaultStorage`, but it is unclear whether all storage variables (e.g., `royaltyAsset`, `splitterProxy`, `platformFee`, `platformFeeRecipient`) are properly initialized before use. Uninitialized variables could lead to unexpected behavior.
   - **Impact**: Potential for runtime errors or incorrect state.

---

### 12. **No Handling of ERC20 Transfer Failures**
   - **Description**: The `sendToSplitter` function assumes that `IERC20.transfer` will always return `true`. However, some ERC20 tokens may return `false` instead of reverting on failure. This is not handled in the contract.
   - **Impact**: Failed transfers may go unnoticed, leading to incorrect state or loss of funds.

---

### 13. **No Fallback or Receive Function**
   - **Description**: The contract does not implement a `receive` or `fallback` function, which means it cannot receive Ether or handle unexpected calls.
   - **Impact**: Inability to handle Ether transfers or unexpected interactions.

---

### 14. **Lack of Documentation**
   - **Description**: The contract lacks detailed documentation, such as NatSpec comments, explaining the purpose of functions, parameters, and expected behavior.
   - **Impact**: Reduced readability and maintainability of the code.

---

### 15. **Gas Optimization Issues**
   - **Description**: The contract does not optimize for gas usage. For example:
     - The `getVaultBalance` function reads the `royaltyAsset` storage variable twice (once in `getVaultBalance` and once in `sendToSplitter`).
     - The `sendToSplitter` function performs multiple external calls and storage reads, which could be optimized.
   - **Impact**: Higher gas costs for users interacting with the contract.

---

These vulnerabilities should be addressed to improve the security, efficiency, and reliability of the smart contract.","### **Output**

---

#### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:  
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to ensure the transfer has been successful. While `transfer()` function calls were checked, `transferFrom()` calls were not, which could lead to silent failures in token transfers, especially when dealing with non-compliant or malicious tokens.

**Match in Response List**:  
Matches with the issue titled **""No Handling of ERC20 Transfer Failures""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked ERC20 transfer return values, specifically mentioning that `IERC20.transfer` assumes a `true` return value. While the response focuses on `transfer`, the underlying issue of unchecked return values applies equally to `transferFrom`, aligning with the reported vulnerability.

---

#### **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Report Description**:  
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g., 100% = 10000), directing the entire contract balance and future balances to the `platformFeeRecipient` (controlled by the owner) instead of the splitter contract. This allows the owner to steal the entire contract balance and any future balances, bypassing the splitter.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of input validation for `_platformFee`, which is a critical part of the issue. However, it does not explicitly address the centralization risk or the owner's ability to drain funds, which is the core concern of the reported vulnerability. The response focuses on incorrect fee calculations rather than the malicious potential of the owner.

---

#### **[H-09] ERC20 tokens with no return value will fail to transfer**

**Report Description**:  
Although the ERC20 standard suggests that a transfer should return `true` on success, many tokens (including high-profile ones like USDT) are non-compliant and do not return a value. In such cases, the `.transfer()` call will revert because Solidity expects a return value of a specific size. This could cause transfers to fail even when successful.

**Match in Response List**:  
Matches with the issue titled **""No Handling of ERC20 Transfer Failures""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with ERC20 transfer failures, specifically mentioning that some tokens may return `false` instead of reverting. While the response does not explicitly mention tokens with no return value, the underlying issue of handling ERC20 transfer failures is covered, aligning with the reported vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] ERC20 transferFrom return values not checked**  
- **[H-09] ERC20 tokens with no return value will fail to transfer**

**Partially Correct Matches**:

- **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Missed Issues from Issue Report**:

- *None*

---

### **Conclusion**

The `response_list` effectively covers most of the issues in the `issue` report, with two correct matches and one partially correct match. The partially correct match for **[H-05]** could be improved by explicitly addressing the centralization risk and the owner's ability to drain funds. Overall, the responses demonstrate a strong understanding of Solidity vulnerabilities and best practices.",2,1,0,15,"```
1. No Handling of ERC20 Transfer Failures
2. No Handling of ERC20 Transfer Failures
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - The true positives are ""No Handling of ERC20 Transfer Failures"".
   - This vulnerability appears at rank 12 in the ranked list of predictions.

2. **Calculate the precision at the rank where the true positive appears**:
   - Precision at rank 12 (\( P@12 \)) is calculated as the number of true positives up to rank 12 divided by 12.
   - Since there is only one true positive up to rank 12, \( P@12 = \frac{1}{12} \approx 0.0833 \).

3. **Average the precision values**:
   - Since there is only one true positive, the AP is simply the precision at rank 12.

**Average Precision (AP)**: 0.0833"
SplitFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197.0,175.0,"[M-01] DoS: Attacker May Front-Run `createSplit()` With A merkleRoot Causing Future Transactions With The Same merkleRoot to Revert
A merkleRoot may only be used once in `createSplit()` since it is used as salt to the deployment of a SplitProxy.
The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same merkleRoot but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this merkleRoot.",1.0,"pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  

  address public immutable splitter;
  address public immutable royaltyVault;

  
  

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; 
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  

  
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",893.0,0,1,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Lack of Input Validation**
   - **Issue**: Several functions lack proper input validation, which could lead to unexpected behavior or vulnerabilities.
     - Example: `createSplit` functions do not validate if `_splitAsset` or `_collectionContract` are valid addresses.
     - Example: `setPlatformFee` and `setPlatformFeeRecipient` do not validate if `_vault` is a valid deployed contract.
   - **Impact**: Invalid inputs could cause contract failures or unintended behavior.

---

### 2. **State Variable Deletion**
   - **Issue**: The contract deletes state variables (`merkleRoot`, `splitAsset`, `splitterProxy`, `royaltyAsset`) after use in functions like `createSplitProxy` and `createVaultProxy`.
     - Deleting state variables is unnecessary and wasteful in terms of gas costs.
   - **Impact**: Increased gas costs without any functional benefit.

---

### 3. **Uninitialized State Variables**
   - **Issue**: The contract initializes `platformFee` and `platformFeeRecipient` in the constructor but does not provide a way to update them.
     - If the platform fee or recipient needs to change, the contract lacks functionality to do so.
   - **Impact**: Inflexibility in managing platform fees and recipients.

---

### 4. **Reentrancy Risk**
   - **Issue**: The contract interacts with external contracts (e.g., `ICoreCollection`, `IRoyaltyVault`) without using reentrancy guards.
     - Example: `createSplit` calls `ICoreCollection(_collectionContract).setRoyaltyVault(vault)`.
   - **Impact**: If the external contract is malicious or vulnerable, it could lead to reentrancy attacks.

---

### 5. **Unrestricted Deployment of Proxies**
   - **Issue**: The `createSplitProxy` and `createVaultProxy` functions deploy new contracts without restrictions.
     - Any user can deploy unlimited proxy contracts, which could lead to bloating the blockchain.
   - **Impact**: Increased blockchain bloat and potential denial-of-service (DoS) attacks.

---

### 6. **Hardcoded Platform Fee**
   - **Issue**: The `platformFee` is hardcoded to `500` in the constructor and cannot be updated.
     - This limits the flexibility of the contract to adjust fees based on market conditions.
   - **Impact**: Inflexibility in managing platform fees.

---

### 7. **Lack of Access Control on `createSplit`**
   - **Issue**: The `createSplit` function is callable by anyone, as long as the `_splitId` is unique.
     - This could lead to misuse or spamming of splits.
   - **Impact**: Unintended creation of splits by unauthorized users.

---

### 8. **No Check for Zero Address in Constructor**
   - **Issue**: The constructor does not validate if `_splitter` or `_royaltyVault` are zero addresses.
     - Passing zero addresses could lead to contract failures or vulnerabilities.
   - **Impact**: Potential deployment issues or vulnerabilities.

---

### 9. **Unclear Purpose of `splitterProxy`**
   - **Issue**: The `splitterProxy` state variable is set in `createVaultProxy` but immediately deleted afterward.
     - Its purpose is unclear, and it seems redundant.
   - **Impact**: Confusion in code readability and potential misuse.

---

### 10. **Lack of Event Emission for Critical Actions**
   - **Issue**: The `setPlatformFee` and `setPlatformFeeRecipient` functions do not emit events.
     - This makes it difficult to track changes to platform fees and recipients.
   - **Impact**: Reduced transparency and auditability.

---

### 11. **Potential Front-Running in `createSplit`**
   - **Issue**: The `createSplit` function uses `onlyAvailableSplit` to ensure uniqueness of `_splitId`.
     - However, there is no protection against front-running, where an attacker could preemptively create a split with the same ID.
   - **Impact**: Potential race conditions and misuse of split IDs.

---

### 12. **Inconsistent State Management**
   - **Issue**: The `merkleRoot` and `splitAsset` state variables are set in `createSplit` but deleted in `createSplitProxy`.
     - This could lead to inconsistencies if multiple functions rely on these variables.
   - **Impact**: Potential state corruption or unintended behavior.

---

### 13. **Lack of Error Handling for External Calls**
   - **Issue**: The contract does not handle errors or failures from external calls (e.g., `ICoreCollection.setRoyaltyVault`).
     - If the external call fails, the contract state could be left in an inconsistent state.
   - **Impact**: Potential state corruption or contract failures.

---

### 14. **Gas Optimization Issues**
   - **Issue**: The contract uses `delete` on state variables unnecessarily, which increases gas costs.
     - Example: `delete merkleRoot`, `delete splitAsset`, etc.
   - **Impact**: Higher gas costs for users.

---

### 15. **Potential Integer Overflow/Underflow**
   - **Issue**: The contract does not use SafeMath or similar protections for arithmetic operations.
     - Example: `platformFee` could theoretically overflow or underflow if not handled properly.
   - **Impact**: Potential arithmetic vulnerabilities.

---

### 16. **Lack of Documentation**
   - **Issue**: The contract lacks comments or documentation explaining the purpose of functions, variables, and logic.
   - **Impact**: Reduced readability and maintainability of the code.

---

These vulnerabilities and issues should be addressed to improve the security, efficiency, and usability of the smart contract.","### **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Report Description**:  
The `createSplit()` function uses `merkleRoot` as a salt for deploying a `SplitProxy`. Since a `merkleRoot` can only be used once, an attacker can front-run a legitimate `createSplit()` transaction by submitting a transaction with the same `merkleRoot` but different parameters (e.g., `_collectionContract` or `_splitAsset`). This causes the original transaction to revert, preventing the user from using that `merkleRoot` in the future. This vulnerability can lead to denial-of-service (DoS) attacks, disrupting the intended functionality of the contract.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running in `createSplit`""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of front-running in the `createSplit` function, which aligns with the issue reported. However, the response does not explicitly mention the use of `merkleRoot` as a salt or the specific DoS impact caused by the inability to reuse the same `merkleRoot`. While the core issue of front-running is addressed, the response misses critical details about the mechanism and impact of the vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis of Gaps**  
The response list covers a broad range of vulnerabilities and issues but lacks depth in addressing specific mechanisms and impacts. For example, while the front-running issue is identified, the response does not fully explain the use of `merkleRoot` as a salt or the resulting DoS impact. This highlights a need for more detailed analysis in the response list to ensure comprehensive coverage of vulnerabilities.",0,1,0,16,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
,,,,,,,,9,2,,,6,3,2,78,,
