nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
RCOrderbook.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    /*╔═════════════════════════════════╗
      ║          MODIFIERS              ║
      ╚═════════════════════════════════╝*/

    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    /*╔═════════════════════════════════╗
      ║         GOVERNANCE              ║
      ╚═════════════════════════════════╝*/

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    /*╔═════════════════════════════════════╗
      ║             INSERTIONS              ║
      ║ functions that add to the orderbook ║
      ╚═════════════════════════════════════╝*/

    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    /*╔═════════════════════════════════╗
      ║        HELPER FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7831.0,933.0,"[H-01] findNewOwner edgecase
In the function `findNewOwner()` of `RCOrderbook`, as loop is done which included the check `_loopCounter < maxDeletions` Afterwards, a check is done for ""(_loopCounter != maxDeletions)"" to determine if the processing is finished. If `_loopCounter == maxDeletions` then the conclusion is that it isn't finished yet.
However, there is the edgecase that the processing might just be finished at the same time as `_loopCounter == maxDeletions`.
You can see this the best if you assume `maxDeletions==1`, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.",1.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";


contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    
    
    mapping(address => Bid[]) public user;
    
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    
    mapping(address => Market) public market;
    
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    
    address[] public override closedMarkets;
    
    mapping(address => uint256) public override userClosedMarketIndex;

    
    
    IRCTreasury public override treasury;
    
    
    uint256 public override maxSearchIterations = 1000;
    
    uint256 public override maxDeletions = 70;
    
    uint256 public override cleaningLoops = 2;
    
    uint256 public override marketCloseLimit = 70;
    
    uint256 public override nonce;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    

    
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    

    
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    

    
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    
    
    
    
    
    
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        
        cleanWastePile();

        if (user[_user].length == 0) {
            
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    
    
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            
            
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            
            _price < _requiredPrice &&
            
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        
        
        
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _nextUser.prev = _user; 
        _prevUser.next = _user; 
        user[_user].push(_newBid);

        
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        
        
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; 
        _prevUser.next = _user; 

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    

    
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        
        treasury.decreaseBidRate(_user, _currUser.price);

        
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    
    
    
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    
    
    
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    
    
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; 
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        
                        uint256 _price = user[_user][_index].price;

                        
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        
                        if (_index != _lastRecord) {
                            
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        
                        _loopCounter++;
                    } else {
                        
                        
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                
                uint256 _lastRecord = user[_user].length - 1;
                
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    

    
    
    
    
    
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            
            if (index[_user][_market][_card] != 0) {
                
                return true;
            } else {
                
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    
    
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    
}",5819.0,1,0,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Risk**
   - **Location**: Functions like `_newBidInOrderbook`, `_updateBidInOrderbook`, and `transferCard` involve external calls (e.g., `IRCMarket.transferCard`).
   - **Issue**: If the external contract is malicious or compromised, it could re-enter the contract and manipulate state variables before they are fully updated.
   - **Example**: `transferCard` calls `IRCMarket.transferCard`, which could call back into the contract.

---

### 2. **Unbounded Loops**
   - **Location**: Functions like `_searchOrderbook`, `findNewOwner`, `removeUserFromOrderbook`, and `cleanWastePile` use loops that depend on external data or mappings.
   - **Issue**: If the number of iterations grows too large (e.g., due to a large number of bids or markets), the transaction could run out of gas, causing it to fail.
   - **Example**: `findNewOwner` iterates up to `maxDeletions`, which could be set to a high value.

---

### 3. **Incorrect Use of `SafeCast`**
   - **Location**: `SafeCast.toUint64`, `SafeCast.toUint128`, and other casting functions are used in multiple places.
   - **Issue**: If the input value exceeds the maximum value for the target type, the cast will fail, reverting the transaction. This could happen if inputs are not properly validated.
   - **Example**: `_newBidInOrderbook` casts `_price` to `uint128` without checking if `_price` is within bounds.

---

### 4. **State Variable Exposure**
   - **Location**: State variables like `user`, `market`, `ownerOf`, `oldOwner`, and `oldPrice` are public or exposed via getter functions.
   - **Issue**: Sensitive data (e.g., bid details, market configurations) can be accessed by anyone, potentially exposing private information or enabling manipulation.
   - **Example**: `getBid` and `getBidValue` allow anyone to query bid details.

---

### 5. **Inconsistent State Updates**
   - **Location**: Functions like `_removeBidFromOrderbookIgnoreOwner` and `_updateBidInOrderbook` update multiple state variables in sequence.
   - **Issue**: If an external call fails or the transaction reverts, the state could be left partially updated, leading to inconsistencies.
   - **Example**: `_removeBidFromOrderbookIgnoreOwner` updates `user` and `index` mappings but does not ensure atomicity.

---

### 6. **Improper Access Control**
   - **Location**: Modifiers like `onlyMarkets`, `onlyUberOwner`, and `onlyFactory` restrict access to certain functions.
   - **Issue**: If the `treasury` contract is compromised or misconfigured, unauthorized users could gain access to sensitive functions.
   - **Example**: `setTreasuryAddress` can only be called by `onlyUberOwner`, but if `treasury.checkPermission` is faulty, access control could be bypassed.

---

### 7. **Lack of Input Validation**
   - **Location**: Functions like `addBidToOrderbook`, `_newBidInOrderbook`, and `setTreasuryAddress` do not fully validate inputs.
   - **Issue**: Invalid or malicious inputs could lead to unexpected behavior or vulnerabilities.
   - **Example**: `addBidToOrderbook` does not validate `_prevUserAddress` beyond checking if it exists.

---

### 8. **Gas Limit Issues**
   - **Location**: Functions like `closeMarket`, `removeOldBids`, and `cleanWastePile` perform operations on large arrays or mappings.
   - **Issue**: If the number of elements is too large, the transaction could exceed the gas limit, causing it to fail.
   - **Example**: `closeMarket` iterates over `user[_market].length`, which could be very large.

---

### 9. **Potential Front-Running**
   - **Location**: Functions like `addBidToOrderbook` and `_updateBidInOrderbook` modify bid prices and orderbook positions.
   - **Issue**: An attacker could monitor the mempool and front-run transactions to manipulate the orderbook for profit.
   - **Example**: An attacker could place a higher bid just before a legitimate bid is processed.

---

### 10. **Uninitialized Mappings**
   - **Location**: Mappings like `user`, `index`, and `market` are used without explicit initialization.
   - **Issue**: Accessing uninitialized mappings could lead to unexpected behavior or errors.
   - **Example**: `bidExists` checks `index[_user][_market][_card]` without ensuring it has been initialized.

---

### 11. **Incorrect State Cleanup**
   - **Location**: Functions like `removeBidFromOrderbook` and `_removeBidFromOrderbookIgnoreOwner` remove bids but may leave stale data in mappings.
   - **Issue**: Stale data could lead to inconsistencies or unexpected behavior.
   - **Example**: `_removeBidFromOrderbookIgnoreOwner` sets `index[_user][_market][_card]` to 0 but does not clear other related mappings.

---

### 12. **Unhandled Edge Cases**
   - **Location**: Functions like `findNewOwner` and `removeUserFromOrderbook` assume certain conditions (e.g., `maxDeletions` is sufficient).
   - **Issue**: Edge cases (e.g., no valid owner found) are not properly handled, potentially causing the function to fail or behave unexpectedly.
   - **Example**: `findNewOwner` does not handle the case where `maxDeletions` is reached without finding a valid owner.

---

### 13. **Dependency on External Contracts**
   - **Location**: The contract relies heavily on external contracts like `IRCTreasury` and `IRCMarket`.
   - **Issue**: If these contracts are compromised, misconfigured, or upgraded, the functionality of this contract could be affected.
   - **Example**: `treasury.checkPermission` is used for access control, but if the treasury contract is faulty, access control could fail.

---

### 14. **Potential Integer Overflows/Underflows**
   - **Location**: Arithmetic operations in functions like `_searchOrderbook` and `reduceTimeHeldLimit`.
   - **Issue**: If Solidity version < 0.8.0 is used, integer overflows/underflows could occur. Even with SafeMath or Solidity >= 0.8.0, edge cases should be handled.
   - **Example**: `reduceTimeHeldLimit` subtracts `_timeToReduce` without checking if it exceeds the current value.

---

### 15. **Insufficient Event Logging**
   - **Location**: Some state-changing functions do not emit events, making it difficult to track changes.
   - **Issue**: Lack of event logging can hinder debugging, auditing, and monitoring of the contract.
   - **Example**: `setTreasuryAddress` changes a critical state variable but does not emit an event.

---

### 16. **Hardcoded Values**
   - **Location**: Constants like `1 days` and `100` are hardcoded in calculations.
   - **Issue**: Hardcoded values reduce flexibility and could lead to errors if assumptions change.
   - **Example**: `minimumRentalDuration` is calculated using `1 days / IRCMarket(_market).minRentalDayDivisor()`.

---

### 17. **Potential Denial of Service (DoS)**
   - **Location**: Functions like `closeMarket` and `removeOldBids` perform operations that could be blocked by external factors.
   - **Issue**: If the contract relies on external calls or large loops, it could be rendered unusable by an attacker.
   - **Example**: `closeMarket` iterates over `user[_market].length`, which could be manipulated to cause a DoS.

---

### 18. **Lack of Error Messages**
   - **Location**: Some `require` statements do not include descriptive error messages.
   - **Issue**: Lack of error messages makes it difficult to diagnose issues when transactions fail.
   - **Example**: `require(_newTreasury != address(0));` in `setTreasuryAddress`.

---

### 19. **Unsafe Type Casting**
   - **Location**: Functions like `_newBidInOrderbook` and `_updateBidInOrderbook` cast values to smaller types (e.g., `uint64`, `uint128`).
   - **Issue**: If the input value exceeds the target type's range, the cast will fail, reverting the transaction.
   - **Example**: `_newBidInOrderbook` casts `_price` to `uint128` without checking its range.

---

### 20. **Inconsistent Naming Conventions**
   - **Location**: Variable and function names are inconsistent (e.g., `_newBidInOrderbook` vs. `_updateBidInOrderbook`).
   - **Issue**: Inconsistent naming can lead to confusion and errors during development and maintenance.
   - **Example**: `_newBidInOrderbook` and `_updateBidInOrderbook` perform similar tasks but have different names.

---

This list highlights potential vulnerabilities and issues in the smart contract. Each issue should be carefully evaluated and addressed to improve the contract's security and reliability.","### **[H-01] findNewOwner Edge Case**

**Report Description**:
The function `findNewOwner()` in `RCOrderbook` contains a loop that checks `_loopCounter < maxDeletions`. After the loop, it checks if `_loopCounter != maxDeletions` to determine if processing is finished. However, there is an edge case where processing might finish exactly when `_loopCounter == maxDeletions`. This is particularly problematic if `maxDeletions == 1`, as the function will never conclude that processing is finished. While `maxDeletions == 1` is unlikely in practice, this edge case could lead to incorrect behavior or infinite loops under specific conditions.

**Match in Response List**:
Matches with the issue titled **""Unhandled Edge Cases""** in the response list.

**Validation**:
**Partially Correct**. The response identifies the issue of unhandled edge cases in the `findNewOwner` function, which aligns with the reported issue. However, the response does not specifically address the edge case where `_loopCounter == maxDeletions` could lead to incorrect conclusions about processing completion. The response could have provided more detailed guidance on handling this specific edge case, such as modifying the loop condition or adding additional checks to ensure correct behavior.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-01] findNewOwner Edge Case**

**Missed Issues from Issue Report**:
- *None*

---

### **Conclusion**
The response list partially addresses the reported issue by identifying the general problem of unhandled edge cases in the `findNewOwner` function. However, it misses the specific edge case where `_loopCounter == maxDeletions` could lead to incorrect behavior. To improve the response, it should include more detailed guidance on handling this specific scenario, such as modifying the loop condition or adding additional checks to ensure correct processing completion.",0,1,0,20,"```
None.
```",0.0
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        /* setup AccessControl

                         UBER_OWNER
            ┌───────────┬────┴─────┬────────────┬─────────┐
            │           │          │            │         │
          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD
            │           │
         GOVERNOR     MARKET
            │
         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE
        */
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",8609.0,920.0,"[H-02] UberOwner has too much power
The`Uber_Owner` has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code
The above functions can be used by the Uber Owner to completely change the functionality of the system. This goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.
Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.
  [M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol
The variable, `marketWhitelist`, is never initialized in the contract RCTreasury.sol. As a result, the function `marketWhitelistCheck()` does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.
The initial state variable is defined in RCTreasury.sol L75.
The state variable `marketWhitelist` is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281.
The function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.
Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.
  [M-03] Deposits don't work with fee-on transfer tokens
There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
The `deposit()` function will credit more deposits than the contract actually received:
``` erc20.safeTransferFrom(msgSender(), address(this), _amount);
user[_user].deposit += SafeCast.toUint128(_amount); ```",3.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";



contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;
 
    IRCOrderbook public override orderbook;
    
    IRCLeaderboard public override leaderboard;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    IRCFactory public override factory;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public override marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 public override marketBalanceTopup;

    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;


    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    
    mapping(address => bytes32) public marketWhitelist;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;
    
    mapping(address => bool) public override lockMarketPaused;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1_000_000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    
    modifier balancedBooks() {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

   
    
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    
    
    
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    
    
    
    
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        
        erc20.safeTransfer(msg.sender, _balance);
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        assessForeclosure(_user);
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            
            isForeclosed[_msgSender] = true;
            
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        
        return _amount;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        
        if (user[_user].lastRentCalc == 0) {
            
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                
                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    
}",5177.0,1,2,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### **1. Reentrancy Risk**
- **Description**: The contract uses `safeTransferFrom` and `safeTransfer` for ERC20 token transfers, which are generally safe. However, the `deposit`, `withdrawDeposit`, and `sponsor` functions could still be vulnerable if the token contract behaves maliciously or implements a callback mechanism.
- **Location**: 
  - `deposit` function
  - `withdrawDeposit` function
  - `sponsor` function

---

### **2. Integer Overflow/Underflow**
- **Description**: Although Solidity 0.8.x has built-in overflow/underflow checks, certain calculations (e.g., `rentOwedBetweenTimestamps`, `foreclosureTimeUser`) involve arithmetic operations that could lead to unexpected behavior if inputs are not properly validated.
- **Location**:
  - `rentOwedBetweenTimestamps` function
  - `foreclosureTimeUser` function

---

### **3. Access Control Issues**
- **Description**: The contract uses OpenZeppelin's `AccessControl`, but there are potential issues:
  - The `grantRole` and `revokeRole` functions can be called by anyone with the appropriate role, but the `grantRole(string memory role, address account)` and `revokeRole(string memory role, address account)` functions do not enforce role-based access control, potentially allowing unauthorized role assignments.
  - The `setFactoryAddress`, `setOrderbookAddress`, and `setTokenAddress` functions are restricted to `UBER_OWNER`, but there is no mechanism to prevent misuse or accidental changes.
- **Location**:
  - `grantRole` function
  - `revokeRole` function
  - `setFactoryAddress` function
  - `setOrderbookAddress` function
  - `setTokenAddress` function

---

### **4. Lack of Input Validation**
- **Description**: Several functions lack proper input validation, which could lead to unexpected behavior or vulnerabilities:
  - `setMinRental` and `setMaxContractBalance` do not validate the input values.
  - `changePauseMarket` does not validate the `_market` address.
  - `deposit` does not validate the `_user` address.
- **Location**:
  - `setMinRental` function
  - `setMaxContractBalance` function
  - `changePauseMarket` function
  - `deposit` function

---

### **5. Unbounded Loops**
- **Description**: The `batchWhitelist` function iterates over an array of addresses, which could lead to gas exhaustion if the array is too large.
- **Location**:
  - `batchWhitelist` function

---

### **6. Incorrect State Updates**
- **Description**: In the `updateRentalRate` function, the `lastRentCalc` timestamp is updated incorrectly if `_timeOwnershipChanged < user[_newOwner].lastRentCalc`. This could lead to incorrect rent calculations.
- **Location**:
  - `updateRentalRate` function

---

### **7. Inconsistent Role Management**
- **Description**: The `grantRole` and `revokeRole` functions emit events for `WHITELIST` role changes but do not emit events for other role changes, leading to inconsistent logging.
- **Location**:
  - `grantRole` function
  - `revokeRole` function

---

### **8. Missing Error Handling**
- **Description**: The contract does not handle errors gracefully in certain scenarios, such as when `erc20.balanceOf` or `erc20.allowance` fails.
- **Location**:
  - `deposit` function
  - `withdrawDeposit` function
  - `sponsor` function

---

### **9. Unused Variables and Mappings**
- **Description**: Some variables and mappings are declared but not used, which could indicate incomplete or incorrect logic:
  - `isAllowed` mapping
  - `marketWhitelist` mapping
- **Location**:
  - Contract state variables

---

### **10. Potential Front-Running**
- **Description**: The `deposit` and `withdrawDeposit` functions are susceptible to front-running attacks, where an attacker could manipulate the order of transactions to their advantage.
- **Location**:
  - `deposit` function
  - `withdrawDeposit` function

---

### **11. Inefficient Storage Usage**
- **Description**: The `User` struct uses `uint128` and `uint64` types, which could lead to inefficient storage usage and increased gas costs due to packing and unpacking.
- **Location**:
  - `User` struct

---

### **12. Missing Events**
- **Description**: Some critical state changes do not emit events, making it difficult to track contract activity:
  - `setMinRental` function
  - `setMaxContractBalance` function
- **Location**:
  - `setMinRental` function
  - `setMaxContractBalance` function

---

### **13. Incorrect Time Calculations**
- **Description**: The `foreclosureTimeUser` function contains complex time calculations that could lead to incorrect results if the inputs are not properly validated or if edge cases are not handled.
- **Location**:
  - `foreclosureTimeUser` function

---

### **14. Potential Denial of Service (DoS)**
- **Description**: The `collectRentUser` function could revert if the `_timeToCollectTo` parameter is set to a value greater than `block.timestamp`, leading to a potential DoS attack.
- **Location**:
  - `collectRentUser` function

---

### **15. Unrestricted Token Approval**
- **Description**: The `setBridgeAddress` function approves the bridge contract to spend an unlimited amount of tokens (`type(uint256).max`), which could lead to potential misuse if the bridge contract is compromised.
- **Location**:
  - `setBridgeAddress` function

---

### **16. Lack of Fail-Safe Mechanism**
- **Description**: The contract does not have a fail-safe mechanism to recover funds or pause all operations in case of an emergency, except for the `globalExit` function, which is restricted to `UBER_OWNER`.
- **Location**:
  - `globalExit` function

---

### **17. Incorrect Role Admin Setup**
- **Description**: The `_setRoleAdmin` function is used to set role admins, but there is no validation to ensure that the role admin is not set to an invalid or insecure role.
- **Location**:
  - Constructor

---

### **18. Potential Logic Errors**
- **Description**: The `assessForeclosure` function updates the `isForeclosed` mapping but does not validate the user's deposit or bid rate, potentially leading to incorrect foreclosure status.
- **Location**:
  - `assessForeclosure` function

---

### **19. Inconsistent Naming Conventions**
- **Description**: The contract uses inconsistent naming conventions for events, functions, and variables, which could lead to confusion and errors during development.
- **Location**:
  - Events (e.g., `LogUserForeclosed`, `LogAdjustDeposit`)
  - Functions (e.g., `changeGlobalPause`, `toggleWhitelist`)

---

### **20. Missing Documentation**
- **Description**: The contract lacks sufficient inline documentation, making it difficult to understand the purpose and behavior of certain functions and variables.
- **Location**:
  - Entire contract

---

These vulnerabilities and issues should be carefully reviewed and addressed to ensure the security and reliability of the smart contract.","### **Comparison and Evaluation**

---

#### **[H-02] UberOwner has too much power**

**Report Description**:  
The `Uber_Owner` has excessive control over the system, making the protocol resemble a centralized prediction market. The `Uber_Owner` can alter the system's functionality beyond simple parameter adjustments, effectively reprogramming the protocol. This poses a significant risk if the `Uber_Owner` address is compromised. The recommendation is to limit the `Uber_Owner`'s permissions and use a proxy for upgrades.

**Match in Response List**:  
Matches with the issue titled **""Access Control Issues""**.

**Validation**:  
**Partially Correct**. The response identifies access control issues but does not specifically address the excessive power of the `Uber_Owner`. While it mentions the `UBER_OWNER` role in the context of restricted functions, it does not highlight the systemic risk of centralization or the recommendation to use a proxy for upgrades. This misses critical details about the severity and scope of the issue.

---

#### **[M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol**

**Report Description**:  
The `marketWhitelist` variable in `RCTreasury.sol` is never initialized, causing the `marketWhitelistCheck()` function to always return `true`. This prevents the intended functionality of restricting markets to specific whitelists. The recommendation is to ensure the behavior is intentional or add a function to enable market creators to restrict their markets to specific roles.

**Match in Response List**:  
Matches with the issue titled **""Unused Variables and Mappings""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the `marketWhitelist` mapping as unused but does not address the functional impact of its uninitialized state. It misses the critical detail that the `marketWhitelistCheck()` function always returns `true`, which undermines the intended access control mechanism.

---

#### **[M-03] Deposits don't work with fee-on transfer tokens**

**Report Description**:  
The `deposit()` function does not account for fee-on-transfer or rebasing tokens, leading to discrepancies between the actual token balance and the recorded deposit amount. This could result in incorrect accounting and potential vulnerabilities.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk""**.

**Validation**:  
**Incorrect**. The response misidentifies the issue as a reentrancy risk. While it mentions `safeTransferFrom` and `safeTransfer`, it does not address the core problem of fee-on-transfer or rebasing tokens. The proposed solution does not resolve the accounting discrepancy caused by these token types.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] UberOwner has too much power**  
- **[M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol**

**Incorrect Matches**:  
- **[M-03] Deposits don't work with fee-on transfer tokens**

**Missed Issues from Issue Report**:  
- *None*

---

### **Overall Assessment**  
The `response_list` partially addresses some issues but misses critical details or misidentifies the core vulnerabilities in several cases. Specifically, the response fails to fully capture the risks associated with the `Uber_Owner`'s excessive power, the functional impact of the uninitialized `marketWhitelist` variable, and the accounting issues with fee-on-transfer tokens. Improvements are needed to ensure comprehensive coverage and accurate identification of vulnerabilities.",0,2,1,20,"```
None.
```",0.0
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    /////// CONTRACT VARIABLES ///////
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    /// @dev reference contract
    address public override referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public override referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(IRCMarket.Mode => address[]) public marketAddresses;

    ////// BACKUP MODE //////
    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data
    /// @dev the IPFS hash for each market
    mapping(address => string) public override ipfsHash;
    /// @dev the slug each market is hosted at
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    /// @dev the number of results to return in the backup view function
    uint256 public override marketInfoResults;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms initial pot
    uint256 public override sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev The number of users that are allowed to mint an NFT
    uint256 public override nftsToAward;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public override advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public override maximumDuration;
    /// @dev market closing time must be at least this many seconds after opening
    uint32 public override minimumDuration;
    /// @dev if false, anyone can create markets
    bool public override marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public override approvedAffiliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public override approvedArtistsOnly = true;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the maximum number of rent collections to have performed before locking the market
    uint256 public override maxRentIterationsToLockMarket;
    /// @dev the address of the arbitrator
    address public override arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public override timeout;
    /// @dev if true markets default to the paused state
    bool public override marketPausedDefaultState;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public override cardLimit;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;

    ///// OTHER /////
    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)
    /// @dev store the tokenURIs for when we need to mint them
    /// @dev we may want the original and the copies to have slightly different metadata
    /// @dev so we append the metadata for the copies to the end of this array
    mapping(address => mapping(uint256 => string)) tokenURIs;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // store contract instances
        treasury = _treasury;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setMinimumPriceIncreasePercent(10); // 10%
        setNumberOfNFTsToAward(3);
        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes
        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /// @notice fetch the current oracle, arbitrator and timeout settings
    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    /// @return Oracle Address
    /// @return Arbitrator Address
    /// @return Question timeout in seconds
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    /// @notice Returns market addresses and ipfs hashes
    /// @dev used for the UI backup mode
    /// @param _mode return markets only in the given mode
    /// @param _state return markets only in the given state
    /// @param _skipResults the number of results to skip
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in MegaBip (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice how many NFTs will be awarded to the leaderboard
    /// @param _nftsToAward the number of NFTs to award
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _cardLimit the limit to set
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        // event is emitted from the Oracle when the question is asked
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    /// @notice Allow the owner to update a token URI.
    /// @param _market the market address the token belongs to
    /// @param _cardId the index 0 card id of the token to change
    /// @param _newTokenURI the new URI to set
    /// @param _newCopyTokenURI the new URI to set for the copy
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        // reuse this event so the frontend can pickup the change
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    /// @notice change how many results are returned from getMarketInfo
    /// @dev would be better to pass this as a parameter in getMarketInfo
    /// @dev .. however we are limited because of stack too deep errors
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        // no event needed, only used for the backup view mode
        marketInfoResults = _results;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        // check it's an RC contract
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        // governors shouldn't have the ability to pause a market, only un-pause.
        // .. if a governor accidentally approves a market they should seek
        // .. assistance from the owner to decide if it should be paused.
        treasury.unPauseMarket(_market);
        // the market will however be hidden from the UI in the meantime
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /*╔═════════════════════════════════╗
      ║   GOVERNANCE - Role management  ║
      ╚═════════════════════════════════╝*/
    /// @dev the following functions could all be performed directly on the treasury
    /// @dev .. they are here as an interim solution to give governors an easy way
    /// @dev .. to change all their parameters via the block explorer.

    /// @notice Grant the artist role to an address
    /// @param _newArtist the address to grant the role of artist
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    /// @notice Remove the artist role from an address
    /// @param _oldArtist the address to revoke the role of artist
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    /// @notice Grant the affiliate role to an address
    /// @param _newAffiliate the address to grant the role of affiliate
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    /// @notice Remove the affiliate role from an address
    /// @param _oldAffiliate the address to revoke the role of affiliate
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades, this is separated so owner can be
    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    /// @notice change the reference contract for the contract logic
    /// @param _newAddress the address of the new reference contract to set
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice where the NFTs live
    /// @param _newAddress the address to set
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newOrderbook the address to set
    /// @dev set by the treasury to ensure all contracts use the same orderbook
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    /// @notice set the address of the leaderboard contract
    /// @param _newLeaderboard the address to set
    /// @dev set by the treasury to ensure all contracts use the same leaderboard
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all
    /// @param _ipfsHash the IPFS location of the market metadata
    /// @param _slug the URL subdomain in the UI
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata, originals followed by copies
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliates cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        // check nfthub has been set
        require(address(nfthub) != address(0), ""Nfthub not set"");

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check the number of NFTs to mint is within limits
        /// @dev we want different tokenURIs for originals and copies
        /// @dev ..the copies are appended to the end of the array
        /// @dev ..so half the array length if the number of tokens.
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        // affiliate
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        // tell Treasury and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        // update internals
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        // initialize the market
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        // store token URIs
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            // different statements to give clearer revert messages
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    /// @notice Called by the markets to mint the original NFTs
    /// @param _card the card id to be minted
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard
    /// @param _user the user to award the NFT to
    /// @param _cardId the tokenId to copy
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",7456.0,838.0,"[M-02] Parameter updates not propagated
Function `setNftHubAddress` to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results. Examples are:
``` function setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {
    require(address(_newAddress) != address(0), ""Must set Address"");
    nfthub = _newAddress;
} ```",1.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";


contract RCFactory is NativeMetaTransaction, IRCFactory {
    
    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    
    address public override referenceContractAddress;
    
    uint256 public override referenceContractVersion;
    
    
    mapping(IRCMarket.Mode => address[]) public marketAddresses;


    mapping(address => string) public override ipfsHash;
    
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    
    uint256 public override marketInfoResults;

    
    
    uint256[5] public potDistribution;
    
    uint256 public override sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint256 public override nftsToAward;
    
    uint32 public override advancedWarning;
    
    uint32 public override maximumDuration;
    
    uint32 public override minimumDuration;
    
    bool public override marketCreationGovernorsOnly = true;
    
    bool public override approvedAffiliatesOnly = true;
    
    bool public override approvedArtistsOnly = true;
    
    uint256 public override maxRentIterations;
    
    uint256 public override maxRentIterationsToLockMarket;
    
    address public override arbitrator;
    
    uint32 public override timeout;
    
    bool public override marketPausedDefaultState;
    
    uint256 public override cardLimit;

    
    
    mapping(address => bool) public override isMarketApproved;

    
    uint256 public constant PER_MILLE = 1000; 
    
    
    
    mapping(address => mapping(uint256 => string)) tokenURIs;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        treasury = _treasury;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setMinimumPriceIncreasePercent(10); 
        setNumberOfNFTsToAward(3);
        setCardLimit(100); 
        setMaxRentIterations(50, 25); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    
    
    
    
    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    
    
    
    
    
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    
    
    
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    
    
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    

    
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    
    
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    
    
    
    
    
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    
    
    
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        
        marketInfoResults = _results;
    }

    
    

    
    
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        
        
        
        treasury.unPauseMarket(_market);
        
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    
    

    
    
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    
    
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    
    
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    
    
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    
    
    
    

    
    
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    
    
    
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    
    
    
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    

    
    
    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        
        require(address(nfthub) != address(0), ""Nfthub not set"");

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        
        
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        
        
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        
        
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    
    
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    
    
    
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    
}",4268.0,0,1,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Lack of Input Validation**
   - **Issue**: Several functions lack proper input validation, which could lead to unexpected behavior or vulnerabilities.
     - Example: `setPotDistribution` does not validate if the individual cuts are within reasonable bounds.
     - Example: `createMarket` does not validate the length of `_cardAffiliateAddresses` properly.
   - **Impact**: Malicious inputs could cause the contract to behave unexpectedly or fail.

---

### 2. **Reentrancy Risk**
   - **Issue**: The contract interacts with external contracts (e.g., `treasury`, `nfthub`, `IRCMarket`) without using checks-effects-interactions pattern.
     - Example: `createMarket` calls `treasury.addMarket` and `nfthub.addMarket` after updating state variables.
   - **Impact**: A malicious external contract could exploit reentrancy to manipulate the contract's state.

---

### 3. **Unbounded Loops**
   - **Issue**: Loops in functions like `getMarketInfo` and `createMarket` could run out of gas if the number of iterations is too large.
     - Example: `getMarketInfo` iterates over `marketAddresses[_mode]` without a clear upper bound.
   - **Impact**: Gas costs could become prohibitively high, leading to transaction failures.

---

### 4. **Lack of Access Control**
   - **Issue**: Some functions have insufficient access control or rely on external contracts for permission checks.
     - Example: `setOrderbookAddress` and `setLeaderboardAddress` rely on `treasury.checkPermission`, but there is no guarantee that the treasury contract enforces proper permissions.
   - **Impact**: Unauthorized users could call sensitive functions.

---

### 5. **Dependence on External Contracts**
   - **Issue**: The contract relies heavily on external contracts (e.g., `treasury`, `nfthub`, `IRCMarket`) for critical functionality.
     - Example: `treasury.checkPermission` is used for access control, but the treasury contract could be malicious or compromised.
   - **Impact**: If an external contract is compromised or behaves unexpectedly, this contract could be exploited.

---

### 6. **Uninitialized Variables**
   - **Issue**: Some state variables are not initialized in the constructor or are set to default values.
     - Example: `marketInfoResults`, `referenceContractAddress`, and `referenceContractVersion` are not initialized in the constructor.
   - **Impact**: Uninitialized variables could lead to unexpected behavior or vulnerabilities.

---

### 7. **Potential Integer Overflow/Underflow**
   - **Issue**: Arithmetic operations are performed without explicit checks for overflow/underflow.
     - Example: `setPotDistribution` adds multiple values without ensuring the sum does not exceed `PER_MILLE`.
   - **Impact**: Integer overflow/underflow could lead to incorrect calculations or vulnerabilities.

---

### 8. **Lack of Event Emission for Critical Actions**
   - **Issue**: Some critical state changes do not emit events, making it difficult to track changes.
     - Example: `setReferenceContractAddress` and `setNftHubAddress` do not emit events.
   - **Impact**: Lack of transparency and auditability.

---

### 9. **Hardcoded Values**
   - **Issue**: Some values are hardcoded, which could lead to inflexibility or vulnerabilities.
     - Example: `setTimeout` hardcodes the timeout value to `86400` seconds.
   - **Impact**: Hardcoded values may not be suitable for all use cases and could lead to vulnerabilities.

---

### 10. **Incorrect Array Length Handling**
   - **Issue**: Some functions do not properly handle array lengths, which could lead to out-of-bounds errors.
     - Example: `updateTokenURI` assumes the length of `_tokenURIs` matches the number of cards in the market.
   - **Impact**: Incorrect array handling could lead to unexpected behavior or vulnerabilities.

---

### 11. **Improper Error Handling**
   - **Issue**: Some functions do not handle errors or edge cases properly.
     - Example: `mintCopyOfNFT` does not check if `_cardId` is valid.
   - **Impact**: Improper error handling could lead to vulnerabilities or unexpected behavior.

---

### 12. **Lack of Fallback Function**
   - **Issue**: The contract does not have a fallback or receive function to handle unexpected Ether transfers.
   - **Impact**: Ether sent to the contract could be lost permanently.

---

### 13. **Potential Front-Running**
   - **Issue**: Some functions (e.g., `changeMarketApproval`) could be front-run, allowing attackers to manipulate the state.
   - **Impact**: Front-running could lead to unfair advantages or vulnerabilities.

---

### 14. **Lack of Upgradeability**
   - **Issue**: The contract does not implement any upgradeability mechanism, making it difficult to fix bugs or vulnerabilities.
   - **Impact**: Bugs or vulnerabilities cannot be easily patched.

---

### 15. **Gas Optimization Issues**
   - **Issue**: Some functions are not optimized for gas usage, leading to higher transaction costs.
     - Example: `getMarketInfo` uses multiple loops and array allocations.
   - **Impact**: Higher gas costs could make the contract less efficient or prohibitively expensive to use.

---

### 16. **Lack of Documentation**
   - **Issue**: The contract lacks inline comments or documentation, making it difficult to understand its functionality.
   - **Impact**: Poor readability and maintainability.

---

### 17. **Potential Race Conditions**
   - **Issue**: Some functions (e.g., `setReferenceContractAddress`) could be vulnerable to race conditions if called concurrently.
   - **Impact**: Race conditions could lead to unexpected behavior or vulnerabilities.

---

### 18. **Unused Variables**
   - **Issue**: Some variables (e.g., `marketInfoResults`) are declared but not used in the contract.
   - **Impact**: Unused variables increase code complexity and could lead to confusion.

---

### 19. **Incorrect Use of `require`**
   - **Issue**: Some `require` statements are not used effectively or are missing.
     - Example: `setTimeout` does not validate the input value.
   - **Impact**: Missing or incorrect `require` statements could lead to vulnerabilities.

---

### 20. **Lack of Security Audits**
   - **Issue**: The contract does not appear to have undergone a security audit.
   - **Impact**: Undiscovered vulnerabilities could exist in the contract.

---

These vulnerabilities and issues should be carefully addressed to ensure the security and reliability of the smart contract.","### **[M-02] Parameter updates not propagated**

**Report Description**:  
The function `setNftHubAddress` updates the `nfthub` address but does not propagate this change to other contracts that depend on it. This could lead to inconsistencies and unpredictable behavior in the system. For example, if `nfthub` is updated in one contract but not in others, it could result in failed interactions or incorrect state management. The issue is exacerbated by the lack of event emission to track such changes.

**Match in Response List**:  
No direct match found. However, the issue partially aligns with **""Lack of Event Emission for Critical Actions""** and **""Dependence on External Contracts""** in the response list.

**Validation**:  
**Partially Correct**. The response list does not explicitly address the issue of parameter updates not being propagated to dependent contracts. However, it does highlight the lack of event emission for critical actions, which is related to the issue's secondary concern of tracking changes. Additionally, the ""Dependence on External Contracts"" point indirectly touches on the risks of relying on external contracts without ensuring consistency. While these points are relevant, they do not fully capture the core issue of parameter propagation. Therefore, the match is partially correct but insufficient.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] Parameter updates not propagated**

**Missed Issues from Issue Report**:  
- *None*",0,1,0,20,"```
None.
```",0.0
,,,,,,,,2,3,,,0,4,1,60,,
