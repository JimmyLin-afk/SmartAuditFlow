nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Wrappedlbbtc.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)
*/
contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Current pricePerShare read live from oracle
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",1204.0,156.0,"[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool
Per the documentation, variables `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.
Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.
The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the pricePerShare increases.
Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored reserves to match the balances.
  [H-02] Approved spender can spend too many tokens
The `approve` function has not been overridden and therefore uses the internal shares, whereas transfer(From) uses the rebalanced amount.
Impact: The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.
Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).
 
[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers
If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.
  [M-01] Unable to transfer WrappedIbbtc if Oracle go down
In function `WrappedIbbtc`, user will not be able to transfer if `oracle.pricePerShare()` (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().
If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it uses the cached value in a local variable pricePerShare, which is only updated upon call to updatePricePerShare().
  [M-02] Null check in `pricePerShare`
oracle can 0 as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: WrappedIbbtc.sol L148) resulting in Denial Of Service.
  [M-03] hard to clear balance
The contract does not allow users to `transfer` by share. Therefore, It is hard for users to clear out all the shares. There will be users using this token with Metamask and it is likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.
 
[M-04] No sanity check on `pricePerShare` might lead to lost value
`pricePerShare` is read either from an oracle or from ibBTC's core.
If one of these is bugged or exploited, there are no safety checks to prevent loss of funds. Impact: As pricePerShare is used to calculate transfer amount, a bug or wrong data retuning a smaller pricePerShare than it really is, could result in drainage of wibbtc from Curve pool.",7.0,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";


contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",811.0,3,4,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Vulnerability**
   - The `mint` and `burn` functions involve external calls (`transferFrom` and `transfer`) before updating the contract state. This could allow an attacker to re-enter the contract and manipulate the state.
   - Example: An attacker could call `mint` repeatedly before the state is updated, leading to unintended behavior.

---

### 2. **Lack of Input Validation**
   - The `initialize` function does not validate the input addresses (`_governance`, `_ibbtc`, `_oracle`). If any of these addresses are zero or invalid, the contract could behave unexpectedly.
   - Similarly, `setPendingGovernance` and `setOracle` do not validate the input addresses.

---

### 3. **Upgradeable Contract Risks**
   - The contract uses the `Initializable` pattern from OpenZeppelin but does not implement proper upgrade safeguards. If the contract is upgraded maliciously, critical functionality (e.g., governance or oracle) could be compromised.

---

### 4. **Governance Risks**
   - The `setPendingGovernance` and `acceptPendingGovernance` functions allow for a two-step governance transfer, but there is no time delay or additional validation to prevent malicious governance takeover.
   - If the `pendingGovernance` address is compromised, the attacker could immediately take control of the contract.

---

### 5. **Oracle Dependency**
   - The contract relies heavily on an external oracle (`ICoreOracle`) for critical functionality (e.g., `pricePerShare`). If the oracle is compromised or returns incorrect data, the contract's behavior could be manipulated.
   - There is no fallback mechanism or validation for the oracle's data.

---

### 6. **Integer Division Precision Loss**
   - The `balanceToShares` and `sharesToBalance` functions involve integer division, which can lead to precision loss. This could result in incorrect calculations for small values.

---

### 7. **Incorrect `transferFrom` Implementation**
   - The `transferFrom` function uses `balanceToShares` to convert the input `amount` but does not ensure that the converted `amountInShares` matches the intended logic. This could lead to incorrect token transfers.
   - The function also does not validate whether the `sender` has sufficient allowance for the transfer.

---

### 8. **Lack of Event Emission for Critical State Changes**
   - The `mint` and `burn` functions do not emit events, making it difficult to track token minting and burning activities.

---

### 9. **Uninitialized State Variables**
   - The `pendingGovernance` state variable is not initialized in the `initialize` function. This could lead to unexpected behavior if `acceptPendingGovernance` is called before `setPendingGovernance`.

---

### 10. **Potential for Front-Running**
   - The `setPendingGovernance` and `acceptPendingGovernance` functions are susceptible to front-running attacks. An attacker could monitor the mempool and replace the transaction with their own malicious address.

---

### 11. **Unbounded Loops or Gas Issues**
   - While there are no explicit loops in the contract, the reliance on external calls (e.g., `transferFrom`, `transfer`) could lead to gas issues if the external contracts have complex logic or revert unexpectedly.

---

### 12. **Lack of Pausability**
   - The contract does not implement a pausable mechanism. In case of an emergency (e.g., oracle compromise or governance attack), the contract cannot be paused to prevent further damage.

---

### 13. **Potential for Denial of Service (DoS)**
   - If the `ibbtc` token contract reverts on `transferFrom` or `transfer`, the `mint` and `burn` functions could be rendered unusable, leading to a denial of service.

---

### 14. **Unprotected Initializer**
   - The `initialize` function is not protected from being called multiple times. If called again, it could reset critical state variables (e.g., `governance`, `oracle`, `ibbtc`).

---

### 15. **Lack of Access Control for `mint` and `burn`**
   - The `mint` and `burn` functions are publicly accessible and do not have any access control. This could allow anyone to mint or burn tokens, leading to potential abuse.

---

### 16. **Potential for Token Locking**
   - If the `ibbtc` token contract does not allow transfers to/from the `WrappedIbbtc` contract, tokens could become permanently locked in the contract.

---

### 17. **Incorrect Balance Calculations**
   - The `balanceOf` and `totalSupply` functions rely on `pricePerShare`, which is fetched from an external oracle. If the oracle returns incorrect or manipulated data, the balance calculations will be inaccurate.

---

### 18. **Lack of Error Handling for External Calls**
   - The contract does not handle potential errors from external calls (e.g., `transferFrom`, `transfer`). If these calls revert, the entire transaction will fail, potentially leaving the contract in an inconsistent state.

---

### 19. **Potential for Overflow/Underflow**
   - While Solidity 0.6.12 has built-in overflow/underflow checks, the contract does not explicitly handle edge cases where calculations could exceed the maximum or minimum values for `uint256`.

---

### 20. **Insufficient Testing and Documentation**
   - The contract lacks inline comments and documentation, making it difficult to understand the intended behavior and edge cases. This increases the risk of undetected vulnerabilities.

---

These vulnerabilities highlight the need for careful auditing and testing before deploying the contract to a production environment.","### **[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool**

**Report Description**:
The `wibBTC` token is designed for a Curve StableSwap pool, but its dynamic balance changes are incompatible with the pool's static balance management. The Curve pool maintains balances based on token additions, removals, and exchanges, and cannot handle automatic balance changes. This discrepancy can lead to deviations between the actual and recorded balances in the pool, especially as `pricePerShare` increases. Additionally, there is no mechanism like UNI v2's `sync()` function to force synchronization of balances.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the incompatibility between `wibBTC` and the Curve StableSwap pool. This issue is specific to the interaction between the token and the pool, which is not covered in the response list.

---

### **[H-02] Approved spender can spend too many tokens**

**Report Description**:
The `approve` function in the contract uses internal `shares`, while `transfer(From)` uses the rebalanced amount. This discrepancy allows an approved spender to spend more tokens than intended, as the approved amount grows with `pricePerShare`. Contracts that use the same amount for `approve` and `transferFrom` may inadvertently approve excessive amounts, leading to unintended token transfers.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `approve` and `transferFrom` discrepancies. This is a specific vulnerability related to token approval and transfer logic, which is not covered in the response list.

---

### **[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers**

**Report Description**:
The `WrappedIbbtc` contracts do not filter out price feed outliers, which can be manipulated or result from market volatility. This lack of filtering exposes users to economic risks from unsustainable price movements. Implementing mitigation mechanics could reduce the attack surface and protect user economics.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of price feed outliers or the lack of filtering mechanisms. This is a specific vulnerability related to oracle data handling, which is not covered in the response list.

---

### **[M-01] Unable to transfer `WrappedIbbtc` if Oracle goes down**

**Report Description**:
The `WrappedIbbtc` contract relies on `oracle.pricePerShare()` for transfers. If the oracle goes down and reverts, users will be unable to transfer tokens. This behavior contrasts with `WrappedIbbtcEth`, which uses a cached `pricePerShare` value updated only upon calling `updatePricePerShare()`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of oracle dependency and its impact on token transfers. This is a specific vulnerability related to oracle reliability, which is not covered in the response list.

---

### **[M-02] Null check in `pricePerShare`**

**Report Description**:
The `pricePerShare` function can return `0`, which would cause division by zero errors in calculations (e.g., in `WrappedIbbtc.sol` L148). This can lead to Denial of Service (DoS) if SafeMath reverts on division by zero.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of null checks in `pricePerShare`. This is a specific vulnerability related to division by zero, which is not covered in the response list.

---

### **[M-03] Hard to clear balance**

**Report Description**:
The contract does not allow users to transfer by share, making it difficult to clear out all shares. As `pricePerShare` increases, users may find it challenging to transfer their entire balance, especially when using tools like Metamask. This is considered a medium-risk issue.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of transferring by share or the difficulty in clearing balances. This is a specific usability and security concern, which is not covered in the response list.

---

### **[M-04] No sanity check on `pricePerShare` might lead to lost value**

**Report Description**:
The `pricePerShare` value is read from an oracle or `ibBTC`'s core without sanity checks. If the oracle or core is bugged or exploited, incorrect `pricePerShare` values could result in the drainage of `wibBTC` from the Curve pool, leading to loss of funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of sanity checks on `pricePerShare`. This is a specific vulnerability related to oracle data validation, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool**
- **[H-02] Approved spender can spend too many tokens**
- **[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers**
- **[M-01] Unable to transfer `WrappedIbbtc` if Oracle goes down**
- **[M-02] Null check in `pricePerShare`**
- **[M-03] Hard to clear balance**
- **[M-04] No sanity check on `pricePerShare` might lead to lost value**

---

The response list does not adequately address the specific vulnerabilities and risks outlined in the issue report. Many critical issues, particularly those related to oracle dependency, token compatibility, and balance management, are entirely missed. The response list focuses on general vulnerabilities (e.g., reentrancy, input validation) but fails to cover the unique and context-specific issues presented in the report.",0,0,7,20,"```
None.
```",0.0
WrappedlbbtcEth.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)
*/
contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.
    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Update live ibBTC price per share from core
    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.
    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",1337.0,164.0,"[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly
Malicious user can monitor `SetPricePerShare` event and, if it was run long enough time ago and market moved, but, since there were no `SetPricePerShare` fired, the contract's `pricePerShare` is outdated, so a user can `mint()` with `pricePerShare` that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.
  [H-04] WrappedIbbtcEth contracts do not filter out price feed outliers
If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.",2.0,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";


contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    
    
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    
    
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",854.0,2,0,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy in `mint` and `burn` Functions**
   - The `mint` and `burn` functions interact with external tokens (`ibbtc.transferFrom` and `ibbtc.transfer`) before updating the contract's state. This could lead to reentrancy attacks if the external token contract is malicious or compromised.

---

### 2. **Lack of Input Validation**
   - The `initialize` function does not validate the input addresses (`_governance`, `_ibbtc`, `_core`). If these addresses are set to zero or invalid addresses, the contract may become unusable or vulnerable to attacks.

---

### 3. **Unrestricted `updatePricePerShare` Function**
   - The `updatePricePerShare` function is `public` and `virtual`, meaning anyone can call it. This could allow malicious actors to manipulate the `pricePerShare` value, affecting the contract's functionality.

---

### 4. **Potential Integer Overflow/Underflow**
   - The contract uses arithmetic operations (e.g., `mul`, `div`) without checking for overflow or underflow. Although Solidity 0.8.x introduced built-in checks, this contract uses Solidity 0.6.12, which does not have these protections.

---

### 5. **Incorrect `transferFrom` Implementation**
   - The `transferFrom` function overrides the ERC20 `transferFrom` but does not correctly handle the `allowance` mechanism. It subtracts `amountInShares` from the allowance instead of `amount`, which could lead to incorrect allowance calculations.

---

### 6. **Incorrect `balanceOf` and `totalSupply` Calculations**
   - The `balanceOf` and `totalSupply` functions multiply by `pricePerShare` and divide by `1e18`. If `pricePerShare` is zero or very small, this could lead to division by zero or incorrect calculations.

---

### 7. **Governance Privilege Escalation**
   - The `setPendingGovernance` and `acceptPendingGovernance` functions allow the governance address to be changed. If the `pendingGovernance` address is compromised or set incorrectly, an attacker could take control of the contract.

---

### 8. **Lack of Event Emission for Critical Actions**
   - Some critical actions, such as `mint` and `burn`, do not emit events. This makes it difficult to track these actions on-chain and could lead to transparency issues.

---

### 9. **Uninitialized State Variables**
   - The `pricePerShare` and `lastPricePerShareUpdate` variables are not initialized in the `initialize` function. If `updatePricePerShare` is not called immediately after deployment, these variables may contain incorrect or stale values.

---

### 10. **Potential Front-Running in Governance Functions**
   - The `setPendingGovernance` and `acceptPendingGovernance` functions are susceptible to front-running attacks. An attacker could intercept the transaction and replace the `pendingGovernance` address with their own.

---

### 11. **Incorrect Use of `now`**
   - The `now` keyword is deprecated in favor of `block.timestamp`. While this is not a critical vulnerability, it is a best practice to use `block.timestamp` for clarity and future compatibility.

---

### 12. **Lack of Access Control for `updatePricePerShare`**
   - The `updatePricePerShare` function can be called by anyone, which could lead to manipulation of the `pricePerShare` value. This function should be restricted to authorized addresses.

---

### 13. **Potential Token Locking in `burn` Function**
   - The `burn` function burns the tokens before transferring the underlying assets. If the transfer fails (e.g., due to insufficient balance), the tokens will still be burned, leading to a loss of funds.

---

### 14. **Incorrect `balanceToShares` and `sharesToBalance` Calculations**
   - The `balanceToShares` and `sharesToBalance` functions multiply and divide by `pricePerShare` without checking if `pricePerShare` is zero. This could lead to division by zero errors.

---

### 15. **Lack of Error Handling for External Calls**
   - The contract does not handle errors from external calls (e.g., `ibbtc.transferFrom`, `ibbtc.transfer`). If these calls fail, the contract may revert without providing meaningful error messages.

---

### 16. **Potential Denial of Service (DoS)**
   - If the `core.pricePerShare()` function reverts or fails, the `updatePricePerShare` function will also revert, potentially causing a denial of service for functions that depend on it.

---

### 17. **Unprotected Initialization**
   - The `initialize` function is not protected from being called multiple times. If an attacker calls it after the initial deployment, they could reset critical state variables.

---

### 18. **Incorrect Use of `_msgSender()`**
   - The contract uses `_msgSender()` in some functions (e.g., `transferFrom`, `transfer`) but does not implement the `Context` contract from OpenZeppelin. This could lead to compatibility issues with meta-transactions.

---

### 19. **Lack of Pause Mechanism**
   - The contract does not have a pause mechanism, making it impossible to stop operations in case of an emergency or vulnerability.

---

### 20. **Incorrect ERC20 Compliance**
   - The `transferFrom` and `transfer` functions override the ERC20 functions but do not fully comply with the ERC20 standard. For example, they do not emit `Transfer` events, which are required by the standard.

---

These vulnerabilities and issues should be addressed to ensure the security and correctness of the smart contract.","### **[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly**

**Report Description**:
The `WrappedIbbtcEth` contract relies on the `pricePerShare` value for `mint` and `burn` operations. If the `updatePricePerShare` function is not called regularly, the `pricePerShare` value may become outdated. A malicious user can monitor the `SetPricePerShare` event and exploit the outdated price by minting tokens at the stale price and burning them after the price is updated, resulting in risk-free profit at the expense of the contract's holdings.

**Match in Response List**:
Matches with the issue titled **""Uninitialized State Variables""** and **""Unrestricted `updatePricePerShare` Function""**.

**Validation**:
**Partially Correct**. The response identifies that `pricePerShare` and `lastPricePerShareUpdate` are uninitialized, which could lead to stale values. However, it does not fully address the exploit scenario where a malicious user can profit from the outdated price. The response also mentions that `updatePricePerShare` is unrestricted, which is relevant but does not cover the full impact of the vulnerability. The issue requires a more detailed mitigation strategy, such as enforcing regular price updates or adding safeguards against stale prices.

---

### **[H-04] WrappedIbbtcEth contracts do not filter out price feed outliers**

**Report Description**:
The `WrappedIbbtcEth` contract does not implement mechanisms to filter out price feed outliers. If the price feed is manipulated or experiences volatility due to market malfunctions, the contract will pass these anomalies directly to users. This creates a substantial attack surface, as malicious actors could exploit price outliers to manipulate the contract's operations. Implementing mitigation mechanics would ensure that only sustainable price movements affect user economics.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of price feed outliers or the lack of filtering mechanisms. This is a significant gap, as price feed manipulation is a critical vulnerability in DeFi contracts. The issue requires specific mitigation strategies, such as implementing price feed validation, using multiple oracles, or adding safeguards against extreme price movements.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly**

**Missed Issues from Issue Report**:
- **[H-04] WrappedIbbtcEth contracts do not filter out price feed outliers**

---

### **Analysis of Gaps**
- The response list does not address the issue of price feed outliers, which is a critical vulnerability in the `WrappedIbbtcEth` contract. This gap highlights the need for additional focus on oracle manipulation and price feed validation in smart contract security reviews.
- While the response list partially covers the issue of stale prices, it does not fully address the exploit scenario or propose comprehensive mitigation strategies. This indicates a need for more detailed analysis and solutions for vulnerabilities related to outdated or manipulated data.",0,1,1,20,"```
None.
```",0.0
,,,,,,,,5,4,,,0,1,8,40,,
