nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Correct Matches,Partially Correct,Missed,GPT-generated,Comparison,matchList,MAP
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using `timeUnlockERC721()`. This is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()). Because of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).   [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval. Impact 1: The approval is not removed (set to false) after a transfer in transferERC721(). So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.
Impact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.
  [H-03] Approval for NFT transfers is not removed after transfer
The `Visor.transferERC721` does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
  [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.
The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time. Recommend using a mapping (e.g., mapping(address=>Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.   [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2. While the contract uses Uniswap’s TransferHelper library function safeTransfer in other places for ERC20 tokens, or OpenZeppelin’s saferTransferFrom for ERC721 tokens (both of which call the token’s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token’s transferFrom() call without checking for its return value.
The impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.
  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).   [M-03] `timelockERC721Keys` could exceed the block size limit
On line 504 of Visor.sol, looping through the `timelockERC721Keys` could exceed the block size limit
Recommend transfer by index instead of token ID",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";


contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

   
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

   
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }


    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }


    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }


    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }


    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }


    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }


    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }


    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,"Alright, I'm looking at this smart contract, and I need to identify all the vulnerabilities. Let's start by understanding what the contract does. It's a UniversalVault that can manage locks and time-locked transactions for both ERC20 and ERC721 tokens.

First, I'll go through each function and see what it does and any potential issues.

**Initialization Functions:**
- The contract uses OpenZeppelin's Initializable, so that's good. There's an initialize() function that set the owner. Not sure if that's an issue, but might be a point to check for setup issues.
- The receive() function is payable, so it accepts ETH. Need to see if that's a vector, like being able to receive ETH without any conditions, which could be a bug if someone can drain the contract.

**Lock and Unlock Functions:**
- The lock() function allows creating a lock for a token, amount, and a permission. It checks if the lock ID exists and either updates the balance or adds a new entry. It also requires the contract has enough balance to cover the lock, which is a good check.
- The unlock() function does the opposite, deducts the balance, or removes the lock if fully unlocked. Here, I notice a possible issue: if the balance is less than the amount, it deletes the lock but doesn't handle partial unlocks, which might be a problem if not fully released.

**RageQuit Function:**
- It interacts with an external IRageQuit contract. Using a separate contract is good, but there's no error handling here. If the delegate isn't a contract or the gas isn't sufficient, it could lead to issues. Also, no check that the _nonce is incremented correctly, which might mean reentrancy risks if not.

**URI and Transfer Functions:**
- The setURI() function is only owner accessible, which is good. Transfer functions like transferERC20(), delegatedTransferERC20() seem to handle approvals and balance checks. But, I notice that in delegatedTransferERC20(), there's an if condition checking if msg.sender is not the owner, but the require statement seems incomplete. It doesn't check if the sender is approved, which could lead to unauthorized transfers.

- The transferERC721() function checks for approvals and also handles time-locked NFTs. There's a loop checking timelockERC721Keys, but if multiple time locks exist, only the first matching one is processed, which could incorrectly handle transfers.

- The onERC721Received() function adds an NFT when a transfer is received, which is correct, but what if the operator isn't OwnedERC721? Not sure, but could be a point to consider.

- The timeLockERC721() function can lock an NFT and transfer it to the contract. It requires generating a key and checking for existing locks, but no check that the recipient is authorized or that the transfer is valid.

- The timeUnlockERC721() function releases the NFT back to the recipient, but requires that the msg.sender is the lock recipient. If not, this could be a problem, but the contract's setup should enforce that.

**EIP712 and Hashing:**
- The getPermissionHash() function uses EIP712 to generate a typed hash. This is good for permissions, but could be a vector if the permissions aren't properly checked.

**Time Locks and Key Management:**
- Both ERC20 and ERC721 have their own time lock structures. The keys are stored in mappings and arrays. Are there any issues with how keys are managed or checked? It seems secure, but maybe if the key mapping isn't enforced properly, duplicates could cause issues.

**Gas Management:**
- The RAGEQUIT_GAS is a constant, but hardcoding gas might not be best practice. Also, no check that sufficient gas is available before calling the delegate's method, which could cause fatal errors if gas is insufficient, leading to overall errors.

**Possible Issues I Spotted:**

1. **Insufficient Checks in transferERC20().**
   - The line `if(msg.sender != _getOwner()) { require(...)` checks if the sender is not the owner, but it seems incomplete. It should check if the sender is allowed to transfer, possibly via erc20Approvals.

2. **Partial Unlock Issue in unlock() Function.**
   - If _locks[lockID].balance > amount, it subtracts. Otherwise, it deletes the lock. But if the balance is less, maybe it should still inform or handle it differently, but I'm not sure if it's a vulnerability since it assumes the lock is only fully unlocked.

3. **RageQuit没有错误处理.**
   - No error handling if the delegate isn't a contract or if the transfer to delegate fails. This could lead to unhandled errors or state issues.

4. **Possible Malformed Key in timelockERC721.**
   - No check that all keys are correctly generated or unique, but the code does check if the key exists, so maybe not an issue.

5. **No Check for Recipient in timeUnlockERC721.**
   - It requires msg.sender is the recipient, but if someone provides a malicious parameter, could that be an issue? Probably not, since the recipient is passed in.

6. **inconsistent Transfer Handling:**
   - The transferERC721() function might incorrectly process the first match in the loop, not all time locks. Need to see if it correctly processes all relevant locks.

7. **MissingPermission in ERC20 Transfer:**
   - The delegateTransferERC20() doesn't check if the msg.sender is allowed to transfer the token.

8. **RageQuit Gas Check:**
   - Doesn't check if the recipient's contract can handle the gas, leading to potential rerolling or errors.

9. **No Check in ragingQuit that the lock exists correctly:**
   - No check that the lockID exists before proceeding, so could result in a missing lock.

10. **Uninitialized variables:**
    - Are there any potential uninitialized state issues? For example, _lockSet and _locks are initially empty, so that's okay.

**Suggested Fixes:**

For each issue, I need to think about how to mitigate them. For example, adding checks in transferERC20 and delegatedTransferERC20 for the sender's approval or race conditions in the unlock function.

Alternatively, maybe there's no issue at all if the checks are sufficient.

Wait, maybe I missed something. Let's re-examine.

- **Delegation Transfer ERC20:**
  The code has `if (msg.sender != _getOwner()) { ... }`, but the condition inside just has a require that erc20Approvals[...] >= amount. However, this is problematic because the if statement is not correctly enclosing the condition. Unlike a typical if statement, it seems to have incorrect syntax, but looking at the code:

  The code has:

  if(msg.sender != _getOwner()) {
    require( erc20Approvals[keccak256( ... )] >= amount, ""Account not approved..."" );
  }

  But this might not be correctly encapsulated. It appears that even if msg.sender is not the owner, the approval is still checked. So, it's possible that unauthorized transfers could occur if the approval is present.

- **Namely, in the code, the condition is incorrectly placed, leading to the approval check happening regardless of whether the sender is the owner or not. So, the check is redundant, and perhaps the code is flawed.

- **RageQuit function:**
  The code doesn't handle cases where the delegate isn't a contract, which could lead to a call to a non-contract address, causing the transaction to fail but leaving the contract in an undefined state. Also, no error handling if the gas is insufficient, which could lead to the transaction failing mid-execution, leaving the contract in an inconsistent state.

- **TimeUnlockERC721 function:**
  It doesn't check that the recipient has the ability to receive the NFT, assuming that the parameters are correct. If someone maliciously calls this function with a wrong recipient, the NFT might be sent to an address that doesn't have the contract, causing a failure, but perhaps this is handled by the operational layer.

- **TransferERC721 function:**
  The loop checks timelockERC721Keys for the given nftContract and tokenId. If the recipient's key exists, it requires the lock to be expired and that the recipient is the current msg.sender. However, if there are multiple time locks, it only checks the first one. But in the code, it loops through timelockERC721Keys[nftContract].length and for each, checks if the tokenId matches and then if the recipient is the current msg.sender.

Wait, the code inside the loop is:

for each key in the nftContract's keys:

   if the tokenId matches, then check if it's expired and the recipient is the msg.sender.

But the code does not break; it continues. So, if a user has multiple time-loks on the same NFT, it would only process the first one and the transaction would proceed past the loop.

Hmm, but the function is transferring the NFT, so it needs to ensure all applicable time locks are handled. Otherwise, if someone else has a pending time lock on the same NFT from another address, this transfer could proceed even if there's a pending lock.

So, that's a vulnerability because the transfer function might proceed even if an NFT is locked by another user.

Alternatively, perhaps the contract doesn't allow sending NFTs if they're time-locked. So, the function is trying to ensure that before transferring, the time-locks are cleared. But the way it's implemented—checking each time key and if any match, proceed with some checks—might not handle all cases correctly.

Finally, after checking all these, I can list the identified vulnerabilities with their reasons and fixes.","**Step-by-Step Explanation and Answer:**

The contract `UniversalVault` implemented in the provided Solidity code has several potential vulnerabilities that could lead to unexpected behavior or security issues. Here is a structured analysis of the identified issues:

1. **Insufficient Approval Check in Delegation Transfer for ERC20 (Potential Denial of Service):**
   - **Issue:** In the `delegatedTransferERC20` function, the condition checks whether `msg.sender` is not the owner but does not correctly encapsulate the approval logic. This results in the approval check being performed regardless of the sender's status.
   - **Impact:** Unauthorized transfers might occur if the sender has been approved but is not the owner.
   - **Fix:** The logic should correctly hinge on whether the sender is authorized, irrespective of ownership. The approval should be checked whether `msg.sender` is in the approved list.

2. **RageQuit Without Proper Error Handling (Potential State Inconsistencies):**
   - **Issue:** The `rageQuit` function lacks error handling for cases where the delegate isn't a contract or if `gas` isn't sufficient. This could leave the contract in an undefined state.
   - **Impact:** Failing mid-execution can lead to inconsistent contract states and potential errors.
   - **Fix:** Implement proper error handling for these edge cases, providing clear error messages and reverting if necessary.

3. **Partial Unlock Without Handling (Potential Balance Mismatches):**
   - **Issue:** The `unlock` function only axes the lock if the balance is exactly matched. If not, it leaves the balance reduced but doesn't inform the owner.
   - **Impact:** This could lead to confusion about the balance state if partial unlocking is intended.
   - **Fix:** Ensure partial unlocking is either supported properly or disallowed, providing clear feedback if only full unlocks are permitted.

4. **TransferERC721 May Process Multiple Time Locks Improperly (Potential NFT Theft):**
   - **Issue:** The transfer function processes each time lock but continues looping after finding a match. This might bypass other valid locks not processed in the first iteration.
   - **Impact:** NFTs might be transferred even if under a pending time lock from another address.
   - **Fix:** Ensure all applicable time locks for the NFT are correctly processed and all locks are removed before transferring.

5. **Missing Check in Time Unlock ERC721 for recipient's Contract (Potential Transfer Failure):**
   - **Issue:** The function assumes the recipient's address is a valid NFT contract. If not, the transfer fails but isn't handled beyond the function's scope.
   - **Impact:** The contract's operational layer might handle this, but it's a potential point of failure.
   - **Fix:** Optionally add a check that the recipient can receive the NFT, providing a revert if not.

6. **RageQuit Gas Check Without Validation (Potential Gas Leak):**
   - **Issue:** The contract doesn't verify that the delegate's contract can handle the specified gas amount before proceeding.
   - **Impact:** Gas could be wasted if the delegate's contract can't handle the gas, potentially causing orphaned transactions.
   - **Fix:** Add a check that the delegate's contract is capable of receiving the specified gas, perhaps via balance checks or interface requirements.

**Conclusion:**

These issues highlight areas where the contract's security could be improved. Each fix would enhance robustness and prevent potential runtime issues, ensuring the contract operates more reliably and securely. However, some issues, like the RageQuit gas handling, might depend on the contract's operational context and may not always be directly fixable in the smart contract alone.",0,0,7,6,"### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:  
The `transferERC721()` function does not delete the `timelockERC721s[key]` entry for an NFT tokenID after transferring it out of the vault. If the same NFT is later moved back into the vault without a timelock, the vault logic still considers it timelocked with the stale recipient address. This causes the `transferERC721()` call to fail unless the owner controls the stale recipient address.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The failure to delete the `timelockERC721s[key]` entry is a critical oversight that can lead to NFTs becoming permanently stuck in the vault. This should be explicitly fixed by ensuring the deletion of the timelock entry after transferring the NFT.

**Suggestions**:  
Add a line in `transferERC721()` to delete the `timelockERC721s[key]` entry after transferring the NFT, similar to the logic in `timeUnlockERC721()`.

---

#### **[H-02] NFT transfer approvals are not removed and cannot be revoked, thus leading to loss of NFT tokens**

**Report Description**:  
NFT transfer approvals set in `approveTransferERC721()` are never reset, and there is no mechanism to revoke them. This allows a compromised delegate to transfer the NFT multiple times without requiring new approvals, leading to potential loss of NFTs.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The lack of a mechanism to revoke approvals is a significant security vulnerability that can lead to NFT theft.

**Suggestions**:  
Implement a function to revoke approvals, such as `revokeTransferERC721()`, and ensure approvals are reset after each transfer in `transferERC721()`.

---

#### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:  
The `transferERC721()` function does not reset the approval for the NFT after transferring it. This allows a delegatee to transfer the NFT multiple times, even if it is deposited back into the vault by a new owner.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The failure to reset approvals after transfers is a critical oversight that can lead to NFT theft.

**Suggestions**:  
Reset the approval for the NFT in `transferERC721()` after the transfer is completed.

---

#### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:  
The `_removeNft` function uses an unbounded loop to iterate through the `nfts` array, which can lead to excessive gas consumption or transaction reverts if the array grows too large. A malicious actor can exploit this by sending many NFTs to the vault, causing griefing or denial of service.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The unbounded loop is a significant vulnerability that can be exploited to disrupt the contract's functionality.

**Suggestions**:  
Replace the unbounded loop with a mapping-based approach (e.g., `mapping(address => Nft[]) nfts`) or add a function for the owner to remove NFTs directly.

---

#### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:  
The `timeLockERC20()` function does not handle the return value of the `transferFrom` call, which could lead to fund loss if the token transfer fails but the vault logic assumes it succeeded.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The failure to handle the return value of `transferFrom` is a medium-severity vulnerability that can lead to accounting discrepancies and fund loss.

**Suggestions**:  
Use `TransferHelper.safeTransferFrom` to handle the return value of `transferFrom` in `timeLockERC20()`.

---

#### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:  
The `transferERC721` function does not clean the `timelockERC721s` mapping, which can lead to stale timelock keys being used later and incorrect administration of available NFTs.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The failure to clean the `timelockERC721s` mapping can lead to incorrect contract state and potential vulnerabilities.

**Suggestions**:  
Add a line in `transferERC721()` to delete the `timelockERC721s[key]` entry after transferring the NFT.

---

#### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:  
Looping through the `timelockERC721Keys` array in `Visor.sol` could exceed the block size limit, leading to transaction failures.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The unbounded loop over `timelockERC721Keys` is a medium-severity vulnerability that can lead to transaction failures.

**Suggestions**:  
Implement a mechanism to transfer by index instead of token ID to avoid unbounded loops.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Insufficient Approval Check in Delegation Transfer for ERC20**

**Response Description**:  
The `delegatedTransferERC20` function does not correctly encapsulate the approval logic, potentially allowing unauthorized transfers.

**Assessment**:  
**Valid Concern**. While not mentioned in the original `issue` report, this is a valid security concern that could lead to unauthorized transfers if not addressed.

---

#### **[R-02] RageQuit Without Proper Error Handling**

**Response Description**:  
The `rageQuit` function lacks error handling for cases where the delegate isn't a contract or if `gas` isn't sufficient, potentially leaving the contract in an undefined state.

**Assessment**:  
**Valid Concern**. This is a valid issue that could lead to inconsistent contract states and should be addressed.

---

#### **[R-03] Partial Unlock Without Handling**

**Response Description**:  
The `unlock` function does not handle partial unlocking properly, potentially leading to balance mismatches.

**Assessment**:  
**Valid Concern**. This is a valid issue that could lead to confusion about the balance state and should be addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**  
- **[H-02] NFT transfer approvals are not removed and cannot be revoked, thus leading to loss of NFT tokens**  
- **[H-03] Approval for NFT transfers is not removed after transfer**  
- **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**  
- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**  
- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**  
- **[M-03] `timelockERC721Keys` could exceed the block size limit**

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Insufficient Approval Check in Delegation Transfer for ERC20**  
- **[R-02] RageQuit Without Proper Error Handling**  
- **[R-03] Partial Unlock Without Handling**  

--- 

This analysis highlights significant gaps in the `response_list` and identifies additional potential issues that were not originally reported. Addressing these issues is crucial for improving the security and functionality of the contract.","```
None.
```",The **Average Precision (AP)** for the query is **0.0**.
