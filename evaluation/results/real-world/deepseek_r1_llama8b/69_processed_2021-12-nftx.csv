nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5808.0,615.0,"[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets
In the NFTXMarketplaceZap.sol contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
“require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance”);""
A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAndSwap721WETH() should return unused weth/eth back to `msg.sender` instead of `to`
function `buyAndSwap721WETH`   [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address
`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] `buyAndSwap1155WETH` Does Not Work As Intended
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873.0,2,4,"Okay, so I need to find all the vulnerabilities in this smart contract. I'm new to this, so I'll start by reading through the code and understanding what each part does.

First, I notice that the contract is using a number of interfaces, like INFTXVault, INFTXFeeDistributor, etc. It's also using different ERC20 and ERC721 tokens. There's also the ReentrancyGuard and Ownable contracts, which might be used for security.

The constructor initializes several immutable variables: WETH, lpStaking, nftxFactory, and sushiRouter. It also sets up the IERC20Upgradeable for WETH to allow maximum approvals, which could be a problem if not managed properly.

Looking at the functions, the first thing that stands out is the receive() function. It's external and payable, which means anyone can send ETH directly to the contract. But there's no check on the caller, which could allow reentrancy attacks if not protected. However, the ReentrancyGuard is present with a nonReentrant modifier, so that might block some forms of reentrancy. But I'm not sure how it's applied here—does the receive() function have it? No, I don't see it. So that's a potential issue. When someone sends ETH to the contract without a function call, the nonReentrant modifier won't be triggered, allowing a reentrancy attack if another function calls an external function.

Next, looking at the mintAndSell721WETH function. It uses msg.value to pay for WETH deposit and then transfers WETH to the next address. The problem here is that WETH is an immutable variable, which might be okay since it's initialized once, but if the WETH balance is mishandled, it could lead to issues. Also, when handling transfers, there might be cases where the contract doesn't correctly handle the ETH balance, leading to overflows or underflows.

In the buyAndSwap721WETH function, it's using IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn); without checking if the transfer is successful. If the token doesn't have enough balance or the transfer fails, it could cause issues in the contract. But since it's external, maybe it's relying on the caller to handle it, but I'm not sure.

The _sellVaultTokenWETH and _sellVaultTokenETH functions use the sushiRouter to swap tokens. The problem here is that these functions don't check if the token balance is sufficient. For example, if the user sends too much WETH or not enough tokens, it could cause issues. Also, if the sushiRouter's functions don't handle the ETH correctly, there could be overflows.

Looking at _swap721 and _swap1155, they handle the transfer of tokens. If the function isn't properly approvals or checks, it could cause issues. For instance, if a user tries to swap more tokens than they have, the contract might not handle that gracefully, leading to errors.

The _buyVaultToken function calls the sushiRouter.swapTokensForExactTokens, which could fail if the token transfer doesn't have enough ETH. There's no check here, which might cause the contract to crash if the transaction fails. Similarly, the _sellVaultTokenWETH and _sellVaultTokenETH functions use sushiRouter functions without checking if the amounts are correct.

The _mint721 and _mint1155 functions transfer and approve ERC721 and ERC1155 tokens. These functions don't check if the user has the right to mint or transfer the tokens. For example, in _mint721, it directly calls transferFromERC721 and approveERC721 without checking if the caller is authorized, which could allow minting to any address, leading to issues.

In _redeem, it's sending tokens directly to an address without checking if the caller has the right to redeem them, which could lead to tokens being transferred incorrectly or to malicious addresses.

Another issue is that the constructor sets up the WETH token with a max approval, which could be problematic if the contract doesn't properly manage its WETH holdings, leading to overapprovals or insider attacks if someone can call the approve function multiple times.

Also, the use of immutable variables like WETH and sushiRouter could lead to issues if those contracts themselves are faulty or their storage changes. Since the contract can't update these, any changes in them could affect the contract's functionality.

So, summarizing the possible vulnerabilities:

1. Reentrancy attack via receive() since it's callable externally without the ReentrancyGuard.
2. Potential uninitialized or incorrectly managed WETH approvals.
3. Lack of checks in certain functions when interacting with external contracts (like sushiRouter) leading to unexpected failures.
4. Missing checks in minting functions that bypass authorization.
5. Possible overflow issues when handling ETH and token amounts.
6. Trust in immutable contracts like WETH and sushiRouter, which might not be under control.
7. Lack of checks when selling vault tokens, potentially leading to negative balances or insufficient funds.

I think I need to structure these into clear categories to present them as vulnerabilities.","**Vulnerabilities in the Smart Contract**

1. **Reentrancy Attack Risk**
   - **Function:** `receive()`
   - **Issue:** The `receive()` function is payable and does not employ the `nonReentrant` modifier, making it susceptible to reentrancy attacks. This can allow attackers to repeatedly call external functions within the contract's `nonReentrant`-protected functions, leading to unintended transactions.
   - **Remediation:** Implement the `nonReentrant` modifier in the `receive()` function to block reentrancy.

2. **Improper Authorization in Minting Functions**
   - **Functions:** `_mint721()`, `_mint1155()`
   - **Issue:** The functions `transferFromERC721()` and `approveERC721()` lack checks to ensure the caller is authorized to transfer or approve the NFTs. This can allow any address to mint or transfer tokens if the functions are called without proper authorization.
   - **Remediation:** Add authorization checks to ensure only the contract owner or designated modules can perform these actions.

3. **Insufficient Checks When Interacting with External Contracts**
   - **Functions:** `_sellVaultTokenETH()`, `_sellVaultTokenWETH()`, `_buyVaultToken()`
   - **Issue:** These functions interact with the `sushiRouter` without verifying if the token balances or transaction conditions are met, potentially leading to failures such as insufficient ETH or token supplies.
   - **Remediation:** Add checks to confirm that token balances are sufficient and transactions are feasible before proceeding.

4. **Uninitialized or Mismanaged WETH Approval**
   - **Constructor Issue:**
   - **Issue:** The constructor sets up the WETH token with a maximum approval, which could be problematic if the contract's WETH balance isn't properly managed, leading to overapproval issues or potential exploits.
   - **Remediation:** Ensure that WETH approvals are dynamically adjusted based on the contract's actual holdings and revoke unnecessary approvals when they're no longer needed.

5. **Lack of Checks During Token Sales**
   - **Functions:** `mintAndSell721WETH()`, `buyAndSwap721WETH()`, etc.
   - **Issue:** These functions transfer WETH to the contract without checking if the transfer is valid, which could lead to issues if the WETH balance is insufficient or if the transfer fails.
   - **Remediation:** Implement checks on WETH balance and transfer success before proceeding.

6. **Potential Overflows in Ethereum Handling**
   - **Functions:** Many functions handle ETH and token balances without sufficient overflow checks.
   - **Issue:** This can lead to numeric overflows or underflows, causing unexpected behavior or contract crashes.
   - **Remediation:** Use standard libraries or manual overflow checks to prevent numeric errors.

7. **Trust in Immutable Contracts**
   - **Noted Contracts:** `WETH`, `sushiRouter`
   - **Issue:** Since these contracts are immutable, the NFTXMarketplaceZap cannot update or fix issues in them, potentially leading to unforeseen problems if they malfunction.
   - **Remediation:** Verify the immutability and trustworthiness of dependency contracts to ensure they're reliable and secure.

8. **Unchecked ERC721 and ERC1155 Transfers**
   - **Functions:** `transferFromERC721()`
   - **Issue:** The function transfers tokens without verifying the caller's ownership, allowing potential spoofing or unauthorized transfers.
   - **Remediation:** Include checks to confirm the caller is the token's owner before allowing transfers.

9. **Potential Token Mismanagement in Swaps**
   - **Functions:** `_swap721()`, `_swap1155()`
   - **Issue:** These functions handle token swaps without ensuring the correct number of tokens are being transferred or that the swap is valid.
   - **Remediation:** Ensure accurate token counts and validate each step of the swap process to prevent errors.

These vulnerabilities highlight key areas where the contract's security could be compromised. Addressing each of these would strengthen the contract's resilience against attacks and ensure its operations are reliable.","### **Analysis of Alignment Between Issue Report and Response List**

---

#### **[H-01] `buyAndSwap1155WETH()` Function May Cause Loss of User Assets**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap.sol` uses WETH provided by the user to exchange VaultToken. However, the `_buyVaultToken` method uses `msg.value` instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, potentially causing a loss of user assets.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. This is a critical vulnerability as it directly impacts the functionality of the contract and could lead to user asset loss. The response list does not mention this issue or provide any remediation.

**Suggestions**:  
The `_buyVaultToken` method should be modified to use `maxWethIn` instead of `msg.value` to ensure the function works as intended.

---

#### **[H-03] A Vault Can Be Locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user owning a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is achieved by transferring any amount > 0 of a vault’s vToken to the marketplace or staking zap contracts, causing the balance check to fail and rendering the vault functionality unavailable.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. It is a significant security concern as it allows a single malicious user to disrupt the functionality of the contract for all users.

**Suggestions**:  
Implement additional checks or mechanisms to prevent users from transferring vTokens directly to the marketplace or staking zap contracts.

---

#### **[M-01] Missing Non-Reentrancy Modifier**

**Report Description**:  
Several functions are missing the `nonReentrant` modifier, even though other public/external functions use it. While no exploit was identified, the absence of the modifier in these functions could pose a reentrancy risk.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Attack Risk""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the reentrancy risk in the `receive()` function but does not address the broader issue of missing `nonReentrant` modifiers in other functions.

**Suggestions**:  
Apply the `nonReentrant` modifier to all functions that interact with external contracts or handle funds to mitigate reentrancy risks.

---

#### **[M-03] `buyAndSwap721WETH()` Should Return Unused WETH/ETH Back to `msg.sender` Instead of `to`**

**Report Description**:  
The `buyAndSwap721WETH` function should return unused WETH/ETH back to `msg.sender` instead of `to`. This ensures that the user who initiated the transaction receives any leftover funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. It is a logical error that could lead to user dissatisfaction or confusion.

**Suggestions**:  
Modify the function to return unused funds to `msg.sender` instead of `to`.

---

#### **[M-04] NFTXStakingZap and NFTXMarketplaceZap's `transferFromERC721` Transfers Cryptokitties to the Wrong Address**

**Report Description**:  
The `transferFromERC721` function transfers Cryptokitties to `address(this)` instead of `to`. This is a mistake that leads to incorrect NFT accounting, as the NFT will be missed in the vault.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. It is a logical error that could lead to incorrect NFT accounting and user dissatisfaction.

**Suggestions**:  
Modify the `transferFromERC721` function to transfer Cryptokitties to the correct address (`to`).

---

#### **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` uses `msg.value` instead of `maxWethIn` in the `_buyVaultToken` call. As a result, the function will not work unless the user supplies both WETH and native ETH amounts equivalent to `maxWethIn`.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. It is a critical functional error that prevents the function from working as intended.

**Suggestions**:  
Modify the `_buyVaultToken` call to use `maxWethIn` instead of `msg.value`.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Recommendation to Implement Circuit Breaker Pattern**

**Response Description**:  
The response suggests implementing a circuit breaker pattern to halt contract operations in case of detected anomalies or emergencies, enhancing the contract's ability to respond to unforeseen issues.

**Assessment**:  
**Valid Concern**. While this issue was not mentioned in the original `issue` report, incorporating a circuit breaker pattern is a recognized best practice in Solidity to enhance contract security and resiliency. It provides an emergency stop mechanism, which can be crucial in mitigating damage during an attack or malfunction.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-01] Missing Non-Reentrancy Modifier** (partially correct)

**Partially Correct Matches**:  
- **[M-01] Missing Non-Reentrancy Modifier**

**Missed Issues from Issue Report**:  
- **[H-01] `buyAndSwap1155WETH()` Function May Cause Loss of User Assets**  
- **[H-03] A Vault Can Be Locked from MarketplaceZap and StakingZap**  
- **[M-03] `buyAndSwap721WETH()` Should Return Unused WETH/ETH Back to `msg.sender` Instead of `to`**  
- **[M-04] NFTXStakingZap and NFTXMarketplaceZap's `transferFromERC721` Transfers Cryptokitties to the Wrong Address**  
- **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

--- 

The `response_list` addresses some vulnerabilities but misses several critical issues identified in the `issue` report. Additional attention is required to ensure all vulnerabilities and logical errors are appropriately remediated.",1,0,5,9,"```
None.
```",0.0
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672.0,172.0,"[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the `_sendForReceiver` function.
In the `_sendForReceiver` function, when `_receiver` is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
 
[M-02] `addReceiver()`: Failure to check for existing receiver
The `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
  [M-10] `_sendForReceiver` doesn't return success if receiver is not a contract
Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in `_sendForReceiver`
The `_sendForReceiver()` function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
  [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the `_sendForReceiver` function to distribute the fee In the `_sendForReceiver` function, when the `_receiver` is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605.0,1,5,"Okay, I'm trying to analyze this Solidity smart contract to identify potential vulnerabilities. I'll start by reading through the code carefully and see what each part does.

First, the contract is a `NFTXSimpleFeeDistributor` which seems to handle distributing fees to different receivers. It's using several interfaces like `INFTXLPStaking` and `INFTXInventoryStaking`, so I need to think about how those interact with the main contract.

The contract has several state variables, including `distributionPaused`, `treasury`, `lpStaking`, `inventoryStaking`, and an array `feeReceivers`. The `distributionPaused` is a boolean, probably to control whether fee distribution is active.

Looking at the `__SimpleFeeDistributor__init` function, it initializes the contract with the given LP staking and treasury addresses, and adds a receiver. The `addReceiver` method is called here with 0.8 ether, but I wonder if using a fixed amount is a problem. Maybe the allocation point should be configurable to avoid hardcoding.

The `distribute` function is external and non-reentrant. It checks if the distribution is paused or if there's no allocation to distribute. If so, it sends the balance to the treasury. Then, it loops through each fee receiver, calculates the amount to send, and calls `_sendForReceiver`.

In the `_sendForReceiver` method, there's a check for whether the receiver is a contract. If it is, it creates a payload using `abi.encodeWithSelector` for `INFTXLPStaking.receiveRewards` and sends it to the receiver's address. Then, it checks if the allowance is zero and returns success or failure. Otherwise, if the receiver is not a contract, it uses `safeTransfer`.

I notice there's a `rescueTokens` function that allows transferring tokens from an address to the caller. This could be risky because if someone calls this maliciously, it might drain funds. I should check if this is necessary or if it can be a vulnerability.

Looking at the modifiers, only the owner can call `pauseFeeDistribution` and functions like `addReceiver`, `changeReceiverAlloc`, etc. However, not all functions like `changeReceiverAddress` or `removeReceiver` seem to have proper limits.

The `addReceiver` and `changeReceiverAddress` functions modify the array of fee receivers. If these operations aren't guarded carefully, an attacker could manipulate the allocation points or add malicious receivers.

Another area is the `INFTXLPStaking` interaction in `_sendForReceiver`. It uses `abi.encodeWithSelector` to call `receiveRewards`, but this might not be secure. If an attacker creates a fake contract that mimics `INFTXLPStaking`, the payload could be sent there instead, leading to reentrancy attacks.

The `distribute` function has a for loop over fee receivers. If the `feeReceivers` array is large, processing each could consume resources, but that's probably not a major issue. However, if any receiver could manipulate the loop, it could lead to issues.

The storage of `Treasury`, `LPStaking`, and `InventoryStaking` as direct addresses might expose them to changes via these variables, but without seeing their specific implementation, it's hard to say. If they're being called externally, they might be susceptible to reentrancy.

The `rescueTokens` function is a clear security risk; it's a way for the contract to transfer tokens from any address. This could be used by an attacker to steal funds by providing a malicious address.

Looking at the use of `SafeERC20Upgradeable` and other utility contracts, it's good for safe token handling. But if any of the other contracts don't use these, it could lead to vulnerabilities.

So, summarizing the potential issues:

1. **Hardcoded Allocation Point**: The initial addition of a fee receiver with 0.8 ether is fixed, which might not be flexible and could lead to unintended allocations if the contract's parameters aren't adjustable.

2. **RescueTokens Function**: Allowing any address to retrieve tokens can be a vector for draining funds, especially if called from an external malicious contract.

3. **INFTXLPStaking Interaction**: Using `abi.encodeWithSelector` without proper validation can lead to reentrancy attacks if the receiver is a malicious contract that mimics the interface.

4. **Fee Distribution Loop**: If the loop over feeReceivers isn't properly guarded, an attacker could potentially manipulate it to cause issues.

5. **Extra Ownable Functions**: The contract uses several modifiers like `onlyOwner`, but ensuring all such functions are checked for is important.

6. **Reentrancy Risk in Distribution**: Since `distribute` is non-reentrant, but if `INFTXLPStaking` implements a reentrancy-safe `receiveRewards`, the call shouldn't cause issues. However, if not, could be a problem.

I think points 1, 2, and 3 are the most critical. The rescueTokens can be a significant issue. The hardcoded allocation in the initialize method is risky, especially if the default parameters aren't flexible. The interaction with the LPStaking could expose the contract if the LPStaking isn't secure.

So, the vulnerabilities I should list would include rescueTokens being a direct token drain, the INFTXLPStaking interaction risk, and the hardcoding issue.","The `NFTXSimpleFeeDistributor` smart contract contains several vulnerabilities that could expose the system to risks such as token theft, reentrancy attacks, and unintended fee distribution. Below are the identified vulnerabilities along with their explanations:

---

### 1. **Token Drain Vulnerability (rescueTokens Function)**
   - **Issue:** The `rescueTokens` function allows any caller to transfer tokens from any address to themselves. This can be used maliciously to drain tokens from the contract.
   - **Explanation:** The function retrieves the balance of tokens at the given address and transfers them to the sender. Without proper access control or validation, this can be exploited to steal tokens from connected contracts or addresses.

---

### 2. **Reentrancy Attack Risk (INFTXLPStaking Interaction)**
   - **Issue:** The `_sendForReceiver` function sends a payload to a smart contract address using `abi.encodeWithSelector` for `INFTXLPStaking.receiveRewards`. If the receiver is a malicious contract that mimics the interface, it could cause reentrancy, leading to unintended transactions.
   - **Explanation:** The method assumes the called contract is valid, but without proper validation, malicious contracts can exploit this to cause the original contract to enter an infinite loop or execute unwanted operations.

---

### 3. **Hardcoded Allocation Point in Initialization**
   - **Issue:** The constructor initializes a fee receiver with a fixed allocation point of 0.8 ether. This hardcoding limits flexibility and could lead to unintended distribution if not properly adjusted.
   - **Explanation:** If the contract is modified or upgraded, altering this fixed value is required, which might be overlooked, leading to inefficient or incorrect fee distributions in the future.

---

### 4. **Inadequate Access Control in Modifier Functions**
   - **Issue:** Several functions are marked with `onlyOwner`, ensuring only the owner can execute them. However, in more complex contracts, additional checks or constraints may be necessary to prevent unintended operations.
   - **Explanation:** While the existing checks are good, without further validation, they might not be sufficient in more intricate scenarios or if the contract is extended.

---

### 5. **Potential for Manipulation in Fee Distribution Logic**
   - **Issue:** The `distribute` function iterates over each fee receiver and calculates the amount to send, potentially allowing malicious receivers or the system itself to be manipulated if the logic isn't robust.
   - **Explanation:** If the contract is misused to alter receipt of funds or exploit the looping mechanism, it could lead to financial losses or incorrect fee allocations.

---

### Mitigation and Recommendations:
1. **Remove or Secure the `rescueTokens` Function:** This function is a clear risk and should be removed or, if necessary, have stricter access controls.
2. **Validate Contract Addresses in `_sendForReceiver`:** Before interacting with external contracts, verify their authenticity to prevent reentrancy.
3. **Flexibility in Initialization Parameters:** Allow users to set allocation points and other parameters without hardcoding.
4. **Ensure Access Control is Robust:** Enforce stricter checks, especially if the contract is used in more complex or high-stakes environments.
5. **Review Loop Logic in `distribute`:** Ensure the loop over fee receivers is secure and not exploitable.

By addressing these vulnerabilities, the contract can become more secure against common smart contract risks.","### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**

**Report Description**:  
The `_sendForReceiver` function in `NFTXSimpleFeeDistributor.sol` does not return a value when the receiver is not a contract, causing the `distribute` function to incorrectly assume the fee transfer failed. This results in double payments to receivers and potential depletion of funds for later receivers in the list.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. The response list focuses on other vulnerabilities but does not mention the incorrect handling of return values in `_sendForReceiver`. This is a critical oversight, as it directly impacts the contract's fee distribution logic.

**Suggestions**:  
The `_sendForReceiver` function should explicitly return `true` when the transfer is successful, even for non-contract receivers. This ensures the `distribute` function correctly tracks the status of fee transfers.

---

#### **[M-01] Missing non reentrancy modifier**

**Report Description**:  
Several functions in the contract lack the `nonReentrant` modifier, even though other functions use it. This inconsistency could expose the contract to reentrancy attacks, although no direct exploit path was identified.

**Match in Response List**:  
**No match found**.

**Validation**:  
The `response_list` does not address the absence of the `nonReentrant` modifier in certain functions. While it mentions reentrancy risks in the context of `_sendForReceiver`, it does not generalize this concern to other functions.

**Suggestions**:  
Apply the `nonReentrant` modifier to all external/public functions that interact with external contracts or transfer funds to mitigate reentrancy risks.

---

#### **[M-02] `addReceiver()`: Failure to check for existing receiver**

**Report Description**:  
The `addReceiver` function does not verify if a receiver already exists in the list, potentially leading to duplicate entries and erroneous fee distributions.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not mentioned in the `response_list`. The response list does not address the lack of validation in the `addReceiver` function, which could lead to unintended fee distribution behavior.

**Suggestions**:  
Add a check in the `addReceiver` function to ensure that the receiver does not already exist in the list before adding them.

---

#### **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**

**Report Description**:  
The `_sendForReceiver` function does not return `true` when the receiver is not a contract, causing the `distribute` function to incorrectly assume the transfer failed. This leads to double payments and potential depletion of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. The response list does not mention the incorrect handling of return values in `_sendForReceiver`, which is a critical flaw in the fee distribution logic.

**Suggestions**:  
Modify the `_sendForReceiver` function to explicitly return `true` for successful transfers, regardless of whether the receiver is a contract or an EOA.

---

#### **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Report Description**:  
The `_sendForReceiver` function only sets a return value in the ""if"" block, not the ""else"" block. If the ""else"" block is executed, the function implicitly returns `false`, leading to incorrect fee distribution behavior.

**Match in Response List**:  
**No match found**.

**Validation**:  
This issue is not addressed in the `response_list`. The response list does not mention the incomplete return logic in `_sendForReceiver`, which is a significant oversight.

**Suggestions**:  
Ensure the `_sendForReceiver` function explicitly returns `true` in both the ""if"" and ""else"" blocks to correctly indicate the success of the transfer.

---

#### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:  
If a malicious receiver reverts the `receiveRewards` function, the `distribute` function will fail, leading to a denial of service (DoS) for all subsequent receivers.

**Match in Response List**:  
**Partially Correct**. The response list mentions the risk of reentrancy in `_sendForReceiver` but does not explicitly address the DoS risk caused by malicious receivers.

**Validation**:  
The response list identifies the reentrancy risk but does not fully address the DoS risk. The issue of malicious receivers reverting the `receiveRewards` function is not explicitly mentioned.

**Suggestions**:  
Implement a mechanism to handle reverts from external calls, such as using a try-catch block, to prevent DoS attacks.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Token Drain Vulnerability (rescueTokens Function)**

**Response Description**:  
The `rescueTokens` function allows any caller to transfer tokens from any address to themselves, potentially enabling token theft.

**Assessment**:  
**Valid Concern**. While this issue was not mentioned in the original `issue` report, the `rescueTokens` function poses a significant security risk if not properly secured. It should be restricted to authorized users or removed entirely.

---

#### **[R-02] Hardcoded Allocation Point in Initialization**

**Response Description**:  
The constructor initializes a fee receiver with a fixed allocation point of 0.8 ether, limiting flexibility and potentially leading to incorrect fee distributions.

**Assessment**:  
**Valid Concern**. Hardcoding values in the constructor reduces the contract's flexibility and could lead to unintended behavior if not properly managed. This is a valid design consideration.

---

#### **[R-03] Inadequate Access Control in Modifier Functions**

**Response Description**:  
The `onlyOwner` modifier is used, but additional checks may be necessary to prevent unintended operations in more complex scenarios.

**Assessment**:  
**Valid Concern**. While the `onlyOwner` modifier provides basic access control, stricter validation may be required in high-stakes environments to prevent misuse.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**Missed Issues from Issue Report**:  
- **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**  
- **[M-01] Missing non reentrancy modifier**  
- **[M-02] `addReceiver()`: Failure to check for existing receiver**  
- **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**  
- **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

--- 

The `response_list` fails to address most of the issues identified in the `issue` report, focusing instead on other vulnerabilities. This highlights significant gaps in the response's alignment with the reported issues.",1,0,5,5,"```
None.
```",0.0
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750.0,561.0,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock
The default value of `inventoryLockTime` in NFTXStakingZap is 7 days while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in XTokenUpgradeable.
The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in NFTXInventoryStaking`",2.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033.0,0,2,"Alright, I'm trying to figure out the vulnerabilities in this smart contract. Let's go through it step by step.

First, I notice that the contract is an NFTXVaultUpgradeable, which interacts with several other modules like INFTXVaultFactory, INFTXEligibilityManager, and INFTXFeeDistributor. It also uses various upgradeable proxies, which is a good security practice.

Looking at the constructor, it initializes a lot of settings and the vault ID. But I'm worried about how the vault ID is set. It's derived from the factory's current vault count, which means if someone deploys a new vault before this one, there might be a number that's not expected. That could lead to duplicate IDs or mismanagement. So, maybe the way vault IDs are handled is a problem.

Next, there's a thing called `FINALIZEVAULT`, which sets the manager to address 0. If the manager is crucial for managing the vault, maybe someone could exploit this by using a malicious address to take control. But wait, the function is marked as external, so it depends on who has the deployment privileges, which might be under controlled access. Still, it's something to keep an eye on.

The `setManager` function allows changing the manager, but only via a privileged call. That seems okay since it's protected, but I should note that the manager has significant control.

Looking into minting, the function `mint` requires `enableMint` to be true. However, the `enableMint` is a boolean that can be set by `setVaultFeatures`. The problem could be that if `enableMint` is set without proper checks, it might allow anyone to mint NFTs even when it's not supposed to be enabled. But since the function `setVaultFeatures` is also protected by `onlyPrivileged`, maybe it's not a direct vulnerability.

Moving on to minting fees, the contract calculates fees based on the amount minted. But if the fee calculation isn't properly validated, it might allow for underpayment or overpayment scenarios. However, the `mintFee` function seems to correctly fetch from the factory, so maybe it's more about how these fees are enforced rather than the calculation itself.

Redeeming NFTs has some interesting parts. The function `redeem` allows either specific IDs or random IDs, but it checks if `enableRandomRedeem` is true. If this flag is enabled without proper controls, users could redeem random NFTs without proper validation, which could lead to duplicates or unintended redistribution. But again, `enableRandomRedeem` is set via `setVaultFeatures`, which is privilege-controlled, so maybe it's a design choice rather than a security flaw.

Swap functionality is another area. The `swap` function allows swapping NFTs based on flags like `enableRandomSwap`. Similar to redeeming, without proper checks, users might swap unintended NFTs. However, the same flag setting applies, which is secure if only privileged addresses can change these flags.

Looking at the flash loans, the function is overridden and only responds with a boolean. I'm not sure if this is a full vulnerability, but if the FlashBorrower isn't properly authenticated, it might pose risks. However, it uses the standard `IERC3156FlashBorrowerUpgradeable`, so maybe it's following best practices.

The `setFees` function allows changing fees, but it's again only accessible via `onlyPrivileged`, which is secure. However, if the fee structure isn’t validated correctly, it might lead to issues, but I don’t see a direct vulnerability here.

The `allValidNFTs` function checks eligibility based on whether `allowAllItems` is true or if the IDs pass the eligibility check. If this doesn’t handle malicious data correctly, it might allow invalid NFTs to be transferred. But with the `INFTXEligibilityManager`, it's supposed to handle that.

Cross-module interactions are significant. The contract interacts with multiple modules, and if any of those modules have vulnerabilities, it could affect the overall system. But the contract itself seems to be calling these modules securely, within their designed interfaces.

One potential issue I spot is with the `getRandomTokenIdFromVault` function. It uses `keccak256` with a nonce to generate a random index. But if someone can manipulate the hash or the internal state (like `randNonce` being mutable), they might predict the random index, leading to duplicated IDs or controlled distributions. However, since the nonce is incremented each time, it's somewhat secure, but if the function is called in a way that allows external actors to influence the hash, it could be problematic.

Another point is how the contract handles the manager and eligibility. If the manager is compromised or the eligibility checks are bypassed, it could lead to misuse. For example, if `allowAllItems` is set to true without proper authorization, any user could mint or redeem any NFT, bypassing eligibility checks. But this is controlled by the `setVaultFeatures` function which requires privilege.

Lastly, the contract uses ENCRYPTED storage for just the `UNUSED_FEE1`, `UNUSED_FEE2`, and `UNUSED_FEE3` variables. This might be a security measure, but if more sensitive data is stored this way, it could be a problem.

Overall, the vulnerabilities seem to revolve around how the contract allows changing features via `setVaultFeatures` and the potential for privilege escalation or incorrectly handling random IDs. It’s important to ensure that all feature flags are tightly controlled and that the random ID mechanism is robust against manipulation.","The smart contract in question, `NFTXVaultUpgradeable`, is designed with several security features, including using upgradeable proxies and ensuring certain functionalities are restricted to privileged addresses. However, there are a few potential vulnerabilities and areas that could be improved:

1. **Vault ID Assignment**:
   - **Issue**: The `vaultId` is assigned based on the current count from the factory, which could lead to unexpected behavior if not properly managed.
   - **Fix**: tattoos should be uniquely assigned by the contract rather than derived from the factory's count.

2. **Manager Control**:
   - **Issue**: The `setManager` function allows changing the manager, which could potentially be misused if not correctly handled.
   - **Fix**: Ensure that the manager’s ability to change does not introduce any security risks.

3. **Minting and Eligibility Bypass**:
   - **Issue**: If the `enableMint` flag is set incorrectly, it could allow unintended minting without proper checks.
   - **Fix**: Ensure that `enableMint` is only set by authorized personnel via secure functions.

4. **Redeem and Swap Function Risks**:
   - **Issue**: The functions allow for either specific or random ID Redeeming/Swap, which could be misused if not properly validated.
   - **Fix**: Ensure that random ID selection is robust and not exploitable.

5. **Random ID Generation**:
   - **Issue**: The `getRandomTokenIdFromVault` function may be predictable, leading to duplicate IDs or unintended distributions.
   - **Fix**: Implement a more secure random number generator that is less predictable and less susceptible to manipulation.

6. **Cross-Module Interaction**:
   - **Issue**: The contract interacts with multiple modules, each of which could have vulnerabilities. A compromise in any module could affect the functionality of the entire system.
   - **Fix**: Ensure that all external modules are rigorously tested for vulnerabilities.

7. **Insufficient Validation in Fee Distribution**:
   - **Issue**: The fee distribution logic might not sufficiently validate users, potentially allowing underpayment/overpayment.
   - **Fix**: Implement more checks to ensure fees are correctly applied based on the number of NFTs transferred.

8. **Exposure of Fees Variables**:
   - **Issue**: The fee variables are exposed as view functions, but they might not be fully protected.
   - **Fix**: Ensure that fee data is only accessible via secure channels or protected by internal checks.

**Summary**:
The identified issues center around the potential manipulation of features via misconfigured flags, the risk of predicting random IDs, and the reliance on external modules. While the contract employs several security measures like upgradeable proxies and privilege checks, the vulnerabilities mentioned highlight areas where the contract could be more secure. Addressing these through more robust flag controls, better random ID generation, and thorough testing of external modules would enhance the contract's security.","### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:  
The Pool Manager can front-run the entry fee to 100%, which could result in users losing all their deposits. Specifically, if a large deposit is made, the admin could front-run the transaction and set the fee to the maximum value (`uint(1 ether) = 10**18`), effectively stealing the entire deposit. This is a significant risk, especially when dealing with untrusted users or malicious actors.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is **completely unaddressed** in the `response_list`. The response list does not mention or provide any fixes for the front-running vulnerability related to fee manipulation by the Pool Manager. This is a critical oversight, as the issue poses a high risk to user funds.

**Suggestions**:  
To mitigate this issue, the contract should implement mechanisms to prevent front-running, such as:  
1. **Fee Change Timelocks**: Introduce a delay before fee changes take effect, allowing users to react or withdraw funds.  
2. **Fee Caps**: Limit the maximum fee that can be set to a reasonable percentage of the deposit.  
3. **User Consent**: Require explicit user consent for fee changes, especially for large deposits.  

---

### **[M-09] Bypass zap timelock**

**Report Description**:  
The default value of `inventoryLockTime` in `NFTXStakingZap` is 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. The applicable timelock is calculated as `block.timestamp + timelockLength`, even when the existing timelock is further in the future. This allows an attacker to reduce their long timelock (e.g., 7 days) to 2 ms by calling `deposit` in `NFTXInventoryStaking`, effectively bypassing the intended timelock mechanism.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is **completely unaddressed** in the `response_list`. The response list does not mention or provide any fixes for the timelock bypass vulnerability. This is a significant oversight, as it undermines the security and intended functionality of the timelock mechanism.

**Suggestions**:  
To address this issue, the contract should:  
1. **Enforce Maximum Timelock**: Ensure that the timelock cannot be reduced below a minimum threshold.  
2. **Track Original Timelock**: Store the original timelock value and prevent it from being overridden by shorter timelocks.  
3. **Audit Timelock Logic**: Review and test the timelock implementation to ensure it behaves as intended.  

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-01] Vault ID Assignment**  

**Response Description**:  
The `vaultId` is assigned based on the current count from the factory, which could lead to unexpected behavior if not properly managed.  

**Assessment**:  
**Valid Concern**. While this issue was not mentioned in the original `issue` report, improper management of `vaultId` assignment could lead to conflicts or unexpected behavior. Ensuring unique and secure assignment of `vaultId` is a good practice.  

---

**[R-02] Manager Control**  

**Response Description**:  
The `setManager` function allows changing the manager, which could potentially be misused if not correctly handled.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the original `issue` report, but improper handling of manager changes could introduce security risks. Implementing access control and timelocks for such changes is recommended.  

---

**[R-03] Minting and Eligibility Bypass**  

**Response Description**:  
If the `enableMint` flag is set incorrectly, it could allow unintended minting without proper checks.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the original `issue` report, but improper handling of the `enableMint` flag could lead to unauthorized minting. Ensuring strict access control for such flags is crucial.  

---

**[R-04] Random ID Generation**  

**Response Description**:  
The `getRandomTokenIdFromVault` function may be predictable, leading to duplicate IDs or unintended distributions.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the original `issue` report, but predictable random ID generation could lead to exploitation. Implementing a secure and unpredictable random number generator is essential.  

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*  

**Partially Correct Matches**:  
- *None*  

**Missed Issues from Issue Report**:  
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**  
- **[M-09] Bypass zap timelock**  

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Vault ID Assignment**  
- **[R-02] Manager Control**  
- **[R-03] Minting and Eligibility Bypass**  
- **[R-04] Random ID Generation**  

--- 

**Conclusion**:  
The `response_list` fails to address the two critical issues identified in the `issue` report, leaving significant vulnerabilities unmitigated. Additionally, the `response_list` introduces several potential issues that, while valid, were not part of the original report. Addressing the missed issues and implementing the suggested fixes is essential to ensure the contract's security and functionality.",0,0,2,8,"```
None.
```",0.0
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4828.0,479.0,"[M-08] Low-level call return value not checked
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,0,1,"Okay, I need to list all the vulnerabilities in the given smart contract. There's no need for mitigations, just the vulnerabilities.

First, I should start by understanding the structure of the contract. It's a smart contract written inSolidity 0.8.0. Let's look at the imports, interfaces, and the main contract.

The contract is called NFTXStakingZap and inherits from Ownable, ReentrancyGuard, ERC721HolderUpgradeable, and ERC1155HolderUpgradeable. It has some immutable external tokens like WETH, lpStaking, inventoryStaking, nftxFactory, and sushiRouter.

Looking at the constructor, it initializes several dependencies. The ReentrancyGuard is used, but I should check if it's properly configured to prevent reentrancy attacks.

Next, I'll examine the functions. There are several functions like setLPLockTime and setInventoryLockTime, which seem fine. The provideInventory721 and provideInventory1155 functions involve minting tokens and handling transfers, which could be points of interest.

Now, the addLiquidity functions are concerning. They handle adding liquidity to Uniswap pools, which might involve routing attacks or token improperly handled. The fact that they are marked as payable makes them a target for routing, especially since they accept ETH directly.

Looking at the _addLiquidityAndLock function, it's internal and returns liquidity, which could be exploited if there's a mistake in how the liquidity is handled. The use of WETH.deposit made me think about possible price manipulation or overflows if WETH isn't properly managed.

Another area is the transferFromERC721 and approveERC721 functions. These interact with external ERC721 tokens like the ones from NFT projects. Any interaction here could be a vector if not handled correctly, such as not checking if the sender is authorized or if the transfer is valid.

The pairFor function uses an external library, which might introduce vulnerabilities if the library isn't trust-worthy. Also, the sortTokens function contains some logic to compare token addresses, but I should check if it's correctly implemented and not prone to errors.

The rescue function allows the owner to retrieve tokens, but this could be a security hazard if not properly guarded against, such as during a reentrancy attack.

Additionally, I need to check the overall structure for possible reentrancy issues. Each function is marked with nonReentrant, but I should make sure every payable function is properly guarded.

I also notice that some of the functions use external calls, like to IUniswapV2Router and IERC20Upgradeable, which could be points where attacks might be initiated if those contracts have vulnerabilities.

Potential vulnerabilities might include:

1. Reentrancy attacks due to lack of proper status checks in ReentrancyGuard.
2. Payloads being sent to external ERC721 contracts without proper checks, leading to unintended token movements.
3. Improper handling of WETH deposits and withdrawals, risking over-deposits or under-withdrawals.
4. Lack of balance checks in functions that mint or transfer tokens, potentially leading to overflows or incorrect balances.
5. Dependent contracts like WETH or NFTXVaultFactory not being properly checked for vulnerabilities, which could传播攻击到这份合约.
6. Potentially infinite loops or unhandled errors in the sortTokens function or other utility logic.
7. ERC721 approval not being checked before transfer, allowing attackers to manipulate the holder.
8. Using IERC20 and IERC1155 tokens without checking if the address is a valid one, leading to unauthorized token transfers.

I think these points cover the main areas. Each of these can be a vulnerability and could lead to unauthorized token movements or reentrancy attacks.","Based on the analysis, here are the vulnerabilities identified in the smart contract:

1. **Reentrancy Attacks Risk**: The contract lacks proper checks in certain functions, putting it at risk of reentrancy attacks, which can allow attackers to repeatedly call functions until a certain condition is met, leading to unrestricted access to prone functions.

2. ** ERC721 and ERC1155 Transfer Without Authorization**: The `transferFromERC721` and `approveERC721` functions interact with external ERC721 tokens without verifying if the calling address is the rightful owner. This could allow attackers to manipulate the smart contract's state by transferring tokens on behalf of users without their consent.

3. **Improper Handling of WETH Deposits and Withdrawals**: The functions involving WETH (like adding liquidity) might not correctly handle deposits and withdrawals, potentially leading to over-deposits or under-withdrawals, affecting the contract's balance and operations.

4. **Lack of Balance Checks in Minting and Transferring Functions**: Functions such as `provideInventory721` and others might lack necessary checks to ensure the correct balance of tokens is minted or transferred, risking overflows or incorrect token distributions.

5. **External Dependencies with Unproven Safety**: The contract heavily relies on external contracts like `IUniswapV2Router01`, `INFTXVaultFactory`, and others, which may themselves be vulnerable or not fully tested, posing risks through potential attack vectors in these dependencies.

6. **Infinite Loops or Unhandled Errors in Helper Functions**: The `sortTokens` function and others might contain logic that could lead to infinite loops or unhandled exceptions, causing the contract to malfunction or allow attackers to manipulate its state.

7. **Potential ERC721 Approval Issues**: The `approveERC721` function could be misused if not properly checked, allowing external attackers to approve tokens for the contract without proper authorization.

8. **Rescue Function Security Risk**: The `rescue` function allows transferring tokens to the owner, which could be a point of attack if not properly guarded, risking token theft during reentrancy attacks.

These vulnerabilities, if exploited, could result in unauthorized token movements, financial losses, or the halting of contract operations. Proper mitigations would involve adding reentrancy guards, verifying external contracts, implementing balance checks, and ensuring all interactions with external tokens are authorized and correctly handled.","### **[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded. This could lead to silent failures, especially when interacting with untrusted addresses or contracts, potentially resulting in loss of funds or unexpected behavior.

**Match in Response List**:  
**No match found**.  

**Validation**:  
The issue is **completely unaddressed** in the `response_list`. The response list does not mention the unchecked low-level call in `addLiquidity721ETHTo` or the risks associated with it. This is a significant oversight, as unchecked low-level calls are a known security vulnerability in Solidity, especially when dealing with ETH transfers or external contract interactions.

**Suggestions**:  
The response should include a recommendation to check the return value of the low-level `.call` to ensure the transfer was successful. For example, the code could be updated as follows:  
```solidity
(bool success, ) = payable(to).call{value: msg.value - amountEth}("""");
require(success, ""ETH transfer failed"");
```

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

**[R-01] Reentrancy Attacks Risk**  

**Response Description**:  
The response identifies a risk of reentrancy attacks due to the lack of proper checks in certain functions. It suggests that attackers could repeatedly call functions until a certain condition is met, leading to unrestricted access to prone functions.  

**Assessment**:  
**Valid Concern**. While this issue was not explicitly mentioned in the `issue` report, reentrancy is a critical vulnerability in Solidity smart contracts. The response correctly highlights the risk and aligns with best practices, such as using reentrancy guards (e.g., `nonReentrant` modifier from OpenZeppelin).  

---

**[R-02] ERC721 and ERC1155 Transfer Without Authorization**  

**Response Description**:  
The response points out that the `transferFromERC721` and `approveERC721` functions interact with external ERC721 tokens without verifying if the calling address is the rightful owner. This could allow attackers to manipulate the smart contract's state by transferring tokens on behalf of users without their consent.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the `issue` report, but it is a valid security concern. Proper authorization checks should be implemented to ensure that only the rightful owner can transfer or approve tokens.  

---

**[R-03] Improper Handling of WETH Deposits and Withdrawals**  

**Response Description**:  
The response suggests that functions involving WETH (like adding liquidity) might not correctly handle deposits and withdrawals, potentially leading to over-deposits or under-withdrawals, affecting the contract's balance and operations.  

**Assessment**:  
**Partially Valid**. While this issue was not mentioned in the `issue` report, improper handling of WETH could lead to balance discrepancies. However, the response does not provide specific examples or details, making it difficult to assess its accuracy.  

---

**[R-04] Lack of Balance Checks in Minting and Transferring Functions**  

**Response Description**:  
The response identifies that functions such as `provideInventory721` might lack necessary checks to ensure the correct balance of tokens is minted or transferred, risking overflows or incorrect token distributions.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the `issue` report, but it is a valid concern. Proper balance checks should be implemented to prevent overflows or incorrect token distributions.  

---

**[R-05] External Dependencies with Unproven Safety**  

**Response Description**:  
The response highlights that the contract heavily relies on external contracts like `IUniswapV2Router01`, `INFTXVaultFactory`, and others, which may themselves be vulnerable or not fully tested, posing risks through potential attack vectors in these dependencies.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the `issue` report, but it is a valid concern. Contracts should carefully evaluate and audit external dependencies to mitigate risks.  

---

**[R-06] Infinite Loops or Unhandled Errors in Helper Functions**  

**Response Description**:  
The response suggests that the `sortTokens` function and others might contain logic that could lead to infinite loops or unhandled exceptions, causing the contract to malfunction or allow attackers to manipulate its state.  

**Assessment**:  
**Partially Valid**. While this issue was not mentioned in the `issue` report, infinite loops or unhandled errors are potential risks. However, the response does not provide specific examples or details, making it difficult to assess its accuracy.  

---

**[R-07] Potential ERC721 Approval Issues**  

**Response Description**:  
The response identifies that the `approveERC721` function could be misused if not properly checked, allowing external attackers to approve tokens for the contract without proper authorization.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the `issue` report, but it is a valid concern. Proper authorization checks should be implemented to prevent misuse of the `approveERC721` function.  

---

**[R-08] Rescue Function Security Risk**  

**Response Description**:  
The response points out that the `rescue` function allows transferring tokens to the owner, which could be a point of attack if not properly guarded, risking token theft during reentrancy attacks.  

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the `issue` report, but it is a valid concern. The `rescue` function should be secured with proper access controls and reentrancy guards.  

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*  

**Partially Correct Matches**:  
- *None*  

**Missed Issues from Issue Report**:  
- **[M-08] Low-level call return value not checked**  

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Reentrancy Attacks Risk**  
- **[R-02] ERC721 and ERC1155 Transfer Without Authorization**  
- **[R-03] Improper Handling of WETH Deposits and Withdrawals**  
- **[R-04] Lack of Balance Checks in Minting and Transferring Functions**  
- **[R-05] External Dependencies with Unproven Safety**  
- **[R-06] Infinite Loops or Unhandled Errors in Helper Functions**  
- **[R-07] Potential ERC721 Approval Issues**  
- **[R-08] Rescue Function Security Risk**  

--- 

The `response_list` fails to address the specific issue in the `issue` report but identifies several other valid concerns that were not originally mentioned. These additional issues highlight potential vulnerabilities that should be addressed to improve the contract's security and robustness.",0,0,1,8,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
,,,,,,,,3,12,,,,2,0,13,30,,
