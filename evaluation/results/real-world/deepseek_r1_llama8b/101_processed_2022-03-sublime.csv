nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct,Partially,Not Matched,LLM-generated,matchList,MAP
LendingPool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';

/**
 * @title Contract that deals with pooling of capital from lenders
 * @notice Implements the functions related to lender pooling
 * @author Sublime
 **/

contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of savings account
     */
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    /**
     * @notice address of pooled credit line
     */
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    /**
     * @notice address of verification module
     */
    IVerification public immutable VERIFICATION;
    /*
     * @notice Factor with which certain variables/constants are multiplied to maintain precision
     */
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- State variables start --------------------------------//

    /**
     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line
     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender
     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender
     */
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    /**
     * @notice Struct that stores the constants of a pooled credit line
     * @param startTime Timestamp at which pooled credit line starts
     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param collateralAsset address of token that is used as collateral deposited by the borrower
     * @param borrowLimit max tokens that was requested by borrower
     * @param minBorrowAmount min tokens that was requested by borrower
     * @param lenderVerifier address of verifier with which lenders should be verified to lend
     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account
     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable
     */
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    /**
     * @notice Struct that stores the variables of a pooled credit line
     * @param lenders mapping that stores lender specific info for the pooled credit line
     * @param sharesHeld total shares of borrow token held by the pooled credit line
              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit
              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced
              when any amount is repaid sharedHeld is increased.
              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is
              not changed.
     * @param borrowerInterestShares total interest in shares repaid by borrower
     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares
     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together
     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation
     */
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    /**
     * @notice Mapping that stores constants for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    /**
     * @notice Mapping that stores variables for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    /**
     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId
     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here
     */
    mapping(uint256 => uint256) public totalSupply;

    //-------------------------------- State variables end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice Modifier that allows only pooled credit line to call a function
     */
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- LenderPool events start ---------------------------//

    /**
     * @notice Emitted when lender deposits tokens for pooled credit line
     * @param id identifier for the pooled credit line
     * @param user address of the user
     * @param amount amount of tokens lent by user
     */
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares amount of shares of liquidity provided initially by lender withdrawn
     */
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation
     */
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when interest by yield or/and borrower is withdrawn
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower
     */
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when a lender withdraws their share of liquidation
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param collateralShare share of collateral withdrawn by lender from liquidation
     */
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    /**
     * @notice Emitted when a pooled credit line is liquidated by a lender
     * @param id identifier for the pooled credit line
     * @param collateralLiquidated amount of collateral that is received after liquidation
     */
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    //--------------------------- LenderPool events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Init start --------------------------------//

    /**
     * @notice constructor to initialize immutable global variables
     * @param _pooledCreditLine address of pooled credit line contract
     * @param _savingsAccount address of savings account contract
     * @param _verification address of verification contract
     */
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    /**
     * @notice initializes the contract in context of proxy
     */
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    //-------------------------------- Init end --------------------------------//

    //-------------------------------- PCL creation start --------------------------------//

    /**
     * @notice function invoked when creating pooled credit line
     * @dev only pooled credit line can call the create function
     * @param _id identifier for the pooled credit line
     * @param _lenderVerifier address of verifier with which lenders should be verified to lend
     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account
     * @param _borrowLimit max tokens that was requested by borrower
     * @param _minBorrowAmount min tokens that was requested by borrower
     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines
     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable
     */
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    //-------------------------------- PCL creation end --------------------------------//

    //-------------------------------- Lend & accept start --------------------------------//

    /**
     * @notice Function used by lenders to lend to pooled credit line
     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called
     * @param _id identifier for the pooled credit line
     * @param _amount amount of borrow tokens to lend
     */
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    /**
     * @notice function used to start the pooled credit line once the start time is reached
     * @dev this function needs to be called by the borrower
     * @param _id identifier for the pooled credit line
     */
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        // PCL can be started once the collection period is over
        require(block.timestamp >= _startTime, 'LP:S2');
        // PCL cannot be started once it has ended
        // PCL remains in the REQUESTED stage if it is not started
        // check _withdrawLiquidity method to see how these cases are handled
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        // If msg.sender is not borrower, then tx is rejected
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    //-------------------------------- Lend & accept end --------------------------------//

    //-------------------------------- callbacks start --------------------------------//

    /**
     * @notice Function invoked on borrow from the pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesBorrowed amount of shares borrowed
     */
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    /**
     * @notice Function invoked when repayment is done to pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesRepaid shares repaid
     * @param _interestShares interest in shares repaid
     */
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    /**
     * @notice Function invoked when pooled credit line is cancelled
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     */
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.
        delete pooledCLConstants[_id].startTime;

        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'
        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _to address to which all the borrow tokens are transferred
     */
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this is the maximum amount which can be borrowed from the PCL
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        // the borrower has not borrowed this much amount yet
        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI
        // also _notBorrowed == _borrowedLimit when the PCL has not started
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]
            // when the PCL is active totalSupply[_id] == _borrowedLimit
            // but _borrowLimit is some cases can be different than totalSupply[_id]
            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI
            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI
            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds
            // in this case too _borrowedLimit is greater than the totalSupply[_id]
            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit
            // this is done to get the _actualNotBorrowedInShares which might be less than the
            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares
            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because
            // no withdrawal of the principal fund deposited in the PCL can happen when it is active
            // interest withdrawn from the PCL has already been deducted from sharesHeld
            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime
            // borrowInterest is accrued only when PCL is active
            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares
            // any change in the totalSupply[_id] on does affect the interest shares in the PCL
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    //-------------------------------- callbacks end --------------------------------//

    //-------------------------------- Interest start --------------------------------//

    /**
     * @notice Function used to withdraw interest repaid by the borrower and
               the yield interest generated by the borrow assets deposited in the strategy
     * @dev Tokens lent are locked till end of Pooled Credit line. 
            Any interest paid by borrower can be withdrawn by lenders proportional to
            their token balances for that pooled credit line. Partial withdrawal of
            interest is not allowed. Whenever they call the `withdrawInterest` function
            they will get the entire amount of interest that is owed to them by that time
     * @param _id identifier for the pooled credit line
     */
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this checks if the constants are not deleted
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    /*
     * @dev this function updates the interest shares withdrawn by the lender.
            interest shares are of 2 types
            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender
            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender
     */
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    /**
     * @notice Function used to get interest withdrawable by a lender in pooled credit line.
               the interest this function returns is a sum of borrowerInterest + yieldInterest
               borrower interest is the interest paid by the borrower
               yield interest is the interest generated by the yield strategy
     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't 
            make any state changes except for getSharesForTokens and getTokensForShares in yield
     * @param _lender address of lender for whom interest is withdrawn
     */
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // get borrower repayments and yield interest shares
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        // convert total interest shares into tokens and return
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            // _sharesHeld is set in the _accept method
            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate
            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)
            // is the _totalYieldInterest
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    //-------------------------------- Interest end --------------------------------//

    //-------------------------------- Liquidity withdraw start --------------------------------//

    /**
     * @notice Function to withdraw liquidity by lender
     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios
            - pcl is cancelled by the borrower
            - pcl gets cancelled because because desired amount wasn't reached
            - pcl gets cancelled because it was never started by the borrower and endTime has reached
            - pcl is liquidated before the endTime has reached
            - pcl is liquidated after the endTime has reached
            - pcl is closed after all repayments
           in the other cases this function reverts
     * @param _id identifier for the pooled credit line
     */

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            // Case 0:
            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)
            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met
            // &&
            // Case 1: Pooled credit line never started because desired amount wasn't reached
            // _maxToLend is 0 if credit line is accepted so this case is never run

            //transfer liquidity provided
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within
                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL
                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            // all other cases distribute the sharesHeld proportional to their poolToken balances
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    /**
     * @notice Function that can be used to calculate principal withdrawable
     * @param _id identifier for the pooled credit line
     * @param _lender lender whose share of principal is to be withdrawn
     * @return Principal withdrawable
     */
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            // this else if block covers the conditions when PCL was cancelled OR
            // the PCL was in requested stage but never started
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    /*
    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed
           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount
    */
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    //-------------------------------- Liquidity withdraw end --------------------------------//

    //-------------------------------- Liquidation start --------------------------------//

    /**
     * @notice Function used to liquidate a pooled credit line
     * @dev only one of the lenders can liquidate their pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _withdraw flag used to identify if lender's share of
              liquidated collateral and liquidity (amount lent + interest) is also withdrawn
     */
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        // This line would call the liquidate function in the pooledCreditLine contract.
        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            // This function would give the share of the lender who called this function from the total liquidated amount
            // this will withdraw both the _collateralAsset and the borrowAsset
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    /**
     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset
     * @param _id identifier for the pooled credit line
     */
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        // this will withdraw the lender's share of liquidity (amount lent + interest)
        _withdrawLiquidity(_id, true);
    }

    //-------------------------------- Liquidation end --------------------------------//

    //-------------------------------- Pre token transfer start --------------------------------//

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                // cannot transfer to the borrower
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                // cannot transfer to a non verified user
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                // this is the case for minting tokens
                // increase the total supply of lp tokens
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                // this is the case for burn
                // reduce the total supply of lp tokens
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                // case for user to user transfer
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                // we need to transfer the lender info from to the receiving address
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            // if the transfer is from user to user, we will withdraw all the interest for the user
            // this is done because we need to transfer the lender info
            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    //-------------------------------- Pre token transfer end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _lender address of the lender for which query is made
     * @return returns lender info
     */
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    //-------------------------------- getters end --------------------------------//
}",9069,858,"[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee
LenderPool.sol#L594-L599 LenderPool.sol#L399-L404
The _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.
``` function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {
  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
  return _principalWithdrawable;
} ```  [H-02] PooledCreditLine: termination likely fails because _principleWithdrawable is treated as shares
LenderPool.sol#L404-L406
_principalWithdrawable is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.
``` // _notBorrowed = borrowAsset amount that isn't borrowed
// totalSupply[_id] = ERC1155 total supply of _id
// _borrowedTokens = borrower's specified borrowLimit
uint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);

SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false);
``` 
 [M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens
`IERC20(_borrowAsset).transfer(_to, _fee);`
If the USDT token is supported as _borrowAsset, the unsafe version of .transfer(_to, _fee) may revert as there is no return value in the USDT token contract’s transfer() implementation (but the IERC20 interface expects a return value).
Function start() will break when _borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.
   [M-02] Lack of access control allow anyone to withdrawInterest() for any lender
LenderPool.sol#L442 ```
function withdrawInterest(uint256 _id, address _lender) external nonReentrant {
    _withdrawInterest(_id, _lender);
}

function _withdrawInterest(uint256 _id, address _lender) internal {
    address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
    address _borrowAsset = pooledCLConstants[_id].borrowAsset;

    (uint256 _interestToWithdraw, uint256 _interestSharesToWithdraw) = _calculateInterestToWithdraw(
        _id,
        _lender,
        _strategy,
        _borrowAsset
    );
    pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);

    if (_interestToWithdraw != 0) {
        SAVINGS_ACCOUNT.withdraw(_borrowAsset, _strategy, _lender, _interestToWithdraw, false);
    }
    emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
}
```
`withdrawInterest()` at a certain time may not be in the best interest of the specific `lender`.
It's unconventional and can potentially cause leak of value for the lender. For example, the lender may still want to accrued more interest from the strategy.
   [M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time
LenderPool.sol#L312 LenderPool.sol#L336
An attacker could keep track of the `totalSupply` of each LenderPool to see if it is more than the `minBorrowAmount`. If so, at startTime, which is pre-announced, the attacker could call `start`, which will trigger `SAVINGS_ACCOUNT.deposit()` of the entire pool assets to mint LP tokens from external strategy, for example, in CompoundYield.
There is potentially a big sum depositing into a known Compound `cToken` contract at a known fixed time. Thus, the attacker could prepare the pool by depositing a fair sum first to lower the exchange rate before calling start in lenderPool. Hence, the deposit of the entire pool could be at a less favourable rate. This also applies to other potential strategies that are yet to be integrated. For example, in Curve pool, the attacker could prime the pool to be very imbalanced first and trigger the deposit and then harvest the arbitrage bonus by bringing the pool back to balance.
This attack can happen once only when the pooledCreditLine becomes active for each new lenderPool.",5,"pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';



contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    

    
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    
    IVerification public immutable VERIFICATION;
    
    uint256 constant SCALING_FACTOR = 1e18;

    

    

    
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    
    mapping(uint256 => uint256) public totalSupply;

    

    

    
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    

    

    

    
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    

    

    

    
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    

    

    
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    

    

    
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        
        require(block.timestamp >= _startTime, 'LP:S2');
        
        
        
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    

    

    
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        
        delete pooledCLConstants[_id].startTime;

        
        
    }

    
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        
        
        
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            
            
            
            
            
            
            
            
            
            
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            
            
            
            
            
            
            
            
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    

    

    
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            
            
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            
            
            
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    

    

    

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            
            
            
            
            
            

            
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                
                
                
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            
            
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    

    

    
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        
        
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            
            
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        
        _withdrawLiquidity(_id, true);
    }

    

    

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                
                
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                
                
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            
            
            
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    

    

    
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    
}",5453,2,3,"Okay, so I'm trying to analyze the vulnerabilities in the provided smart contract, LenderPool.sol, without needing to suggest any mitigations. Let me go through this step by step.

First, I'll read through the code carefully to understand its structure and functionality.

The contract is a smart contract for a pooled credit line. It interacts with various modules like savings accounts, verification, and a strategy for borrowing assets. The contract has several structs and mappings to manage lender information, constants, and variables related to the credit line.

I'll look for common vulnerabilities or patterns that could lead to exploits. Here are some key areas to check:

1. **Reentrancy Vulnerabilities**: The contract has a `nonReentrant` modifier, which is good because it prevents reentrancy attacks. But I should confirm that all key functions are indeed nonReentrant and that no other functions might leave a reentrancy gap.

2. **Overflows or Underflows**: Since the code uses SafeMath, it should prevent overflow, but I'll check all arithmetic operations to ensure that all possible overflows are handled.

3. **Unauthorized Access or Privilege Escalation**: Look for any functions that might grant improper access or allow users to manipulate the contract state incorrectly.

4. **Edge Cases or Off-By-One Errors**: Ensure that all conditions and loops are correctly handled, especially for unique cases like when an operation should not proceed if certain conditions are met.

5. **Gasanelarges**: Check the gas usage of critical functions to avoid situations where a malicious actor could cause a gas bomb.

6. **Incorrect Value Handling**: Ensure all variables are assigned correctly and that there are no mixed-up variables or incorrect addresses being used.

Let me go through each function one by one to spot potential issues.

Starting with the `create` function. It initializes the pooled credit line, sets various constants. It also checks if the allowance is less than max, and if so, approves it. This seems straightforward, but maybe something is missing in the approval that could lead to a misallocation later.

Next, the `lend` function. It checks if the amount is zero, verifies the user is a lender, and checks if the time is before the start. Then it calculates the amount to lend, transfers tokens, and mints. It seems okay, but I need to check the mint function. MInting could potentially be a point of control if not properly handled.

Looking at the `start` function. It begins the credit line, accepts from the strategy, and updates the borrow limit. The acceptance is done in a private _accept function. I wonder if the minting or transfer in _accept is secure.

The `borrowed` function adjusts the shares held, which is a straightforward operation, but I should ensure that it's properly called and that it doesn't inadvertently burn the shares incorrectly.

The `repaid` function adds shares and interest. This could be a point where the contract might miscalculate if not handled correctly. Using SafeMath ensures it's correctly added.

The `requestCancelled` function deletes the start time. Seems simple, but if this function isn't correctly called, it could leave the contract in an inconsistent state.

The `terminate` function is complex. It handles withdrawing the borrowed tokens, calculating interest, and transferring collateral. Here, there are multiple steps where an error could occur. For instance, the calculation of _totalBorrowAsset might have overflows or incorrect logic. Also, the handling of withdraws needs to correctly lock and release liquidity without errors.

The `withdrawInterest` function calls a private _withdrawInterest method. It correctly checks if the sender is a lender and has the rights. The _withdrawInterest method first updates the interest, checks the strategy and borrow asset, then ensures interest shares are subtracted.

Looking into the _withdrawInterest function, it correctly calculates how much can be withdrawn, considering the lender's balance and the total borrow limit. It uses the verification to ensure the sender is an allowed user. However, I need to confirm that the verification is correctly implemented in the verification contract.

The `getLenderInterestWithdrawable` function returns the interest and yield shares, converting them into tokens. It's essential that this calculation is accurate to prevent disagreements between the contract state and external views.

In the `_calculateLenderInterest` function, it computes the interest shares. The logic looks a bit complicated, with nested conditions. I'm a bit concerned that an error here could lead to incorrect transfers of tokens.

Moving to the `withdrawLiquidity` functions, they handle the actual withdrawal of the liquidity. It interacts with multiple components: the savings account, verification, and the pool. It's crucial that these interactions are correctly implemented to prevent over-withdrawing or under-withdrawing tokens.

The `liquidate` function calls an external function in POOLED_CREDIT_LINE to get the collateral. It then handles the transfer. If there's a miscalculation or incorrect handling, it could lead to loss of funds.

The `_withdrawTokensAfterLiquidation` function attempts to withdraw the collateral and then the liquidity. It needs to correctly calculate the share of the collateral to return, which could be error-prone.

In the `_beforeTokenTransfer` function, this is a crucial point as it's part of the ERC1155 contract. It checks for reentrancy, validates the addresses, checks if the receiver is not the borrower, and verifies the transfer. It also uses a function to rebalance interest withdrawals, which can be a risk point if not implemented correctly.

Lastly, the `getLenderInfo` function allows viewing the LenderInfo struct. It's a view, so it shouldn't cause any state changes but needs to correctly reflect the current state.

Common general vulnerabilities to check for include:

- SQL Injection (but not applicable here)
- Buffer Overflows (addressable via SafeMath)
- Denial of Service (DOS) via大量调用，但由于有限的资源，这可能不太可怕)
- Cross-Chain Attacks (此处可能无关)
- wei值的错误转换

Now, considering the use of modifiers like nonReentrant, it's possible that some functions might not correctly use them or that certain paths don't. For instance, if a function isn’t properly marked with nonReentrant and calls another function that is, it can lead to reentrancy.

Another point is the use of immutable variables. Are they correctly initialized and never updated, which could be a point of panic if not handled?

I should also check for any missing security checks, especially in the helper functions like _calculateLenderInterest or _beforeTokenTransfer, which might inadvertently allow reentrancy or incorrectly update states.

Looking for any trusted外部调用，如Verification，是否正确验证用户身份。这是出发点之一，因为如果Verificationerring，那么所有依赖其结果的函数都可能有问题。

关于私有函数，如_accept和_withdrawInterest，这些函数是否正确执行了所有必要的安全检查？有没有可能通过调用这些私有函数在系统之外进行操作？

此外，检查是否所有异常条件都被正确处理，避免意外情况的崩溃。

另一个问题是，是否所有变量都被正确初始化？尤其是在构造函数和初始化函数中有可能的失误。

考虑到这些潜在问题，我需要逐一检查这些地方，但鉴于时间限制，不能深入每一个。

那么，具体的潜在漏洞可能包括：

1. 私有函数的潜在漏洞，如withdrawTokensAfterLiquidation可能允许攻击者以不正确的方式提取资本。

2. 在_WithdrawInterest或_WithdrawLiquidity中，是否有潜在的误算，导致利息或代币被不正确地转移。

3. 通过刻意拖延或提前结算，导致代币供应量不正确，进而影响池的操作。

4. rebalanceInterestWithdrawn函数可能存在逻辑错误，导致利息没有正确分配或被夺取。

5. lender的地址在某些函数中是否被无授权地更改，导致利息分配到错误的地址。

6. 在某些情况下，如终止函数，可能因为状态逻辑不正确而陷入死循环或其他问题。

7. 当计算总供给和总借款时，是否有计算错误，如溢出或误算，导致钱包的不平衡。

8. 由于该协议的复杂性，外部调用可能遭受波动，特别是如果验证不正确，会导致误授权。

9. 当代入测试用例中，比如测试终止与恢复，或者复杂的借贷逻辑，是否有未处理的情况。

例如，考虑到终止函数试图提前结算，而没有正确终止可能导致一些变量保留，允许攻击者铃声扩张。这可能被错误地实现，特别是在_pooledCLConstants和_pooledCLVariables的删除上。

另外，考虑一些流程是否在状态变化中被覆盖，例如，在终止时，-delete pooledCLConstants和pooledCLVariables可能意外地影响其他合约或其他请求。

综上所述，可能的漏洞包括：

- 误算或错误处理在计算利息或代币转移。

- 绕过非复审保护，导致攻击者传输代币或修改状态。

- 状态转移中的错误，导致代币流向错误地址或漏送。

- 拖延或提前结算，导致池的变量不正确。

鉴于我的分析，我认为最常见的漏洞可能是在withdrawInterest或类似函数中，错误地处理利息转移。另一个可能是，在非审核保护的函数中遗漏了修饰符，让攻击者进行转移，或者作为管理员的某些操作可以被误用来转移代币。

此外，end函数和类似的终止可能因为未正确清空或删除变量而造成一系列后果。

另一个潜在的漏洞是在rebalancing利息时，误用shares的转移，导致声称的优惠利率未能正确分配或转移。

而且，因为该合约是通过一个初始化商AGG另一个地方，初始设置中可能存在问题，比如允许其他不应有的地址访问。

总之，在不进行完整的安全审计的情况下，我会指出几个主要的潜在漏洞，再加上特定的函数或流程中的漏洞。这些可能包括：

1. 在_WithdrawInterest中的计算错误，导致利息转移到错误的address。

2. _beforeTokenTransfer中的某些条件没有被正确检查，允许非借款者提前转移。

3. 终止函数在delete操作中的潜在问题，错误地清除某些变量，导致后续操作失败或重复初始化。

4. 虽然使用了nonReentrant修饰符，但可能存在其他递归调用链未被覆盖的情况，导致攻击者链策略。

5. 表单的管理中缺少额外的检查，如是否是管理员，可能允许某些操作被误用。

如有其他思路，可能可以针对这些点进行进一步的验证，或者寻找代码中是否存在其他潜在的安全问题。","Here is the list of vulnerabilities and potential issues in the `LenderPool` smart contract identified during the analysis:

### Potential Vulnerabilities:

1. **Incorrect Interest Calculation in `_calculateLenderInterest`**:
   - **Issue**: The function might incorrectly compute the borrower's interest and yield interest shares, leading to misallocated tokens.
   - **CRUX**: The logic for dividing and multiplying shares could result in miscalculations, especially if the values are not updated correctly in subsequent calls.
   - **Mitigation**: Review the mathematical operations to ensure they accurately reflect the intended logic.

2. **Reentrancy Vulnerability Despite `nonReentrant` Modifier**:
   - **Issue**: While the contract has `nonReentrant` modifiers, certain functions may still be affected by reentrancy due to how external calls interact within the contract.
   - **CRUX**: Functions that interact with external contracts or call other non-`nonReentrant` functions might still be vulnerable.
   - **Mitigation**: Verify that all paths in `nonReentrant` functions correctly prevent reentrancy by ensuring no direct or indirect calls to reentrant functions occur.

3. **Incorrect Token Transfer in `_beforeTokenTransfer`**:
   - **Issue**: The function might allow unintended token transfers if certain conditions are not properly checked.
   - **CRUX**: The function checks that `to` is neither the borrower nor a non-verified address, but if there's a logic error here, tokens could be transferred incorrectly.
   - **Mitigation**: Ensure all checks in `_beforeTokenTransfer` are accurate and that mechanism prevents any invalid transfers.

4. **Inadequate State Management in `terminate`**:
   - **Issue**: The method may delete crucial states when terminating a pool without fully liquidating or settling all obligations.
   - **CRUX**: Deleting `pooledCLConstants` and `pooledCLVariables` might leave residual data or unhandled state changes.
   - **Mitigation**: Double-check that all necessary variables are reset or cleaned up appropriately to prevent inconsistencies.

5. **Malfunctional `liquidate` Function**:
   - **Issue**: The function might not correctly handle the collateral return or subsequent withdrawals after liquidation.
   - **CRUX**: Incomplete logic in `liquidate` or related functions might miss transferring the correct amounts or not handle all paths.
   - **Mitigation**: Ensure `liquidate` and its downstream functions correctly process both principal and interest.

### Additional Points of Consideration:

- **Incorrect Variable Initialization**: Ensure all variables, especially those in `SavingsAccount` and `PooledCreditLine`, are correctly initialized in the constructor.
- **Authentication and Privilege Control**: Verify that all functions correctly enforce the required permissions using `Verification` checks.
- **Gas Usage Optimization**: Some functions may consume excessive gas if not optimized, potentially leading to DoS attacks.

### Summary:

The `LenderPool` smart contract has some identifiable vulnerabilities, mainly in token transfer logic, interest calculation, and state management during termination. Addressing these issues would require thorough code audits and possibly additional checks or breakups into more modular functions for enhanced security.","### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**

**Report Description**:  
The `_calculatePrincipalWithdrawable` function in `LenderPool.sol` incorrectly calculates the principal withdrawable when `start()` is invoked with a non-zero start fee. The borrow limit is reduced by the fee, causing `totalSupply[id]` to not be 1:1 with the borrow limit. This results in the principal withdrawable being higher than expected, leading to potential discrepancies in token balances.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. The incorrect calculation of `_principalWithdrawable` is a significant logical error that could lead to financial discrepancies. The response list does not mention this issue or provide any mitigation.

**Suggestions**:  
The response list should include a review of the `_calculatePrincipalWithdrawable` function to ensure the borrow limit and total supply are correctly aligned, especially when a start fee is applied.

---

#### **[H-02] PooledCreditLine: Termination likely fails because _principalWithdrawable is treated as shares**

**Report Description**:  
The `_principalWithdrawable` variable is denominated in the borrow asset but is treated as shares in the `SAVINGS_ACCOUNT.withdrawShares` function. This mismatch could cause termination to fail or result in incorrect withdrawals.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. The incorrect treatment of `_principalWithdrawable` as shares is a critical logical error that could prevent proper termination of the pooled credit line.

**Suggestions**:  
The response list should include a review of the termination logic to ensure `_principalWithdrawable` is correctly handled as borrow asset amounts, not shares.

---

#### **[M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens**

**Report Description**:  
The `start()` function uses `IERC20(_borrowAsset).transfer(_to, _fee)`, which may revert if `_borrowAsset` is a non-ERC20 compliant token like USDT (which does not return a value in its `transfer` function). This could prevent the pooled credit line from starting, especially when USDT is used as the borrow asset.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. The use of `transfer` without handling non-ERC20 compliant tokens is a significant oversight that could prevent the contract from functioning with widely used tokens like USDT.

**Suggestions**:  
The response list should recommend using `SafeERC20`'s `safeTransfer` function to handle non-ERC20 compliant tokens.

---

#### **[M-02] Lack of access control allows anyone to withdrawInterest() for any lender**

**Report Description**:  
The `withdrawInterest()` function lacks access control, allowing anyone to withdraw interest on behalf of any lender. This is unconventional and could lead to value leakage for lenders, as they may prefer to accrue more interest rather than withdraw it prematurely.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. The lack of access control in `withdrawInterest()` is a clear violation of best practices and could lead to unintended consequences for lenders.

**Suggestions**:  
The response list should recommend adding access control to `withdrawInterest()` to ensure only authorized parties can initiate withdrawals on behalf of lenders.

---

#### **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**

**Report Description**:  
An attacker could monitor the `totalSupply` of each `LenderPool` and call `start()` at a pre-announced time to deposit the entire pool assets into a known strategy (e.g., Compound or Curve) at an unfavorable rate. This could be exploited to manipulate the exchange rate or harvest arbitrage bonuses.

**Match in Response List**:  
**No match found**.

**Validation**:  
The issue is not addressed in the `response_list`. The potential for rate manipulation and arbitrage exploitation is a significant concern that should be mitigated.

**Suggestions**:  
The response list should recommend implementing mechanisms to prevent large deposits at known times, such as staggered deposits or rate smoothing.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Incorrect Interest Calculation in `_calculateLenderInterest`**

**Response Description**:  
The response suggests that the `_calculateLenderInterest` function might incorrectly compute the borrower's interest and yield interest shares, leading to misallocated tokens.

**Assessment**:  
**Valid Concern**. While this issue was not mentioned in the original `issue` report, incorrect interest calculations could lead to financial discrepancies. The response highlights a potential logical error that warrants further review.

---

#### **[R-02] Reentrancy Vulnerability Despite `nonReentrant` Modifier**

**Response Description**:  
The response claims that certain functions may still be vulnerable to reentrancy despite the `nonReentrant` modifier, due to interactions with external contracts.

**Assessment**:  
**Partially Valid**. While the `nonReentrant` modifier generally prevents reentrancy, the response does not provide specific examples of vulnerable functions. This concern should be investigated further to confirm its validity.

---

#### **[R-03] Incorrect Token Transfer in `_beforeTokenTransfer`**

**Response Description**:  
The response suggests that the `_beforeTokenTransfer` function might allow unintended token transfers if certain conditions are not properly checked.

**Assessment**:  
**Valid Concern**. Improper checks in `_beforeTokenTransfer` could lead to unauthorized transfers. This is a valid security concern that should be addressed.

---

#### **[R-04] Inadequate State Management in `terminate`**

**Response Description**:  
The response claims that the `terminate` function may delete crucial states without fully liquidating or settling all obligations.

**Assessment**:  
**Valid Concern**. Incomplete state management during termination could lead to inconsistencies or residual data. This is a valid issue that should be addressed.

---

#### **[R-05] Malfunctional `liquidate` Function**

**Response Description**:  
The response suggests that the `liquidate` function might not correctly handle collateral return or subsequent withdrawals after liquidation.

**Assessment**:  
**Valid Concern**. Incorrect liquidation logic could lead to financial losses or inconsistencies. This is a valid issue that should be reviewed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**  
- **[H-02] PooledCreditLine: Termination likely fails because _principalWithdrawable is treated as shares**  
- **[M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens**  
- **[M-02] Lack of access control allows anyone to withdrawInterest() for any lender**  
- **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**  

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Incorrect Interest Calculation in `_calculateLenderInterest`**  
- **[R-02] Reentrancy Vulnerability Despite `nonReentrant` Modifier**  
- **[R-03] Incorrect Token Transfer in `_beforeTokenTransfer`**  
- **[R-04] Inadequate State Management in `terminate`**  
- **[R-05] Malfunctional `liquidate` Function**  

--- 

The `response_list` does not address any of the issues in the `issue` report but identifies several potential issues that were not originally mentioned. These GPT-generated issues highlight valid concerns but require further investigation to confirm their relevance and accuracy.",0,0,5,5,"```
None.
```",0.0
