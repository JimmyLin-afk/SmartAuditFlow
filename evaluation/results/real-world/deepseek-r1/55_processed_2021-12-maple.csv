nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP
MapleLoan.sol,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IERC20 }             from ""../modules/erc20/src/interfaces/IERC20.sol"";
import { IMapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

import { ERC20Helper } from ""../modules/erc20-helper/src/ERC20Helper.sol"";

import { IMapleLoan } from ""./interfaces/IMapleLoan.sol"";
import { IMapleGlobalsLike } from ""./interfaces/Interfaces.sol"";

import { MapleLoanInternals } from ""./MapleLoanInternals.sol"";

/// @title MapleLoan implements a primitive loan with additional functionality, and is intended to be proxied.
contract MapleLoan is IMapleLoan, MapleLoanInternals {

    modifier whenProtocolNotPaused() {
        require(!isProtocolPaused(), ""ML:PROTOCOL_PAUSED"");
        _;
    }

    /********************************/
    /*** Administrative Functions ***/
    /********************************/

    function migrate(address migrator_, bytes calldata arguments_) external override {
        require(msg.sender == _factory(),        ""ML:M:NOT_FACTORY"");
        require(_migrate(migrator_, arguments_), ""ML:M:FAILED"");
    }

    function setImplementation(address newImplementation_) external override {
        require(msg.sender == _factory(),               ""ML:SI:NOT_FACTORY"");
        require(_setImplementation(newImplementation_), ""ML:SI:FAILED"");
    }

    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {
        require(msg.sender == _borrower, ""ML:U:NOT_BORROWER"");

        emit Upgraded(toVersion_, arguments_);

        IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_);
    }

    /************************/
    /*** Borrow Functions ***/
    /************************/

    function acceptBorrower() external override {
        require(msg.sender == _pendingBorrower, ""ML:AB:NOT_PENDING_BORROWER"");

        _pendingBorrower = address(0);

        emit BorrowerAccepted(_borrower = msg.sender);
    }

    function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:CL:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _closeLoan();

        emit LoanClosed(principal_, interest_);
    }

    function drawdownFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        require(msg.sender == _borrower, ""ML:DF:NOT_BORROWER"");

        emit FundsDrawnDown(amount_, destination_);

        // Post additional collateral required to facilitate this drawdown, if needed.
        uint256 additionalCollateralRequired = getAdditionalCollateralRequiredFor(amount_);

        if (additionalCollateralRequired > uint256(0)) {
            // Determine collateral currently unaccounted for.
            uint256 unaccountedCollateral = _getUnaccountedAmount(_collateralAsset);

            // Post required collateral, specifying then amount lacking as the optional amount to be transferred from.
            collateralPosted_ = postCollateral(
                additionalCollateralRequired > unaccountedCollateral ? additionalCollateralRequired - unaccountedCollateral : uint256(0)
            );
        }

        _drawdownFunds(amount_, destination_);
    }

    function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:MP:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _makePayment();

        emit PaymentMade(principal_, interest_);
    }

    function postCollateral(uint256 amount_) public override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(
            amount_ == uint256(0) || ERC20Helper.transferFrom(_collateralAsset, msg.sender, address(this), amount_),
            ""ML:PC:TRANSFER_FROM_FAILED""
        );

        emit CollateralPosted(collateralPosted_ = _postCollateral());
    }

    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:PNT:NOT_BORROWER"");

        emit NewTermsProposed(_proposeNewTerms(refinancer_, calls_), refinancer_, calls_);
    }

    function removeCollateral(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:RC:NOT_BORROWER"");

        emit CollateralRemoved(amount_, destination_);

        _removeCollateral(amount_, destination_);
    }

    function returnFunds(uint256 amount_) public override whenProtocolNotPaused returns (uint256 fundsReturned_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:RF:TRANSFER_FROM_FAILED"");

        emit FundsReturned(fundsReturned_ = _returnFunds());
    }

    function setPendingBorrower(address pendingBorrower_) external override {
        require(msg.sender == _borrower, ""ML:SPB:NOT_BORROWER"");

        emit PendingBorrowerSet(_pendingBorrower = pendingBorrower_);
    }

    /**********************/
    /*** Lend Functions ***/
    /**********************/

    function acceptLender() external override {
        require(msg.sender == _pendingLender, ""ML:AL:NOT_PENDING_LENDER"");

        _pendingLender = address(0);

        emit LenderAccepted(_lender = msg.sender);
    }

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:ANT:NOT_LENDER"");

        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:ACT:TRANSFER_FROM_FAILED"");

        emit NewTermsAccepted(_acceptNewTerms(refinancer_, calls_), refinancer_, calls_);

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        // NOTE: This block ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:ANT:TRANSFER_FAILED"");
        }
    }

    function claimFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:CF:NOT_LENDER"");

        emit FundsClaimed(amount_, destination_);

        _claimFunds(amount_, destination_);
    }

    function fundLoan(address lender_, uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsLent_) {
        // The amount specified is an optional amount to be transferred from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:FL:TRANSFER_FROM_FAILED"");

        // If the loan is not active, fund it.
        if (_nextPaymentDueDate == uint256(0)) {
            emit Funded(lender_, fundsLent_ = _fundLoan(lender_), _nextPaymentDueDate);
        }

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        // NOTE: This block is not only a stopgap solution to allow a LiquidityLockerV1 to send funds to a DebtLocker, while maintaining PoolV1 accounting,
        //       but also ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:FL:TRANSFER_FAILED"");
        }
    }

    function repossess(address destination_) external override whenProtocolNotPaused returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        require(msg.sender == _lender, ""ML:R:NOT_LENDER"");

        ( collateralRepossessed_, fundsRepossessed_ ) = _repossess(destination_);

        emit Repossessed(collateralRepossessed_, fundsRepossessed_, destination_);
    }

    function setPendingLender(address pendingLender_) external override {
        require(msg.sender == _lender, ""ML:SPL:NOT_LENDER"");

        emit PendingLenderSet(_pendingLender = pendingLender_);
    }

    /*******************************/
    /*** Miscellaneous Functions ***/
    /*******************************/

    function skim(address token_, address destination_) external override whenProtocolNotPaused returns (uint256 skimmed_) {
        require((msg.sender == _borrower) || (msg.sender == _lender),    ""L:S:NO_AUTH"");
        require((token_ != _fundsAsset) && (token_ != _collateralAsset), ""L:S:INVALID_TOKEN"");

        emit Skimmed(token_, skimmed_ = IERC20(token_).balanceOf(address(this)), destination_);

        require(ERC20Helper.transfer(token_, destination_, skimmed_), ""L:S:TRANSFER_FAILED"");
    }

    /**********************/
    /*** View Functions ***/
    /**********************/

    function getAdditionalCollateralRequiredFor(uint256 drawdown_) public view override returns (uint256 collateral_) {
        // Determine the collateral needed in the contract for a reduced drawable funds amount.
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds - drawdown_, _principalRequested, _collateralRequired);

        return collateralNeeded > _collateral ? collateralNeeded - _collateral : uint256(0);
    }

    function getEarlyPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();
    }

    function getNextPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();
    }

    function isProtocolPaused() public view override returns (bool paused_) {
        return IMapleGlobalsLike(IMapleProxyFactory(_factory()).mapleGlobals()).protocolPaused();
    }

    /****************************/
    /*** State View Functions ***/
    /****************************/

    function borrower() external view override returns (address borrower_) {
        return _borrower;
    }

    function claimableFunds() external view override returns (uint256 claimableFunds_) {
        return _claimableFunds;
    }

    function collateral() external view override returns (uint256 collateral_) {
        return _collateral;
    }

    function collateralAsset() external view override returns (address collateralAsset_) {
        return _collateralAsset;
    }

    function collateralRequired() external view override returns (uint256 collateralRequired_) {
        return _collateralRequired;
    }

    function drawableFunds() external view override returns (uint256 drawableFunds_) {
        return _drawableFunds;
    }

    function earlyFeeRate() external view override returns (uint256 earlyFeeRate_) {
        return _earlyFeeRate;
    }

    function endingPrincipal() external view override returns (uint256 endingPrincipal_) {
        return _endingPrincipal;
    }

    function excessCollateral() external view override returns (uint256 excessCollateral_) {
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);

        return _collateral > collateralNeeded ? _collateral - collateralNeeded : uint256(0);
    }

    function factory() external view override returns (address factory_) {
        return _factory();
    }

    function fundsAsset() external view override returns (address fundsAsset_) {
        return _fundsAsset;
    }

    function gracePeriod() external view override returns (uint256 gracePeriod_) {
        return _gracePeriod;
    }

    function implementation() external view override returns (address implementation_) {
        return _implementation();
    }

    function interestRate() external view override returns (uint256 interestRate_) {
        return _interestRate;
    }

    function lateFeeRate() external view override returns (uint256 lateFeeRate_) {
        return _lateFeeRate;
    }

    function lateInterestPremium() external view override returns (uint256 lateInterestPremium_) {
        return _lateInterestPremium;
    }

    function lender() external view override returns (address lender_) {
        return _lender;
    }

    function nextPaymentDueDate() external view override returns (uint256 nextPaymentDueDate_) {
        return _nextPaymentDueDate;
    }

    function paymentInterval() external view override returns (uint256 paymentInterval_) {
        return _paymentInterval;
    }

    function paymentsRemaining() external view override returns (uint256 paymentsRemaining_) {
        return _paymentsRemaining;
    }

    function pendingBorrower() external view override returns (address pendingBorrower_) {
        return _pendingBorrower;
    }

    function pendingLender() external view override returns (address pendingLender_) {
        return _pendingLender;
    }

    function principalRequested() external view override returns (uint256 principalRequested_) {
        return _principalRequested;
    }

    function principal() external view override returns (uint256 principal_) {
        return _principal;
    }

    // NOTE: This is needed for `fundLoan` call from PoolV1.
    function superFactory() external view override returns (address superFactory_) {
        return _factory();
    }

}",3055.0,345.0,"[H-01] `makePayment()` Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss
“function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {“
The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.
This makes it possible for a malicious lender to call makePayment() multiple times right after fundLoan() and retrieve most of the funds back immediately, while then borrower must continue to make payments or lose the collateral.
  [M-01] Anyone can call `closeLoan()` to close the loan
“function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_)""
Based on the context, we believe that the `closeLoan()` should only be called by the borrower. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.
If there is no `earlyFee`, this enables a griefing attack, causing the borrower and lender to abandon this contract and redo everything which costs more gas.
If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.",2.0,"pragma solidity ^0.8.7;

import { IERC20 }             from ""../modules/erc20/src/interfaces/IERC20.sol"";
import { IMapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

import { ERC20Helper } from ""../modules/erc20-helper/src/ERC20Helper.sol"";

import { IMapleLoan } from ""./interfaces/IMapleLoan.sol"";
import { IMapleGlobalsLike } from ""./interfaces/Interfaces.sol"";

import { MapleLoanInternals } from ""./MapleLoanInternals.sol"";


contract MapleLoan is IMapleLoan, MapleLoanInternals {

    modifier whenProtocolNotPaused() {
        require(!isProtocolPaused(), ""ML:PROTOCOL_PAUSED"");
        _;
    }

    
    
    

    function migrate(address migrator_, bytes calldata arguments_) external override {
        require(msg.sender == _factory(),        ""ML:M:NOT_FACTORY"");
        require(_migrate(migrator_, arguments_), ""ML:M:FAILED"");
    }

    function setImplementation(address newImplementation_) external override {
        require(msg.sender == _factory(),               ""ML:SI:NOT_FACTORY"");
        require(_setImplementation(newImplementation_), ""ML:SI:FAILED"");
    }

    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {
        require(msg.sender == _borrower, ""ML:U:NOT_BORROWER"");

        emit Upgraded(toVersion_, arguments_);

        IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_);
    }

    
    
    

    function acceptBorrower() external override {
        require(msg.sender == _pendingBorrower, ""ML:AB:NOT_PENDING_BORROWER"");

        _pendingBorrower = address(0);

        emit BorrowerAccepted(_borrower = msg.sender);
    }

    function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:CL:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _closeLoan();

        emit LoanClosed(principal_, interest_);
    }

    function drawdownFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        require(msg.sender == _borrower, ""ML:DF:NOT_BORROWER"");

        emit FundsDrawnDown(amount_, destination_);

        
        uint256 additionalCollateralRequired = getAdditionalCollateralRequiredFor(amount_);

        if (additionalCollateralRequired > uint256(0)) {
            
            uint256 unaccountedCollateral = _getUnaccountedAmount(_collateralAsset);

            
            collateralPosted_ = postCollateral(
                additionalCollateralRequired > unaccountedCollateral ? additionalCollateralRequired - unaccountedCollateral : uint256(0)
            );
        }

        _drawdownFunds(amount_, destination_);
    }

    function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:MP:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _makePayment();

        emit PaymentMade(principal_, interest_);
    }

    function postCollateral(uint256 amount_) public override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        
        require(
            amount_ == uint256(0) || ERC20Helper.transferFrom(_collateralAsset, msg.sender, address(this), amount_),
            ""ML:PC:TRANSFER_FROM_FAILED""
        );

        emit CollateralPosted(collateralPosted_ = _postCollateral());
    }

    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:PNT:NOT_BORROWER"");

        emit NewTermsProposed(_proposeNewTerms(refinancer_, calls_), refinancer_, calls_);
    }

    function removeCollateral(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:RC:NOT_BORROWER"");

        emit CollateralRemoved(amount_, destination_);

        _removeCollateral(amount_, destination_);
    }

    function returnFunds(uint256 amount_) public override whenProtocolNotPaused returns (uint256 fundsReturned_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:RF:TRANSFER_FROM_FAILED"");

        emit FundsReturned(fundsReturned_ = _returnFunds());
    }

    function setPendingBorrower(address pendingBorrower_) external override {
        require(msg.sender == _borrower, ""ML:SPB:NOT_BORROWER"");

        emit PendingBorrowerSet(_pendingBorrower = pendingBorrower_);
    }

    
    
    

    function acceptLender() external override {
        require(msg.sender == _pendingLender, ""ML:AL:NOT_PENDING_LENDER"");

        _pendingLender = address(0);

        emit LenderAccepted(_lender = msg.sender);
    }

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:ANT:NOT_LENDER"");

        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:ACT:TRANSFER_FROM_FAILED"");

        emit NewTermsAccepted(_acceptNewTerms(refinancer_, calls_), refinancer_, calls_);

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:ANT:TRANSFER_FAILED"");
        }
    }

    function claimFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:CF:NOT_LENDER"");

        emit FundsClaimed(amount_, destination_);

        _claimFunds(amount_, destination_);
    }

    function fundLoan(address lender_, uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsLent_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:FL:TRANSFER_FROM_FAILED"");

        
        if (_nextPaymentDueDate == uint256(0)) {
            emit Funded(lender_, fundsLent_ = _fundLoan(lender_), _nextPaymentDueDate);
        }

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        
        
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:FL:TRANSFER_FAILED"");
        }
    }

    function repossess(address destination_) external override whenProtocolNotPaused returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        require(msg.sender == _lender, ""ML:R:NOT_LENDER"");

        ( collateralRepossessed_, fundsRepossessed_ ) = _repossess(destination_);

        emit Repossessed(collateralRepossessed_, fundsRepossessed_, destination_);
    }

    function setPendingLender(address pendingLender_) external override {
        require(msg.sender == _lender, ""ML:SPL:NOT_LENDER"");

        emit PendingLenderSet(_pendingLender = pendingLender_);
    }

    
    
    

    function skim(address token_, address destination_) external override whenProtocolNotPaused returns (uint256 skimmed_) {
        require((msg.sender == _borrower) || (msg.sender == _lender),    ""L:S:NO_AUTH"");
        require((token_ != _fundsAsset) && (token_ != _collateralAsset), ""L:S:INVALID_TOKEN"");

        emit Skimmed(token_, skimmed_ = IERC20(token_).balanceOf(address(this)), destination_);

        require(ERC20Helper.transfer(token_, destination_, skimmed_), ""L:S:TRANSFER_FAILED"");
    }

    
    
    

    function getAdditionalCollateralRequiredFor(uint256 drawdown_) public view override returns (uint256 collateral_) {
        
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds - drawdown_, _principalRequested, _collateralRequired);

        return collateralNeeded > _collateral ? collateralNeeded - _collateral : uint256(0);
    }

    function getEarlyPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();
    }

    function getNextPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();
    }

    function isProtocolPaused() public view override returns (bool paused_) {
        return IMapleGlobalsLike(IMapleProxyFactory(_factory()).mapleGlobals()).protocolPaused();
    }

    
    
    

    function borrower() external view override returns (address borrower_) {
        return _borrower;
    }

    function claimableFunds() external view override returns (uint256 claimableFunds_) {
        return _claimableFunds;
    }

    function collateral() external view override returns (uint256 collateral_) {
        return _collateral;
    }

    function collateralAsset() external view override returns (address collateralAsset_) {
        return _collateralAsset;
    }

    function collateralRequired() external view override returns (uint256 collateralRequired_) {
        return _collateralRequired;
    }

    function drawableFunds() external view override returns (uint256 drawableFunds_) {
        return _drawableFunds;
    }

    function earlyFeeRate() external view override returns (uint256 earlyFeeRate_) {
        return _earlyFeeRate;
    }

    function endingPrincipal() external view override returns (uint256 endingPrincipal_) {
        return _endingPrincipal;
    }

    function excessCollateral() external view override returns (uint256 excessCollateral_) {
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);

        return _collateral > collateralNeeded ? _collateral - collateralNeeded : uint256(0);
    }

    function factory() external view override returns (address factory_) {
        return _factory();
    }

    function fundsAsset() external view override returns (address fundsAsset_) {
        return _fundsAsset;
    }

    function gracePeriod() external view override returns (uint256 gracePeriod_) {
        return _gracePeriod;
    }

    function implementation() external view override returns (address implementation_) {
        return _implementation();
    }

    function interestRate() external view override returns (uint256 interestRate_) {
        return _interestRate;
    }

    function lateFeeRate() external view override returns (uint256 lateFeeRate_) {
        return _lateFeeRate;
    }

    function lateInterestPremium() external view override returns (uint256 lateInterestPremium_) {
        return _lateInterestPremium;
    }

    function lender() external view override returns (address lender_) {
        return _lender;
    }

    function nextPaymentDueDate() external view override returns (uint256 nextPaymentDueDate_) {
        return _nextPaymentDueDate;
    }

    function paymentInterval() external view override returns (uint256 paymentInterval_) {
        return _paymentInterval;
    }

    function paymentsRemaining() external view override returns (uint256 paymentsRemaining_) {
        return _paymentsRemaining;
    }

    function pendingBorrower() external view override returns (address pendingBorrower_) {
        return _pendingBorrower;
    }

    function pendingLender() external view override returns (address pendingLender_) {
        return _pendingLender;
    }

    function principalRequested() external view override returns (uint256 principalRequested_) {
        return _principalRequested;
    }

    function principal() external view override returns (uint256 principal_) {
        return _principal;
    }

    
    function superFactory() external view override returns (address superFactory_) {
        return _factory();
    }

}",2642.0,1,1,"Here is a list of vulnerabilities identified in the provided MapleLoan smart contract:

1. **Insecure Collateral Handling (Unauthorized Collateral Posting & Theft):**
   - The `postCollateral` function allows any address to add collateral. Since the borrower can remove excess collateral via `removeCollateral`, this enables potential theft of collateral posted by third parties if the borrower is malicious.

2. **Incompatibility with Fee-on-Transfer/Deflationary Tokens:**
   - The contract assumes ERC20 transfers are exact (i.e., no fees/deductions). Tokens with fee-on-transfer or rebasing mechanisms will cause discrepancies between internal accounting (`_collateral`, `_drawableFunds`) and actual balances, leading to under-collateralization or incorrect fund tracking.

3. **Funds Theft via `fundLoan` Post-Initial Funding:**
   - After the loan is initially funded, any user can call `fundLoan`, depositing tokens that are immediately forwarded to the lender. This could be exploited to trick users into transferring their tokens to the lender unknowingly.

4. **Upgradeability Control Risk:**
   - The `upgrade` function allows the borrower to change the contract's implementation. A compromised borrower could deploy malicious logic, risking fund theft or contract takeover.

5. **Front-Runnable `fundLoan` Initialization:**
   - The first caller of `fundLoan` becomes the lender. Attackers could front-run legitimate lender transactions to hijack the lender role, leading to unauthorized control over loan terms and funds.

6. **Lack of Input Validation in Critical Functions:**
   - Functions like `_removeCollateral` and `_postCollateral` (in internal implementations) may lack checks for valid parameters (e.g., ensuring non-zero destinations), risking fund loss or invalid state changes.

7. **Insufficient Event Emission After State Changes:**
   - Some state changes (e.g., collateral adjustments in internal functions) may not emit events, reducing transparency and off-chain monitoring capabilities.

8. **Reliance on Trusted External Contracts:**
   - The contract depends on `IMapleGlobalsLike` and `IMapleProxyFactory` without explicit checks for their integrity. Compromised factory/globals contracts could pause functionality or alter critical logic.

9. **Potential Reentrancy in `_acceptNewTerms` and `_fundLoan`:**
   - If internal functions like `_acceptNewTerms` make external calls to untrusted contracts before updating state, reentrancy attacks could occur (though ERC20 interactions are generally safe).

10. **Incorrect Collateral Requirement Calculation:**
    - The `getAdditionalCollateralRequiredFor` function might miscalculate required collateral if `_getCollateralRequiredFor` contains errors, leading to under/over-collateralization (depends on unverified internal logic).

11. **Missing Access Control in `skim`:**
    - While `skim` restricts access to borrower/lender, it allows draining non-core tokens. If the contract unintentionally holds other assets (e.g., airdropped tokens), they can be extracted even if they should belong to the protocol.

12. **Time Manipulation Risks:**
    - Dependence on block timestamps (`_nextPaymentDueDate`) for payment scheduling could be exploited if loan terms allow minimal intervals, though this is inherent to most time-based contracts.

Note: These vulnerabilities are identified based on the provided code snippet and common patterns. A full audit would require examining the entire codebase, including inherited/internal functions (e.g., `MapleLoanInternals`).","### **[H-01] `makePayment()` Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss**

**Report Description**:  
The `makePayment()` function in the contract lacks access control, allowing anyone to call it and repay the loan using `_drawableFunds`. This enables a malicious lender to call `makePayment()` multiple times immediately after `fundLoan()`, retrieving most of the funds back while the borrower is still obligated to make payments or risk losing collateral. This design flaw can lead to significant financial loss for the borrower.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of unauthorized access to the `makePayment()` function. While the list includes vulnerabilities related to access control (e.g., ""Insecure Collateral Handling""), it does not cover the risk of malicious lenders exploiting `makePayment()` to drain funds prematurely. This is a critical oversight.

---

### **[M-01] Anyone can call `closeLoan()` to close the loan**

**Report Description**:  
The `closeLoan()` function is intended to be called only by the borrower, but the current implementation allows anyone to call it after `fundLoan()`. This can lead to griefing attacks, forcing the borrower and lender to abandon the contract and incur additional gas costs. If a platform fee exists, the lender may also suffer financial loss due to fees charged during `fundLoan()`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unauthorized access to the `closeLoan()` function. While the list includes general access control risks (e.g., ""Insecure Collateral Handling""), it does not specifically identify the vulnerability of allowing anyone to close the loan, which can lead to griefing attacks and financial losses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] `makePayment()` Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss**  
- **[M-01] Anyone can call `closeLoan()` to close the loan**

---

### **Analysis of Gaps**  
The `response_list` fails to address two critical issues from the `issue` report:  
1. The lack of access control in `makePayment()`, which allows malicious lenders to exploit the function and cause financial harm to borrowers.  
2. The unrestricted access to `closeLoan()`, which enables griefing attacks and potential financial losses for both borrowers and lenders.  

These gaps highlight the need for a more comprehensive review of access control mechanisms in the contract. The `response_list` focuses on other vulnerabilities (e.g., collateral handling, fee-on-transfer tokens) but misses these significant risks. Addressing these issues is essential to ensure the security and fairness of the contract.",0,0,2,12,"Okay, let's take a look at this MapleLoan smart contract and try to identify any vulnerabilities. Hmm, first, I'll start by going through the functions and modifiers to see if there's anything that stands out.

Looking at the modifiers, there's a whenProtocolNotPaused modifier used in several functions. That's good practice, but maybe there are functions that should have this modifier but don't. Let me check each function.

The migrate function is only callable by the factory, which seems okay. The setImplementation is also restricted to the factory. The upgrade function requires the sender to be the borrower. Wait, when you upgrade, does that introduce any risks? Like, if the borrower can upgrade the contract to a malicious implementation, that could be a problem. But maybe that's intended behavior here. Not sure yet.

In the acceptBorrower function, the pending borrower can become the new borrower. But is there a way for a malicious pending borrower to front-run or something? Maybe not, since it's a straightforward check.

The closeLoan function transfers funds and calls _closeLoan. The transferFrom is conditional on amount_ not being zero. But maybe there's a reentrancy issue here? The function does a transfer before calling _closeLoan. Wait, the ERC20 transferFrom is done via a helper that uses SafeTransferLib, which should be safe against reentrancy since ERC20 tokens don't have callbacks. So that's probably okay.

drawdownFunds has a check for msg.sender == _borrower. It calculates additionalCollateralRequired and then calls _drawdownFunds. The collateralPosted_ is set based on postCollateral, which again uses transferFrom. But maybe there's an issue with how collateral is calculated. For example, if the additional collateral required is less than unaccountedCollateral, collateralPosted_ could be zero even if some collateral is needed. Wait, the code subtracts unaccountedCollateral from additionalCollateralRequired. But if additionalCollateralRequired is less than unaccountedCollateral, it would underflow, but there's a ternary check to prevent that. So it uses max(0, additionalCollateralRequired - unaccountedCollateral). That seems okay, but maybe there's a miscalculation here. Let me check the logic again.

postCollateral function allows anyone to post collateral? Wait, no, the function is public but requires that the msg.sender transfers the collateral, so only the caller can post their own collateral. But maybe it's intended for the borrower to post collateral. Wait, the function is public, so anyone can call it. But in the context of a loan, maybe that's okay because it's adding more collateral. Although if someone else adds collateral, it might benefit the borrower, but the borrower could potentially remove it if they have access to removeCollateral. Wait, the removeCollateral function requires msg.sender == _borrower. So if someone else posts collateral, the borrower can remove it. That's a problem. So if an external user mistakenly sends collateral via postCollateral, the borrower can take it. That's a risk. So that's a vulnerability—collateral posted by anyone can be removed by the borrower. That's a centralization risk or a potential theft vector.

Another thing: the postCollateral function emits the amount of collateral posted as collateralPosted_, which is the return value of _postCollateral. Need to check what _postCollateral does. If it's just adding the amount_ to _collateral, then the event would log the actual increase. But if there's a miscalculation here, maybe. Let's assume _postCollateral correctly accounts for the transferred amount. But the problem is that anyone can call postCollateral, and the borrower can then remove that collateral. So that's an issue.

Looking at the removeCollateral function, it allows the borrower to remove any amount. But there's a check in _removeCollateral that ensures they don't remove more than the excess. Wait, the function calls _removeCollateral(amount_, destination_). So the internal function should handle the checks. Let's check MapleLoanInternals.sol (not provided here), but assuming that _removeCollateral checks that the amount to remove doesn't exceed the excess collateral. If not, then the borrower could remove more collateral than allowed, leading to under-collateralization. That's a potential issue if the internal function doesn't properly validate.

Another function is proposeNewTerms. Only the borrower can propose new terms. But what's the process for accepting them? The lender has to accept. But maybe there's a front-running issue here, but not sure.

In the acceptNewTerms function, the lender can accept new terms. The function transfers funds and then calls _acceptNewTerms. There's a part where after processing, it checks for any extra funds and sends them back to the lender. But if the transfer fails, the whole transaction reverts. That's okay.

The fundLoan function is called to fund the loan. It checks if _nextPaymentDueDate is zero to emit the Funded event. But what if the loan is already funded? The function allows multiple funding, but maybe that's intended. However, if the loan is already funded, adding more funds might be possible. But the _fundLoan function probably sets the lender and initializes the loan. Wait, the code says if _nextPaymentDueDate is zero, then it calls _fundLoan(lender_). So it's only allowed once. So multiple calls to fundLoan after the initial funding would not set the lender again, but would still transfer funds. However, the extra funds are sent back to the lender. So maybe that's okay. But if the lender is different in subsequent calls, that could be a problem. Wait, no, the lender is set in the initial call. So the first time fundLoan is called, the lender_ is set, and any subsequent calls would have to come from the same lender (since fundLoan is external and whenProtocolNotPaused, but the lender is fixed once set). Hmm, maybe not. The fundLoan function's parameter is lender_, but in the code, when _nextPaymentDueDate is zero, it calls _fundLoan(lender_), which probably sets the _lender variable. So the first call to fundLoan sets the lender. Subsequent calls would not go into that if block, so the lender is fixed. But anyone can call fundLoan as long as the protocol is not paused. But the function transfers funds from msg.sender to the contract. But after the initial funding, any additional funds sent would be considered as part of the loan? Or would be redirected back to the lender. Because after processing, there's a check for extra funds, which are sent to _lender. So if someone else calls fundLoan after the initial funding, they transfer funds to the contract, which then gets sent to the original lender. That's a problem because an attacker could make someone else's tokens get sent to the lender. For example, if Alice is the lender, and Bob calls fundLoan with amount_ 100, transferring 100 tokens from Bob to the contract, then the code would see that _nextPaymentDueDate is not zero, so it skips setting the lender. Then, the code checks for extra funds (the 100 just transferred) and sends them to _lender (Alice). So Bob's 100 tokens are sent to Alice. That's a vulnerability where anyone can cause tokens to be transferred from their address to the lender's address. But since the function requires that msg.sender approves the contract to spend their tokens, maybe it's not a direct theft, but if someone is tricked into approving the contract and calling fundLoan, their funds would be sent to the lender. But the function's existence allows this, which could be a phishing risk or unexpected behavior.

Another issue: the skim function allows the borrower or lender to skim any tokens that are not the fundsAsset or collateralAsset. But if the contract accidentally receives fundsAsset or collateralAsset, they can't be skimmed, leading to locked funds. However, the functions that handle funds (like closeLoan, makePayment, etc.) should account for those. But if there's an error in accounting, those funds could be stuck. But the skim function is intended to allow recovery of other tokens. However, if the contract is supposed to hold fundsAsset or collateralAsset normally, then not being able to skim them is correct. So that's probably not a vulnerability.

Looking at access controls: functions like setPendingBorrower, setPendingLender are only callable by the current borrower or lender. That's okay. But if a borrower sets a pending borrower who is malicious, the new borrower could take over. But there's an acceptBorrower step, so it requires the pending borrower to accept. So that's a two-step process, which is secure.

Reentrancy: Most functions use transferFrom which is safe, but are there any functions that perform external calls before updating state? For example, in acceptNewTerms, after calling _acceptNewTerms, it transfers extra funds to the lender. If the _acceptNewTerms makes an external call, that could be a reentrancy vector. But without seeing the implementation of _acceptNewTerms, it's hard to say. But assuming that internal functions are secure.

Another thing: the getAdditionalCollateralRequiredFor function calculates required collateral. If the calculation is incorrect, it could lead to under-collateralization. But that's a business logic issue, not a vulnerability per se unless the math is wrong. Without seeing the implementation of _getCollateralRequiredFor, it's hard to tell.

The upgrade function allows the borrower to upgrade the contract's implementation. This is a high-risk function because a malicious implementation could drain funds or change the contract's behavior. The function calls IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_), which presumably changes the implementation. If the borrower is compromised, they could upgrade to a malicious contract. This is a centralization risk and a significant vulnerability if the borrower's account is not trustworthy.

Also, the migrate function can be called by the factory to migrate the contract. The _migrate function's success is required. But again, if the factory is compromised, this could be an issue, but that's a trust in the factory.

In the fundLoan function, if the initial funding is done by a malicious actor before the intended lender, they could set themselves as the lender. But the function can only be called once because _nextPaymentDueDate is set after the first call. So the first fundLoan call sets the lender. If someone front-runs the initial funding, they could become the lender. That's a vulnerability if the lender isn't properly authenticated. For example, in a system where the lender is supposed to be a specific entity, but the fundLoan allows anyone to fund it first, leading to a wrong lender. This could happen if the loan is initialized without a predefined lender, and the first person to call fundLoan becomes the lender. That's a potential issue if not properly managed off-chain.

Another possible issue is the use of _getUnaccountedAmount in drawdownFunds. This function probably checks the contract's balance against the internal accounting. If there's a discrepancy, it's considered unaccounted. However, if the collateralAsset is a fee-on-transfer token, the actual received amount could be less than the transferred amount, leading to incorrect calculations. For example, when posting collateral, if the token takes a fee, the contract's balance increases by less than amount_. The _postCollateral function would then add the full amount_ to _collateral, but the actual balance is less. This would cause an inconsistency and potential under-collateralization. Similarly for other ERC20 interactions, if tokens with fee-on-transfer are used, the accounting would be incorrect. The contract doesn't account for such tokens, which is a vulnerability.

Also, in functions like postCollateral, the code transfers amount_ from the user, but if the token is fee-on-transfer, the actual received amount is less. However, the code adds amount_ to _collateral (assuming _postCollateral does that), leading to an overstatement of collateral. This would allow the borrower to drawdown more funds than collateralized, leading to under-collateralization. So the contract is incompatible with fee-on-transfer tokens, which is a vulnerability.

Similarly, in functions like makePayment, closeLoan, etc., transferring the exact amount_ without checking the actual balance change could lead to issues with fee-on-transfer tokens. The contract assumes that the transferred amount is exactly what's received, which isn't the case for such tokens. This would result in incorrect accounting of payments or funds.

The returnFunds function allows the borrower to return funds. But if they use a fee-on-transfer token, the actual received amount is less, leading to underpayment but the contract would consider the full amount_ as returned. This could cause the lender to receive less than expected.

Another possible issue is the lack of event emission in some state-changing functions. For example, when collateral is removed, the event CollateralRemoved is emitted, but does the internal function _removeCollateral properly update the state? If the internal function doesn't adjust _collateral correctly, the event might not reflect the actual state. But since the event is emitted before the internal call, if the internal function fails, the event would still be emitted. Wait, no: in removeCollateral, the code emits CollateralRemoved and then calls _removeCollateral. If _removeCollateral reverts, the entire transaction is reverted, including the event. So that's okay.

There's also a possible issue with the late fee calculation. If the lateFeeRate is too high, it could cause integer overflows, but since Solidity 0.8.x has checked math, that would revert, which is safe.

In the acceptNewTerms function, after processing, any extra funds are sent back to the lender. But if the lender is a contract with a revert-on-receive logic, this transfer could fail, causing the entire transaction to revert. That's a potential DoS if the lender is a malicious contract. However, the lender is supposed to be a trusted party, so this might be acceptable.

The _getEarlyPaymentBreakdown and _getNextPaymentBreakdown functions return values based on internal state. If the calculations are incorrect, it could lead to incorrect payment amounts. But again, without seeing the implementation, it's hard to tell.

In summary, the key vulnerabilities I can spot are:

1. **Incorrect Collateral Handling (Centralization Risk):** The postCollateral function allows anyone to post collateral, which the borrower can then remove. This could lead to a scenario where a third party's collateral is stolen by the borrower if they are tricked into posting collateral.

2. **Incompatibility with Fee-on-Transfer Tokens:** The contract does not account for tokens that charge fees on transfers, leading to discrepancies between the actual balance and the recorded amounts. This affects collateral posting, fund transfers, and could result in under-collateralization or incorrect payment accounting.

3. **Funds Theft via fundLoan Function:** After the initial funding, any user can call fundLoan, transferring their tokens to the contract, which are then immediately sent to the lender. This could be used to trick users into sending their tokens to the lender, especially if they are misled into approving the contract.

4. **Upgradeability Risk (Malicious Implementation):** The borrower can upgrade the contract's implementation, which could introduce malicious code if the borrower's account is compromised. This centralizes trust in the borrower and poses a significant risk.

5. **Front-Running Initial fundLoan Call:** The first caller to fundLoan becomes the lender, which could be exploited by an attacker front-running the intended lender's transaction, thereby becoming the lender illegitimately.

6. **Lack of Access Control in postCollateral:** Although postCollateral is public, allowing anyone to add collateral may not be desirable. While the borrower can remove excess collateral, this could lead to unexpected behavior or confusion.

7. **Potential Under-Collateralization Due to Incorrect Collateral Calculation:** If the _getCollateralRequiredFor function miscalculates the required collateral, the contract might allow drawdowns without sufficient collateral, but this depends on the internal implementation.

8. **Unhandled ERC20 Return Values:** The code uses ERC20Helper which presumably uses SafeTransferLib, which should handle ERC20 transfers correctly. So this might not be an issue, but if any transfer is not checked, it could fail silently. However, the helper likely reverts on failure, so this is probably not a problem.

So the main vulnerabilities are related to access controls (postCollateral), fee-on-transfer tokens, fundLoan's unexpected behavior, upgradeability risks, and front-running in fundLoan.","```
None.
```",0.0
MapleLoanInternals.sol,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IERC20 } from ""../modules/erc20/src/interfaces/IERC20.sol"";

import { ERC20Helper }  from ""../modules/erc20-helper/src/ERC20Helper.sol"";
import { MapleProxied } from ""../modules/maple-proxy-factory/contracts/MapleProxied.sol"";

import { ILenderLike } from ""./interfaces/Interfaces.sol"";

/// @title MapleLoanInternals defines the storage layout and internal logic of MapleLoan.
contract MapleLoanInternals is MapleProxied {

    uint256 private constant SCALED_ONE = uint256(10 ** 18);

    // Roles
    address internal _borrower;         // The address of the borrower.
    address internal _lender;           // The address of the lender.
    address internal _pendingBorrower;  // The address of the pendingBorrower, the only address that can accept the borrower role.
    address internal _pendingLender;    // The address of the pendingLender, the only address that can accept the lender role.

    // Assets
    address internal _collateralAsset;  // The address of the asset used as collateral.
    address internal _fundsAsset;       // The address of the asset used as funds.

    // Loan Term Parameters
    uint256 internal _gracePeriod;      // The number of seconds a payment can be late.
    uint256 internal _paymentInterval;  // The number of seconds between payments.

    // Rates
    uint256 internal _interestRate;         // The annualized interest rate of the loan.
    uint256 internal _earlyFeeRate;         // The fee rate for prematurely closing loans.
    uint256 internal _lateFeeRate;          // The fee rate for late payments.
    uint256 internal _lateInterestPremium;  // The amount to increase the interest rate by for late payments.

    // Requested Amounts
    uint256 internal _collateralRequired;  // The collateral the borrower is expected to put up to draw down all _principalRequested.
    uint256 internal _principalRequested;  // The funds the borrowers wants to borrow.
    uint256 internal _endingPrincipal;     // The principal to remain at end of loan.

    // State
    uint256 internal _drawableFunds;       // The amount of funds that can be drawn down.
    uint256 internal _claimableFunds;      // The amount of funds that the lender can claim (principal repayments, interest, etc).
    uint256 internal _collateral;          // The amount of collateral, in collateral asset, that is currently posted.
    uint256 internal _nextPaymentDueDate;  // The timestamp of due date of next payment.
    uint256 internal _paymentsRemaining;   // The number of payments remaining.
    uint256 internal _principal;           // The amount of principal yet to be paid down.

    // Refinance
    bytes32 internal _refinanceCommitment;

    /**********************************/
    /*** Internal General Functions ***/
    /**********************************/

    /// @dev Clears all state variables to end a loan, but keep borrower and lender withdrawal functionality intact.
    function _clearLoanAccounting() internal {
        _gracePeriod     = uint256(0);
        _paymentInterval = uint256(0);

        _interestRate        = uint256(0);
        _earlyFeeRate        = uint256(0);
        _lateFeeRate         = uint256(0);
        _lateInterestPremium = uint256(0);

        _endingPrincipal = uint256(0);

        _nextPaymentDueDate = uint256(0);
        _paymentsRemaining  = uint256(0);
        _principal          = uint256(0);
    }

    /**
     *  @dev   Initializes the loan.
     *  @param borrower_   The address of the borrower.
     *  @param assets_     Array of asset addresses.
     *                         [0]: collateralAsset,
     *                         [1]: fundsAsset.
     *  @param termDetails_ Array of loan parameters:
     *                         [0]: gracePeriod,
     *                         [1]: paymentInterval,
     *                         [2]: payments,
     *  @param amounts_    Requested amounts:
     *                         [0]: collateralRequired,
     *                         [1]: principalRequested,
     *                         [2]: endingPrincipal.
     *  @param rates_      Fee parameters:
     *                         [0]: interestRate,
     *                         [1]: earlyFeeRate,
     *                         [2]: lateFeeRate,
     *                         [3]: lateInterestPremium.
     */
    function _initialize(
        address borrower_,
        address[2] memory assets_,
        uint256[3] memory termDetails_,
        uint256[3] memory amounts_,
        uint256[4] memory rates_
    )
        internal
    {
        // Principal requested need to be non-zero (see `_getCollateralRequiredFor` math).
        require(amounts_[1] > uint256(0), ""MLI:I:INVALID_PRINCIPAL"");

        // Ending principal needs to be less than or equal to principal requested.
        require(amounts_[2] <= amounts_[1], ""MLI:I:INVALID_ENDING_PRINCIPAL"");

        _borrower = borrower_;

        _collateralAsset = assets_[0];
        _fundsAsset      = assets_[1];

        _gracePeriod       = termDetails_[0];
        _paymentInterval   = termDetails_[1];
        _paymentsRemaining = termDetails_[2];

        _collateralRequired = amounts_[0];
        _principalRequested = amounts_[1];
        _endingPrincipal    = amounts_[2];

        _interestRate        = rates_[0];
        _earlyFeeRate        = rates_[1];
        _lateFeeRate         = rates_[2];
        _lateInterestPremium = rates_[3];
    }

    /**************************************/
    /*** Internal Borrow-side Functions ***/
    /**************************************/

    /// @dev Prematurely ends a loan by making all remaining payments.
    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {
        require(block.timestamp <= _nextPaymentDueDate, ""MLI:CL:PAYMENT_IS_LATE"");

        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.
        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid_;

        _claimableFunds += totalPaid_;

        _clearLoanAccounting();
    }

    /// @dev Sends `amount_` of `_drawableFunds` to `destination_`.
    function _drawdownFunds(uint256 amount_, address destination_) internal {
        _drawableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:DF:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                ""MLI:DF:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Makes a payment to progress the loan closer to maturity.
    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.
        // NOTE: This line will revert if not enough funds were added for the full payment amount.
        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid_;

        _claimableFunds += totalPaid_;

        if (_paymentsRemaining == uint256(1)) {
            _clearLoanAccounting();  // Assumes `_getNextPaymentBreakdown` returns a `principal_` that is `_principal`.
        } else {
            _nextPaymentDueDate += _paymentInterval;
            _principal          -= principal_;
            _paymentsRemaining--;
        }
    }

    /// @dev Registers the delivery of an amount of collateral to be posted.
    function _postCollateral() internal returns (uint256 collateralPosted_) {
        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));
    }

    /// @dev Sets refinance commitment given refinance operations.
    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {
        // NOTE: There is no way to invalidate the `refinanceCommitment` (i.e. bytes32(0)) without explicitly setting it if `calls_.length` is 0.
        return _refinanceCommitment =
            calls_.length > uint256(0)
                ? _getRefinanceCommitment(refinancer_, calls_)
                : bytes32(0);
    }

    /// @dev Sends `amount_` of `_collateral` to `destination_`.
    function _removeCollateral(uint256 amount_, address destination_) internal {
        _collateral -= amount_;

        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), ""MLI:RC:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                     ""MLI:RC:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Registers the delivery of an amount of funds to be returned as `_drawableFunds`.
    function _returnFunds() internal returns (uint256 fundsReturned_) {
        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));
    }

    /************************************/
    /*** Internal Lend-side Functions ***/
    /************************************/

    /// @dev Processes refinance operations.
    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {
        // NOTE: A zero refinancer address and/or empty calls array will never (probabilistically) match a refinance commitment in storage.
        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), ""MLI:ANT:COMMITMENT_MISMATCH"");

        uint256 size;

        assembly {
            size := extcodesize(refinancer_)
        }

        require(size != uint256(0), ""MLI:ANT:INVALID_REFINANCER"");

        // Clear refinance commitment to prevent implications of re-acceptance of another call to `_acceptNewTerms`.
        _refinanceCommitment = bytes32(0);

        uint256 callCount = calls_.length;

        for (uint256 i; i < callCount; ++i) {
            ( bool success, ) = refinancer_.delegatecall(calls_[i]);
            require(success, ""MLI:ANT:FAILED"");
        }

        // Ensure that collateral is maintained after changes made.
        require(_isCollateralMaintained(), ""MLI:ANT:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Sends `amount_` of `_claimableFunds` to `destination_`.
    /// @dev If `amount_` is higher than `_claimableFunds` the transaction will underflow and revert.
    function _claimFunds(uint256 amount_, address destination_) internal {
        _claimableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:CF:TRANSFER_FAILED"");
    }

    /// @dev Fund the loan and kick off the repayment requirements.
    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {
        // Can only fund loan if there are payments remaining (as defined by the initialization) and no payment is due yet (as set by a funding).
        require((_nextPaymentDueDate == uint256(0)) && (_paymentsRemaining != uint256(0)), ""MLI:FL:LOAN_ACTIVE"");

        _lender             = lender_;
        _nextPaymentDueDate = block.timestamp + _paymentInterval;

        // Amount funded and principal are as requested.
        fundsLent_ = _principal = _principalRequested;

        // Cannot under-fund loan, but over-funding results in additional funds left unaccounted for.
        require(_getUnaccountedAmount(_fundsAsset) >= fundsLent_, ""MLI:FL:WRONG_FUND_AMOUNT"");

        // Transfer the annualized treasury fee, if any, to the Maple treasury, and decrement drawable funds.
        uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.
        uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        // Drawable funds is the amount funded, minus any fees.
        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;

        require(
            treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),
            ""MLI:FL:T_TRANSFER_FAILED""
        );

        require(
            delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),
            ""MLI:FL:PD_TRANSFER_FAILED""
        );
    }

    /// @dev Reset all state variables in order to release funds and collateral of a loan in default.
    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        uint256 nextPaymentDueDate = _nextPaymentDueDate;

        require(
            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),
            ""MLI:R:NOT_IN_DEFAULT""
        );

        _clearLoanAccounting();

        // Uniquely in `_repossess`, stop accounting for all funds so that they can be swept.
        _collateral     = uint256(0);
        _claimableFunds = uint256(0);
        _drawableFunds  = uint256(0);

        // Either there is no collateral to repossess, or the transfer of the collateral succeeds.
        require(
            (collateralRepossessed_ = _getUnaccountedAmount(_collateralAsset)) == uint256(0) ||
            ERC20Helper.transfer(_collateralAsset, destination_, collateralRepossessed_),
            ""MLI:R:C_TRANSFER_FAILED""
        );

        // Either there are no funds to repossess, or the transfer of the funds succeeds.
        require(
            (fundsRepossessed_ = _getUnaccountedAmount(_fundsAsset)) == uint256(0) ||
            ERC20Helper.transfer(_fundsAsset, destination_, fundsRepossessed_),
            ""MLI:R:F_TRANSFER_FAILED""
        );
    }

    /*******************************/
    /*** Internal View Functions ***/
    /*******************************/

    /// @dev Returns whether the amount of collateral posted is commensurate with the amount of drawn down (outstanding) principal.
    function _isCollateralMaintained() internal view returns (bool isMaintained_) {
        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);
    }

    /// @dev Get principal and interest breakdown for paying off the entire loan early.
    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        principal_ = _principal;
        interest_  = (_principal * _earlyFeeRate) / SCALED_ONE;
    }

    /// @dev Get principal and interest breakdown for next standard payment.
    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getPaymentBreakdown(
            block.timestamp,
            _nextPaymentDueDate,
            _paymentInterval,
            _principal,
            _endingPrincipal,
            _paymentsRemaining,
            _interestRate,
            _lateFeeRate,
            _lateInterestPremium
        );
    }

    /// @dev Returns the amount of an `asset_` that this contract owns, which is not currently accounted for by its state variables.
    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {
        return IERC20(asset_).balanceOf(address(this))
            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   // `_collateral` is `_collateralAsset` accounted for.
            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  // `_claimableFunds` and `_drawableFunds` are `_fundsAsset` accounted for.
    }

    /*******************************/
    /*** Internal Pure Functions ***/
    /*******************************/

    /// @dev Returns the total collateral to be posted for some drawn down (outstanding) principal and overall collateral ratio requirement.
    function _getCollateralRequiredFor(
        uint256 principal_,
        uint256 drawableFunds_,
        uint256 principalRequested_,
        uint256 collateralRequired_
    )
        internal pure returns (uint256 collateral_)
    {
        // Where (collateral / outstandingPrincipal) should be greater or equal to (collateralRequired / principalRequested).
        // NOTE: principalRequested_ cannot be 0, which is reasonable, since it means this was never a loan.
        return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_;
    }

    /// @dev Returns principal and interest portions of a payment instalment, given generic, stateless loan parameters.
    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)
        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        /*************************************************************************************************\
         *                             |                                                                 *
         * A = installment amount      |      /                         \     /           R           \  *
         * P = principal remaining     |     |  /                 \      |   | ----------------------- | *
         * R = interest rate           | A = | | P * ( 1 + R ) ^ N | - E | * |   /             \       | *
         * N = payments remaining      |     |  \                 /      |   |  | ( 1 + R ) ^ N | - 1  | *
         * E = ending principal target |      \                         /     \  \             /      /  *
         *                             |                                                                 *
         *                             |---------------------------------------------------------------- *
         *                                                                                               *
         * - Where R           is `periodicRate`                                                         *
         * - Where (1 + R) ^ N is `raisedRate`                                                           *
         * - Both of these rates are scaled by 1e18 (e.g., 12% => 0.12 * 10 ** 18)                       *
        \*************************************************************************************************/

        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);
        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);

        // NOTE: If a lack of precision in `_scaledExponent` results in a `raisedRate` smaller than one, assume it to be one and simplify the equation.
        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));

        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);

        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);
        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);
    }

    /// @dev Returns an amount by applying an annualized and scaled interest rate, to a principal, over an interval of time.
    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {
        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;
    }

    /// @dev Returns total principal and interest portion of a number of payments, given generic, stateless loan parameters and loan state.
    function _getPaymentBreakdown(
        uint256 currentTime_,
        uint256 nextPaymentDueDate_,
        uint256 paymentInterval_,
        uint256 principal_,
        uint256 endingPrincipal_,
        uint256 paymentsRemaining_,
        uint256 interestRate_,
        uint256 lateFeeRate_,
        uint256 lateInterestPremium_
    )
        internal pure virtual
        returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        ( principalAmount_,interestAmount_ ) = _getInstallment(
            principal_,
            endingPrincipal_,
            interestRate_,
            paymentInterval_,
            paymentsRemaining_
        );

        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;

        if (currentTime_ > nextPaymentDueDate_) {
            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, currentTime_ - nextPaymentDueDate_);
            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;
        }
    }

    /// @dev Returns the interest rate over an interval, given an annualized interest rate.
    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {
        return (interestRate_ * interval_) / uint256(365 days);
    }

    /// @dev Returns refinance commitment given refinance parameters.
    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {
        return keccak256(abi.encode(refinancer_, calls_));
    }

    /**
     *  @dev Returns exponentiation of a scaled base value.
     *
     *       Walk through example:
     *       LINE  |  base_          |  exponent_  |  one_  |  result_
     *             |  3_00           |  18         |  1_00  |  0_00
     *        A    |  3_00           |  18         |  1_00  |  1_00
     *        B    |  3_00           |  9          |  1_00  |  1_00
     *        C    |  9_00           |  9          |  1_00  |  1_00
     *        D    |  9_00           |  9          |  1_00  |  9_00
     *        B    |  9_00           |  4          |  1_00  |  9_00
     *        C    |  81_00          |  4          |  1_00  |  9_00
     *        B    |  81_00          |  2          |  1_00  |  9_00
     *        C    |  6_561_00       |  2          |  1_00  |  9_00
     *        B    |  6_561_00       |  1          |  1_00  |  9_00
     *        C    |  43_046_721_00  |  1          |  1_00  |  9_00
     *        D    |  43_046_721_00  |  1          |  1_00  |  387_420_489_00
     *        B    |  43_046_721_00  |  0          |  1_00  |  387_420_489_00
     *
     * Another implementation of this algorithm can be found in Dapphub's DSMath contract:
     * https://github.com/dapphub/ds-math/blob/ce67c0fa9f8262ecd3d76b9e4c026cda6045e96c/src/math.sol#L77
     */
    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {
        // If exponent_ is odd, set result_ to base_, else set to one_.
        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          // A

        // Divide exponent_ by 2 (overwriting itself) and proceed if not zero.
        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      // B
            base_ = (base_ * base_) / one_;                                     // C

            // If exponent_ is even, go back to top.
            if (exponent_ & uint256(1) == uint256(0)) continue;

            // If exponent_ is odd, multiply result_ is multiplied by base_.
            result_ = (result_ * base_) / one_;                                 // D
        }
    }

}",5492.0,477.0,"[M-02] Unsafe implementation of fundLoan() allows attacker to steal collateral from an unfunded loan
“uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);”
“uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);""
“_drawableFunds = fundsLent_ - treasuryFee - delegateFee;”
In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.
This allows the attacker to set very high fees, making `_drawableFunds` near 0.
Since mapleTreasury and poolDelegate are also read from `lender_`, treasuryFee and investorFee can be retrieved back to the attacker.
As a result, the borrower won't get any _drawableFunds while also being unable to remove collateral.",1.0,"pragma solidity ^0.8.7;

import { IERC20 } from ""../modules/erc20/src/interfaces/IERC20.sol"";

import { ERC20Helper }  from ""../modules/erc20-helper/src/ERC20Helper.sol"";
import { MapleProxied } from ""../modules/maple-proxy-factory/contracts/MapleProxied.sol"";

import { ILenderLike } from ""./interfaces/Interfaces.sol"";


contract MapleLoanInternals is MapleProxied {

    uint256 private constant SCALED_ONE = uint256(10 ** 18);

    
    address internal _borrower;         
    address internal _lender;           
    address internal _pendingBorrower;  
    address internal _pendingLender;    

    
    address internal _collateralAsset;  
    address internal _fundsAsset;       

    
    uint256 internal _gracePeriod;      
    uint256 internal _paymentInterval;  

    
    uint256 internal _interestRate;         
    uint256 internal _earlyFeeRate;         
    uint256 internal _lateFeeRate;          
    uint256 internal _lateInterestPremium;  

    
    uint256 internal _collateralRequired;  
    uint256 internal _principalRequested;  
    uint256 internal _endingPrincipal;     

    
    uint256 internal _drawableFunds;       
    uint256 internal _claimableFunds;      
    uint256 internal _collateral;          
    uint256 internal _nextPaymentDueDate;  
    uint256 internal _paymentsRemaining;   
    uint256 internal _principal;           

    
    bytes32 internal _refinanceCommitment;

    
    
    

    
    function _clearLoanAccounting() internal {
        _gracePeriod     = uint256(0);
        _paymentInterval = uint256(0);

        _interestRate        = uint256(0);
        _earlyFeeRate        = uint256(0);
        _lateFeeRate         = uint256(0);
        _lateInterestPremium = uint256(0);

        _endingPrincipal = uint256(0);

        _nextPaymentDueDate = uint256(0);
        _paymentsRemaining  = uint256(0);
        _principal          = uint256(0);
    }

    
    function _initialize(
        address borrower_,
        address[2] memory assets_,
        uint256[3] memory termDetails_,
        uint256[3] memory amounts_,
        uint256[4] memory rates_
    )
        internal
    {
        
        require(amounts_[1] > uint256(0), ""MLI:I:INVALID_PRINCIPAL"");

        
        require(amounts_[2] <= amounts_[1], ""MLI:I:INVALID_ENDING_PRINCIPAL"");

        _borrower = borrower_;

        _collateralAsset = assets_[0];
        _fundsAsset      = assets_[1];

        _gracePeriod       = termDetails_[0];
        _paymentInterval   = termDetails_[1];
        _paymentsRemaining = termDetails_[2];

        _collateralRequired = amounts_[0];
        _principalRequested = amounts_[1];
        _endingPrincipal    = amounts_[2];

        _interestRate        = rates_[0];
        _earlyFeeRate        = rates_[1];
        _lateFeeRate         = rates_[2];
        _lateInterestPremium = rates_[3];
    }

    
    
    

    
    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {
        require(block.timestamp <= _nextPaymentDueDate, ""MLI:CL:PAYMENT_IS_LATE"");

        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        
        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid_;

        _claimableFunds += totalPaid_;

        _clearLoanAccounting();
    }

    
    function _drawdownFunds(uint256 amount_, address destination_) internal {
        _drawableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:DF:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                ""MLI:DF:INSUFFICIENT_COLLATERAL"");
    }

    
    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        
        
        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid_;

        _claimableFunds += totalPaid_;

        if (_paymentsRemaining == uint256(1)) {
            _clearLoanAccounting();  
        } else {
            _nextPaymentDueDate += _paymentInterval;
            _principal          -= principal_;
            _paymentsRemaining--;
        }
    }

    
    function _postCollateral() internal returns (uint256 collateralPosted_) {
        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));
    }

    
    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {
        
        return _refinanceCommitment =
            calls_.length > uint256(0)
                ? _getRefinanceCommitment(refinancer_, calls_)
                : bytes32(0);
    }

    
    function _removeCollateral(uint256 amount_, address destination_) internal {
        _collateral -= amount_;

        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), ""MLI:RC:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                     ""MLI:RC:INSUFFICIENT_COLLATERAL"");
    }

    
    function _returnFunds() internal returns (uint256 fundsReturned_) {
        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));
    }

    
    
    

    
    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {
        
        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), ""MLI:ANT:COMMITMENT_MISMATCH"");

        uint256 size;

        assembly {
            size := extcodesize(refinancer_)
        }

        require(size != uint256(0), ""MLI:ANT:INVALID_REFINANCER"");

        
        _refinanceCommitment = bytes32(0);

        uint256 callCount = calls_.length;

        for (uint256 i; i < callCount; ++i) {
            ( bool success, ) = refinancer_.delegatecall(calls_[i]);
            require(success, ""MLI:ANT:FAILED"");
        }

        
        require(_isCollateralMaintained(), ""MLI:ANT:INSUFFICIENT_COLLATERAL"");
    }

    
    
    function _claimFunds(uint256 amount_, address destination_) internal {
        _claimableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:CF:TRANSFER_FAILED"");
    }

    
    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {
        
        require((_nextPaymentDueDate == uint256(0)) && (_paymentsRemaining != uint256(0)), ""MLI:FL:LOAN_ACTIVE"");

        _lender             = lender_;
        _nextPaymentDueDate = block.timestamp + _paymentInterval;

        
        fundsLent_ = _principal = _principalRequested;

        
        require(_getUnaccountedAmount(_fundsAsset) >= fundsLent_, ""MLI:FL:WRONG_FUND_AMOUNT"");

        
        uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        
        uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        
        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;

        require(
            treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),
            ""MLI:FL:T_TRANSFER_FAILED""
        );

        require(
            delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),
            ""MLI:FL:PD_TRANSFER_FAILED""
        );
    }

    
    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        uint256 nextPaymentDueDate = _nextPaymentDueDate;

        require(
            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),
            ""MLI:R:NOT_IN_DEFAULT""
        );

        _clearLoanAccounting();

        
        _collateral     = uint256(0);
        _claimableFunds = uint256(0);
        _drawableFunds  = uint256(0);

        
        require(
            (collateralRepossessed_ = _getUnaccountedAmount(_collateralAsset)) == uint256(0) ||
            ERC20Helper.transfer(_collateralAsset, destination_, collateralRepossessed_),
            ""MLI:R:C_TRANSFER_FAILED""
        );

        
        require(
            (fundsRepossessed_ = _getUnaccountedAmount(_fundsAsset)) == uint256(0) ||
            ERC20Helper.transfer(_fundsAsset, destination_, fundsRepossessed_),
            ""MLI:R:F_TRANSFER_FAILED""
        );
    }

    
    
    

    
    function _isCollateralMaintained() internal view returns (bool isMaintained_) {
        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);
    }

    
    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        principal_ = _principal;
        interest_  = (_principal * _earlyFeeRate) / SCALED_ONE;
    }

    
    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getPaymentBreakdown(
            block.timestamp,
            _nextPaymentDueDate,
            _paymentInterval,
            _principal,
            _endingPrincipal,
            _paymentsRemaining,
            _interestRate,
            _lateFeeRate,
            _lateInterestPremium
        );
    }

    
    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {
        return IERC20(asset_).balanceOf(address(this))
            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   
            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  
    }

    
    
    

    
    function _getCollateralRequiredFor(
        uint256 principal_,
        uint256 drawableFunds_,
        uint256 principalRequested_,
        uint256 collateralRequired_
    )
        internal pure returns (uint256 collateral_)
    {
        
        
        return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_;
    }

    
    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)
        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        

        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);
        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);

        
        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));

        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);

        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);
        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);
    }

    
    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {
        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;
    }

    
    function _getPaymentBreakdown(
        uint256 currentTime_,
        uint256 nextPaymentDueDate_,
        uint256 paymentInterval_,
        uint256 principal_,
        uint256 endingPrincipal_,
        uint256 paymentsRemaining_,
        uint256 interestRate_,
        uint256 lateFeeRate_,
        uint256 lateInterestPremium_
    )
        internal pure virtual
        returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        ( principalAmount_,interestAmount_ ) = _getInstallment(
            principal_,
            endingPrincipal_,
            interestRate_,
            paymentInterval_,
            paymentsRemaining_
        );

        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;

        if (currentTime_ > nextPaymentDueDate_) {
            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, currentTime_ - nextPaymentDueDate_);
            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;
        }
    }

    
    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {
        return (interestRate_ * interval_) / uint256(365 days);
    }

    
    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {
        return keccak256(abi.encode(refinancer_, calls_));
    }

    
    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {
        
        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          

        
        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      
            base_ = (base_ * base_) / one_;                                     

            
            if (exponent_ & uint256(1) == uint256(0)) continue;

            
            result_ = (result_ * base_) / one_;                                 
        }
    }

}",3148.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unsafe Delegatecall in `_acceptNewTerms`**  
   The function uses `delegatecall` to execute arbitrary code from an external `refinancer_` address. This allows the `refinancer_` to modify the contract's state arbitrarily, leading to potential exploits such as unauthorized state changes or collateral manipulation.

2. **Integer Overflow/Underflow in Fee Calculation**  
   In `_fundLoan`, the calculation of `treasuryFee` and `delegateFee` involves multiple multiplications that could exceed `uint256` limits, causing overflows. Additionally, insufficient validation may lead to underflows if `treasuryFee + delegateFee > fundsLent_`, reverting the transaction.

3. **Insufficient Collateral Validation Post-Delegatecall**  
   After executing `delegatecall` in `_acceptNewTerms`, the collateral check relies on state variables that could have been altered maliciously by the `refinancer_`, potentially bypassing collateral requirements.

4. **Incorrect Handling of Token Fees**  
   The fee deduction logic in `_fundLoan` assumes the contract holds enough tokens to cover both the principal and fees. If fees exceed the principal (due to misconfigured rates), the subtraction `fundsLent_ - treasuryFee - delegateFee` underflows, reverting the transaction.

5. **Refinance Commitment Malleability**  
   The `_getRefinanceCommitment` hashes the `refinancer_` address and call data but does not account for subsequent code changes in the `refinancer_` contract, allowing for unexpected behavior if the contract is upgraded post-commitment.

6. **Gas Exhaustion in `_scaledExponent`**  
   The loop-based exponentiation in `_scaledExponent` may consume excessive gas for large exponents, causing transaction failures due to out-of-gas errors.

7. **Late Payment Interest Calculation Overflow**  
   If a payment is extremely late, the interest calculation in `_getPaymentBreakdown` could overflow `uint256`, reverting the transaction and potentially locking funds.

8. **Unaccounted Token Balances**  
   Direct transfers of `_collateralAsset` or `_fundsAsset` to the contract without using designated functions (e.g., `_postCollateral`) may leave tokens unaccounted, affecting internal bookkeeping.

9. **Repossession of Unearned Funds**  
   The `_repossess` function transfers all remaining collateral and funds to the lender upon default, regardless of partial repayments, potentially unfairly seizing borrower assets.

10. **Lack of Access Control for Critical Functions**  
    Key functions (e.g., `_proposeNewTerms`, `_acceptNewTerms`) lack explicit access control checks, risking unauthorized execution if not properly restricted in parent contracts.

These vulnerabilities stem from unsafe external calls, improper arithmetic checks, insufficient validation, and potential state manipulation.","### **[M-02] Unsafe implementation of `fundLoan()` allows attacker to steal collateral from an unfunded loan**

**Report Description**:  
The `fundLoan()` function in the smart contract calculates `treasuryFee` and `delegateFee` based on user-provided `lender_` input, which can be manipulated by an attacker. By setting up a malicious contract implementing the `ILenderLike` interface, the attacker can specify excessively high fees, causing `_drawableFunds` to be near zero. Additionally, since `mapleTreasury` and `poolDelegate` are also derived from `lender_`, the attacker can retrieve the fees back to themselves. This results in the borrower receiving no `_drawableFunds` while being unable to remove their collateral, effectively stealing the collateral.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Handling of Token Fees""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with fee calculations and mentions the risk of underflows if `treasuryFee + delegateFee > fundsLent_`. However, it misses the critical aspect of the vulnerability: the ability for an attacker to manipulate `lender_` to set arbitrary fees and retrieve them, leading to collateral theft. The response focuses on arithmetic issues but does not address the broader security implications of untrusted input and fee manipulation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] Unsafe implementation of `fundLoan()` allows attacker to steal collateral from an unfunded loan**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis of Gaps**  
The response list partially addresses the issue by highlighting arithmetic risks in fee calculations but fails to fully capture the exploitability of the vulnerability. Specifically, it does not consider the impact of untrusted `lender_` input and the ability for an attacker to manipulate fees and retrieve them. This gap indicates a need for a more comprehensive understanding of the vulnerability's root cause and potential exploitation scenarios.",0,1,0,10,"Okay, let's take a look at this MapleLoanInternals smart contract and try to identify any vulnerabilities. Hmm, starting with the imports and inheritance. It uses MapleProxied, which is part of a proxy factory. Proxies can have issues with storage collisions, but since this is a proxied contract, maybe that's handled, but maybe there are other proxy-related issues. Let me note that as a possible area to check.

Looking at the state variables, they're all internal or private. So maybe visibility is okay. But need to check for reentrancy, especially in functions that transfer tokens. Let's check functions like _drawdownFunds, _removeCollateral, _claimFunds, etc. These functions use ERC20 transfers. Since ERC20 tokens can have callbacks (like ERC777), but the transfer function used here is from ERC20Helper. Let me check what that does. Oh, ERC20Helper.transfer probably uses the standard transfer method. But if any of the tokens are malicious or have hooks, that could be a problem. However, ERC20 standard transfers don't have hooks, so maybe not. But if the token is not compliant, like some tokens don't return a boolean, then the transfer could fail but the require would catch it. So maybe not a vulnerability here.

Next, let's check the _initialize function. There are some require statements. For example, require(amounts_[1] > 0, ""INVALID_PRINCIPAL""). That's checking that the principal requested is greater than zero. That's good. Then, require(amounts_[2] <= amounts_[1], ""INVALID_ENDING_PRINCIPAL""). Ending principal should be less than or equal to principal. Makes sense. So initial setup seems okay.

Looking at the _closeLoan function. It checks if block.timestamp <= nextPaymentDueDate. Then calculates principal and interest. Then adjusts drawableFunds and claimableFunds. Then clears loan accounting. Wait, when they add _getUnaccountedAmount(_fundsAsset) - totalPaid_ to drawableFunds. What is _getUnaccountedAmount? It's the balance of the asset minus collateral or claimable/drawable funds. So this is accounting for any extra funds sent to the contract. But if someone sends extra funds, they might be accounted here. However, if the contract is supposed to manage these funds properly, maybe there's a way for funds to get locked or mishandled here.

In _drawdownFunds, they subtract amount_ from _drawableFunds and transfer to destination. Then check if collateral is maintained. But if the transfer fails, the state is already updated. Wait, no: the code is _drawableFunds -= amount_; then transfer. If the transfer fails, the function would revert because of the require(ERC20Helper.transfer(...)), so the _drawableFunds would be reverted as well. So that's safe. Similarly in other functions like _removeCollateral.

The _postCollateral function adds the unaccounted collateral. So if someone transfers collateral to the contract, it's added to _collateral. But what if someone transfers tokens without calling this function? Then the collateral wouldn't be accounted for. But there's a function to post collateral, so maybe users are expected to call that. However, if someone accidentally sends collateral directly, it's not accounted for until _postCollateral is called. That could be a potential issue, but maybe by design.

Looking at _proposeNewTerms, it sets _refinanceCommitment. Then in _acceptNewTerms, it checks that the passed refinancer and calls match the stored commitment. Then it does delegatecall to the refinancer. Wait, delegatecall is dangerous here. Because it's using delegatecall to an arbitrary refinancer_ address. The refinancer is supposed to be a trusted contract, but if the commitment allows any refinancer, then an attacker could provide a malicious contract. But the refinancer is part of the commitment, so if the commitment was properly set by a trusted party, maybe that's okay. However, if there's a way to propose a malicious refinancer, then delegatecall could lead to vulnerabilities. Since the code checks that refinancer_ has code (extcodesize != 0), but that's not enough because the code could be malicious. So if the refinancer is not properly vetted, this could allow arbitrary code execution via delegatecall, which can modify the contract's state. This is a high-risk vulnerability.

Another thing: the _fundLoan function calculates treasuryFee and delegateFee. The calculation is (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / (365 days * 10_000). Wait, the multiplication order here could lead to overflow. Because fundsLent_ is a token amount, which could be up to 1e18 (for 18 decimals), then multiplied by treasuryFee (maybe up to 10_000, but let's say a percentage). Then multiplied by _paymentInterval (could be in seconds, maybe 30 days = 2,592,000) and _paymentsRemaining (could be a large number). Multiplying all these together could exceed uint256, causing an overflow. But since Solidity 0.8.x has checked math, this would revert. So if these values are not properly constrained, this could make the function revert, which is a DoS vulnerability. For example, if paymentsRemaining is large enough, the multiplication would overflow. The lender's treasuryFee and investorFee should be checked to not cause this overflow.

Another point: in _fundLoan, they require that the unaccounted amount of fundsAsset is >= fundsLent_. Then subtract the fees. But if the fees are a portion of fundsLent_, the actual funds available must be fundsLent_ (the principal) plus the fees. Because the contract needs to have fundsLent_ + fees in order to take the fees out. Wait, let's see: fundsLent_ is the principal. Then the fees are computed as (fundsLent_ * treasuryFee * paymentInterval * paymentsRemaining) / (365 days * 10000). Then the drawableFunds is fundsLent_ - treasuryFee - delegateFee. But where do the fees come from? If the lender is supposed to send the principal plus the fees, then the contract's balance should be fundsLent_ + treasuryFee + delegateFee. But in the code, they check that the unaccounted amount (which is balance minus claimable and drawable) is >= fundsLent_. That could be an issue because the fees are deducted from the principal, but the actual required funds are principal + fees. So the contract might not have enough balance to cover both the principal and the fees. This could lead to underflow when subtracting fees from fundsLent_. For example, if fundsLent_ is 100, and treasuryFee + delegateFee is 110, then 100 - 110 would underflow, causing a revert. But the code doesn't check that fundsLent_ >= treasuryFee + delegateFee. So if the fees sum to more than the principal, this would underflow. Which would be a problem. Therefore, the calculation of the fees must ensure that treasuryFee + delegateFee <= fundsLent_. But there's no check for that. This is a possible vulnerability.

Wait, let's look at the code:

fundsLent_ is set to _principal = _principalRequested.

treasuryFee is (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / (365 days * 10_000).

Same for delegateFee.

So if the product of treasuryFee rate, paymentInterval, and paymentsRemaining is high enough, the fees could be larger than fundsLent_, leading to underflow. For example, suppose the treasuryFee is 10_000 (100%), paymentInterval is 1 year (365 days), paymentsRemaining is 1. Then the calculation would be (fundsLent_ * 10000 * 365 days * 1) / (365 days * 10000) = fundsLent_. So treasuryFee would be fundsLent_, and delegateFee could be another fundsLent_, leading to treasuryFee + delegateFee = 2 * fundsLent_. Then fundsLent_ - 2 * fundsLent_ would underflow. So this is a possible issue. Therefore, the code should ensure that (treasuryFee + delegateFee) <= fundsLent_. Otherwise, this would revert and the loan funding would fail. But if the lender can set these fees arbitrarily, this is a problem. So the lack of a check here is a vulnerability.

Another possible issue is in the _getInstallment function. It calculates the periodicRate and raisedRate. If raisedRate is less than or equal to SCALED_ONE, returns (principal - endingPrincipal)/payments, 0 interest. But if the interest rate is zero, this would happen, leading to no interest. But that's intended. However, if paymentsRemaining is zero, division by zero would occur. But in _fundLoan, paymentsRemaining is checked to be non-zero. So maybe that's handled.

In _getPaymentBreakdown, when currentTime_ is after nextPaymentDueDate_, it adds late interest and fees. The late interest is computed as (principal * (interestRate + lateInterestPremium) * (currentTime - nextPaymentDueDate)) / (365 days * 1e18). But if currentTime is very large, this could cause the interest to be very high, leading to potential overflow. However, with Solidity 0.8's checked math, this would revert. But if the payment is extremely late, this could cause the transaction to revert, which might lock funds. This is a possible DoS vector, but depends on how the contract is used.

Another thing: the _repossess function allows the lender to repossess collateral and funds if the loan is in default. It transfers all unaccounted collateral and funds. But what if the loan has been partially paid? The function clears all accounting, so any remaining principal or collateral is taken by the lender, which might not account for what's owed. But this is part of the loan terms, so maybe intended. However, the _repossess function doesn't check if the borrower has already made some payments. It just checks if the current time is past the due date plus grace period. So if the borrower made a partial payment but not enough, the lender can still repossess everything. This could be a design choice, but if not properly documented, could be an issue.

In the _scaledExponent function, there's a loop that does exponentiation by squaring. However, if the exponent is large, this could consume a lot of gas, leading to potential out-of-gas errors. For example, if exponent_ is a very large number, the loop could run many times. But in practice, paymentsRemaining is likely not going to be extremely large, so maybe this is acceptable.

Looking back at the _acceptNewTerms function, it uses delegatecall to the refinancer. This is a critical point. Delegatecall allows the called contract to modify the state of the current contract. If the refinancer is malicious or has vulnerabilities, it could manipulate the contract's state variables. Since the refinancer is part of the commitment, which is proposed via proposeNewTerms, which can be called by whom? The function _proposeNewTerms is internal, so it must be called by another function. But if the pending lender or borrower can propose new terms with arbitrary refinancers, this could be a problem. However, the access control for proposing new terms isn't clear here. The contract has _pendingLender and _pendingBorrower, but how are these set? Are there functions that allow the borrower or lender to propose new terms? If a malicious actor can propose a refinancer, they could take over the contract via delegatecall. This is a high-severity vulnerability.

Another issue: the _getRefinanceCommitment function generates the commitment as keccak256(abi.encode(refinancer_, calls_)). But the calls_ are passed as calldata, which is an array of bytes. If the calls_ modify the refinancer's code, the commitment could be for a specific refinancer address, but if the refinancer's code is upgraded or changed, the same address could have different behavior. However, the code checks extcodesize(refinancer_) != 0, but doesn't check the code hash. So if the refinancer is a contract that can be upgraded, the commitment could be valid for the same address but different code. This could lead to unexpected behavior if the refinancer is changed after the commitment is made.

Also, in _acceptNewTerms, after delegatecalls, it checks if collateral is maintained. But if the delegatecall modified the state variables (like _collateral, _principal, etc.), the check might not reflect the actual state. Wait, the delegatecall runs in the context of this contract, so any state changes during delegatecall would affect this contract's state. The check _isCollateralMaintained() is after all delegatecalls, so if the delegatecalls altered the state in a way that collateral is not maintained, the require would catch it. But if the delegatecall maliciously changes variables to bypass the check, that's a problem. However, the require ensures that after the delegatecalls, the collateral is still maintained. So maybe that's okay. But if the delegatecall can manipulate variables that affect _isCollateralMaintained, like _collateral, _principal, etc., then the check could be bypassed. For example, if the delegatecall increases _collateral artificially, the check would pass, but the actual collateral might not be there. But since _isCollateralMaintained uses the stored _collateral value, which was potentially modified by the delegatecall, this could be an issue. However, the _collateral variable is only modified by the contract's own functions, so if the delegatecall can modify it, that's a problem. Since delegatecall can write to any state variable, this is a risk. So a malicious refinancer in the delegatecall could manipulate the state to pass the collateral check even if it's not true. For example, set _collateral to a high value, allowing the loan to proceed with insufficient collateral. This is a major vulnerability.

In summary, the key vulnerabilities I can see are:

1. **Unsafe Delegatecall in _acceptNewTerms**: Using delegatecall with a user-provided refinancer_ address allows arbitrary code execution in the context of the contract, leading to potential state manipulation and security breaches.

2. **Potential Integer Overflow in Fee Calculation**: In _fundLoan, the calculation of treasuryFee and delegateFee could overflow if the parameters are too large, causing the transaction to revert. Additionally, insufficient checks on the fee amounts could lead to underflow when subtracting fees from fundsLent_.

3. **Insufficient Collateral Check After Delegatecall**: Even though _acceptNewTerms checks collateral maintenance after delegatecalls, if the delegatecall altered state variables related to collateral or principal, the check could be based on manipulated values, leading to an undercollateralized loan.

4. **Incorrect Fee Deduction Leading to Underflow**: If the sum of treasuryFee and delegateFee exceeds fundsLent_, the subtraction in _drawableFunds calculation would underflow, causing the transaction to revert and preventing the loan from being funded.

5. **Inaccurate Commitment for Refinancing**: The refinance commitment relies on the refinancer's address and call data but doesn't account for potential changes in the refinancer's contract code, allowing for code upgrades that might introduce vulnerabilities.

6. **Possible DoS in Scaled Exponent Function**: The _scaledExponent function uses a loop that could consume excessive gas for large exponents, leading to out-of-gas errors and failed transactions.

7. **Unhandled Token Fees in Fund Loan**: The contract may not have sufficient funds to cover both the principal and the calculated fees if the lender's fees are set too high, causing the fund transaction to revert.

These are the main points I can spot. Let me make sure I didn't miss anything else.","```
None.
```",0.0
,,,,,,,,1,2,,,0,1,2,22,,,