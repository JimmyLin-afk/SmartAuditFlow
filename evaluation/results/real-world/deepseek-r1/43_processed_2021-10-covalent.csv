nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
DelegatedStaking.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates
    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked
    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked
    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed
    uint128 rewardsLocked; // # of tokens the owner sent to the contract
    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens
    uint128 totalGlobalShares; // global shares
    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last
    uint128 globalExchangeRate;
    uint128 validatorsN; // number of validators, used to get validator ids
    mapping(uint128 => Validator) validators; // id -> validator instance
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; // initial CQT amount staked
        uint128 shares; // # of validator shares that delegate owns
    }
    struct Unstaking {
        uint128 coolDownEnd; // epoch when unstaking can be redeemed
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; // validator commission rate
        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled
        uint128 globalShares; // total number of global shares under a validator
        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time
        uint128 totalShares; // total number of validator shares
        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest
        uint128 exchangeRate; // validator exchange rate
        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    // this is used to have the contract upgradeable
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; // ~ 6 months
        delegatorCoolDown = 28*6646; // ~ 28 days
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; // should never be 0
        globalExchangeRate = 10**18; // 1 to 1
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    // used to transfer CQT from delegators, validators and the owner to the contract
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    // update global exchange rate
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        // if the program ended, set update epoch to the end epoch
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            // when no one has staked anything, do not update the rate
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    // update validator exchange rate
    function _updateValidator(Validator storage v) internal {
        // if validator is disabled, we do not update it since it was updated during disabling transaction
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate
                v.exchangeRate = globalExchangeRate;
            }
            else {
                // the growth of global exchange rate since the validator was updated the last time
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                // tokens given to the validator and its delegators since last update
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                // commission paid out of the tokens
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                // increase validator exchange rate by distributing the leftover tokens through the validator shares
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                // give commission tokens to the validator
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            // set the last update global rate to the current one
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    // used to convert global shares or validator shares to CQT
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    // used to convert CQT to global shares or validator shares
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    // need to update global exchange rate, validator data and then delegator instance
    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        // if this is the first stake, then set the end epoch
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; // no longer used and saves a bit of gas
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // if staker is validator who self delegates
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            // otherwise need to check for max cap
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        // it is set to true when there is a stake
        // it is set to false when we recover delegation from unstaking
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        // update global shares #
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        // update validator shares #
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    // need to update global exchange rate, validator data and then delegator instance
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            // update global shares #
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            // update validator shares #
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        // create unstaking instance
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    // restake unstaked tokens
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    // if amount is 0 then redeem all
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            // first redeem rewards from commission
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            // if there is more, redeem  it from regular rewards
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        // update global shares #
        // this includes commission and rewards earned
        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    // redeem all available rewards
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    // add new validator instance
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    // can only be called by the owner or the validator, disabling will allow validator to fully unstake
    // validator instance can only be disabled once and can never be reenabled
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    // change emission rate, should reset end epoch
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            // get number of epochs from now to the end epoch
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            // calculate how much rewards would be distributed with the old emission rate
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            // calculate how many epochs will be covered
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    // we assume that we will never set it to less than what is staked already
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    // only owner can change commission rate
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    // if a validator gets disabled, delegators can redelegate their tokens to another validator
    // first they need to unstake
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    // transfer out unlocked unstaked tokens back to the delegator
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    // returns details of each validator
    // array index is id
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator
    // array index is id of validator
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}",5629,477,"[H-01] Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions
“function initialize(uint128 minStakedRequired) public initializer {“
Based on the context and comments in the code, the DelegatedStaking.sol contract is designed to be deployed as an upgradeable proxy contract.
However, the current implementation is using an non-upgradeable version of the Ownbale library: @openzeppelin/contracts/access/Ownable.sol instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.
A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.
As a result, all the `onlyOwner` functions will be inaccessible.
  [H-02] unstake should update exchange rates first
The unstake function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` with the old exchange rate.
Only afterwards, it updates the exchange rates (if the validator is not disabled):
```
uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate);
require(validatorSharesRemove > 0, ""Unstake amount is too small"");

if (v.disabledEpoch == 0) {
    // @audit rates are updated here
    updateGlobalExchangeRate();
    updateValidator(v);
    // ...
}```   [M-01] reward tokens could get lost due to rounding down
The function `depositRewardTokens` divides the ""amount"" of tokens by `allocatedTokensPerEpoch` to calculate the `endEpoch`. When ""amount"" isn't a multiple of `allocatedTokensPerEpoch` the result of the division will be rounded down, effectively losing a number of tokens for the rewards.
For example if allocatedTokensPerEpoch is set to 3e18 and ""amount"" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.
A similar problem occurs here:
- in `setAllocatedTokensPerEpoch()`, with the recalculation of `endEpoch`
- in `takeOutRewardTokens()`, with the retrieval of tokens
- in `_stake()`, when initializing `endEpoch` (e.g. when endEpoch==0)


[M-02] Incorrect updateGlobalExchangeRate implementation
function `_UpdateGlobalExchangeRate` has incorrect implementation when `totalGlobalShares` is zero.
If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.
  [M-03] Validator can fail to receive commission reward in `redeemAllRewards`
Validator can fail to receive commission reward by calling redeemAllRewards. There's a check in `redeemAllRewards`
“uint128 rewards = sharesToTokens(s.shares, v.exchangeRate) - s.staked;”
“require(rewards > 0, ""Nothing to redeem”);""
The validator's tx might be reverted here even if he got some commission reward to receive.",5,"pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; 
    uint128 validatorCoolDown; 
    uint128 delegatorCoolDown; 
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; 
    uint128 allocatedTokensPerEpoch; 
    uint128 rewardsLocked; 
    uint128 endEpoch; 
    uint128 totalGlobalShares; 
    uint128 lastUpdateEpoch; 
    uint128 globalExchangeRate;
    uint128 validatorsN; 
    mapping(uint128 => Validator) validators; 
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; 
        uint128 shares; 
    }
    struct Unstaking {
        uint128 coolDownEnd; 
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; 
        uint128 disabledEpoch; 
        uint128 globalShares; 
        uint128 lastUpdateGlobalRate; 
        uint128 totalShares; 
        uint128 delegated; 
        uint128 exchangeRate; 
        uint128 commissionAvailableToRedeem; 
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; 
        delegatorCoolDown = 28*6646; 
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; 
        globalExchangeRate = 10**18; 
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    
    function _updateValidator(Validator storage v) internal {
        
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                
                v.exchangeRate = globalExchangeRate;
            }
            else {
                
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    
    
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; 
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        
        
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        
        
        
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    
    
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    
    
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    
    
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    
    
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}",4532,2,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Rounding Down in Reward Redemption Leading to Incorrect Shares Accounting**  
   - **Location**: `_redeemRewards` function  
   - **Impact**: When redeeming rewards, converting tokens to shares may round down, allowing users to redeem more tokens than their shares account for. This can drain the contract's funds over time as users repeatedly redeem small amounts without sufficient shares being deducted.

2. **Unchecked Arithmetic in Global Exchange Rate Update Causing Overflow**  
   - **Location**: `_updateGlobalExchangeRate` function  
   - **Impact**: The unchecked addition to `globalExchangeRate` may overflow due to large inputs, corrupting the exchange rate. This leads to incorrect reward calculations, enabling users to claim excessive rewards or causing fund loss.

3. **Potential Overflow in Token to Shares Conversion**  
   - **Location**: `_sharesToTokens` and `_tokensToShares` functions  
   - **Impact**: Large values for `amount` or `rate` can cause multiplication/division to overflow `uint128`, resulting in incorrect share/token conversions. This disrupts staking/unstaking logic and may block transactions.

4. **Division by Zero in `getDelegatorDetails` View Function**  
   - **Location**: `getDelegatorDetails` function  
   - **Impact**: If `totalGlobalShares` is zero (no stakers), calculating `newGlobalExchangeRate` divides by zero, reverting the function. This breaks reward estimation for users and frontends.

5. **Validator Update DoS Due to Overflow in Token Calculation**  
   - **Location**: `_updateValidator` function  
   - **Impact**: Computing `tokensGivenToValidator` via `v.globalShares * rateDifference` may overflow `uint128`, reverting transactions. This prevents validator state updates, blocking staking/unstaking operations.

6. **Insufficient Validation in `recoverUnstaking` and `redelegateUnstaked`**  
   - **Location**: `recoverUnstaking` and `redelegateUnstaked` functions  
   - **Impact**: Users can restake zero amounts if `amount` is too small after rounding, bypassing checks and creating dust entries. This wastes gas and may enable spam.

7. **Incorrect Reward Distribution After Validator Disabling**  
   - **Location**: `disableValidator` function  
   - **Impact**: When a validator is disabled, `totalGlobalShares` is reduced, but `globalExchangeRate` is not updated. This leads to incorrect reward distribution for remaining validators due to outdated global state.

8. **Unhandled Edge Case in `takeOutRewardTokens`**  
   - **Location**: `takeOutRewardTokens` function  
   - **Impact**: If `endEpoch` is in the past, reducing rewards via `endEpoch - epochs` may underflow, causing invalid state transitions and locked funds.

These vulnerabilities stem from arithmetic errors, improper rounding, unchecked inputs, and insufficient edge-case handling, leading to potential fund loss, reward miscalculations, and transaction reverts.","### **[H-01] Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions**

**Report Description**:  
The `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract. However, it uses the non-upgradeable version of the `Ownable` library (`@openzeppelin/contracts/access/Ownable.sol`) instead of the upgradeable version (`@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`). This causes the deployer to be set as the owner in the constructor, which is incompatible with proxy-based upgradeability systems. As a result, all `onlyOwner` functions will be inaccessible when deployed as a proxy contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect use of the `Ownable` library in an upgradeable contract, which is a critical oversight in proxy-based systems. This issue is not covered in the response list.

---

### **[H-02] unstake should update exchange rates first**

**Report Description**:  
The `unstake` function computes `validatorSharesRemove` using the old exchange rate before updating the exchange rates (if the validator is not disabled). This can lead to incorrect calculations of shares to be removed, as the exchange rate is updated only after the initial computation.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is related to the incorrect order of operations in the `unstake` function, which is not covered in the response list.

---

### **[M-01] Reward tokens could get lost due to rounding down**

**Report Description**:  
The function `depositRewardTokens` divides the `amount` of tokens by `allocatedTokensPerEpoch` to calculate the `endEpoch`. When `amount` is not a multiple of `allocatedTokensPerEpoch`, the division rounds down, resulting in lost tokens. This issue also occurs in `setAllocatedTokensPerEpoch`, `takeOutRewardTokens`, and `_stake`.

**Match in Response List**:  
Matches with the issue titled **""Rounding Down in Reward Redemption Leading to Incorrect Shares Accounting""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of rounding down in reward calculations but focuses on the `_redeemRewards` function rather than the broader context of `depositRewardTokens`, `setAllocatedTokensPerEpoch`, and `takeOutRewardTokens`. The response misses the specific impact of lost tokens due to rounding down in these functions.

---

### **[M-02] Incorrect updateGlobalExchangeRate implementation**

**Report Description**:  
The `_updateGlobalExchangeRate` function has an incorrect implementation when `totalGlobalShares` is zero. If no user has staked, `totalGlobalShares` is zero, and the function may fail or produce incorrect results. This can occur later if all users unstake or a validator is disabled.

**Match in Response List**:  
Matches with the issue titled **""Division by Zero in `getDelegatorDetails` View Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of division by zero in `getDelegatorDetails` but does not address the specific problem in `_updateGlobalExchangeRate`. The core issue of incorrect implementation when `totalGlobalShares` is zero is not fully covered.

---

### **[M-03] Validator can fail to receive commission reward in redeemAllRewards**

**Report Description**:  
The `redeemAllRewards` function includes a check that reverts the transaction if `rewards` is zero. This can prevent validators from receiving their commission rewards, even if they are entitled to them.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the `redeemAllRewards` function and its handling of commission rewards, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] Reward tokens could get lost due to rounding down**  
- **[M-02] Incorrect updateGlobalExchangeRate implementation**

**Missed Issues from Issue Report**:  
- **[H-01] Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions**  
- **[H-02] unstake should update exchange rates first**  
- **[M-03] Validator can fail to receive commission reward in redeemAllRewards**

---

The response list partially addresses some issues but misses critical vulnerabilities related to upgradeability, exchange rate updates, and commission rewards. The identified matches are either partially correct or incorrect, indicating significant gaps in coverage and accuracy.",0,2,3,8,"Okay, let me try to figure out the vulnerabilities in this smart contract. Hmm, first, I'll look through the code step by step.

Starting with the imports and the contract definition. It's using OpenZeppelin upgradeable contracts, so maybe there's something related to that. Oh, the contract is Initializable, so maybe if the initialize function isn't secured properly. Wait, the initialize function is public, but it's using the initializer modifier, which should prevent multiple initializations. But maybe there's a way someone else could call it? No, because the initializer modifier from OpenZeppelin should handle that. So maybe that's okay.

Looking at the structs and variables. There's a lot of uint128 usage. Maybe there's an overflow risk? But Solidity 0.8.0 has checked math by default, so unless they're using unchecked blocks, which they are in some places. For example, in the depositRewardTokens function, they have unchecked { endEpoch += amount / allocatedTokensPerEpoch; }. Since amount is user-provided, dividing by allocatedTokensPerEpoch (which is at least 1e18) could result in a very small number, but maybe not. But if allocatedTokensPerEpoch is zero, division by zero would happen. But in initialize, allocatedTokensPerEpoch is set to 1e18, and the setAllocatedTokensPerEpoch function requires amount > 0. So division by zero might not be a problem here.

Wait, in the takeOutRewardTokens function, there's a check that amount > 0 and that amount is a multiple of allocatedTokensPerEpoch. But if allocatedTokensPerEpoch is changed to a larger value via setAllocatedTokensPerEpoch, maybe some tokens could get stuck? Not sure yet.

Looking at the stake function. They have a check that validatorId < validatorsN. But validatorsN is a uint128 that's incremented when adding a validator. So if someone tries to stake on a non-existent validator, it would revert. That seems okay.

In the _stake function, when a delegator stakes, they check that the new delegated amount doesn't exceed the validator's max cap. The max cap is validatorStaked * maxCapMultiplier. But if the validator unstakes some of their own tokens, the max cap would decrease, possibly making existing delegations exceed the cap. Wait, when a validator unstakes, does it check if existing delegations are still within the new max cap? Let me check the unstake function.

In the unstake function, if the caller is the validator, they check that after unstaking, the remaining staked amount (newValidatorStaked) multiplied by maxCapMultiplier is still >= the delegated amount (delegated, which is total delegated minus validator's own stake). Wait, delegated is v.delegated - s.staked (the validator's staked amount). So when a validator unstakes, delegated is the total delegated from others, and newValidatorStaked is the validator's new stake. Then newValidatorMaxCap is newValidatorStaked * maxCapMultiplier. The check is delegated <= newValidatorMaxCap. So if the validator reduces their stake, the max cap reduces, and if the existing delegated is higher, the unstake would fail. So that check is there. So that seems okay.

What about reentrancy? The contract uses SafeERC20Upgradeable, which is supposed to handle ERC20 tokens that have callback vulnerabilities. So when they call safeTransferFrom and safeTransfer, that should be safe. So maybe no reentrancy here.

Another thing: in the _updateValidator function, when updating the exchange rate, the calculation of tokensGivenToValidator is done as shares multiplied by rate difference. Then commission is taken from that. Then exchange rate is increased by (tokensGiven - commission) / totalShares. But if totalShares is zero, this division would fail. However, in the code, there's a check in _updateValidator: if (v.totalShares == 0) then set exchange rate to globalExchangeRate. Otherwise, proceed with the calculation. So division by zero here is prevented.

What about the globalExchangeRate? In _updateGlobalExchangeRate, if totalGlobalShares is zero, they don't update the rate. But if totalGlobalShares is zero and someone tries to stake, they would add shares. Wait, when totalGlobalShares is zero, adding the first stake would set totalGlobalShares += sharesToAdd. So maybe when the first staker comes in, the global exchange rate is updated correctly. Not sure about that.

Looking at the _sharesToTokens and _tokensToShares functions. If the rate is zero, this would cause division by zero. But when are the rates zero? The globalExchangeRate is initialized to 1e18. When a validator is added, their exchange rate is set to globalExchangeRate. So rates start at 1e18. But if for some reason the rate becomes zero, these functions would fail. But how would that happen? The globalExchangeRate is updated in _updateGlobalExchangeRate. If allocatedTokensPerEpoch is non-zero and totalGlobalShares is zero, the rate would not be updated. So if there's a situation where totalGlobalShares is zero but someone is still able to call functions that update the rate, maybe that's a problem. But in depositRewardTokens, the owner can only deposit if amount >= allocatedTokensPerEpoch and a multiple. But if there are no shares (totalGlobalShares is zero), then when rewards are deposited, endEpoch is set. Then when someone stakes, they would call _updateGlobalExchangeRate, which would check if totalGlobalShares is zero, so skip updating the rate. Then the shares are added based on the existing globalExchangeRate (which is 1e18 initially). So tokensToShares would be amount * 1e18 / 1e18 = amount. So shares would be equal to the amount. Then when the first staker comes in, totalGlobalShares is increased. Then when the next epoch comes, the rate would be updated. So maybe that's okay.

Another possible issue is in the redeemRewards function. The _redeemRewards function allows a user to redeem their rewards. When the user is the validator, they can redeem both their own rewards and the commission. But in the code, if the amount is zero, it sets amount to rewards + v.commissionAvailableToRedeem. Then it checks that rewards + commission >= amount. But if the user specifies an amount, it checks that rewards + commission >= amount. However, if the user specifies an amount that is more than rewards but less than (rewards + commission), the code allows it and subtracts the commission first. Let me see:

In the validator case:
If amount is specified as, say, 100, and rewards are 50 and commission is 60. So 50 + 60 = 110 >= 100. Then commissionLeftOver would be 60 - (100 - 50) = 10? Wait, no. The code says:

commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;

Wait, that's not correct. Let me check:

If the user is the validator and is redeeming amount X:

If X is less than the commissionAvailable, then commissionLeftOver is commissionAvailable - X. But in reality, the commissionAvailable is part of the amount. Wait, no. The code says:

amount can be up to rewards + commissionAvailable.

If the user is the validator, when they call redeem with amount, the code requires that rewards + commissionAvailable >= amount.

Then, the code checks if amount is less than commissionAvailable. For example, if commissionAvailable is 100, rewards is 50, and amount is 120. Then commissionAvailable is 100, so 100 + 50 = 150 >= 120. Then, since amount (120) is not less than commissionAvailable (100), commissionLeftOver is 0. Then, the code subtracts (amount - commissionAvailable) from rewards. So 120 - 100 = 20 comes from rewards. So validatorSharesRemove is tokensToShares(20, exchangeRate). But if exchangeRate is high, maybe this results in zero shares, causing an underflow. Wait, the code does:

uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);

But if amount > commissionAvailable, then amount - commissionAvailable is the part taken from rewards. But if that value is zero, then sharesRemove would be zero, and s.shares -= 0 (no problem). Wait, no, if amount is 100, and commissionAvailable is 60, then amount - commissionAvailable is 40. So sharesRemove is tokensToShares(40, v.exchangeRate). If exchangeRate is high, 40 / rate could be zero. But the code checks that the amount is allowed. But in the case where the tokensToShares returns zero, then the shares wouldn't be reduced, but the tokens are transferred. That would allow the user to redeem more tokens than their shares account for. That's a problem.

Wait, the code for the validator's redeem:

In the validator case, when redeeming:

If the user specifies an amount, and it's covered by rewards + commission, then:

commissionLeftOver is commissionAvailable - (amount - rewards) if amount exceeds rewards. Wait, no, the code's logic here is confusing. Let's re-express:

When msg.sender is the validator:

rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked; // this is the staking rewards

Then, if amount is 0, amount is set to rewards + commissionAvailable.

When amount is specified, the code checks that rewards + commissionAvailable >= amount.

Then, commissionLeftOver is calculated as:

if amount < commissionAvailable, then commissionLeftOver = commissionAvailable - amount

else, commissionLeftOver = 0

Wait, that doesn't make sense. Because if the amount is 120, commissionAvailable is 100, rewards is 50:

amount (120) is less than commissionAvailable (100)? No. So commissionLeftOver becomes 0.

But the total amount being redeemed is 120, which comes from 100 (commission) + 20 (rewards). So commissionAvailable is reduced by 100 (to 0), and the rewards part (20) is converted to shares. But how is the 20 taken from the rewards?

The code does:

if (commissionLeftOver == 0) {

    uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);

    s.shares -= validatorSharesRemove;

    v.totalShares -= validatorSharesRemove;

}

Wait, in this case, commissionAvailableToRedeem was 100, and amount is 120. So amount - commissionAvailableToRedeem is 20. Then, sharesRemove is _tokensToShares(20, exchangeRate). If exchangeRate is 1e18, 20 * 1e18 / 1e18 = 20. So shares would decrease by 20. But if exchangeRate is higher than 1e18, like 2e18, then 20 tokens would be 10 shares. So shares are decreased by 10. But the problem is that the user is allowed to redeem more tokens than the shares they have. Because shares are based on the exchange rate. Wait, no, because the rewards are calculated as shares * exchange rate. But when redeeming, the code subtracts shares based on the amount redeemed. So maybe the code is correctly converting the redeemed amount to shares. But perhaps there's a rounding issue here.

For example, if the exchange rate is 1.5e18, and the user redeems 1 token, the shares required would be 1 * 1e18 / 1.5e18 = 0.666..., which would be 0 in integer division. So the user could redeem 1 token without decreasing their shares, leading to an underflow when converting in the future.

Wait, the code uses uint128, so division truncates. For example, _tokensToShares(1, 1.5e18) would be 1 * 1e18 / 1.5e18 = 0.666... which truncates to 0. Then, when redeeming 1 token, the code subtracts 0 shares, but the tokens are sent. This would allow the user to redeem more tokens than their shares account for, leading to an incorrect state.

So the problem is that when converting tokens to shares for redemption, if the amount is not a multiple of the exchange rate, the shares subtracted would be less than the actual value, allowing users to redeem more tokens than they should. This could lead to an underflow of shares in the future or incorrect accounting.

This is a possible vulnerability due to rounding down in _tokensToShares. For example, if a user redeems an amount that doesn't divide evenly by the exchange rate, the shares subtracted would be less than required, but the tokens are transferred. Over time, this could accumulate and allow users to drain the contract.

Another possible issue is in the unstake function. When a delegator unstakes, the amount is converted to shares. If the conversion results in zero shares (because the amount is too small relative to the exchange rate), then the code would revert due to the require(validatorSharesRemove > 0). So that's handled. But in the case where the exchange rate is very high, even a small amount could result in zero shares, making the unstake impossible. But the require(validatorSharesRemove > 0) ensures that the unstake is only possible if the shares to remove are non-zero, which is good.

Another thing to check is the use of block.number for timing. The coolDown periods are based on blocks, which can be manipulated by miners to some extent. But in this contract, the coolDown is a fixed number of blocks, so it's not a vulnerability per se, but a design choice.

In the getDelegatorDetails function, there's a line where newGlobalExchangeRate is calculated. The code does:

uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;

But if totalGlobalShares is zero, this would divide by zero. However, the function is a view function and doesn't modify the state. So if a user calls getDelegatorDetails when totalGlobalShares is zero, this line would revert. But totalGlobalShares is only zero if no one has staked yet. So perhaps the function should handle that case, but since it's a view function, it's up to the frontend to handle such errors. However, this could lead to denial of service for the function when there are no stakers, but that's not a security vulnerability, more of a usability issue.

Looking at the setAllocatedTokensPerEpoch function. The owner can change the allocated tokens per epoch. The code has some logic to handle existing epochs. But if the owner reduces the allocatedTokensPerEpoch, it might affect the rewards distribution. However, since the owner is supposed to be trusted, this is a centralization risk but not a vulnerability in the code itself.

Another thing is that the contract uses a constant address for CQT. If the CQT token is upgraded or if there's a mistake in the address, the contract cannot be changed. But since it's a constant, it's intentional. However, if the token contract at that address is not the intended one, it's a problem. But that's outside the scope of the code's vulnerabilities.

In the _updateValidator function, when a validator is disabled, their global shares are subtracted from totalGlobalShares. But if the validator is disabled multiple times, this could underflow. However, the disabledEpoch is checked to be zero before disabling, so a validator can only be disabled once. So that's safe.

In the stake function, when a delegator stakes, the code checks that newDelegated (v.delegated - validatorStaked + amount) <= validatorMaxCap. But validatorStaked is v.stakings[v._address].staked. If the validator's own stake changes after this check, the max cap could be violated. But since this is done within the same transaction, and the validator's stake can't change during the stake function call (unless reentrancy), which is prevented by SafeERC20, this should be okay.

Another possible issue is in the getDelegatorDetails function. It calculates newGlobalExchangeRate by multiplying allocatedTokensPerEpoch by (currentEpoch - lastUpdateEpoch), but if currentEpoch is less than lastUpdateEpoch, this could underflow. However, currentEpoch is set to min(block.number, endEpoch), and lastUpdateEpoch is updated in _updateGlobalExchangeRate. So currentEpoch should be >= lastUpdateEpoch, because _updateGlobalExchangeRate is called in functions that modify state, ensuring that lastUpdateEpoch is up to date. But in getDelegatorDetails, currentEpoch is block.number or endEpoch. If the function is called without any state changes since the last update, currentEpoch could be larger than lastUpdateEpoch. So the calculation (currentEpoch - lastUpdateEpoch) is safe.

Wait, in getDelegatorDetails, currentEpoch is calculated as block.number < endEpoch ? block.number : endEpoch. Then lastUpdateEpoch is the last time the global exchange rate was updated. So if lastUpdateEpoch is less than currentEpoch, the code calculates the new rate. But in the code:

uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;

But this calculation assumes that totalGlobalShares is the same as when the update happened. However, between the last update and the current block, totalGlobalShares could have changed due to staking or unstaking. So the view function's calculation of newGlobalExchangeRate may not be accurate, leading to incorrect reward estimations. However, this is a view function and doesn't affect the actual state. But users relying on this function might get incorrect information. This is more of a data inconsistency issue rather than a vulnerability.

Another possible problem is in the depositRewardTokens function. The code says:

if (endEpoch != 0) {
    unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
}
else {
    unchecked { rewardsLocked += amount; }
}

But if the owner deposits reward tokens when endEpoch is not zero, the endEpoch is extended by (amount / allocatedTokensPerEpoch). However, this could be incorrect if the current block is beyond the original endEpoch. Because when endEpoch is in the past, the _updateGlobalExchangeRate sets currentEpoch to endEpoch, so adding more epochs would start from the current block, not the previous endEpoch. But according to the code, when endEpoch is not zero, it's simply adding the number of epochs (amount / allocatedTokensPerEpoch) to endEpoch. So if the current block is beyond endEpoch, depositing more tokens would extend the endEpoch, but rewards between the old endEpoch and the new endEpoch would be distributed. However, during that time, if there were no stakers, the globalExchangeRate would not have been updated, leading to incorrect reward calculations. Not sure if this is a vulnerability or just a design choice.

Also, the function requires that amount is a multiple of allocatedTokensPerEpoch. If allocatedTokensPerEpoch is changed via setAllocatedTokensPerEpoch, then future deposits must be multiples of the new value. But if the owner changes allocatedTokensPerEpoch to a higher value, existing rewards locked may not be compatible. For example, if rewardsLocked is 100e18, and allocatedTokensPerEpoch is changed to 50e18, then the next deposit must be a multiple of 50e18. But the code doesn't check for that. Wait, no: the depositRewardTokens function checks that amount is a multiple of the current allocatedTokensPerEpoch. So if the owner changes allocatedTokensPerEpoch, future deposits need to be multiples of the new value. That's correct.

Another thing to note is that the contract uses a fixed-point arithmetic with divider = 1e18. Rounding errors are possible in various calculations, which could lead to small discrepancies. For example, in _tokensToShares, converting tokens to shares may truncate, leading to dust amounts that can't be unstaked. But this is a common issue in staking contracts and is usually handled by requiring minimum amounts, which the code does (e.g., stake requires at least 1 token).

In the recoverUnstaking function, a user can recover an unstaked amount by staking it again without transferring tokens. However, if the user's unstaking entry is for a disabled validator, the code allows restaking into another validator. But how is the amount handled? Since the tokens were already transferred to the contract when the user initially staked, and when they unstaked, the tokens are kept in the contract until redeemed. So when recovering, the tokens are already in the contract, so restaking doesn't require a transfer. That's correct.

In the transferUnstakedOut function, the user can transfer their unstaked tokens after the cooldown. The code checks that block.number > coolDownEnd. However, the cooldown periods are set in terms of blocks. For example, validatorCoolDown is 180*6646 blocks. The exact time depends on block time, but that's a design choice.

Another possible vulnerability is related to the ERC20 return values. Although the code uses SafeERC20Upgradeable's safeTransfer and safeTransferFrom, which handle non-compliant tokens that don't return booleans, it assumes that the CQT token is compliant. But since CQT is a constant and the code is using SafeERC20, this should be okay.

Looking at the initialize function again: it's called with a minStakedRequired parameter. But after initialization, the owner can call setValidatorMinStakedRequired to change it. So if the owner is malicious, they could lower the min staked required, allowing validators to unstake more than intended. But since the owner is supposed to be trusted, this is a centralization risk, not a code vulnerability.

In the addValidator function, the owner can add a validator with any commission rate less than 100%. However, if the commission rate is too high, delegators might not get rewards. But again, that's a business logic issue, not a vulnerability.

Another thing to check is the use of uint128 for variables like totalGlobalShares and globalExchangeRate. If these variables exceed 2^128-1, they will overflow. But since the contract uses Solidity 0.8.0, which has default checked math, except in unchecked blocks. The code uses unchecked blocks in several places where variables are expected not to overflow, like incrementing validatorsN. Since validatorsN is a uint128, it's unlikely to overflow in practice. Similarly, totalGlobalShares is a uint128, which could be a problem for very large token supplies, but given that the divider is 1e18, the maximum value for totalGlobalShares would be 1e18 * 2^128, which is a huge number, so likely not an issue.

In the _updateGlobalExchangeRate function, when calculating the rate increase:

globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ;

But allocatedTokensPerEpoch is per epoch, so multiplying by divider and then by the number of epochs. If totalGlobalShares is very small, this could cause an overflow in the multiplication. For example, allocatedTokensPerEpoch is 1e18, divider is 1e18, epochs difference is large, say 1e18, then 1e18 * 1e18 * 1e18 = 1e54, which divided by totalGlobalShares (say 1) would be 1e54. But uint128 can only hold up to ~3.4e38. So if the calculation results in a value larger than 2^128-1, this would cause an overflow, and since it's in an unchecked block (because the entire function is not marked as unchecked), but Solidity 0.8.0 would revert on overflow. Wait, no: the code uses the unchecked keyword in this line:

unchecked { globalExchangeRate += ... }

So the code is explicitly allowing overflow here. That's a problem. If the calculation overflows, the addition to globalExchangeRate would wrap around, causing incorrect exchange rates. This is a critical vulnerability.

Let me look again. The line inside _updateGlobalExchangeRate:

unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }

This line calculates the amount to add to the globalExchangeRate. If allocatedTokensPerEpoch, currentEpoch - lastUpdateEpoch, and divider are large enough, the multiplication could exceed uint256, but in reality, uint256 can hold up to 1.1e77, which is larger than 1e18 * 1e18 * 1e18 (1e54). So the multiplication shouldn't overflow. However, when dividing by totalGlobalShares, which could be 1, the result could be up to 1e54, which is way larger than uint128's max value (3e38). So casting to uint128 would truncate the value, leading to an incorrect globalExchangeRate. For example, if the actual value is 5e38, which is larger than 2^128 (3.4e38), then casting to uint128 would result in 5e38 - 2^128*1.5..., which is a garbage value. This would completely break the exchange rate calculation, leading to incorrect rewards.

This is a critical vulnerability because it can cause the globalExchangeRate to be set to an incorrect value when the product of allocatedTokensPerEpoch, divider, and epochs is large, leading to incorrect reward distribution and possible fund loss.

Another instance of this issue is in the _updateValidator function:

tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);

Which is calculated as v.globalShares * rateDifference / divider. If v.globalShares and rateDifference are large, their product could exceed uint128's max value. But since they are both uint128, their product is up to (2^128-1)^2, which divided by 1e18 could still fit into a uint128. Maybe not. Let's see: (2^128-1)^2 / 1e18 ≈ (1e38)^2 / 1e18 = 1e58, which is way larger than uint128's max. So this multiplication would also overflow. But since this is inside an unchecked block (the function _updateValidator is called in internal functions that may be inside unchecked blocks?), wait, the code here does not have an unchecked block around this line. However, Solidity 0.8.0 checks for overflows by default. So the multiplication here would revert if it overflows. But the code does not handle that. So if v.globalShares * rateDifference exceeds 2^256-1 (which is unlikely, since they are uint128), but even when divided by 1e18, the result could be larger than uint128. For example, if v.globalShares is 1e30 (but since it's a uint128, max is 3e38), and rateDifference is 1e30, then 1e30 * 1e30 = 1e60, divided by 1e18 is 1e42, which is larger than uint128's max. So this would cause an overflow in the _sharesToTokens function, leading to a revert. But since the code doesn't use an unchecked block here, Solidity would revert on overflow. So this is a possible denial of service if the product exceeds the maximum uint128 value.

This is another vulnerability: potential overflow in the calculation of tokensGivenToValidator, leading to a revert and preventing validators from being updated, which could block key functions like staking, unstaking, or reward redemption.

Similarly, in the calculation of rateIncrease in _updateValidator:

rateIncrease = uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);

If (tokensGivenToValidator - commissionPaid) * divider is larger than uint128 can hold, the cast to uint128 would truncate the value, leading to an incorrect rate increase. For example, if tokensGivenToValidator - commissionPaid is 1e20, multiplied by 1e18 gives 1e38, which is about 3e38, which is exactly the max of uint128. If it's 1e20+1, then the product is 1e38+1e18, which is 1.000000000001e38, which would overflow uint128 and cause a revert if not in an unchecked block. But the code here is:

v.exchangeRate += uint128(uint256(...));

This line is inside an unchecked block in the _updateValidator function? Looking back:

In _updateValidator:

unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }

Then:

uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);

But the calculation of tokensGivenToValidator is not in an unchecked block. So if the multiplication overflows, the transaction would revert. This could be a problem if rateDifference is large enough.

So, summarizing the vulnerabilities:

1. **Incorrect Reward Calculation Due to Improper Rounding in Redeem Functions**: When redeeming rewards, especially for validators, converting tokens to shares can lead to rounding down, allowing users to redeem more tokens than their shares account for, leading to incorrect state and possible fund drainage.

2. **Unchecked Arithmetic Leading to Overflow in Global Exchange Rate Update**: In the _updateGlobalExchangeRate function, the calculation of the global exchange rate addition uses unchecked arithmetic, which can overflow, causing the globalExchangeRate to wrap around or become incorrect, leading to massive reward calculation errors.

3. **Potential Overflow in Token to Shares Conversion**: In the _sharesToTokens and _tokensToShares functions, if the multiplication or division overflows the uint128 type, it can cause reverts or incorrect values, leading to failed transactions or incorrect accounting.

4. **Incorrect Calculation in getDelegatorDetails Leading to Division by Zero**: The view function getDelegatorDetails does not handle the case when totalGlobalShares is zero, leading to a division by zero error when calculating newGlobalExchangeRate.

5. **Centralization Risks**: The contract owner has significant control over parameters like allocatedTokensPerEpoch, validator commission rates, etc., which could be misused, but this is more of a trust issue than a code vulnerability.

6. **Possible DoS in Validator Updates Due to Overflow**: Calculations in _updateValidator could overflow if values are too large, causing transactions to revert and preventing updates to validator states.

Now, I need to list these vulnerabilities clearly. Let's structure them:

1. **Rounding Down in Reward Redemption Leading to Incorrect Shares Accounting**  
   In the `_redeemRewards` function, when converting tokens to shares, the division may round down, allowing users to redeem more tokens than their shares account for. This can lead to underflow of shares in future operations or allow users to drain the contract by repeatedly redeeming small amounts.

2. **Unchecked Arithmetic in Global Exchange Rate Update Causing Overflow**  
   The `_updateGlobalExchangeRate` function uses unchecked arithmetic when updating `globalExchangeRate`, which can overflow if the calculated value exceeds `uint128` limits. This results in incorrect reward calculations and potential loss of funds.

3. **Potential Overflow in Token to Shares Conversion**  
   The `_sharesToTokens` and `_tokensToShares` functions perform multiplication and division that could overflow if inputs are large, leading to incorrect share calculations and failed transactions.

4. **Division by Zero in getDelegatorDetails View Function**  
   The `getDelegatorDetails` function does not handle the case where `totalGlobalShares` is zero, leading to a division by zero error when computing `newGlobalExchangeRate`, causing the function to revert.

5. **Validator Update DoS Due to Overflow in Token Calculation**  
   In `_updateValidator`, the calculation of `tokensGivenToValidator` may overflow if `v.globalShares` and `rateDifference` are large enough, causing transactions to revert and preventing validator state updates.

6. **Centralization Risks with Owner Privileges**  
   The contract owner can change critical parameters like `allocatedTokensPerEpoch`, `validatorMinStakedRequired`, and `maxCapMultiplier`, which could be used to manipulate the system. However, this is an inherent risk of the design rather than a code vulnerability.

Final list would include these points, focusing on the code vulnerabilities and not the centralization aspects unless specified. Since the user asked for vulnerabilities without mitigation, I need to list them as such.","```
None.
```",0.0,0