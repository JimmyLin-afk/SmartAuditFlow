nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
Lock.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",1088.0,145.0,"[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
There are two functions that allow to lock some amount of assets. The first function is Lock.lock which creates a new bond. The second function is the function `extendLock`. This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.
The issue is that the `extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `release` is called.
Therefore only the amount of assets deposited via `lock` can be released again. The amount of assets deposited using `extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.
  [M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract
When calling the function `claimGovFees()`, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in the function `bondNFT.distribute`.
  [M-02] Must approve 0 first
Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved in function `claimGovFees()`.  Recommend: Add an approve(0) before approving",3.0,"pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",790.0,1,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unchecked ERC20 Transfer Return Values**  
   The contract uses `transferFrom` and `transfer` without verifying the return value. Tokens that return `false` on failure (instead of reverting) will not trigger a revert, leading to silent failures and incorrect state changes (e.g., locked balances not matching actual transfers).

2. **Missing Period Validation in `extendLock`**  
   The `extendLock` function does not enforce the `minPeriod` and `maxPeriod` constraints, allowing users to extend locks beyond the intended minimum or maximum durations, violating protocol rules.

3. **Unbounded Loop in `claimGovFees`**  
   The loop iterates over all assets returned by `bondNFT.getAssets()`. If the asset list grows too large, the transaction may run out of gas, causing a denial-of-service (DoS) for critical functions that depend on `claimGovFees` (e.g., `lock`, `release`).

4. **Unsafe ERC20 Approval in `claimGovFees`**  
   The contract approves `bondNFT` with `type(uint256).max` allowance for each asset. If `bondNFT` is compromised, it could drain all approved tokens from the contract, even beyond the intended distribution amount.

5. **Reentrancy Risk via External Calls**  
   Functions like `release`, `claim`, and `extendLock` interact with external contracts (`bondNFT`, `govNFT`). If these contracts are malicious, they could reenter the Lock contract mid-execution, potentially leading to state manipulation (e.g., double-spending).

6. **Underflow Risk in `totalLocked`**  
   If `bondNFT.release` returns a `lockAmount` exceeding `totalLocked[asset]`, subtracting it from `totalLocked` would cause an underflow. While Solidity 0.8.x reverts on underflow, this indicates a logical flaw if `bondNFT` returns invalid data.

7. **Front-Runnable ERC20 Approvals**  
   Repeatedly setting `approve` to `type(uint256).max` in `claimGovFees` could allow an attacker to exploit residual allowances if `bondNFT.distribute` is not atomic with the approval step.

8. **Trust in Immutable External Contracts**  
   The contract assumes `bondNFT` and `govNFT` are secure and properly implemented. Compromises in these contracts could directly affect the Lock contract’s integrity (e.g., stealing funds, manipulating lock periods).","### **Output**

---

#### **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Report Description**:  
The `extendLock` function in `Lock.sol` allows users to extend the lock period or increase the locked amount. However, it fails to update the `totalLocked[_asset]` variable. This omission means that only assets deposited via the `lock` function can be released. Assets deposited via `extendLock` cannot be released because reducing `totalLocked[_asset]` during `release` will cause an underflow revert.

**Match in Response List**:  
Matches with the issue titled **""Underflow Risk in `totalLocked`""**.

**Validation**:  
**Correct**. The response identifies the underflow risk in `totalLocked`, which aligns with the issue described in the report. It correctly highlights the logical flaw where `totalLocked` is not updated in `extendLock`, leading to potential underflow during `release`.

---

#### **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Report Description**:  
The `claimGovFees` function interacts with `bondNFT.distribute`. If the assets are not allowed or have no shares in the `BondNFT` contract, the function will silently fail, causing assets to be stuck in the `Lock` contract.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the silent failure issue in `claimGovFees`. While it mentions an unbounded loop and unsafe ERC20 approvals, it does not cover the specific scenario where assets become stuck due to silent failures in `bondNFT.distribute`.

---

#### **[M-02] Must approve 0 first**

**Report Description**:  
Some tokens (e.g., USDT) require setting the allowance to 0 before approving a new value. The `claimGovFees` function does not follow this practice, which could lead to transaction failures when interacting with such tokens.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of ERC20 token approvals requiring a zero allowance reset before setting a new value. This is a specific vulnerability that is not covered in the responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**  
- **[M-02] Must approve 0 first**

---

### **Analysis of Gaps**

1. **Silent Failures in `claimGovFees`**:  
   The response list does not address the issue of silent failures in `bondNFT.distribute`, which can cause assets to be stuck in the `Lock` contract. This is a critical oversight, as it directly impacts the contract's functionality and user funds.

2. **ERC20 Approval Requirements**:  
   The response list misses the specific issue of tokens requiring a zero allowance reset before approving a new value. This is a common issue when interacting with certain ERC20 tokens (e.g., USDT) and should have been included in the response list.

---

### **Recommendations**

1. **Add Coverage for Silent Failures**:  
   Include a response addressing the silent failure issue in `claimGovFees`, emphasizing the need to handle cases where `bondNFT.distribute` fails silently.

2. **Address ERC20 Approval Requirements**:  
   Add a response highlighting the need to reset allowances to 0 before setting a new value, especially when interacting with tokens like USDT.

3. **Expand on Logical Flaws**:  
   While the response list covers underflow risks, it could further elaborate on logical flaws in state management, such as the failure to update `totalLocked` in `extendLock`.

By addressing these gaps, the response list would provide more comprehensive coverage of the vulnerabilities identified in the issue report.",1,0,2,8,"Okay, let me try to figure out the vulnerabilities in this smart contract. I'll start by going through each function and looking for common issues.

First, the contract imports several interfaces and uses Ownable. The constructor initializes bondNFT and govNFT with addresses provided. Let's check if there are any issues with those initializations. Maybe they're not validated? If the addresses are zero, that could be a problem, but the constructor parameters are from the deployer, so maybe not a vulnerability per se, but a potential risk if not set correctly.

Looking at the lock function: it checks if the asset is allowed, transfers the tokens from the user to the contract, increments totalLocked, and creates a lock via bondNFT. One thing here is the use of transferFrom. If the asset is a token that doesn't revert on failure but returns false (like some ERC20 implementations), then using transferFrom without checking the return value could lead to issues. But since they're using OpenZeppelin's IERC20, which has a safeTransferFrom that does revert, but wait, in the code here, they're using IERC20(_asset).transferFrom, which is the standard method. Wait, OpenZeppelin's ERC20 has transferFrom that returns a boolean. If the transfer fails, it returns false, but the code here doesn't check the return value. So if the transferFrom fails (e.g., insufficient allowance or balance), the transaction won't revert, leading to the function proceeding as if the transfer was successful. That's a major issue. So this is an ERC20 transferFrom return value not checked vulnerability.

Same problem applies to other functions like extendLock and release. For example, in extendLock, after calling claim, they transferFrom again. Again, not checking the return value. Similarly, in release, after releasing, they transfer using IERC20(asset).transfer(_owner, amount); again, not checking the return value. So this is a recurring issue across multiple functions.

Next, looking at the claimGovFees function. They loop through assets, claim from govNFT, then calculate the difference in balance. Then they approve bondNFT to spend the asset with type(uint256).max. However, they do this inside a loop. Each iteration approves the same asset again. But since approve overwrites the previous allowance, this might not be a problem, but it's unnecessary. However, a possible issue here is that if the assets array includes the same asset multiple times (though bondNFT.getAssets() probably returns unique assets), but in that case, multiple approvals for the same asset. Not sure if that's a problem. Also, if the govNFT.claim(assets[i]) call is malicious and drains funds, but since govNFT is set in the constructor and onlyOwner can change allowedAssets, maybe that's not a problem if govNFT is trusted. But if govNFT is compromised, this function could be a vector. But that's more about trusting external contracts.

In the release function, totalLocked[asset] is decremented by lockAmount. But what if lockAmount is greater than totalLocked[asset]? It could underflow. However, Solidity 0.8.x has default checked math, so that would revert. So as long as bondNFT.release returns a lockAmount that's <= totalLocked[asset], this is okay. But if bondNFT is malicious or has a bug, this could underflow. But since bondNFT is immutable and set at construction, maybe it's considered trusted. So perhaps not a vulnerability here.

In the claim function, after bondNFT.claim returns _amount and _tigAsset, the contract transfers _amount of _tigAsset to msg.sender. But the problem is similar to earlier: if the transfer fails (e.g., the contract doesn't have enough balance), but since the contract is supposed to have received the funds via bondNFT.claim, maybe that's handled. But again, not checking the return value of transfer could lead to silent failures. For example, if the token is USDT which doesn't revert on failure, the transfer might fail but the code proceeds. So this is another instance of unsafe ERC20 transfers.

The same applies to claimDebt: after getting amount from bondNFT.claimDebt, they transfer it. Again, no check.

Another possible issue is reentrancy. Let's see. In the release function, after calling bondNFT.release, which might call back into the Lock contract if the bondNFT is malicious. But since bondNFT is immutable, maybe it's trusted. But if bondNFT is not trusted, then a reentrancy attack could happen. For example, when they call bondNFT.release, which could call back into Lock's functions. For example, during the release, after the bondNFT.release is called, the code proceeds to transfer the asset to the owner. If the bondNFT's release function makes an external call that reenters into release again, could that lead to double-spending? But since totalLocked is decremented before the transfer, maybe not. Wait, in the release function:

bondNFT.release is called, which returns (amount, lockAmount, asset, owner). Then totalLocked[asset] is decremented by lockAmount. Then transfer. If during bondNFT.release, a reentrant call is made to release again, then the totalLocked would be decremented again. But since the lockAmount is from the bondNFT, which might not have updated its state yet, this could cause underflow. However, since bondNFT is a separate contract, and assuming that bondNFT correctly updates its state before returning, then the lockAmount would be correct, and the first release would decrement totalLocked, and a reentrant call would use the new lockAmount. But if the bondNFT hasn't updated its state yet during the first call, then the second call could get the same lockAmount, leading to underflow. But this depends on the implementation of bondNFT.release. If bondNFT is trusted, this isn't an issue. But if it's not trusted, this could be a reentrancy vulnerability.

Another reentrancy possibility is in the claim function. After bondNFT.claim, which might call back, then the transfer happens. But the transfer is the last step. If the attacker can reenter claim again, but the bondNFT's claim function would have already processed the claim, so maybe not. But again, depends on the external contract.

Another thing to check is access control. For example, the lock function is public, so anyone can call it as long as they have the asset. But the allowedAssets is controlled by the owner. So maybe no issue there. The extendLock function calls claim(_id), which is public. The claim function calls claimGovFees(), which is public. But the claim function is public and can be called by anyone with a valid _id. However, bondNFT.claim is called with msg.sender as the recipient. So maybe only the owner of the NFT can claim. But depends on how bondNFT.claim is implemented. If bondNFT.claim checks that the caller is the owner of the NFT, then it's safe. Otherwise, if it doesn't, then anyone could call claim with any _id and steal funds. But since the Lock contract is passing msg.sender to bondNFT.claim, perhaps that's handled by bondNFT. So the security here depends on the bondNFT's implementation, which is external. So if bondNFT's claim function properly authenticates the sender, then no problem. Otherwise, it's a vulnerability.

The sendNFTs function is onlyOwner, and sends govNFTs. That's probably okay, assuming the owner is trusted.

Another possible issue is the use of IERC20(_tigAsset).approve(address(bondNFT), type(uint256).max); in claimGovFees. This sets an unlimited allowance for bondNFT to spend the contract's tokens. If bondNFT is compromised, it could drain all the tokens of that type from the Lock contract. Since bondNFT is immutable, this is a risk if bondNFT has a vulnerability. But this is a design choice. However, in the code, after each distribution, the allowance is set to max again. So even if a previous allowance was used, the approve function might be vulnerable to the race condition where the previous allowance was non-zero. For example, if the bondNFT uses a transferFrom in the distribute function, but only uses part of the allowance, then the next approve would reset it. However, OpenZeppelin's approve has a mitigation for this by first setting to zero and then to the new value, but here they directly set to max. If the bondNFT.distribute function is called in between, there's a possible front-running attack. However, since the Lock contract is the one calling approve and then immediately distribute, maybe the risk is low. But it's still a potential issue if the bondNFT doesn't use the entire allowance. For example, if distribute is supposed to transfer the exact balanceAfter - balanceBefore, but if for some reason it's possible to call distribute again before the approve, then the allowance is already max, which could allow bondNFT to take more tokens. But since the allowance is set to max each time, this could accumulate. However, in the code, the distribute is called with balanceAfter - balanceBefore, which is the difference. So if distribute properly transfers that amount, then the allowance is sufficient. But if bondNFT's distribute function can be manipulated to take more than that, then the unlimited allowance is dangerous. But again, this depends on bondNFT's implementation.

Another thing: the claimGovFees function iterates over all assets from bondNFT.getAssets(). If the number of assets is large, this loop could run out of gas. So this is a potential denial-of-service (DoS) if the assets array is too big. For example, if bondNFT.getAssets() returns a dynamic array that can grow indefinitely, then claimGovFees could become uncallable due to gas limits. This would prevent the function from executing, which might affect other functions that call claimGovFees, like lock, release, etc., since they call claimGovFees() at the beginning.

In the extendLock function, after calling claim(_id), which returns _asset, they then call transferFrom. However, if the claim function returns a malicious _asset (e.g., a token with a hook that executes code on transfer), then during transferFrom, a reentrancy could occur. But again, since _asset is determined by the bondNFT's claim function, if bondNFT is malicious, this could be a problem. But bondNFT is immutable and set during construction, so if it's trusted, then no issue. Otherwise, this could be a reentrancy vector.

Also, in extendLock, the user is transferring _amount of the _asset (from claim's return). However, the code allows the user to specify _amount and _period. Are there any checks that _amount is correct? For example, if the user can extend the lock by adding more tokens, but the code doesn't check if the _amount is positive or if the _period is within min/max again. Wait, extendLock has a parameter _period, but it's not checked in extendLock. Wait, looking at the code for extendLock:

function extendLock(
    uint _id,
    uint _amount,
    uint _period
) public {
    address _asset = claim(_id);
    IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
    bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
}

Wait, there's no check on _period here. The lock function has checks that _period is between min and max, but extendLock does not. So a user could extend the lock with a _period less than minPeriod or greater than maxPeriod. That's a vulnerability because the lock period could be set outside the allowed bounds when extending. So this is a missing check in extendLock.

Also, when extending the lock, the user can specify any _period. So even if the original lock had a period within min and max, extending could set it to something outside. This violates the intended constraints of the contract, which enforces min and max periods only during the initial lock, not during extension.

Another possible issue is in the release function. The bondNFT.release returns (amount, lockAmount, asset, _owner). Then, the code transfers 'amount' to _owner. However, what if _owner is not the same as msg.sender? Because the release function is called by msg.sender, but the bondNFT.release could return a different _owner. But the code checks that msg.sender is authorized in bondNFT.release. For example, if bondNFT.release ensures that the caller (msg.sender in the Lock contract's release function) is allowed to release the lock, then _owner would be the rightful owner. But if bondNFT's release function allows anyone to release any lock, then this could result in transferring funds to the wrong _owner. However, since bondNFT is a trusted contract (as it's immutable), this is dependent on its correct implementation.

Also, in the claimDebt function, bondNFT.claimDebt is called with msg.sender and _tigAsset, and then transfers the amount. But if the bondNFT allows any user to claim debt for any asset, this could be a problem. Again, depends on bondNFT's implementation.

Additionally, in the Lock contract, the allowedAssets mapping is controlled by the owner via editAsset. If the owner adds a malicious ERC20 token, it could cause issues. But the owner is supposed to be trusted.

Other issues: possible front-running in approvals. For example, in claimGovFees, the approve is set to max each time. If an attacker can front-run this transaction and call transferFrom before the distribute is called, they could drain funds. But since the distribute is called immediately after approval, maybe the risk is low. But in general, using approve with max is risky if the spender is untrusted. Since bondNFT is immutable, if it's compromised, the Lock contract's funds in any allowed asset could be stolen.

Another thing: the bondNFT.distribute function is called with balanceAfter - balanceBefore. If the govNFT.claim function somehow manipulates the balance in a way that balanceAfter - balanceBefore is incorrect (e.g., if someone else transfers tokens to the contract during the claim), but since claim is called in the same transaction, maybe it's safe. But if the govNFT.claim function interacts with external contracts that can transfer tokens to the Lock contract, then balanceAfter - balanceBefore might not accurately reflect the claimed amount, leading to incorrect distribution.

Also, in the claimGovFees loop, for each asset, they approve bondNFT for max, then call distribute. If distribute is called multiple times for the same asset, the allowance might not be needed anymore, but since it's set to max, any leftover allowance remains. However, since the Lock contract is designed to distribute the exact delta (balanceAfter - balanceBefore), the distribute function should transfer that exact amount. If bondNFT.distribute uses the entire delta, then there's no leftover. But if it doesn't, the leftover allowance could be exploited in future calls.

In summary, the vulnerabilities I can identify are:

1. **Unchecked ERC20 transfer return values**: The contract uses transferFrom and transfer without checking the return value, which can lead to failed transfers not being detected. This is especially critical for tokens that don't revert on failure but return false.

2. **Missing period check in extendLock function**: The extendLock function doesn't enforce the minPeriod and maxPeriod constraints, allowing locks to be extended beyond the allowed periods.

3. **Unbounded loop in claimGovFees**: If the number of assets returned by bondNFT.getAssets() is too large, the loop could consume excessive gas, leading to a DoS.

4. **Unsafe approval in claimGovFees**: Using approve with type(uint256).max can lead to over-authorization. If the bondNFT contract is compromised, it could drain the Lock contract's funds for any approved asset.

5. **Potential reentrancy in external calls**: Functions like release, claim, etc., make external calls to bondNFT and govNFT contracts which could potentially reenter the Lock contract if those contracts are malicious. However, this depends on the trustworthiness of the bonded NFT contracts.

6. **Underflow risk in totalLocked**: If bondNFT returns a lockAmount greater than totalLocked[asset], totalLocked could underflow. However, Solidity 0.8.x's checked math would revert, which is safe, but requires that bondNFT returns valid lockAmounts.

7. **Front-run in ERC20 approvals**: The approve in claimGovFees could be front-run, allowing an attacker to use a previous approval before it's reset. However, since the approval is set to max each time, this might not be exploitable.

The most critical issues are likely the unchecked ERC20 transfers and the missing period check in extendLock.","```
1. Underflow Risk in `totalLocked`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Underflow Risk in `totalLocked`"".
   - In the ranked list of predictions, this appears at rank 6.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 6, \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.1667 \).

**Output**:
```
0.1667
```",0.1667
BondNFT.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",3270.0,384.0,"[H-05] Malicious user can steal all assets in BondNFT
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
When calling `claim()` for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.
  [M-06] BondNFTs can revert when transferred
In the function `_transfer`, `BondNFTs` should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against.
  [M-14] BondNFT.sol#claim() needs to correct all the missing epochs
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.
 
[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch
Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function Lock.lock() first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.
  [M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT
After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.   [M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called
Calling the following `Trading._handleOpenFees` function does not approve the GovNFT contract for spending any of the Trading contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`.",6.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; 
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; 

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             
                address(0),     
                _asset,         
                _amount,        
                epoch[_asset],  
                block.timestamp,
                expireEpoch,    
                0,              
                shares,         
                _period,        
                false           
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",2608.0,1,5,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unbounded Loop in `distribute` Function**  
   The `distribute` function uses a loop to increment `epoch[_tigAsset]` for each day between the current epoch and `block.timestamp / DAY`. If this period is large (e.g., years), the loop will exceed gas limits, causing the transaction to fail and preventing reward distribution.

2. **Incorrect Epoch Handling for Expiration**  
   Bond expiration checks rely on `epoch[_asset]`, which is only updated via `distribute()`. If `distribute` is not called regularly, `epoch` becomes outdated, leading to incorrect expiration statuses (`expired` flag) and miscalculations in `idToBond()`.

3. **Unchecked Arithmetic in Critical Functions**  
   - `createLock` and `extendLock` use `unchecked` blocks, risking overflow/underflow (e.g., `totalBonds++`, `shares` calculation). While unlikely in practice, this could result in incorrect share calculations or token ID overflows.
   - `_mint` performs unchecked multiplication in `bondPaid`, risking overflow if `shares` or `accRewardsPerShare` are extremely large.

4. **Incorrect Reward Calculation in `claim` Function**  
   The `_pendingDelta` calculation in `claim()` may erroneously subtract `bondPaid[_id][bond.asset]` twice, leading to incorrect reward payouts. This could result in under/overpayment of rewards to users.

5. **Dependency on Regular `distribute` Calls**  
   Core functionalities like `extendLock`, `createLock`, and `_transfer` depend on `epoch` being up-to-date via `distribute()`. If `distribute` is not called, these functions may revert or misbehave (e.g., ""Bad epoch"" errors).

6. **Unbounded Loops in Transfer Functions**  
   `safeTransferMany`, `safeTransferFromMany`, and `approveMany` loop over input arrays without size limits, creating a gas exhaustion risk if large arrays are processed, leading to DoS.

7. **Inconsistent Owner Data in Bond Struct**  
   The stored `Bond` struct sets `owner` to `address(0)`, while `idToBond()` dynamically retrieves the ERC721 owner. This discrepancy could cause confusion during audits or debugging but does not directly impact functionality.

8. **Epoch Misalignment in `extendLock`**  
   The `extendLock` function requires `epoch[bond.asset] == block.timestamp / DAY`. If `distribute` is not called, `epoch` lags, making `extendLock` unusable until `distribute` updates the epoch.

9. **Transfer Restrictions with `mintTime` Check**  
   The `_transfer` function enforces a 5-minute cooldown (`block.timestamp > bond.mintTime + 300`). If bonds are minted in quick succession, transfers may fail unexpectedly.

10. **ERC20 Transfer Failures in `claim` and `claimDebt`**  
    The contract uses `IERC20.transfer` to send tokens to `manager`. If `manager` is a non-compliant contract (e.g., lacking `ERC20` support), transfers could fail, reverting transactions and locking funds.

11. **Lack of Access Control for `distribute` Function**  
    The `distribute` function lacks access control (e.g., `onlyManager`), allowing anyone to trigger reward distribution. While not inherently a vulnerability, it could lead to unintended interactions if called maliciously or erroneously.","### **Output**

---

**[H-05] Malicious user can steal all assets in BondNFT**

**Report Description**:  
A malicious user can drain all assets in `BondNFT`, causing other users to lose their rewards. When calling `claim()` for an expired bond, `accRewardsPerShare` is recalculated. However, rewards after the `expireEpoch` do not belong to the expired bond and should be redistributed to all other bonds. This oversight allows a malicious user to exploit the system and steal assets.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of malicious users draining assets or the incorrect recalculation of `accRewardsPerShare` for expired bonds. This is a critical vulnerability that is entirely missed.

---

**[M-06] BondNFTs can revert when transferred**

**Report Description**:  
The `_transfer` function in `BondNFTs` should allow transfers, as per the proposal and sponsor's intent. However, the function may revert, preventing bonds from being sold or borrowed against.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of `BondNFTs` reverting during transfers. This is a functional issue that impacts the usability of the contract.

---

**[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Report Description**:  
In the `claim()` function, `accRewardsPerShare[][]` is updated to reflect expired shares. However, only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated, missing all epochs between `bond.expireEpoch-1` and `epoch[bond.asset]`. This leads to incorrect reward calculations.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Reward Calculation in `claim` Function""**.

**Validation**:  
**Partially Correct**. The response identifies incorrect reward calculations in `claim()` but does not specifically address the issue of missing epochs between `bond.expireEpoch-1` and `epoch[bond.asset]`. This is a critical detail that is overlooked.

---

**[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**

**Report Description**:  
The `distribute()` function does not update `epoch[tigAsset]` when `totalShares[tigAsset] == 0`. This causes `createLock()` to set incorrect values for the bond's mint epoch, leading to misaligned epochs and potential reward distribution issues.

**Match in Response List**:  
Matches with the issue titled **""Dependency on Regular `distribute` Calls""**.

**Validation**:  
**Correct**. The response accurately identifies the dependency on `distribute()` to update `epoch[tigAsset]`. It correctly explains the risks of `epoch` becoming outdated, which aligns with the issue described.

---

**[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**

**Report Description**:  
After a lock expires, it no longer receives rewards. However, unreleased locks cause `totalShares` to remain unchanged, leading to flawed reward distribution. As a result, bond owners receive fewer rewards than they should.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unreleased locks causing flawed reward distribution. This is a significant oversight that impacts the fairness of the reward system.

---

**[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called**

**Report Description**:  
The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance. This differs from `Trading._handleCloseFees`, which approves spending. As a result, Governance NFT holders may lose deserved rewards.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing approvals in `Trading._handleOpenFees`. This is a critical oversight that could lead to loss of rewards for Governance NFT holders.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**

**Partially Correct Matches**:

- **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Missed Issues from Issue Report**:

- **[H-05] Malicious user can steal all assets in BondNFT**
- **[M-06] BondNFTs can revert when transferred**
- **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**
- **[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called**

--- 

### **Conclusion**

The `response_list` covers some issues but misses several critical vulnerabilities, particularly those related to malicious exploitation, reward distribution flaws, and functional issues like transfer reverts. The responses that do match are either correct or partially correct but often lack the depth or specificity needed to fully address the reported issues.",1,1,4,11,"Okay, let's start by looking through this BondNFT smart contract to identify any vulnerabilities. First, I'll read through the code step by step and check each function for common issues.

Starting with the struct and mappings. The Bond struct has several fields, and the contract uses mappings like _idToBond to track bonds. Maybe there's a risk of reentrancy, but since the functions use the onlyManager modifier, perhaps external calls are controlled.

Looking at the createLock function. It increments totalBonds in an unchecked block. Since it's using Solidity 0.8, which has default overflow checks, but here it's in an unchecked block, so there's a possible overflow if totalBonds reaches max uint256. Although, in practice, that's highly unlikely, but still a theoretical vulnerability.

The extendLock function modifies the bond's shares, amount, etc. It checks that epoch[bond.asset] equals block.timestamp/DAY. Wait, epoch is a mapping that's updated elsewhere? Let me check the distribute function. In distribute, if the current epoch is higher, they loop from epoch to aEpoch, incrementing each time. But if aEpoch is much larger than the current epoch, this loop could run out of gas. For example, if the distribute function is called after a long time, the loop could exceed the block gas limit, causing the function to fail. That's a possible DoS vulnerability in distribute when epochs are far apart.

Then in release function, when claiming, they call claim which transfers tokens to the manager. The claim function uses IERC20.transfer which could fail if the manager is a contract that doesn't handle tokens. However, since the manager is set by the owner, maybe that's a trusted contract. Still, a failed transfer could cause the release function to revert, which could be problematic.

In the claim function, there's an unchecked block where bondPaid is updated. But bondPaid is a mapping, so maybe underflow isn't an issue here. However, the calculation of _pendingDelta could be incorrect if the order of operations is wrong, leading to incorrect reward distribution. Let me check that part again. The code is: _pendingDelta = (bond.shares * accRewardsPerShare / 1e18 - bondPaid) - (bond.shares * previous accRewards - bondPaid). Wait, maybe this is subtracting bondPaid twice? That might not be correct. If bond.expired is true, the pendingDelta calculation might have an error, leading to incorrect accounting of rewards. That's a possible logic error leading to incorrect reward distribution.

In the distribute function, the loop increments epoch[_tigAsset] for each i from current epoch to aEpoch. If aEpoch is, say, a year later, this loop would have 365 iterations, which is manageable. But if it's multiple years, it could exceed gas limits. So if the contract hasn't distributed rewards for a long time, this function would become unusable, leading to stuck funds or inability to update the accRewardsPerShare properly. Definitely a vulnerability here.

Looking at the _transfer function. It checks if the epoch is the current day (block.timestamp/DAY). If someone transfers a bond when the epoch has advanced, this check would fail. But how is epoch updated? It's updated in distribute. If distribute isn't called regularly, the epoch for an asset might not be current, causing transfers to revert unexpectedly. Also, the line require(block.timestamp > bond.mintTime + 300, ""Recent update""); enforces a 5-minute wait before transferring. So users can't transfer a bond within 5 minutes of minting. That's a user experience issue, but not a vulnerability per se. However, if the mintTime is manipulated, but it's set to block.timestamp in createLock, so that's okay.

In addAsset function, adding an asset checks if it's already in the assets array. But the check uses assetsIndex[_asset], which for a new asset would be zero. However, if the first asset was added and then removed, assetsIndex might not be accurate. Wait, the code says require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added""). But if assetsIndex[_asset] was set for a previously added asset, but the asset was removed (but the contract doesn't have a removeAsset function), then this check might fail incorrectly. Since there's no remove function, maybe this is okay, but if an asset was allowed and then disallowed via setAllowedAsset, the assets array still contains it. So adding the same asset again would fail because assetsIndex[_asset] points to its position, and if it's already there, the check prevents adding. So that's probably okay.

The safeTransferMany and safeTransferFromMany functions loop over the _ids array. Since there's no limit on the array length, a very large array could cause out-of-gas errors. However, since these are external functions, a malicious user could send a transaction with a large array to cause the function to consume excessive gas and fail. But since these functions are for transferring NFTs, it's up to the user to manage gas, but it's still a potential DoS vector if used improperly.

The _mint function uses an unchecked block when setting bondPaid. The calculation is bondPaid[bond.id][bond.asset] = accRewardsPerShare[...] * bond.shares / 1e18. Since it's done in an unchecked block, if the multiplication overflows, it would wrap around. Given that shares are calculated as _amount * _period / 365, which could be a large number if _amount is high and _period is up to 365 days. For example, if _amount is 1e18 and _period is 365, shares would be 1e18, multiplied by accRewardsPerShare (which is in 1e18) would be 1e36, which divided by 1e18 is 1e18, which is a uint256. But if _amount is very large, maybe exceeding 1e59, the multiplication could overflow. But since _amount is an ERC20 amount which usually has 18 decimals, this is unlikely. Still, using unchecked here is risky if not properly constrained.

Another thing: the Bond struct's owner is stored, but the idToBond function retrieves the owner via ownerOf(_id), which is the ERC721 owner. So the Bond struct's owner field is actually not used, since in the struct it's initialized to address(0) and then in idToBond it's set to ownerOf(_id). But in createLock, the Bond is created with owner set to address(0). That's okay because when you call _mint(to, bond.id), the ERC721 owner is set, so the idToBond function correctly retrieves the owner. But in the Bond struct stored in _idToBond, the owner is address(0). However, since the idToBond function overwrites the owner field with the actual owner from ERC721, this is a discrepancy in the stored data. However, since the struct in storage has owner as address(0), but when you retrieve it via idToBond, it's correct. This could be confusing but not a vulnerability.

Looking at the release function, it calls _burn(_id), which deletes the bond from _idToBond. However, if the bond is burned, the ownerOf(_id) would revert since the token no longer exists. But in the release function, bond is retrieved before burning, so it's okay.

In the extendLock function, the line require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");. But epoch is updated in distribute. If distribute hasn't been called for an asset, its epoch would be behind. So if someone tries to extend a lock when the epoch is not up to date, this would fail. So extendLock depends on distribute being called regularly, which may not be the case. This could make the function unusable if distribute is not called, leading to stuck funds or inability to extend locks.

Another possible issue: in the createLock function, the bond is created with expireEpoch = epoch[_asset] + _period. But epoch is the current epoch for the asset. However, if the asset's epoch hasn't been updated (because distribute wasn't called), then expireEpoch could be set based on an old epoch value. For example, if distribute was last called a week ago, then epoch[_asset] is a week old. Adding _period to that would set an expireEpoch that is not correctly aligned with the current time. This could cause bonds to expire later than intended or earlier. Since the expireEpoch is compared to epoch[_asset] in idToBond to check expiration, but if epoch is not updated, the expiration check would be incorrect. This is a critical issue because the expiration logic depends on the epoch being current, which is only updated via distribute. If distribute is not called regularly, the contract's expiration checks are incorrect.

So in summary:

1. **DoS in distribute Function Due to Unbounded Loops**: The loop in distribute could run for a large number of epochs if not called regularly, leading to out-of-gas errors and preventing reward distribution.

2. **Incorrect Epoch Handling Leading to Expiration Issues**: Since epoch is only updated in distribute, if that function isn't called, the expiration checks (based on epoch) will be incorrect, causing bonds to not expire correctly.

3. **Unchecked Arithmetic in createLock and extendLock**: The use of unchecked blocks in these functions could theoretically lead to overflows, though the risk is low given typical parameters.

4. **Potential Reward Calculation Errors in claim Function**: The calculation of _pendingDelta might incorrectly subtract bondPaid twice, leading to incorrect reward payouts.

5. **Dependence on Regular distribute Calls for Core Functionality**: Functions like extendLock and createLock depend on distribute being called to update epochs. If distribute isn't called, these functions may fail or behave unexpectedly.

6. **Unbounded Loops in safeTransferMany and Related Functions**: These functions loop over arrays which could be large, leading to high gas costs and potential DoS.

7. **Incorrect Owner Field in Stored Bond Struct**: The stored Bond struct's owner is address(0), which might lead to confusion but doesn't affect functionality since the correct owner is retrieved from ERC721.

8. **Transfer Restrictions Based on Epoch and Time**: Transfers require the current epoch to match, which depends on distribute being called, and a 5-minute cooldown, which could cause unexpected reverts.

These are the main vulnerabilities I can spot. Now I need to list them concisely.","```
1. Dependency on Regular `distribute` Calls
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Dependency on Regular `distribute` Calls"".
   - This appears at rank 5 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 5 (\( P@5 \)) is calculated as the number of true positives up to rank 5 divided by 5.
   - Since there is only one true positive up to rank 5, \( P@5 = \frac{1}{5} = 0.2 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 0.2 \).

**Output**:
```
0.2
```",0.2
Trading.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",9443.0,1055.0,"[H-02] Riskless trades due to delay check
`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
  [H-06] Incorrect calculation of new price while adding position
The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.
  [H-09] Users can bypass the `maxWinPercent` limit using a partially closing
Users can bypass the `maxWinPercent` limit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.
  [H-11] Not enough margin pulled or burned from user when adding to a position
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.
  [M-04] Approved operators of Position token can't call Trading.initiateCloseOrder
Approved operators of owner of Position token can't call several function in Trading.
Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function.
  [M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations
Formula for `fee paid` in the `_handleOpenFees`  is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.   [M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds
The function `initiateCloseOrder()`   [M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()
The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.
  [M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18
In Trading.sol a deposit or withdrawal of tokens with decimals higher than 18 will always revert.
  [M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred
When `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`.",10.0,"pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); 
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; 
    uint private constant liqPercent = 9e9; 

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; 

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; 
        bool actionType; 
    }
    mapping(uint => Delay) public blockDelayPassed; 
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; 

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    

    
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); 
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, 
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); 
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); 
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); 
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); 

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    

    
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); 
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) 
                / DIVISION_CONSTANT 
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); 
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); 
        }
    }

    
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); 
    }

    
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); 
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    

    
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",7509.0,4,6,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Decimal Handling Leading to Truncation**:
   - In `_handleDeposit`, when converting `_margin` from the contract's decimals (18) to the margin asset's decimals, division truncation can occur. This results in a loss of precision, leading to deposited amounts being less than intended, especially when `_margin` isn't a multiple of `10^(18 - marginAssetDecimals)`.

2. **Incorrect Open Interest (OI) Calculation in Limit Orders**:
   - In `executeLimitOrder`, the OI is updated using the original margin (`trade.margin`) before subtracting fees. This overstates the actual OI since the position size should be based on the margin after fees (`trade.margin - _fee`), leading to inflated OI values affecting funding rates and risk calculations.

3. **Unchecked Fee Parameter Configuration Risks**:
   - In `_handleOpenFees`, if the `daoFees` are set too low relative to `referralFees` or `botFees`, an underflow can occur during fee distribution. Although `setFees` includes checks, improper configuration by the owner (or a compromised owner) could lead to underflows in `unchecked` blocks, causing incorrect fee allocations.

4. **External Call Risks to Vault Contracts**:
   - The contract interacts with external vaults (`IStableVault`) in `_handleDeposit` and `_handleWithdraw` without reentrancy guards. While allowed vaults are trusted, a malicious or compromised vault could exploit reentrancy during deposits/withdrawals, though mitigated by administrative controls.

5. **Price Oracle Manipulation in Averaging**:
   - In `addToPosition`, the new average price calculation (`_newPrice`) uses a weighted average of the existing and added position prices. If the current price (`_price`) is manipulated (e.g., via oracle attacks), the average price becomes inaccurate, potentially disadvantaging the trader.

6. **Insufficient Validation of Fee Multipliers**:
   - The `_handleCloseFees` function applies `asset.feeMultiplier` without upper bounds. If set excessively high (e.g., via `pairsContract`), this could lead to exorbitant fees, draining user funds unexpectedly.

7. **Dependence on Trusted Oracles for Price Feeds**:
   - The contract relies on `tradingExtension.getVerifiedPrice` for price data. If the oracle is compromised or signatures are front-run, trades could be executed at manipulated prices, affecting position validity and profitability.

8. **Potential Token Minting Abuse**:
   - The contract mints `IStable` tokens in multiple functions (e.g., fee distributions). If the `IStable` implementation lacks proper access controls, unlimited minting could occur, leading to inflation and devaluation of the token.

9. **Liquidation Threshold Logic Flaw**:
   - In `liquidatePosition`, the check `if (_payout > ...)` may misinterpret the liquidation threshold. However, further analysis shows the logic correctly allows liquidation when the remaining margin is ≤10%, but this depends on accurate `pnl` calculations.

10. **Block Timestamp Reliance for Proxy Approvals**:
    - The `approveProxy` function uses `block.timestamp` for approval expiration. Miners can manipulate timestamps within a small range, potentially extending or shortening approval validity periods, though impact is limited.","### **Output**

---

**[H-02] Riskless trades due to delay check**

**Report Description**:  
The `Trading.limitClose()` function uses `_checkDelay()`, which allows for riskless trades. This occurs because users can capture price rises by increasing the stop-loss while preventing underwater positions from being closed by continuously increasing the delay. This creates an unfair advantage and potential financial loss for the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of riskless trades due to delay checks. This is a critical oversight, as it directly impacts the fairness and security of the trading mechanism.

---

**[H-06] Incorrect calculation of new price while adding position**

**Report Description**:  
The formula used for calculating `_newPrice` in the `addToPosition()` function of `Trading.sol` is incorrect. This results in users losing part of their funds or profits when using this function.

**Match in Response List**:  
Matches with the issue titled **""Price Oracle Manipulation in Averaging""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of price manipulation in `addToPosition()` but focuses on oracle manipulation rather than the incorrect calculation of `_newPrice`. While related, the core issue of the flawed formula is not addressed.

---

**[H-09] Users can bypass the `maxWinPercent` limit using partial closing**

**Report Description**:  
Users can bypass the `maxWinPercent` limit by partially closing their positions. This allows them to receive more funds than their upper limit from the protocol, leading to potential financial losses for the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of bypassing the `maxWinPercent` limit through partial closing. This is a significant oversight, as it directly impacts the protocol's financial integrity.

---

**[H-11] Not enough margin pulled or burned from user when adding to a position**

**Report Description**:  
When adding to a position, the amount of margin pulled from the user is insufficient. This leaks value from the protocol and lowers the collateralization ratio of `tigAsset`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient margin being pulled or burned when adding to a position. This is a critical oversight, as it directly impacts the protocol's financial stability.

---

**[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**

**Report Description**:  
Approved operators of the owner of a Position token cannot call several functions in `Trading`, including `initiateCloseOrder`. This is because these functions check that the caller is the owner of the token using the `_checkOwner` function, which excludes approved operators.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of approved operators being unable to call certain functions. This is a significant oversight, as it limits the functionality of the protocol.

---

**[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**

**Report Description**:  
The formula for `_feePaid` in the `_handleOpenFees` function is incorrect, leading to incorrect margin calculations. This directly impacts trader margins and associated fee calculations, posing a high risk.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Validation of Fee Multipliers""**.

**Validation**:  
**Partially Correct**. The response identifies issues with fee calculations but focuses on fee multipliers rather than the incorrect formula in `_handleOpenFees`. While related, the core issue of the flawed formula is not addressed.

---

**[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**

**Report Description**:  
The owner has the ability to freeze withdrawals and use a timelock to steal all funds, posing a significant centralization risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the centralization risks associated with the owner's ability to freeze withdrawals and steal funds. This is a critical oversight, as it directly impacts the security and trustworthiness of the protocol.

---

**[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

**Report Description**:  
The open price of a stop order might change during execution, but the function does not validate StopLoss/TakeProfit for the changed price, leading to potential vulnerabilities.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of failing to validate StopLoss/TakeProfit for the new price in `executeLimitOrder()`. This is a significant oversight, as it directly impacts the security of the trading mechanism.

---

**[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Report Description**:  
In `Trading.sol`, deposits or withdrawals of tokens with decimals higher than 18 will always revert, limiting the protocol's functionality.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Decimal Handling Leading to Truncation""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of incorrect decimal handling in `_handleDeposit` and `_handleWithdraw`, which aligns with the reported issue.

---

**[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred**

**Report Description**:  
When `initiateMarketOrder` is called, `_marginAfterFees` is calculated incorrectly, leading to positions being opened with more margin than expected, especially when a trade is referred.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Validation of Fee Multipliers""**.

**Validation**:  
**Partially Correct**. The response identifies issues with fee calculations but focuses on fee multipliers rather than the incorrect calculation of `_marginAfterFees` in `initiateMarketOrder`. While related, the core issue of the flawed calculation is not addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Partially Correct Matches**:

- **[H-06] Incorrect calculation of new price while adding position**
- **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**
- **[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred**

**Missed Issues from Issue Report**:

- **[H-02] Riskless trades due to delay check**
- **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**
- **[H-11] Not enough margin pulled or burned from user when adding to a position**
- **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**
- **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**
- **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

---",1,3,6,10,"Okay, let's take a look at this smart contract. I need to find all the vulnerabilities in it. The user said no need for mitigation, just list them. Alright, let's start going through the code step by step.

First, the contract imports several interfaces and contracts. I should check if there are any unsafe imports or dependencies, but maybe that's not the main issue here. Let's look at the contract structure.

The contract is called Trading and inherits from MetaContext and ITrading. There are multiple interfaces defined, like ITradingExtension, IStable, ExtendedIERC20, ERC20Permit, etc. The contract has various functions for initiating market orders, closing positions, adding margin, etc.

Looking at the initiateMarketOrder function. It calls _validateProxy, which checks if the trader approved a proxy. Then _checkDelay is called, which seems to enforce a block delay between actions. Then _checkVault ensures the vault is allowed. The function then handles fees, deposits, and opens a position. 

Wait, the _handleOpenFees subtracts fees from the margin. But what if the fees exceed the margin? For example, if marginAfterFees is calculated as margin - fees. If fees are higher than margin, this could result in an underflow. But Solidity 0.8.x has default underflow checks, so that would revert. So maybe that's handled.

In the _handleDeposit function, when the tigAsset is not the same as marginAsset, it transfers from the trader. It uses _margin/_marginDecMultiplier. But if _margin is not a multiple of 10^(18 - decimals), this division might truncate, leading to loss of funds. For example, if decimals is 6, then 1e18 / 1e12 = 1e6, but if margin is 1e18 + 1, then dividing by 1e12 would be 1e6 + 0.0001, which truncates to 1e6, losing the 0.0001. So this could cause the actual margin deposited to be less than intended. That's a problem.

Another thing: in _handleDeposit, after depositing into the stable vault, they check if the balance increased by exactly _margin. But depending on how the vault's deposit works, maybe there are fees or rounding issues. If the vault doesn't mint exactly 1:1, this check could fail. For example, if the vault takes a fee on deposit, then the tigAsset balance wouldn't increase by _margin. The code reverts with BadDeposit, which might be incorrect in such cases.

Looking at the executeLimitOrder function: when modifying long or short OI, they pass trade.margin * trade.leverage / 1e18. But if the margin or leverage is very large, this multiplication could overflow. However, Solidity 0.8.x checks for overflows, so it would revert. But maybe the parameters are not properly validated elsewhere.

In the _handleCloseFees function, they calculate _daoFeesPaid and subtract referral and bot fees from it. But if the referral or bot fees are larger than the initial _daoFeesPaid, this could underflow. For example, if _daoFeesPaid is 100, and referral fees are 60, then _daoFeesPaid becomes 100 - 60*2 = negative, which would underflow. Since this is in an unchecked block, it would wrap around, leading to incorrect fee calculations. That's a vulnerability.

Wait, in _handleOpenFees, the code has an unchecked block. Let me check:

unchecked {
    _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
}

If _fees.daoFees is less than _fees.referralFees*2, this would underflow. But since the code is in an unchecked block, it would wrap around. However, earlier there's a check:

require(_daoFees >= _botFees+_referralFees*2);

Wait, no, in setFees, there's a require that _daoFees >= _botFees + _referralFees *2. So maybe that's enforced by the owner. But if the owner sets incorrect values, this could underflow. But since onlyOwner can set fees, maybe that's a trust issue. But if the owner makes a mistake, this could cause underflow in _handleOpenFees.

In the liquidatePosition function, they check if _payout > int(_trade.margin * (DIVISION_CONSTANT - liqPercent)/DIVISION_CONSTANT). Wait, liqPercent is 9e9, so (1e10 - 9e9)/1e10 = 0.1. So if the payout is greater than 10% of the margin, it's not liquidatable. But the condition is if (_payout > ...), then revert NotLiquidatable(). Wait, no: the code says if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();

Wait, liqPercent is 9e9, so (DIVISION_CONSTANT - liqPercent) is 1e10 - 9e9 = 1e9. So the margin multiplied by 1e9 / 1e10 is 10% of the margin. The condition is: if the payout (which is the profit) is greater than 10% of the margin, revert. But liquidation should happen when the position is under water. Wait, maybe the logic here is inverted. Because if the position's value is below a certain threshold, it should be liquidated.

Wait, let's think: _payout is the profit. If the profit is positive, the position is doing well. If it's negative, the position is losing. Wait, no. Let's see how pnl is calculated. The TradingLibrary.pnl function returns the payout. If the payout is negative, that means the position has lost more than the margin, right? But in the liquidate function, they check if _payout > int(_trade.margin * 0.9). Wait, that can't be right. Because if _payout is the profit, then when the loss is such that the remaining margin is less than 10%, the payout (which would be margin - loss) would be less than 0.1 * margin. Wait, maybe I need to look at how pnl is calculated.

Suppose the position's value is such that the payout is margin + profit. But in the code for liquidation, they check if the payout is greater than 90% of the margin (since liqPercent is 9e9, which is 90% when divided by 1e10). Wait, no: (DIVISION_CONSTANT - liqPercent) is 1e10 - 9e9 = 1e9, so 1e9 / 1e10 = 0.1. So the threshold is 10% of the margin. If the payout is less than or equal to 10% of the margin, the position can be liquidated. But the code says:

if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();

So if the payout is greater than 10% of the margin, it reverts. Wait, but if the position is in profit (payout is higher than margin), then it can't be liquidated. But if the payout is negative (i.e., the position has a loss), then _payout would be less than margin. For example, if the loss is 90% of the margin, then payout is margin - 90% margin = 10% margin. If the code checks if _payout > 10% margin, which would only be true if the position hasn't lost that much. Wait, perhaps the logic here is inverted.

Actually, the liquidation condition should be when the remaining margin is below a certain threshold. For example, if the position's value (including PnL) is below the liquidation threshold. Let's see: 

The code calculates _payout as the result of pnl. If the direction is long, and the price drops, the payout would be less than the initial margin. If it's so low that the payout is <= 10% of the margin, then it can be liquidated. So the condition in code is: if _payout > 10% margin, revert. That means if the payout is higher than 10%, it's not liquidatable. So only when the payout is <= 10% margin, the liquidation can proceed. But the code says:

if (_payout > int(_trade.margin * 0.1)) revert NotLiquidatable();

Wait, but if _payout is the amount the user gets back, which could be negative? No, the pnl function returns (positionSizeAfterPrice, payout). Wait, looking at the code:

(,int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);

Then, if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();

But liqPercent is 9e9, so the value is _trade.margin * 0.1. So if the payout is greater than 0.1 * margin, revert. But _payout can be negative. For example, if the position is underwater, the payout could be negative. Wait, no, perhaps the pnl function returns the net value. Let me check.

In TradingLibrary.pnl, the calculation is:

For a long position: price has increased, so profit is (currentPrice - openPrice) * margin * leverage. So the payout would be margin + profit. But if the price drops below openPrice, the profit is negative, so payout is margin + (-loss) = margin - loss. So if the loss is so much that margin - loss <= 0.1 * margin, then the position can be liquidated.

Wait, the code checks if the payout (which is margin + profit) is greater than 0.1 * margin. If it is, then revert. So if the payout is 0.2 * margin, meaning the loss is 0.8 * margin, then it's not liquidatable. But when the payout is <= 0.1 * margin (loss of 0.9 * margin), then it can be liquidated. Wait, but the code's condition is if (_payout > ...) revert. So only positions where the payout is higher than 0.1 * margin are not liquidatable. That seems inverted. Because if the payout is higher than 0.1, the position is still above the liquidation threshold. So the code is correct here. For example:

If the user's remaining margin is 0.1 * initial margin, then they can be liquidated. So the code is checking if the payout (remaining margin) is > 0.1 * margin. If so, revert. Otherwise, proceed. So that part is correct.

Another thing: in the _handleWithdraw function, when converting the tigAsset to the outputToken via the stableVault, they do:

IStableVault(_stableVault).withdraw(_outputToken, _toMint);

But the amount is _toMint, which is in the tigAsset's decimals (assumed 18). However, the withdraw function might expect the amount in the outputToken's decimals. For example, if outputToken is USDC (6 decimals), then _toMint is 1e18 (1 token), but withdrawing 1e18 would be 1e18 / 1e12 (since the vault's stable is 1e18). Wait, in _handleDeposit, they do:

IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);

Where _marginDecMultiplier is 10^(18 - decimals). So when depositing, they divide by that to get the correct amount. When withdrawing, they need to multiply by the same. But in _handleWithdraw, the code is:

IStableVault(_stableVault).withdraw(_outputToken, _toMint);

But _toMint is in 18 decimals. If the outputToken has 6 decimals, this would withdraw 1e18 units, which is 1e18 / 1e12 = 1e6 units of USDC. But that's 1e6 USDC (1 million), which is way more than intended. Wait, this seems like a miscalculation. Because when depositing, they adjust for decimals, but when withdrawing, they don't. Let's see:

In _handleDeposit:

For a marginAsset with decimals less than 18, say 6 (USDC), then _marginDecMultiplier is 1e12 (10^(18-6)). So _margin is in 18 decimals (e.g., 1e18 represents 1 USDT). Then _margin / _marginDecMultiplier = 1e18 / 1e12 = 1e6, which is the correct amount to deposit into the vault, which mints 1e18 tigAsset.

But in _handleWithdraw, when the outputToken is USDC (6 decimals), the code calls withdraw with _toMint (which is in 18 decimals). The vault's withdraw function would burn _toMint tigAsset (1e18) and give back outputToken. But if the vault's exchange rate is 1:1, then burning 1e18 tigAsset would give 1e18 / 1e12 = 1e6 USDC, which is correct. So the code here is correct. Because _toMint is the amount of tigAsset to burn, and the vault converts it back to the outputToken. So the code in _handleWithdraw is okay.

Wait, but in the code:

_handleWithdraw is called with _toMint, which is the amount in tigAsset (18 decimals). So when they call IStableVault(_stableVault).withdraw(_outputToken, _toMint), that would convert _toMint tigAsset into _outputToken. If the vault uses a 1:1 conversion, then that's correct. For example, if the vault's stable is tigAsset (1e18), then 1 tigAsset = 1e6 USDC (if outputToken is USDC). Wait, no. The vault's stable is tigAsset. So when depositing USDC, you get tigAsset. So when withdrawing, you burn tigAsset to get USDC. The amount of USDC received would be tigAssetAmount * (USDC per tigAsset). If the vault is using a 1:1 peg, but with decimals, then 1e18 tigAsset (1 token) would be 1e6 USDC (1 token). So withdrawing 1e18 tigAsset gives 1e6 USDC. So the code here is correct.

Another possible issue: reentrancy. Are there any external calls that could be used for reentrancy? Let's see. In functions like _handleDeposit, they transfer tokens, approve, and call deposit on the vault. The vault's deposit function could be a contract, but since it's a trusted vault (allowed by owner), maybe that's not a concern. However, in general, external calls should be done after state changes. Let's check the flow.

In _handleDeposit, they do:

- TransferFrom the trader to the contract.
- Approve the vault.
- Call deposit on the vault.
- Check the balance of tigAsset.

The external call (deposit) is after the transfer and approve. If the vault is malicious, it could reenter. But since allowedVault is set by the owner, it's assumed that the owner only allows safe vaults. So maybe not a vulnerability here.

Another point: in the _closePosition function, after burning the position, they handle the withdrawal. But what if the position is only partially closed? For example, if _percent is 50%, they reduce the position. But when they call _handleWithdraw, they pass the _trade struct, which may have been modified. Wait, after reducing the position, the trade in storage is updated. But in the code, they first get the trade from storage, then call reducePosition. Then _handleWithdraw is called with the original _trade variable. Because _trade is a memory variable, it's not updated after the reducePosition call. So the code would use the original trade's tigAsset and other parameters. But when reducing the position, the tigAsset could change? Probably not. So that's okay.

Another issue: in the executeLimitOrder function, when modifying the OI (open interest), they use trade.margin * trade.leverage / 1e18. However, after the limit order is executed, the margin is reduced by the fee. So the actual position size is (margin - fee) * leverage. But the code here uses the original margin, leading to an incorrect OI. Wait, let's see:

In executeLimitOrder:

They calculate _fee = _handleOpenFees(...), then:

position.executeLimitOrder(_id, trade.price, trade.margin - _fee);

Then, when modifying OI, they use trade.margin * trade.leverage / 1e18. But after the fee is subtracted, the actual margin is trade.margin - _fee. So the position size should be (trade.margin - _fee) * leverage. But the code here uses the original margin, leading to a larger OI than actual. This would inflate the OI, which affects funding rates and other calculations. That's a vulnerability. For example, if the fee is 1% of the position size, then the OI is calculated based on the original margin, leading to higher OI than the actual. This could be exploited to manipulate OI and funding rates.

Another issue: in the _handleOpenFees function, the referral fees are calculated as _positionSize * _fees.referralFees / DIVISION_CONSTANT. But if the referralFees is set too high, this could drain the contract's funds. However, the setFees function has a require that _daoFees >= _botFees + _referralFees *2. So the owner is supposed to set the fees correctly. But if the owner is malicious or makes a mistake, this could be a problem. But that's an admin privilege issue.

Another possible issue is the use of block.number for delays. The _checkDelay function uses block.number to enforce a delay between actions. However, block numbers can vary in time depending on the network. For example, in Ethereum, a block is ~12 seconds, but in other chains, it could be faster. If the blockDelay is set too low, attackers could perform multiple actions within a short time. But this depends on how blockDelay is configured.

In the addToPosition function, they calculate the new price as:

_newPrice = _trade.price * _trade.margin / _newMargin + _price * _addMargin / _newMargin;

This is a weighted average of the original price and the new price. However, this assumes that the added margin is used to buy at the current price. But if the current price is manipulated, this could affect the average price incorrectly. For example, a miner could manipulate the price at which the addition is executed, leading to an unfair average price.

Another issue: in the _handleCloseFees function, when calculating _daoFeesPaid, _burnFeesPaid, etc., they multiply by asset.feeMultiplier. But if the feeMultiplier is greater than DIVISION_CONSTANT, this could lead to larger fees than intended. For example, if feeMultiplier is 2e10 (200%), then the fees would be doubled. However, the pairsContract's asset feeMultiplier is controlled by the owner, so this is a trust issue.

Reentrancy in _handleCloseFees when minting fees to referrers or bots. For example, when minting to the referrer's address, if the referrer is a contract with a hook, it could reenter. But since the token is a standard ERC20, the mintFor function (assuming it's similar to OpenZeppelin's) would update balances before calling transfer, which would prevent reentrancy. But if the mintFor function is implemented in a way that allows reentrancy, that could be an issue. However, without seeing the implementation of IStable, it's hard to tell. But the code here mints to the referrer, then proceeds. So if the referrer is a malicious contract, maybe.

Another possible issue is front-running. For example, when a user creates a limit order, others can see it and front-run the execution. But that's a general issue with decentralized exchanges and not specific to this contract.

In the cancelLimitOrder function, the code burns the position and mints the tigAsset back to the trader. However, if the tigAsset is a rebasing token or has a fee on transfer, the actual amount received might be less than expected. But the code uses IStable(_trade.tigAsset).mintFor(_trader, _trade.margin), which mints exactly the margin. Assuming that the mintFor function mints the exact amount, this is safe. But if the token has a fee, then the trader might not get the full margin back.

In the _handleOpenFees function, the code mints the fees to various addresses. However, if the tigAsset has a maximum supply, this could potentially exceed it. But since the contract is the minter, that's a configuration issue.

In the liquidatePosition function, after burning the position, they call _handleCloseFees with _positionSizeAfterPrice, which is based on the current price. However, the code calculates _positionSize as _trade.margin * leverage. But if the price has changed, the actual position size might be different. However, the code here uses the original position size for fee calculation, which might not reflect the current value. For example, if the position was liquidated at a loss, the fees are based on the original position size, leading to higher fees than appropriate.

In the _closePosition function, when handling the payout, they calculate _toMint as the payout minus fees. However, if the payout is negative (the position made a loss), _payout could be negative, leading to underflow. But the code checks if (_payout > 0) before proceeding. Wait, the code says:

if (_payout > 0) {
    _toMint = _handleCloseFees(...);
}

But _payout is an int256. So if the payout is negative, this condition is false, and _toMint remains 0. So no funds are minted. That's correct.

Another possible issue is the use of the DIVISION_CONSTANT (1e10). If any fee or calculation uses a value that exceeds the division constant, precision could be lost. For example, if a fee is 1e10, it would be 100% when divided by 1e10. But the code uses DIVISION_CONSTANT as a denominator, so all fee parameters should be less than or equal to 1e10. The setFees function has require statements that check for that.

In the _handleOpenFees function, when the referrer is address(0), the referral fees are not deducted. However, the code subtracts _referralFees*2 from _fees.daoFees. Wait, the code has:

if (_referrer != address(0)) {
    IStable(_tigAsset).mintFor(_referrer, _positionSize * _fees.referralFees / DIVISION_CONSTANT);
    _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
}

So if there is a referrer, then the DAO fees are reduced by 2x the referral fees. But why? For example, if the referral fee is 1%, then the DAO fee is reduced by 2%. That's odd. It suggests that the referral fee is taken from the DAO's share. But if the DAO fee is set to 5%, and the referral is 1%, the DAO would get 5% - 2*1% = 3%, and the referrer gets 1%. That way, the total fees (dao + burn + referral + bot) would sum up correctly. But if the DAO fee isn't sufficient to cover the 2x referral fees, this would underflow. However, the setFees function requires that _daoFees >= _botFees + _referralFees*2, so the DAO fee is sufficient. But if the owner sets fees incorrectly, this could cause an underflow. But since the setter function has a check, that's mitigated.

In the code for _handleCloseFees, when calculating the fees:

_daoFeesPaid = (_positionSize * _fees.daoFees / DIVISION_CONSTANT) * asset.feeMultiplier / DIVISION_CONSTANT;

But asset.feeMultiplier is set in the pairsContract. If the feeMultiplier is very high, this could result in very high fees. For example, if feeMultiplier is 2e10 (200%), the daoFeesPaid would be double. But that's a configuration set by the owner of the pairs contract, so it's a trusted component.

Another vulnerability: the use of tx.origin in _validateProxy. Wait, no, the code uses _msgSender(), which from MetaContext might be using OpenZeppelin's Context, which returns msg.sender. So that's okay.

In the approveProxy function, users can approve a proxy by sending ETH. However, the proxy is set with a timestamp. If the proxy's time is in the past, the approval is expired. But there's no check in the approveProxy function. So a user could approve a proxy with a time that's already passed, making the approval immediately invalid. But when _validateProxy is called, it checks if proxy.time >= block.timestamp. So if the time is in the past, the proxy is not allowed. So the approveProxy function allows setting expired proxies, which would be invalid. That's not a vulnerability, just a possible user error.

Another thing: the contract uses position.burn(_id) in functions like cancelLimitOrder and liquidatePosition. If the position contract's burn function doesn't check ownership, it could allow burning arbitrary positions. But the code here checks _checkOwner(_id, _trader) before burning, so that's okay.

In the addToPosition function, they call tradingExtension.validateTrade with _trade.margin + _addMargin. But _addMargin is the amount after fees. However, validateTrade checks if the new margin plus added margin is acceptable. Wait, the addedMargin is subtracted by the fee. So the code calls:

tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);

But _addMargin is the amount after fees. So if the user adds 100, and the fee is 10, the addedMargin is 90. Then the new margin is trade.margin + 90. The validateTrade checks if this new margin and leverage are acceptable. That's correct.

Potential issues with front-running in price oracles. The contract relies on getVerifiedPrice from tradingExtension, which presumably checks signed prices. If the price data can be manipulated, or if the signature is front-run, this could affect trade execution. But that's more about the oracle design than the contract itself.

In the executeLimitOrder function, the code checks if the current price is within the limitOrderPriceRange of the order's price. However, this is a percentage range. If the price has moved beyond that range, the order can't be executed. But if the limitOrderPriceRange is set too high, it could allow orders to be executed at unfavorable prices. However, this is controlled by the owner via setLimitOrderPriceRange.

In the _updateFunding function, the code calls position.updateFunding with parameters. If the longOi or shortOi is zero, this could cause division by zero in the funding calculation. But the pairsContract's OI should be initialized to prevent that. Or maybe the code in position.updateFunding handles it.

Another thing: the contract uses IStable(_tigAsset).mintFor in several places. If the mintFor function allows arbitrary minting (like a central minting authority), this could lead to inflation. But that depends on the implementation of IStable. If the Stable contract has proper access controls, this is okay. But if the Trading contract has the authority to mint unlimited tokens, that's a critical issue. For example, in _handleOpenFees, the code mints daoFeesPaid and referralFees, etc. So if the Stable contract's mintFor function is not restricted, this could be a problem. However, the code assumes that the Trading contract is allowed to mint those tokens, which is a design choice. If the Stable contract is a legitimate, controlled token, this is acceptable. Otherwise, it's a major vulnerability.

In summary, the vulnerabilities I can identify are:

1. Incorrect handling of decimal conversions in _handleDeposit leading to truncation and loss of funds.
2. Incorrect OI calculation in executeLimitOrder by using the original margin instead of the margin after fees.
3. Potential underflow in fee calculations if fee parameters are misconfigured.
4. Use of unverified external contract calls (e.g., to IStableVault) which could lead to unexpected behavior.
5. Possible reentrancy in external calls, though mitigated by allowedVault checks.
6. Average price calculation in addToPosition could be manipulated by miners/oracle.","```
1. Incorrect Decimal Handling Leading to Truncation
```",1.0,1
,,,,,,,,6,13,,,3,4,12,29,,,,1.3667