nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public orderbook;
    /// @dev nfthub instance, to query current card owner
    IRCNftHubL2 public nfthub;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev address of the Factory so only the Factory can add new markets
    address public override factoryAddress;
    /// @dev so only markets can use certain functions
    mapping(address => bool) public override isMarket;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public marketBalance;
    /// @dev a quick check if a uesr is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 marketBalanceDiscrepancy;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent any cards for specific market
    mapping(address => bool) public override marketPaused;

    /*╔═════════════════════════════════╗
      ║            UBER OWNER           ║
      ╚═════════════════════════════════╝*/
    /// @dev high level owner who can change the factory address
    address public override uberOwner;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1000000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /// @notice only allow markets to call these functions
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    /// @notice only allow orderbook to call these functions
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║           ADD MARKETS           ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can move funds from deposits to marketPots and vice versa
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyOwner
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental for a specific market
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add a user to the whitelist
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    /// @notice Add multiple users to the whitelist
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract (newRental) or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // stpe 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    /// @notice provides the sum total of a users bids accross all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                // they have enough funds, just collect the extra
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /// @dev called when all a user's bids have been removed, disables foreclosure state
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calcualtion and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calcualtes the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the amount of deposit a user is able to withdraw
    /// @notice ..after considering rent due to be paid
    /// @param _user the user to query
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)
            //                   = (deposit * 1day) / totalUserDailyRent
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                // calculate how long they can own the new card for
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            // if no rentals they'll foreclose after the heat death of the universe
            return type(uint256).max;
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepsitLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets availiable balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7143.0,761.0,"[H-01] Unchecked ERC20 transfers can cause lock up
Some major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.
This modifier is present on most functions, but is missing on topupMarketBalance:
In the case where an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, deposit, withdrawDeposit, payRent, payout, sponsor, etc. could be locked up and always failing with “Books are unbalanced”.
Anyone can call `topupMarketBalance` with some unrealistically large number, so that marketBalance does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but is returning “false” instead.   [H-04] Anyone can affect deposits of any user and turn the owner of the token
On RCTreasury, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp. So, calling this method using user = XXXXX and _timeToCollectTo = type(uint256).max), would make isForeclosed[user] = true.
  [M-01] payout doesn't fix isForeclosed state
The function `payout` of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.

 [M-02] Critical uberOwner address changes should be a two-step process
As specified, `uberOwners` of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.
The contracts allow for `uberOwners` to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.
  [M-03] Missing balancedBooks modifier could result in failed system insolvency detection
The `balancedBooks` modifier is used to “check that funds haven't gone missing during this function call” and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.
However, this modifier is missing in the `refundUser()` and topupMarketBalance() functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.
  [M-16] Deposits can be denied by abusing maxContractBalance
A whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.
Any users can be blocked from depositing which prevents them from renting cards. This allows an attacker to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards (causing forfeiture due to a low deposit balance).   [M-17] Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected
The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.
The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable timeLeftOfDeposit indicates the time left of deposit, starting from now. However, at line 672, the foreclosureTimeWithoutNewCard is calculated by timeLeftOfDeposit plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.",8.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";


contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    
    
    IRCOrderbook public orderbook;
    
    IRCNftHubL2 public nfthub;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    address public override factoryAddress;
    
    mapping(address => bool) public override isMarket;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 marketBalanceDiscrepancy;
   
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;


    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;


    address public override uberOwner;

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        uberOwner = msgSender();

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1000000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    

    
    modifier balancedBooks {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    

    
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    

    
    

    

    
    
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    

    
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            
            
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            
            return type(uint256).max;
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    
}",4101.0,2,5,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Deposit Check Leading to Incorrect Foreclosure Status**:
   - **Location**: `deposit` function.
   - **Issue**: After depositing, the contract checks `(user[_user].deposit + _amount) > (bidRate / divisor)` to un-foreclose a user. However, `user[_user].deposit` is already incremented by `_amount`, causing an over-check by effectively doubling `_amount`. This leads to incorrect foreclosure status updates.

2. **Malicious Markets Can Drain Approved Allowances via `sponsor` Function**:
   - **Location**: `sponsor` function.
   - **Issue**: Markets can call `sponsor` with any `_sponsor` address, allowing them to transfer tokens from any account that has approved the treasury. This bypasses user intent, enabling theft of funds from users who granted token approvals.

3. **Unvalidated Divisor in `setMinRental` Allows Division by Zero**:
   - **Location**: `setMinRental` function.
   - **Issue**: The function lacks a check to ensure the divisor is non-zero. If set to zero, critical divisions (e.g., in `withdrawDeposit` and foreclosure checks) will revert, disrupting contract functionality.

4. **Whitelist Functions Toggle Instead of Add**:
   - **Location**: `addToWhitelist` and `batchAddToWhitelist` functions.
   - **Issue**: These functions toggle user status instead of strictly adding them. This can accidentally remove users from the whitelist, undermining access control intentions.

5. **Unchecked Refund Amount in `refundUser`**:
   - **Location**: `refundUser` function.
   - **Issue**: The function does not validate `marketBalance >= _refund`, risking underflow if `_refund` exceeds `marketBalance`, causing transaction reverts and potential denial-of-service.

6. **Potential Division by Zero in Key Functions**:
   - **Locations**: `withdrawDeposit`, `foreclosureTimeUser`, and others.
   - **Issue**: Reliance on `minRentalDayDivisor` without validation allows division by zero if set to zero, crashing functions that depend on it.

7. **Inconsistent Whitelist Batch Processing**:
   - **Location**: `batchAddToWhitelist` function.
   - **Issue**: Iterating over a list and toggling each user's status can result in unintended removals, especially if the list includes already whitelisted users.

8. **Centralization Risks**:
   - **Locations**: Critical functions like `setFactoryAddress`, `setTokenAddress`, etc.
   - **Issue**: Over-reliance on privileged roles (`owner`/`uberOwner`) for core functionalities introduces risks if these accounts are compromised or act maliciously.

These vulnerabilities range from logic errors and access control flaws to input validation issues, each posing risks to the contract's integrity and user funds.","### **Output**

---

#### **[H-01] Unchecked ERC20 transfers can cause lock up**

**Report Description**:
The issue highlights the discrepancy in ERC20 token implementations, where some tokens return `true/false` instead of reverting on failure. This can lead to silent failures in token transfers, particularly in the `topupMarketBalance` function. If a malicious actor uses a non-reverting token, they can manipulate `marketBalance` to exceed actual holdings, causing functions like `deposit`, `withdrawDeposit`, `payRent`, `payout`, and `sponsor` to fail with ""Books are unbalanced."" This could lock up the system.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unchecked ERC20 transfers or the potential lock-up caused by non-reverting tokens. This is a critical oversight, as the issue directly impacts the contract's functionality and security.

---

#### **[H-04] Anyone can affect deposits of any user and turn the owner of the token**

**Report Description**:
The `collectRentUser` function in `RCTreasury` is public, allowing anyone to call it with arbitrary parameters. By setting `_timeToCollectTo` to `type(uint256).max`, an attacker can force `isForeclosed[user] = true` for any user, effectively foreclosing their account without proper authorization.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the public accessibility of `collectRentUser` or the potential for unauthorized foreclosure. This is a significant access control issue that is entirely missed.

---

#### **[M-01] payout doesn't fix isForeclosed state**

**Report Description**:
The `payout` function in `RCTreasury.sol` does not reset the `isForeclosed` state of a user after a payout. This is problematic because a user who receives funds should no longer be considered foreclosed. The failure to update this state could lead to incorrect foreclosure statuses.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the `isForeclosed` state not being reset in the `payout` function. This is a logical error that could lead to incorrect user statuses.

---

#### **[M-02] Critical uberOwner address changes should be a two-step process**

**Report Description**:
The `changeUberOwner` function allows the `uberOwner` to change the address to a new one without validation. If an incorrect address is used, the system could be permanently locked, as there is no way to recover the `uberOwner` role. This is a critical centralization risk.

**Match in Response List**:
**Partially Correct**. The response list mentions ""Centralization Risks"" in general but does not specifically address the lack of a two-step process for `uberOwner` address changes.

**Validation**:
**Partially Correct**. While the response list identifies centralization risks, it does not specifically address the need for a two-step process for `uberOwner` address changes, which is a critical detail.

---

#### **[M-03] Missing balancedBooks modifier could result in failed system insolvency detection**

**Report Description**:
The `balancedBooks` modifier is missing in the `refundUser()` and `topupMarketBalance()` functions, which perform actions that affect the Treasury's balances. This omission could lead to miscalculations and system insolvency, as these functions are not checked for balance consistency.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the missing `balancedBooks` modifier in `refundUser()` and `topupMarketBalance()`. This is a significant oversight that could lead to system insolvency.

---

#### **[M-16] Deposits can be denied by abusing maxContractBalance**

**Report Description**:
A whale can front-run a user's deposit by depositing enough funds to reach the `maxContractBalance` limit, causing the user's deposit to fail. The whale can then withdraw their funds, effectively blocking other users from depositing. This manipulation can be used to prevent competitors from renting cards, influencing market outcomes.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of deposit denial via `maxContractBalance` abuse. This is a significant denial-of-service vulnerability.

---

#### **[M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected**

**Report Description**:
The `foreclosureTimeUser` function in `RCTreasury` underestimates the user's foreclosure time due to an incorrect calculation. The rent between the last rent calculation time and the current time is counted twice, leading to a shorter foreclosure time. This could result in incorrect determinations of the new owner of a card.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the incorrect calculation in `foreclosureTimeUser`. This is a logical error that could lead to incorrect foreclosure determinations.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-02] Critical uberOwner address changes should be a two-step process**

**Missed Issues from Issue Report**:
- **[H-01] Unchecked ERC20 transfers can cause lock up**
- **[H-04] Anyone can affect deposits of any user and turn the owner of the token**
- **[M-01] payout doesn't fix isForeclosed state**
- **[M-03] Missing balancedBooks modifier could result in failed system insolvency detection**
- **[M-16] Deposits can be denied by abusing maxContractBalance**
- **[M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected**

---

### **Conclusion**
The response list fails to address the majority of the issues identified in the issue report. While it partially covers centralization risks, it misses critical vulnerabilities related to unchecked ERC20 transfers, access control, logical errors, and denial-of-service attacks. This indicates a significant gap in the response list's coverage and accuracy.",0,1,6,8,"Okay, I need to analyze this smart contract for vulnerabilities. Let's start by going through the code step by step.

First, the contract imports several OpenZeppelin libraries and other interfaces. It's using Ownable and NativeMetaTransaction. The main contract is RCTreasury, which implements IRCTreasury. The constructor initializes some parameters like the token address and sets the uberOwner.

Looking at the modifiers: there's a balancedBooks modifier that checks the ERC20 balance of the contract against totalDeposits, marketBalance, and totalMarketPots. If this check fails, it reverts. But wait, using the contract's actual balance can be manipulated because ERC20 balances can change outside the contract's control. For example, if someone sends tokens directly to the contract, the balance would increase, but the internal accounting (totalDeposits + marketBalance + totalMarketPots) might not reflect that. However, in the balancedBooks modifier, the check is that the ERC20 balance is >= the sum of these variables. If someone sends tokens directly, the balance would be higher than the sum, which passes the check. So maybe this isn't an issue. But if the sum exceeds the actual balance, that's a problem. Wait, the modifier requires that the ERC20 balance is greater or equal. So the contract's internal accounting assumes that the sum of deposits, market balance, etc., should not exceed the actual token balance. But if the sum is less than the actual balance, that's okay. So maybe this check is okay. But perhaps there's a scenario where the internal accounting doesn't match the actual balance, leading to a revert. For example, if the contract receives tokens without updating the internal variables (like someone transferring tokens directly), then the balance would be higher, but the check would still pass. But if tokens are removed without the contract's knowledge (e.g., via a transfer out not through the contract's functions), then the balance could be lower, causing the modifier to fail. So maybe this check is too strict and can cause unexpected reverts. But is that a vulnerability? It might be a design choice, but could lead to denial of service if the modifier is applied to key functions. Let's note this as a possible issue.

Next, the deposit function: it transfers tokens from the user to the contract. Then, it calls orderbook.removeOldBids(_user). But what if the orderbook address is not set yet? If orderbook is a zero address, this call would fail. But the setOrderbookAddress function can only be called by uberOwner, so maybe it's properly initialized. Still, if not set, deposit would fail. But that's probably a deployment issue rather than a vulnerability.

The withdrawDeposit function has a check that the user hasn't withdrawn too soon. The condition is that block.timestamp - lastRentalTime must be greater than (1 days) / minRentalDayDivisor. If minRentalDayDivisor is set to a very large value, this could allow withdrawals too quickly. For example, if minRentalDayDivisor is 24*6=144, then (1 days)/144 is 10 minutes. But if the divisor is set to a larger value, say 24*60=1440, then the time is 1 minute. But since the divisor is set by the owner, maybe this is acceptable. However, if the owner sets it to a very high value, users might not have enough time to react before their deposits are foreclosed. But that's more of a parameter setting issue rather than a code vulnerability.

Looking at the addToWhitelist function: it calls IRCFactory(factoryAddress).isGovernor(msgSender()). If the factoryAddress is not set, this would call a zero address, which would return false, causing the require to fail. So if factoryAddress is not set, adding to the whitelist is impossible. But this function is supposed to be called by governors, so the factoryAddress must be properly initialized. If the owner hasn't set the factory address, this could be a problem. But again, deployment setup.

In the collectRentUser function, there's a possible reentrancy? Let's see: it calls _increaseMarketBalance, which updates the user's deposit and marketBalance. Then emits an event. But since it's using the Checks-Effects-Interactions pattern, and there are no external calls here, maybe reentrancy isn't an issue. But wait, the _increaseMarketBalance function is internal and just adjusts state variables, so no external calls. So reentrancy might not be a problem here.

Another thing: the User struct uses uint128 for deposit, rentalRate, etc. If the ERC20 token has a higher precision (like 18 decimals), multiplying rentalRate (which is a daily rate) by time could exceed uint128. For example, if rentalRate is 1e24 (which is 1 million tokens with 18 decimals), then multiplying by 1 day (which is 86400 seconds) would be 1e24 * 86400 = 8.64e28, which is way larger than uint128's max value (3.4e38? Wait, no, uint128's max is 2^128-1 ≈ 3.4e38). Wait, 8.64e28 is less than 3.4e38, so maybe it's okay. But if rentalRate is higher, or time spans are longer, this could cause an overflow. However, the code uses SafeCast.toUint128 when assigning to these variables, which would revert on overflow. So maybe that's handled.

The updateRentalRate function is called by the orderbook. It adjusts rental rates for old and new owners. There's a part where if the _timeOwnershipChanged is less than user[_newOwner].lastRentCalc, it calculates additional rent owed. But if the orderbook is malicious or compromised, this could lead to incorrect rent calculations. However, the modifier onlyOrderbook ensures that only the orderbook can call this function. If the orderbook is a trusted contract, this is okay. But if the orderbook has a vulnerability, it could affect the treasury. But this is more of a dependency risk.

In the collectRentUser function, the code checks if rentOwedByUser > user[_user].deposit. If so, it sets rentOwedByUser to user[_user].deposit and marks the user as foreclosed. But what if rentOwedByUser is exactly equal to the deposit? Then the deposit becomes zero, but the user isn't foreclosed. Wait, no: if rentOwedByUser is equal to the deposit, then rentOwedByUser > user[_user].deposit would be false, so it would proceed to subtract rentOwedByUser from the deposit. If the deposit becomes zero, but the user's rentalRate is still non-zero, they would be foreclosed in the next check. Wait, the code in collectRentUser has a part where, after subtracting rentOwedByUser, if the deposit is zero and rentalRate is non-zero, maybe that's handled elsewhere. Hmm, need to check.

In the withdrawDeposit function, after collecting rent, the user's deposit is decreased. Then, if the user's bidRate is non-zero and the deposit is less than bidRate / minRentalDayDivisor, they are foreclosed. However, the check uses user[_msgSender].bidRate / minRentalDayDivisor. If minRentalDayDivisor is zero, this would cause a division by zero. But the constructor sets minRentalDayDivisor to 24*6=144, and the setMinRental function allows the owner to change it. If the owner sets it to zero, this would cause a division by zero in several places. However, setMinRental is only callable by the owner, so if the owner is malicious, they could do that. But since the owner is a privileged role, that's a centralization risk rather than a code vulnerability. However, the function should have a check to prevent setting the divisor to zero. Looking at the setMinRental function: it's public override onlyOwner, but there's no check that _newDivisor is non-zero. So if the owner sets it to zero, any division by minRentalDayDivisor would revert, breaking the contract. That's a possible vulnerability—lack of input validation in setMinRental.

Another issue: the User struct uses uint64 for lastRentCalc and lastRentalTime. These are timestamps, which in Solidity are uint256. However, casting them to uint64 could cause overflow in the future. For example, uint64 can hold up to 18,446,744,073,709,551,615, which as a timestamp (seconds since 1970) would be in the year 584 billion AD. So no, that's not an issue. But using smaller types here is safe.

In the sponsor function, the code transfers tokens from _sponsor to the contract. But the _sponsor is an input parameter, and msg.sender is the market (due to onlyMarkets modifier). The require checks that _sponsor has approved the contract to spend _amount. But if a market is malicious, it could specify any _sponsor and drain their funds if the allowance is set. For example, if a user approved the contract for a certain amount, a malicious market could call sponsor with that user's address and the approved amount, transferring the tokens into the market pot. This would allow the market to take tokens from any user who has approved the contract, even if they didn't intend to sponsor that market. So this is a vulnerability: the sponsor function allows markets to transfer tokens from any address that has granted approval to the treasury, not necessarily the market itself. The check is that erc20.allowance(_sponsor, address(this)) >= _amount, but this doesn't ensure that the msg.sender (the market) is authorized by the _sponsor. So any market can trigger a transfer from any _sponsor who has approved the treasury, leading to possible theft of funds.

Another vulnerability: in the deposit function, the user's deposit is increased before checking if they should be un-foreclosed. The code checks if (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor). However, the deposit is already increased by _amount before this check. Wait, no: the code first adds _amount to user[_user].deposit, then checks if the new deposit (after adding) is greater than bidRate / divisor. But if the user was foreclosed before, adding _amount might bring their deposit above the required threshold, and set isForeclosed to false. But the code says: (user[_user].deposit + _amount) > ... but wait, user[_user].deposit was already increased by _amount earlier. Because the code does user[_user].deposit += SafeCast... So after that line, user[_user].deposit is the new value. Therefore, the check should be user[_user].deposit > ... without adding _amount again. Wait, looking at the code:

user[_user].deposit += SafeCast.toUint128(_amount);
totalDeposits += _amount;
emit LogAdjustDeposit(_user, _amount, true);

// Check if the user's deposit is now sufficient
if (
    (user[_user].deposit + _amount) >
    (user[_user].bidRate / minRentalDayDivisor)
) {
    isForeclosed[_user] = false;
    emit LogUserForeclosed(_user, false);
}

Wait, no: after user[_user].deposit += _amount, the deposit is already increased. So the check adds _amount again, which would be incorrect. For example, if the user had 100 deposit, adds 50, making it 150. Then the check is 150 +50 (200) > X. But that's wrong. This is a bug. The intended check is whether the new deposit (150) is greater than bidRate / divisor. But the code checks (user.deposit + _amount) which is 150 +50 = 200. So this condition is incorrect, leading to a possible incorrect un-foreclosure. For example, if the required amount is 150, the user's new deposit is 150, but the code checks 150 +50 = 200 > 150, which is true, so un-foreclose. But the actual deposit is 150, which meets the requirement. However, if the required amount was 180, then 150 is less than 180, but the code would check 150 +50=200 >180, so un-foreclose, even though the deposit is only 150. Wait, that's not correct. The user's deposit after deposit is user.deposit = previous + _amount. The check should be user.deposit > (bidRate / divisor). But the code is checking (user.deposit + _amount) > ..., which is (previous + _amount + _amount) because user.deposit was already increased. So this is a logical error leading to incorrect un-foreclosure. This is a vulnerability because it can incorrectly mark a user as not foreclosed when they shouldn't be, or vice versa.

Another issue: in the withdrawDeposit function, after collecting rent, the code checks if the user's bidRate / divisor is greater than their deposit. However, if the divisor is zero, this would cause a division by zero. But as mentioned earlier, setMinRental can set divisor to zero if the owner is malicious. But in normal operation, the divisor is set to 144 in the constructor. However, if the owner changes it to zero, this would cause a revert here. But the owner is a trusted entity, so this is a centralization risk rather than a code flaw. However, the code should validate inputs to prevent setting the divisor to zero.

Looking at the payRent function: if marketBalance is less than _amount, the discrepancy is increased by the difference, and _amount is set to marketBalance. But then marketBalance is decremented by _amount, which would set it to zero. However, marketBalanceDiscrepancy is increased by (_amount - marketBalance), which could be incorrect. For example, if marketBalance is 100, and _amount is 150, then discrepancy += 50, and _amount becomes 100. Then marketBalance -= 100 (to 0). But marketBalanceDiscrepancy is now 50. Then, marketPot is increased by 100. But the discrepancy is supposed to track the amount that the marketBalance is short. However, in this case, the code allows the market to pay rent even if the marketBalance is insufficient, which could lead to accounting inconsistencies. But the comment says that this is to ""top up"" the market balance later. However, the exact handling of marketBalanceDiscrepancy needs to be checked. For example, if marketBalance is 100, and _amount is 150, then discrepancy becomes 50, and marketBalance becomes 0. Then, when someone calls topupMarketBalance with 50, discrepancy is reduced by 50 (to 0), and marketBalance increases by 50. So in total, the marketBalance would be 50, but the marketPot has already taken 100 (from the original payRent). So this could lead to underfunding the marketPot. This might be an accounting error. For example, the market is allowed to take more from the marketBalance than is available, leading to a discrepancy that needs to be covered by topup. But if not covered, the total ERC20 balance might not match the internal accounting. However, the balancedBooks modifier would catch this. Wait, the payRent function has the balancedBooks modifier. So after the function runs, the modifier checks that the ERC20 balance is >= totalDeposits + marketBalance + totalMarketPots. Let's see: after payRent, marketBalance is reduced by _amount (which was adjusted to marketBalance). So if marketBalance was 100 and _amount was 150, then marketBalance becomes 0. The discrepancy is increased by 50. marketPot is increased by 100, so totalMarketPots increases by 100. The ERC20 balance hasn't changed because payRent is just moving amounts between marketBalance and marketPot. But the modifier checks that the actual balance is >= totalDeposits + marketBalance + totalMarketPots. However, if there's a discrepancy (marketBalanceDiscrepancy), this isn't accounted for in the modifier. Wait, marketBalanceDiscrepancy is a separate variable. The balancedBooks check doesn't include marketBalanceDiscrepancy. So after payRent, the actual balance might be less than the sum, but the modifier would catch it. Wait, no. Let's take an example:

Suppose totalDeposits = 100, marketBalance = 100, totalMarketPots = 50. ERC20 balance is 250 (100 + 100 +50). Then payRent is called with _amount=150. Since marketBalance is 100, which is less than 150, discrepancy += 50, _amount becomes 100. Then marketBalance -=100 → 0. marketPot +=100 → totalMarketPots = 150. Now, totalDeposits (100) + marketBalance (0) + totalMarketPots (150) = 250. The actual ERC20 balance is still 250 (since no tokens were moved). So the balancedBooks check passes. The discrepancy is tracked separately. However, the problem arises when the marketBalance is insufficient to cover the rent, and the discrepancy is recorded. The topupMarketBalance function allows anyone to add funds to cover the discrepancy. But if the discrepancy isn't covered, the marketPot has more funds allocated than are available in marketBalance. Wait, no: when payRent is called, even if marketBalance is less than _amount, the code reduces marketBalance by the adjusted _amount (which is marketBalance) and adds that to marketPot. So in the example, after payRent, marketBalance is 0, and marketPot increased by 100. The discrepancy is 50. The topupMarketBalance function can be used to add 50, which reduces discrepancy to 0 and increases marketBalance by 50. So the system expects that someone will top up the discrepancy. If not, the marketPot has 150, but marketBalance is 0. The actual ERC20 balance would still be 250, which equals totalDeposits (100) + marketBalance (0) + totalMarketPots (150). So the balancedBooks check is satisfied. However, the marketPot's funds are now in the market's pot, but the marketBalance is zero. The discrepancy represents an amount that the market owes to the treasury, which needs to be topped up. If not, when other functions try to use marketBalance, they might find it insufficient. But the code allows this, as long as the topup is done later. This might be a design choice rather than a vulnerability, but it could lead to underfunded market pots if the discrepancy is not covered. However, since the balancedBooks check is still satisfied, maybe it's acceptable.

Another possible issue is reentrancy in functions that transfer ERC20 tokens. For example, in withdrawDeposit, after adjusting the user's deposit, the code transfers ERC20 tokens. Since ERC20 tokens can have callbacks (like ERC777), this could allow reentrancy attacks. However, the contract uses OpenZeppelin's SafeERC20 for transfers, but looking at the code, the imports don't include SafeERC20. The code directly calls erc20.transfer and erc20.transferFrom. If the token is malicious (like ERC777), a reentrancy attack could occur. For example, when transferring tokens to a user in withdrawDeposit, if the token's transfer function calls back into the contract, the state may not have been fully updated yet. However, in the withdrawDeposit function, the state changes (user deposit and totalDeposits) are done before the transfer, following Checks-Effects-Interactions. So even if reentrancy occurs, the state would already reflect the withdrawal, preventing double-spending. Let's check:

In withdrawDeposit:

1. Collect rent (internal call, updates user's deposit and marketBalance).
2. Adjust user's deposit and totalDeposits.
3. Emit event.
4. Transfer tokens (either via localWithdrawal or bridge).

The state changes (steps 2) are done before the external call (step 4), so reentrancy here should not affect the state. Therefore, even if the token is ERC777, the state is already updated, so reentrancy wouldn't allow an attacker to withdraw again. So this is safe.

Another potential issue is frontrunning. For example, when a user deposits, the orderbook.removeOldBids(_user) is called. If the orderbook's removeOldBids function is susceptible to frontrunning, but that's outside the scope of this contract.

The user struct uses uint128 for deposit and rentalRate, but if the ERC20 token has a high supply, these could overflow. For example, if a user deposits more than 2^128-1 tokens (which is a very large number, around 3.4e38), it would cause an overflow. However, using SafeCast.toUint128 would revert in such cases. Since the contract uses SafeCast, this is handled.

In the setBridgeAddress function, it approves the new bridge to spend an unlimited amount of tokens. If the bridge is compromised, it could drain the contract's tokens. However, this function can only be called by the uberOwner. If the uberOwner is trusted, this is acceptable. But if the bridge is upgraded to a malicious address, it's a risk. However, this is a centralization risk rather than a code vulnerability.

In the collectRentUser function, there's a possible division by zero if the rentalRate is zero. For example, if a user has rentalRate = 0, then in rentOwedUser, the calculation is (rentalRate * timeDelta) / 1 days. If rentalRate is zero, rentOwed is zero. So division by zero isn't an issue here.

Another point: the User struct's lastRentCalc is initialized to zero. When a user first interacts, their lastRentCalc is set. But in collectRentUser, if lastRentCalc is zero (uninitialized), _timeToCollectTo could be a future time, leading to a large rentOwed. However, the code checks if lastRentCalc < _timeToCollectTo. If lastRentCalc is zero, this would be true. For a new user, their rentalRate would be zero, so rentOwed would be zero. So no problem. If a new user has rentalRate > 0 but lastRentCalc is zero, then rentOwed would be (rate * timeDelta) / 1 days, but timeDelta would be from zero to _timeToCollectTo. But if the user's rentalRate is set before their lastRentCalc is initialized, that could be an issue. However, the code in updateRentalRate (called when a user gains a rental) sets lastRentCalc if it's zero. For example, in updateRentalRate, when the new owner's lastRentCalc is zero, it sets it to _timeOwnershipChanged. So that should prevent rent from being calculated from time zero.

In the refundUser function, marketBalance is decreased by _refund, but there's no check that marketBalance >= _refund. If _refund is greater than marketBalance, this would underflow, causing a revert. But the function is only called by markets (onlyMarkets modifier), and presumably, the market would ensure that the refund is valid. However, if a malicious market calls refundUser with a larger _refund than marketBalance, it would cause an underflow and revert. So perhaps the function should have a require(marketBalance >= _refund) to prevent this. Otherwise, it's possible for a market to intentionally or accidentally cause a revert here.

Another issue: the addToWhitelist function toggles the isAllowed status of a user. So each call flips the value. However, the function's name suggests it's supposed to add a user to the whitelist, not toggle. If a governor accidentally calls addToWhitelist on a user who is already allowed, it would remove them from the whitelist. This could lead to unintended behavior. For example, a governor intending to add a user might actually remove them if they were already on the list. The function's name is misleading and the functionality is a toggle instead of strictly adding. This is a potential vulnerability as it could lead to incorrect whitelist management.

The batchAddToWhitelist function loops through an array and calls addToWhitelist for each user. Since addToWhitelist toggles the status, batch adding could result in some users being added and others being removed, depending on their initial state. This is likely unintended and could lead to a compromised whitelist state if not used carefully.

In the updateRentalRate function, when _timeOwnershipChanged is less than the new owner's lastRentCalc, the code calculates additional rent owed between block.timestamp and _timeOwnershipChanged. However, block.timestamp could be after _timeOwnershipChanged, leading to negative time delta. But the code swaps _time1 and _time2 if necessary. Wait, in rentOwedBetweenTimestmaps, if _time1 < _time2, they are swapped. So the delta is always positive. So that's handled.

In the foreclosureTimeUser function, the code has complex calculations involving time and rates. Potential for integer underflow or overflow, but since Solidity 0.8.x has checked math, any overflow would revert, which is safe.

Another possible issue: the marketBalanceDiscrepancy variable is not used in any important checks except in topupMarketBalance. If the discrepancy isn't tracked properly, it could lead to incorrect accounting. But the code in payRent and topupMarketBalance seems to handle it correctly.

Summary of potential vulnerabilities:

1. **Incorrect Deposit Check in deposit Function**: The deposit function incorrectly checks (user[_user].deposit + _amount) after already adding _amount to the user's deposit. This leads to an incorrect calculation when determining if the user should be un-foreclosed. The check should use user[_user].deposit (after the addition) instead of adding _amount again.

2. **Sponsor Function Allows Theft of Allowances**: The sponsor function allows a market to transfer tokens from any address that has approved the treasury, not just the market itself. This could allow malicious markets to drain user funds that have granted approval to the treasury.

3. **Missing Input Validation in setMinRental**: The setMinRental function does not check that the divisor is non-zero, allowing the owner to set it to zero, which would cause division by zero errors in several parts of the code.

4. **Whitelist Toggle Instead of Add**: The addToWhitelist and batchAddToWhitelist functions toggle the user's status instead of strictly adding them, leading to potential accidental removal of users from the whitelist.

5. **Unchecked Refund in refundUser**: The refundUser function does not check that marketBalance >= _refund, which could lead to underflow and revert if _refund exceeds marketBalance.

6. **Division by Zero in withdrawDeposit and Other Functions**: If minRentalDayDivisor is set to zero, several divisions would fail, but this requires owner action. However, the lack of input validation allows this.

7. **Incorrect Handling of marketBalanceDiscrepancy**: The payRent function adjusts marketBalanceDiscrepancy and marketBalance in a way that might not correctly account for owed funds, but this is mitigated by the balancedBooks modifier.

8. **Centralization Risks**: Functions like setMinRental, setMaxContractBalance, and others are controlled by the owner or uberOwner, introducing centralization risks, but these are not code vulnerabilities per se.

These are the main vulnerabilities found. The most critical ones are points 1, 2, 3, 4, and 5."
RCMarket.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",10267.0,1122.0,"[H-02] Can access cards of other markets
Within `RCMarket.sol` the functions ownerOf and `onlyTokenOwner` do not check if the `_cardId/_token` is smaller than `numberOfCards`. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for `isMarketApproved` can be circumvented by trying to move the card via another market.
You can still only move cards you own.
``` // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards
        return nfthub.ownerOf(_tokenId);
    }

https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313
  modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner""); // _token could be higher than numberOfCards,
        _;
    }

function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,
    _checkState(States.WITHDRAW);
    require(
        !factory.trapIfUnapproved() ||
            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market
        ""Upgrade blocked""
    );
    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market
    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
    nfthub.withdrawWithMetadata(_tokenId);
    emit LogNftUpgraded(_card, _tokenId);
} ```   [H-03] anyone can call function sponsor

Submitted by paulius.eth, also found by 0xRajeev, cmichel, and shw
This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:
```     /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }
``   [M-07] maxSumOfPrices check is broken
`rentAllCards()` requires the sender to specify a `_maxSumOfPrices` parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.
However, this function parameter constraint for `_maxSumOfPrices` is broken in the function implementation which leads to the total number of bids placed greater than the _maxSumOfPrices specified.
The impact of this is that the user may not have sufficient deposited, be foreclosed upon and/or impacted on other bids/markets.
  [M-13] Wrong calculation on `_collectRentAction`
The method _collectRentAction contains the following code:
in case 6, it is doing: ```
_refundTime = block.timestamp - marketLockingTime;
```
instead of: ```
_refundTime = _timeUserForeclosed - marketLockingTime;
```",3.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";


contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {

    
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    
    bool public constant override isMarket = true;
    
    
    uint256 public totalNftMintCount;

    
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    
    
    mapping(uint256 => uint256) public cardPrice;
    
    mapping(address => uint256) public rentCollectedPerUser;
    
    mapping(uint256 => uint256) public rentCollectedPerCard;
    
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    
    uint256 public totalRentCollected;
    
    mapping(address => uint256) public exitedTimestamp;

    
    
    
    uint256 public minimumPriceIncreasePercent;
    
    uint256 public minRentalDayDivisor;
    
    uint256 public maxRentIterations;

    
    
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    
    mapping(uint256 => uint256) public totalTimeHeld;
    
    mapping(uint256 => uint256) public timeLastCollected;
    
    mapping(uint256 => uint256) public longestTimeHeld;
    
    mapping(uint256 => address) public longestOwner;
    
    mapping(uint256 => uint256) public cardTimeLimit;

    
    
    uint32 public marketOpeningTime;
    
    uint32 public override marketLockingTime;
    
    
    uint32 public oracleResolutionTime;

    
    uint256 public winningOutcome;
    
    mapping(address => bool) public userAlreadyWithdrawn;
    
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; 
    
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    
    uint256 public winnerCut;
    
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    

    
    
    
    
    
    
    
    
    
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        
        winningOutcome = MAX_UINT256; 

        
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        
        
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    

    
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    

    
    
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); 
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    
    
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    
    
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    

    
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    
    
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        
        setWinner(uint256(_winningOutcome));
    }

    
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    

    
    
    
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    
    
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    
    
    
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    
    function _returnRent() internal {
        
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    
    
    
    

    
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    
    
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    

    

    
    
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    
    
    function rentAllCards(uint256 _maxSumOfPrices) external {
        
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    
    
    
    
    
    
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    
    
    
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    
    
    
    
    
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        
        exitedTimestamp[_msgSender] = block.timestamp;

        
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    
    
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    
    
    
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    

    
    
    
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        
        
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            
            bool _newOwner;
            uint256 _refundTime; 

            

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                
                
                
                
                
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < marketLockingTime) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                
                
                
                
                
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); 

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            
            
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    
    
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    

    
    
    
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    
}",6724.0,2,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Use of `assert` for Input Validation**  
   - **Location**: `initialize` function  
   - **Issue**: The line `assert(_mode <= 2);` uses `assert` for input validation. `assert` should be reserved for invariants, as it consumes all gas on failure. This should be replaced with `require` to properly handle user-input validation.

2. **Division Truncation Leading to Precision Loss**  
   - **Location**: `_processRentCollection` and `_collectRentAction` functions  
   - **Issue**: Rent calculations use integer division (`/ 1 days`), which truncates remainders. This results in small inaccuracies where users may lose fractional amounts of owed funds.

3. **Circuit Breaker State Transition Vulnerability**  
   - **Location**: `circuitBreaker` function  
   - **Issue**: If `circuitBreaker` is called when the contract is already in the `WITHDRAW` state, `_incrementState()` will trigger an `assert` failure (since `state` would be `3`, violating `assert(uint256(state) < 4)`). This could lock the contract permanently and consume all transaction gas.

4. **Potential Division by Zero in `sponsor` Function**  
   - **Location**: `sponsor` function  
   - **Issue**: The line `rentCollectedPerCard[i] += (_amount / numberOfCards);` could revert if `numberOfCards` is zero. While the factory likely prevents this, improper initialization could lead to a critical division-by-zero error.

5. **Unhandled Winning Outcome in `withdraw` Function**  
   - **Issue**: If the contract enters the `WITHDRAW` state without a valid `winningOutcome` (e.g., via `circuitBreaker`), users can claim rent refunds even in `WINNER_TAKES_ALL` mode. This may bypass intended winner-centric payout logic.

6. **Longest Owner Tracking in Case of Ties**  
   - **Issue**: If two users hold a card for the same maximum duration, the last user to trigger rent collection is recorded as the `longestOwner`, potentially leading to disputes over fairness.

7. **Reliance on `block.timestamp` for Time Calculations**  
   - **Issue**: Rent calculations depend on `block.timestamp`, which miners can manipulate slightly. While minor, this could affect time-sensitive operations.

8. **Insecure Upgrade Mechanism in `upgradeCard`**  
   - **Location**: `upgradeCard` function  
   - **Issue**: The function relies on an external `nfthub` contract for NFT transfers. If `nfthub` is compromised, unauthorized upgrades or transfers could occur.","### **[H-02] Can access cards of other markets**

**Report Description**:  
In `RCMarket.sol`, the functions `ownerOf` and `onlyTokenOwner` do not validate whether the `_cardId` or `_token` is within the bounds of `numberOfCards`. This allows users to supply a larger number and access cards from other markets. The most critical issue is in the `upgradeCard` function, where the check for `isMarketApproved` can be circumvented by calling the function via another market. While users can only move cards they own, this vulnerability could lead to unauthorized access and manipulation of cards across markets.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of accessing cards from other markets due to missing bounds checks in `ownerOf` and `onlyTokenOwner`. The vulnerability is entirely missed, and no corresponding solution or identification is provided.

---

### **[H-03] Anyone can call function `sponsor`**

**Report Description**:  
The `sponsor` function in `RCMarket.sol` lacks access control and can be called by anyone. This allows arbitrary users to transfer tokens from a `_sponsorAddress` if the allowance is greater than zero. The function is intended to be called only by the factory during market creation, but the absence of access control introduces a significant security risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not identify the lack of access control in the `sponsor` function. This critical vulnerability is entirely missed, and no corresponding solution or identification is provided.

---

### **[M-07] `maxSumOfPrices` check is broken**

**Report Description**:  
The `rentAllCards` function includes a `_maxSumOfPrices` parameter intended to limit the sum of bids placed, providing front-run protection. However, the implementation fails to enforce this constraint, allowing the total bids to exceed the specified limit. This could lead to insufficient funds, foreclosure, or impacts on other bids/markets.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the broken `maxSumOfPrices` check in the `rentAllCards` function. This vulnerability is entirely missed, and no corresponding solution or identification is provided.

---

### **[M-13] Wrong calculation on `_collectRentAction`**

**Report Description**:  
In the `_collectRentAction` function, the calculation for `_refundTime` is incorrect. The code uses `block.timestamp - marketLockingTime` instead of `_timeUserForeclosed - marketLockingTime`. This error could lead to incorrect rent calculations and unfair refunds.

**Match in Response List**:  
**Partially Correct**. The response list identifies precision loss in rent calculations due to integer division but does not specifically address the incorrect `_refundTime` calculation in `_collectRentAction`.

**Validation**:  
**Partially Correct**. The response partially covers the issue by mentioning precision loss in rent calculations but misses the specific error in the `_refundTime` calculation. The core issue is not fully addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-13] Wrong calculation on `_collectRentAction`**

**Missed Issues from Issue Report**:  
- **[H-02] Can access cards of other markets**  
- **[H-03] Anyone can call function `sponsor`**  
- **[M-07] `maxSumOfPrices` check is broken**  

---

### **Conclusion**  
The response list fails to address the majority of the issues in the issue report. Only one issue is partially covered, while the rest are entirely missed. This indicates significant gaps in the identification and resolution of critical vulnerabilities in the smart contract.",0,1,3,8,"Okay, I need to analyze this smart contract for vulnerabilities. Let's start by reading through the code carefully.

First, looking at the pragma version. It's using 0.8.4, which is good because it's a newer version with built-in overflow checks. That might prevent some common issues, but not all.

The contract imports several OpenZeppelin contracts, including Initializable and SafeCast. It also uses some interfaces and other libraries. Let me check if any of the imports are outdated or have known vulnerabilities. The OpenZeppelin versions here seem okay, but I need to confirm if the specific versions used here are safe.

Looking at the state variables. There's a mapping for cardPrice, rent collected per user, etc. Some variables are public, so I should check if any sensitive data is exposed that shouldn't be. But since they are part of the contract's design, maybe that's intended.

The initialize function is using the initializer modifier from Initializable. That's correct for upgradeable contracts. But they're using assert() in the initialize function: `assert(_mode <= 2);`. Wait, in Solidity, assert is used for invariants and consumes all gas if failed, whereas require is for valid inputs. Here, if _mode is greater than 2, the contract will revert, but since the user can input _mode, maybe this should be a require statement instead of assert. Because assert is meant for internal errors, not input validation. So this could be a vulnerability. If the _mode is invalid, the transaction would revert, but using assert here is not appropriate and could lead to gas exhaustion in case of failure. That's a potential issue.

Another thing in initialize: they set the factory as IRCFactory(msgSender()). But since this is an upgradeable contract, using msg.sender here is okay because the proxy would delegate the call, and msgSender() from NativeMetaTransaction might be using _msgSender(), which could be overridden. Wait, the contract inherits NativeMetaTransaction, which uses _msgSender(). So in the context of meta transactions, msgSender() might not be the actual deployer. But in the initialize function, which is called via the proxy's constructor, maybe it's okay. But need to make sure that the initializer is only called once. Since they're using the initializer modifier, that's handled.

In the payCardAffiliate function, they have a loop that checks if the cardAffiliateAddresses length matches the number of cards. If not, cardAffiliateCut is set to 0. But in the initialize function, they have a check: if the cardAffiliateAddresses length is equal to _numberOfCards, otherwise set cardAffiliateCut to 0. However, in payCardAffiliate, when accessing cardAffiliateAddresses[_card], if cardAffiliateAddresses is shorter than _card, this would cause an out-of-bounds access. For example, if cardAffiliateAddresses has 2 entries, but _card is 3. That would revert. So maybe there's an issue here. But since in initialize, they set cardAffiliateCut to 0 if the lengths don't match, so cardAffiliatePayment would be zero in that case, and maybe cardAffiliateAddresses is only set if the lengths match. But if somehow a card is processed where the cardAffiliateAddresses doesn't have an entry for that card, this would fail. Wait, in initialize, if _cardAffiliateAddresses.length != _numberOfCards, then cardAffiliateCut is set to zero. So when paying card affiliates, even if a card is called, if the cut is zero, the payment would be zero and the function would not try to access the array. But if cardAffiliateCut is non-zero, then the array must have entries for all cards. So maybe this is safe. Hmm, not sure. Maybe a problem if someone calls payCardAffiliate for a card that doesn't have an affiliate address. But in the code, if cardAffiliateCut is zero, then _cardAffiliatePayment would be zero, so the payout would not occur. But if cardAffiliateCut is non-zero, then the array must have entries for all cards. So maybe this is handled correctly. Not a vulnerability here.

Looking at the transferCard function: it's called by the orderbook. The function transfers the card and sets the price and time limit. But there's no check on _price. For example, is _price allowed to be lower than the current price? But since the orderbook is responsible for this, maybe that's handled there. But in the newRental function, there's a check for price increase. So perhaps the orderbook ensures that the price is valid. But if the orderbook is compromised, this could be a problem, but that's outside the scope.

In the newRental function, there's a check for _newPrice >= MIN_RENTAL_VALUE. That's good. But also, the code checks if the user is the current owner, and if so, requires the new price to be >= the required price increase (minimumPriceIncreasePercent). But in the code, if the user is the owner, the newPrice must be >= (currentPrice * (minimumPriceIncrease + 100)) / 100 OR newPrice < currentPrice. Wait, the code has: require( _newPrice >= _requiredPrice || _newPrice < cardPrice[_card], ""Invalid price"" ); So if the user is the owner, they can either increase the price by the required percent or set it lower. But why would an owner lower their own price? That might be a mistake. For example, the owner could lower the price, but the code allows it. That could be a potential issue if the owner accidentally lowers the price, but it's part of the design. Not a vulnerability, but a possible logic flaw. However, according to the code's logic, when you are the owner, you can only lower the price (newPrice < currentPrice) or increase it by at least the minimum. So maybe that's intentional. But why would the owner want to lower the price? Maybe that's allowed for some reason. Not sure if that's a vulnerability.

Another thing in newRental: the code calculates _userTotalBidRate as treasury.userTotalBids(_user) minus orderbook.getBidValue(_user, _card) plus _newPrice. Then checks if the user's deposit is >= _userTotalBidRate / minRentalDayDivisor. The idea is to ensure the user has enough deposit for all their bids. But if the orderbook.getBidValue returns the correct previous value for the card. For example, if the user had a previous bid on the same card, subtracting it and adding the new price. That seems correct. But if there's a mistake in the orderbook's getBidValue, this could allow users to bid without sufficient deposit. But assuming orderbook is implemented correctly, this is okay.

In the _collectRentAction function, there's a complex logic to determine _timeOfCollection and whether to find a new owner. This function handles various cases like foreclosure, time limits, and market locking. The refund time is calculated, and the user is refunded for any overpaid time. However, division is used in calculating _refundAmount: (_refundTime * cardPrice[_card]) / 1 days. Since Solidity truncates division, this could lead to rounding errors where the user is refunded slightly less than the actual owed amount. Similarly, in _processRentCollection, the rent owed is calculated with division. This is a common issue, but the impact depends on how the protocol handles fractions. If the protocol is okay with truncating, maybe it's acceptable. However, if the amounts are significant, users might lose small fractions of funds. This is a potential vulnerability in terms of precision loss.

In the _processRentCollection function, they update the longestOwner if the user's time held is the longest. But what if two users have the same longest time? The last one to collect would overwrite the longestOwner. This could be an issue if there's a tie. For example, two users hold the card for the same maximum time, but the later one becomes the longestOwner. Depending on the protocol's requirements, this could be a problem. But the code's logic is to track the maximum, so the latest user with the maximum time becomes the longest owner. Not a security issue, but a potential fairness concern.

In the circuitBreaker function, they increment the state to WITHDRAW after 12 weeks from oracleResolutionTime. This allows the contract to be unlocked if the oracle doesn't resolve. But there's a check if block.timestamp > oracleResolutionTime + 12 weeks. However, if oracleResolutionTime is not properly set, this could allow the circuit breaker to be activated too early or too late. Also, the function sets orderbook.closeMarket() and state to WITHDRAW. But after calling _incrementState(), which already increments the state, they then set state to WITHDRAW. Wait, the code has:

_incrementState();
orderbook.closeMarket();
state = States.WITHDRAW;

The _incrementState() function increases the state by 1. So if the current state is LOCKED (3), then incrementing would make it 4 (which is beyond the enum's range if States only has up to WITHDRAW). Wait, looking at the States enum: the contract defines States as part of IRCMarket, but in the code, the States enum is declared as:

enum States {CLOSED, OPEN, LOCKED, WITHDRAW}

So CLOSED is 0, OPEN 1, LOCKED 2, WITHDRAW 3. The circuitBreaker function can be called when the state is not LOCKED or WITHDRAW? The code says:

function circuitBreaker() external {
    require(
        block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
        ""Too early""
    );
    _incrementState();
    orderbook.closeMarket();
    state = States.WITHDRAW;
}

But _incrementState() increases the state by 1. Suppose the current state is OPEN (1). Incrementing would make it LOCKED (2), then setting to WITHDRAW (3). But if the state is already LOCKED (2), _incrementState() would set it to WITHDRAW (3). Then, setting to WITHDRAW again is redundant. However, in the require statement, it's possible that this function can be called in any state as long as the timestamp is correct. But after incrementing the state, setting it to WITHDRAW might bypass some checks. Also, if the state is already WITHDRAW, the _incrementState() would cause a revert because States has only 4 values (0-3). For example, if state is WITHDRAW (3), incrementing would try to set it to 4, which is invalid. However, the circuitBreaker function can only be called if block.timestamp is 12 weeks after oracleResolutionTime. If the state is already WITHDRAW, calling this function would first check the timestamp, then call _incrementState(), which would try to set state to 4, which would cause an assertion failure (since assert(3 < 4) would fail). So this is a potential vulnerability because if the state is WITHDRAW, the contract would revert, causing the circuitBreaker function to fail. Also, using assert here could be problematic. Wait, in the _incrementState() function:

function _incrementState() internal {
    assert(uint256(state) < 4);
    state = States(uint256(state) + (1));
    emit LogStateChange(uint256(state));
}

The assert checks that the current state is less than 4. But States are 0 to 3. So if state is 3 (WITHDRAW), the assert would fail, consuming all gas. So if circuitBreaker is called when the state is already WITHDRAW, this would cause the transaction to revert with an assert failure, which is a critical issue. So the circuitBreaker function has a possible bug here. It should check the current state before incrementing. So this is a vulnerability.

Another issue: in the withdraw function, after checking the state is WITHDRAW and the user hasn't withdrawn yet, the code checks if totalTimeHeld[winningOutcome] > 0. If so, calls _payoutWinnings, else _returnRent. But what if winningOutcome is not set yet? If the contract is in WITHDRAW state but winningOutcome is still MAX_UINT256 (which is initialized as that), then totalTimeHeld[winningOutcome] would refer to a non-existing card. For example, if winningOutcome is MAX_UINT256 (2^256-1), and numberOfCards is, say, 10, then totalTimeHeld[MAX_UINT256] is zero. So the code would proceed to _returnRent. But if the mode is WINNER_TAKES_ALL, but the winning outcome is not set, this could allow users to withdraw their rent even though the winner should take all. But how does the winningOutcome get set? It's set via setWinner, which is called either by getWinnerFromOracle or setAmicableResolution. If the contract is in WITHDRAW state, but the winningOutcome hasn't been set (e.g., the oracle hasn't resolved, and the circuitBreaker was called), then the withdraw function would trigger _returnRent. But in WINNER_TAKES_ALL mode, maybe that's not intended. So this could be a vulnerability where, in some cases, users can withdraw their rent even if the contract was supposed to be winner-takes-all. For example, if the market is closed via circuit breaker without resolving the oracle, the winningOutcome remains MAX_UINT256, so totalTimeHeld[winningOutcome] is zero, and users can get their rent back. But maybe that's intentional as part of the circuit breaker functionality. However, if the mode is WINNER_TAKES_ALL and the contract is in WITHDRAW state without a winner, this could lead to an incorrect distribution. Not sure if this is a vulnerability or by design.

In the sponsor function, which allows adding funds to the rent pool, there's a line where they divide _amount by numberOfCards and add it to each card's rentCollectedPerCard. But if numberOfCards is zero, this would cause a division by zero. However, the initialize function has a parameter _numberOfCards, and sets numberOfCards = _numberOfCards. So if during initialization, _numberOfCards is zero, then this could be a problem. But the initialize function is called by the factory, and presumably the factory ensures that _numberOfCards is non-zero. However, if the factory allows creating a market with zero cards, this would be a division by zero in sponsor. So this is a potential vulnerability if the factory doesn't validate _numberOfCards. But since the code here uses IRCFactory, maybe the factory contract ensures that _numberOfCards is positive. If not, this is a critical issue.

In the _postQuestionToOracle function, they call realitio.askQuestion with 2 as the template ID. The parameters seem okay, but if the Realitio contract has changed or uses a different template, this could affect the functionality. But since it's using a factory's getOracleSettings, maybe that's handled externally. Not a direct vulnerability in this contract.

Reentrancy: looking for external calls that could lead to reentrancy. The _payout function calls treasury.payout, which is an external contract call. Since this happens after state changes (userAlreadyWithdrawn is set to true before the call), it's following the checks-effects-interactions pattern. So reentrancy here is mitigated. Similarly, in _processStakeholderPayment, the payout is after updating the paid flags. So reentrancy seems handled.

In the exit function, after collecting rent, they call orderbook.findNewOwner. If findNewOwner makes an external call, could that lead to reentrancy? For example, if findNewOwner calls back into the contract. But the exit function is called during the OPEN state, and the state is changed only when locking. So possible reentrancy here? Not sure, but the code doesn't use any reentrancy guards. If orderbook.findNewOwner can call back into the contract, this could be an issue. For example, during the transferCard, which calls nfthub.transferNft. If transferNft is a callback, maybe. But without knowing the implementation of nfthub, it's hard to say. But in general, external calls should be considered potential reentrancy points. However, since the state is checked before proceeding, maybe it's safe. But this is a possible area to check.

Another potential issue is the use of block.timestamp, which can be manipulated by miners to some extent. However, in the context of days-long rentals, minor manipulation might not be significant. But functions relying on time calculations should be aware.

In the setAmicableResolution function, only the factory owner can call it. So if the factory owner is malicious or compromised, they can set the winning outcome arbitrarily. But this is a trusted role, so it's a centralization risk, not a vulnerability in the code itself.

The upgradeCard function allows the token owner to upgrade the card. It checks if the factory is approved. But if the factory is compromised, this could allow unauthorized upgrades. But again, this is a trusted component.

In the _transferCard function, they use nfthub.transferNft. If transferNft is not implemented correctly, it could lead to issues like improper ownership transfers. But again, depends on the external contract.

Possible front-running in newRental: when a user submits a new rental, someone could front-run the transaction to change the price or take ownership. But this is a common issue in decentralized markets and is typically handled by the orderbook logic. Not a code vulnerability per se.

Now, compiling the list of potential vulnerabilities:

1. Use of assert() for input validation in initialize function: The line `assert(_mode <= 2);` should be a require statement. Using assert here would consume all gas if the condition fails, which is unnecessary and a deviation from best practices.

2. Division truncation in rent calculations: In multiple places, divisions are performed which truncate decimal values, leading to potential loss of precision. For example, in _processRentCollection and _collectRentAction, rent is calculated as (price * time) / 1 days. This can result in small amounts being lost due to integer division.

3. Circuit breaker state transition vulnerability: The circuitBreaker function increments the state and then explicitly sets it to WITHDRAW, which could cause an assertion failure if the state was already at WITHDRAW (3). The _incrementState() function uses an assert which would fail if the state is already 3 (WITHDRAW), leading to a revert and potential gas exhaustion.

4. Potential division by zero in sponsor function: If numberOfCards is zero, the division _amount / numberOfCards would revert. However, the initialize function sets numberOfCards from the input parameter, which should be validated by the factory. If the factory allows creating a market with zero cards, this would be a critical issue.

5. Incorrect winner handling in withdraw function: If the contract is in WITHDRAW state without a valid winningOutcome (e.g., MAX_UINT256), users can call withdraw and receive rent returns even in modes where a winner should take all. This might be by design in the circuit breaker case but could lead to unexpected behavior.

6. Longest owner tracking in ties: If two users have the same maximum time held, the last one to collect rent would be marked as the longest owner, which might not be intended and could lead to disputes.

7. Use of block.timestamp: While not a critical vulnerability, reliance on block.timestamp for critical time calculations can be slightly manipulated by miners, affecting rent calculations.

Other possible issues:

- In the setAmicableResolution function, the factory owner has the power to set the outcome, which is a centralization risk.

- The newRental function allows the current owner to decrease the price, which could be a design choice but might lead to unintended behavior.

Now, from the list, the most critical vulnerabilities are:

1. Incorrect use of assert in initialize.

3. Circuit breaker's state increment leading to assertion failure.

4. Division by zero in sponsor if numberOfCards is zero (if factory allows it).

5. Possible incorrect distribution in withdraw if winner is not set.

Other issues like truncation are more about precision loss and may be considered minor depending on context.

So compiling the final list of vulnerabilities to report."
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    //≡≡≡≡≡≡≡ CONTRACT VARIABLES ≡≡≡≡≡≡≡//
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    ///// CONTRACT ADDRESSES /////
    /// @dev reference contract
    address public referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms iniital pot
    uint256 public sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public maximumDuration;
    /// @dev list of governors
    mapping(address => bool) public governors;
    /// @dev if false, anyone can create markets
    bool public marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public approvedAffilliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public approvedArtistsOnly = true;
    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity
    bool public override trapIfUnapproved = true;
    /// @dev high level owner who can change the factory address
    address public uberOwner;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the address of the arbitrator
    address public arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public timeout;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;
    /// @dev allows artist to receive cut of total rent
    mapping(address => bool) public isArtistApproved;
    /// @dev allows affiliate to receive cut of total rent
    mapping(address => bool) public isAffiliateApproved;
    /// @dev allows card affiliate to receive cut of total rent
    mapping(address => bool) public isCardAffiliateApproved;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public nftMintingLimit;

    ///// OTHER /////
    /// @dev counts the total NFTs minted across all events
    /// @dev ... so the appropriate token id is used when upgrading to mainnet
    uint256 public totalNftMintCount;

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    /// @dev Treasury must be deployed before Factory
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise contract variable
        treasury = _treasuryAddress;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setminimumPriceIncreasePercent(10); // 10%
        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted
        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @dev include the owner as a governor
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - OWNER (SETUP)  ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier

    /// @notice where the NFTs live
    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but
    /// @dev ... keeping flexible in case returning to previous contract
    /// @param _newAddress the address to set
    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newAddress the address to set
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in basis points (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _mintLimit the limit to set
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    /// @notice if true, Cards in unapproved markets can't be upgraded
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    /// @notice market closing time must be no more than this many seconds in the future
    /// @param _newMaximumDuration the duration limit to set in seconds
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    /// @notice to fetch the owner of the contract
    /// @dev used to specifiy the Ownable contract instead of the interface
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    /// @notice check if an address is a governor
    /// @param _user the address to query
    /// @return boolean return if true or false
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    // EDIT GOVERNORS

    /// @notice add or remove an address from market creator whitelist
    /// @param _governor the address to change approval for
    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        // check it's an RC contract
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /// @notice artistAddress, passed in createMarket, must be approved
    /// @param _artist the artist address to change approval for
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    /// @notice affiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the affiliate address to change approval for
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    /// @notice cardAffiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the card affiliate address to change approval for
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    /// @notice change the reference contract for the contract logic
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice to change or renounce ownership of the uberOwner role
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        // affiliate
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        // check the number of NFTs to mint is within limits
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        // tell Treasury, Orderbook, and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        // update internals
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        // initialize the market
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        // create the NFTs
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        // increment totalNftMintCount
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",5732.0,635.0,"[M-05] RCFactory.createMarket() does not enforce _timestamps and _timestamps being larger than _timestamps, even though proper functioning requires them to be so
`RCFactory.createMarket()` does not enforce `_timestamps[1]` and `_timestamps[2]` being larger than _timestamps[0], even though proper functioning requires them to be so.
IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. (1)
The comments explicitly state that _incrementState() should be called ""thrice"" (2)
However, it is possible to create a market where these events do not occur sequentially.
You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.
This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0] (3)
This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. (4)
Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.
When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0] (5)",1.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";




contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    

    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    
    
    address public referenceContractAddress;
    
    uint256 public referenceContractVersion;
    
    
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    
    
    uint256[5] public potDistribution;
    
    uint256 public sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint32 public advancedWarning;
    
    uint32 public maximumDuration;
    
    mapping(address => bool) public governors;
    
    bool public marketCreationGovernorsOnly = true;
    
    bool public approvedAffilliatesOnly = true;
    
    bool public approvedArtistsOnly = true;
    
    bool public override trapIfUnapproved = true;
    
    address public uberOwner;
    
    uint256 public override maxRentIterations;
    
    address public arbitrator;
    
    uint32 public timeout;

    
    
    mapping(address => bool) public override isMarketApproved;
    
    mapping(address => bool) public isArtistApproved;
    
    mapping(address => bool) public isAffiliateApproved;
    
    mapping(address => bool) public isCardAffiliateApproved;
    
    uint256 public nftMintingLimit;

    
    
    
    uint256 public totalNftMintCount;

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    

    
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        uberOwner = msgSender();

        
        treasury = _treasuryAddress;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setminimumPriceIncreasePercent(10); 
        setNFTMintingLimit(60); 
        setMaxRentIterations(35); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    

    
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    
    

    
    
    
    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    
    
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    
    
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    

    
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    
    
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    
    
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    
    
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    
    
    
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    

    
    
    
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    
    

    
    
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    
    
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    
    
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    
    
    
    

    
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        
        
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    
}",3005.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Uninitialized Reference Contract**: The `createMarket` function does not check if `referenceContractAddress` is set. If unset, cloning will fail, halting market creation.

2. **Incorrect Pot Distribution Validation**: `setPotDistribution` allows the sum of distributions to be ≤1000 (100%), but if the total is less than 100%, residual funds may not be properly handled, leading to incorrect profit splits.

3. **NFT Token ID Collision via `setNftHubAddress`**: The owner can decrease `totalNftMintCount`, causing new markets to mint NFTs with overlapping IDs, leading to token duplication or overwrites.

4. **Dynamic Pot Distribution Affects Existing Markets**: Markets likely read `potDistribution` from the factory dynamically. Changes post-creation alter revenue splits retroactively, violating market terms.

5. **Oracle Configuration Changes Impact All Markets**: Modifying `realitio`, `arbitrator`, or `timeout` affects existing markets, potentially altering dispute resolution post-deployment.

6. **Centralization Risks**:
   - **UberOwner Privileges**: The `uberOwner` can arbitrarily change critical addresses (e.g., `referenceContractAddress`), introducing a single point of failure.
   - **Owner Control**: The owner can manipulate `nfthub`, `orderbook`, and distribution settings, risking fund misallocation.

7. **Governor/Owner Privilege Escalation**: Governors/Owners can approve arbitrary markets, artists, or affiliates, enabling malicious actor approvals if compromised.

8. **Zero Address Approvals**: When `approvedArtistsOnly` is enabled, using `address(0)` as an artist/affiliate is allowed, potentially directing funds to irrecoverable addresses.

9. **Dependency on External Contracts**: Reliance on external contracts (e.g., `nfthub`, `treasury`) introduces risk if they are upgraded to malicious implementations.

10. **Insecure `setNftHubAddress` Function**: Allows the owner to reset `totalNftMintCount` to a lower value, risking token ID conflicts in the NFT hub.

11. **Lack of Market Parameter Immutability**: Critical parameters (e.g., oracle settings, pot distribution) are not frozen at market creation, allowing post-deployment changes that undermine user expectations.

12. **Potential Front-Running in Market Creation**: The absence of commit-reveal mechanisms in market setup may allow malicious actors to front-run transactions.

13. **Missing Access Control on `setReferenceContractAddress`**: Only `uberOwner` can set the reference contract, but no safeguards prevent deployment of malicious implementations.

14. **Unenforced Timestamp Constraints**: If `maximumDuration` or `advancedWarning` are modified after market creation, new markets may have inconsistent timing requirements compared to existing ones.

15. **Insufficient Input Validation**:
    - `_cardAffiliateAddresses` may contain duplicates, leading to unintended reward distributions.
    - No check ensures `_timestamps` are chronologically valid (e.g., `timestamps[1]` < `timestamps[2]`).","---

**[M-05] RCFactory.createMarket() does not enforce _timestamps being larger than _timestamps[0]**

**Report Description**:
The `RCFactory.createMarket()` function does not enforce that `_timestamps[1]` and `_timestamps[2]` are larger than `_timestamps[0]`, even though proper functioning requires them to be so. The `IRCMarket` defines a sequence of events (CLOSED, OPEN, LOCKED, WITHDRAW) that each market should progress through sequentially. However, it is possible to create a market where these events do not occur sequentially because `RCFactory` does not validate the relative order of `_timestamps`. Specifically:
1. `RCFactory` checks that `_timestamps[2]` is greater than `_timestamps[1]` but does not check that `_timestamps[1]` is greater than `_timestamps[0]`.
2. `RCFactory` checks that `_timestamps[0]` is equal to or greater than `block.timestamp` but does not enforce minimum values for `_timestamps[1]` or `_timestamps[2]`.
3. This allows a user to create a market where `marketLockingTime` and `oracleResolutionTime` occur before `marketOpeningTime`, disrupting the intended sequence of events.

**Match in Response List**:
Matches with the issue titled **""Unenforced Timestamp Constraints""**.

**Validation**:
**Partially Correct**. The response identifies the issue of unenforced timestamp constraints, which aligns with the core problem described in the issue report. However, the response does not explicitly mention the specific requirement that `_timestamps[1]` and `_timestamps[2]` must be greater than `_timestamps[0]` to ensure the correct sequence of market events. This omission is critical, as it directly impacts the market's functionality. While the response correctly highlights the lack of validation, it misses the specific chronological relationship between the timestamps, which is central to the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-05] RCFactory.createMarket() does not enforce _timestamps being larger than _timestamps[0]**

**Missed Issues from Issue Report**:
- *None*

---",0,1,0,15,"Okay, let me try to figure out the vulnerabilities in this smart contract. I'm a bit new to this, but I'll take it step by step.

First, I'll look through the code for common issues. The contract uses OpenZeppelin's Ownable and Clones, which are generally safe, but maybe there's something in how they're implemented here.

Looking at the constructor, they initialize the EIP712 for meta transactions. That part seems okay. The uberOwner is set to msgSender(), but wait, msgSender() here is from NativeMetaTransaction. Maybe that's using _msgSender() correctly? Let me check. The contract inherits NativeMetaTransaction, which uses _msgSender(), so that should be fine.

The variables: there's a mapping for marketAddresses and mappingOfMarkets. When creating a market, they push the new address into marketAddresses[_mode]. But what if _mode is a value that's not handled? Like, if _mode is greater than the expected range, but since it's a uint32, maybe that's not an issue. Though the getMostRecentMarket function could revert if the array is empty. If someone calls getMostRecentMarket with a _mode that has no markets, marketAddresses[_mode].length would be 0, subtracting 1 would cause an underflow. But since Solidity 0.8, this would revert, so that's safe.

Next, looking at the createMarket function. There's a check that _timestamps.length == 3. That's correct. They check if advancedWarning is not zero, then ensure the market opening time is at least advancedWarning ahead. Wait, the condition is _timestamps[0] - advancedWarning > block.timestamp. So the market opening time must be after (current time + advancedWarning). That makes sense.

Maximum duration check: _timestamps[1] (locking time?) should be less than block.timestamp + maximumDuration. If maximumDuration is zero, this check is skipped. But if it's set, it enforces that the market can't last too long. That seems okay.

The timestamps[1] (locking time) needs to be before timestamps[2] (oracle resolution time), but the check is _timestamps[1] <= _timestamps[2]. Also, timestamps[1] + 1 week must be greater than timestamps[2]. So the oracle resolution must be within a week after locking. That seems okay.

Then they clone the referenceContractAddress. But what if referenceContractAddress hasn't been set? The setReferenceContractAddress can only be called by uberOwner, but if it's not set before createMarket is called, Clones.clone would fail because it's cloning a zero address. So that's a vulnerability. The createMarket function doesn't check if referenceContractAddress is set. So if the owner hasn't set it, any call to createMarket would revert, but maybe that's intended? Or maybe it's a vulnerability if the contract is deployed without setting it.

Another thing: the initialize function on the cloned contract. Since it's using Clones, which is a minimal proxy, the initialize function can be called only once. But here, they call IRCMarket(_newAddress).initialize(...). If someone else can call initialize again, that would be a problem. But since the contract is created via clone, and initialize is called immediately after creation, that's probably safe.

Looking at the sponsorship: they call IRCMarket(_newAddress).sponsor(_creator, _sponsorship). But what if the sponsor function in the market contract allows anyone to call it? Maybe not, but that's in the market contract, not this factory. So maybe not a problem here.

In the setPotDistribution function, they check that the sum of cuts is <= 1000. But 1000 is 100%, so if each value is a percentage with one decimal, that's okay. Wait, the comment says ""Cuts too big"" if sum exceeds 1000. So the total distribution can be up to 1000, which is 100% (assuming 10 = 1%). But if the sum is exactly 1000, that's 100%, which is okay. But if the sum is less than 1000, then there's leftover, but maybe that's intended. However, in the constructor, they set 20,0,0,20,100, which sums to 140. That leaves 860 unaccounted for. But maybe the remaining goes to the winner or somewhere else. The comment says ""// potDistribution[0] = _artistCut; // potDistribution[1] = _winnerCut; // potDistribution[2] = _creatorCut; // potDistribution[3] = _affiliateCut; // potDistribution[4] = _cardAffiliateCut;"". So if those sums don't add up to 1000 (100%), then there's a portion that's not distributed. That could be a problem if the total is not 1000, leading to incorrect distribution. But the setPotDistribution function only requires that the sum is <= 1000, not exactly 1000. So if someone sets it to sum 500, then 50% is distributed, and the rest might be unallocated. Depending on how the treasury uses this, that could be an issue. For example, maybe the remaining funds are stuck or not properly handled. That's a potential vulnerability.

Another thing: the setReferenceContractAddress is called by uberOwner. But if the uberOwner is compromised, they can change the reference contract to a malicious one, leading to all new markets being clones of a malicious contract. So centralization risk here, but maybe that's by design.

The isGovernor function checks governors[_user] or owner. But in the modifier onlyGovernors, it requires governors[msgSender()] || owner() == msgSender(). However, the owner is separate from uberOwner. The owner is from Ownable, and uberOwner is a separate variable. So if the owner is different from uberOwner, the governors could be managed by the owner, but the uberOwner can change the reference contract. Not sure if that's a vulnerability, but it's a potential centralization point.

In the createMarket function, they check if approvedArtistsOnly is true, then require the artist is approved. But if approvedArtistsOnly is true and the artist is address(0), that's allowed. So maybe the artist can be zero address, which might not be intended. Similarly for affiliate addresses.

In the loop over _cardAffiliateAddresses, they check each address is approved or zero. But what if the same address is used multiple times? Like, a card affiliate is added twice. That's allowed, but maybe it's supposed to be unique. Not sure if that's a problem.

The nftMintingLimit is checked against _tokenURIs.length. But if the limit is set to a high number, someone could create a market with many tokens, which could be expensive. But the function has a check, so as long as the limit is set correctly, it's okay. However, if the owner sets nftMintingLimit to a very high value, it might allow minting a large number of NFTs in one transaction, causing gas issues or high costs. But that's up to the owner's configuration.

The totalNftMintCount is incremented by _tokenURIs.length each time a market is created. Since it's a uint256, overflow is not possible in Solidity 0.8. So that's safe.

In the sponsor function call, the _sponsorship is transferred from the creator. The treasury.checkSponsorship(_creator, _sponsorship) function is called first. But what if the sponsorship is deducted but the sponsor function in the market fails? The code proceeds to call sponsor after the loop of minting. If the sponsor call fails, the entire transaction would revert, so that's okay.

Another thing: the marketAddresses is a mapping from uint256 to address[]. So if _mode is a large number, it could potentially use a lot of storage, but that's a design choice.

The realitio and arbitrator addresses are set by the owner. If these are set to malicious contracts, the oracle could be compromised. But that's a trust issue on the owner.

The timeout variable is set by the owner. If it's too short, users might not have enough time to respond to oracle disputes.

The marketCreationGovernorsOnly flag, when true, restricts market creation to governors or the owner. If the owner is malicious, they can create markets regardless. Again, centralization risk.

In the initialize function of the cloned market, parameters like _artistAddress could be zero. If that's allowed, maybe some functions in the market contract expect a valid address and could fail.

The use of Clones.clone means that each market is a minimal proxy. If the reference contract is upgraded (via setReferenceContractAddress), new markets will use the new version. But existing markets remain the old version. That's okay as long as upgrades are backward compatible. However, if the reference contract has a vulnerability, changing it would affect new markets but not old ones.

In the setReferenceContractAddress function, there's a check that the new contract's isMarket() function returns true. But if a malicious contract pretends to be a market (by having an isMarket function that returns true), then it could be set as the reference. So the uberOwner must be trusted to set a valid contract.

Another possible issue: reentrancy. The createMarket function calls external contracts (treasury.addMarket, nfthub.addMarket, orderbook.addMarket, IRCMarket.initialize, nfthub.mint, IRCMarket.sponsor). Since these are external calls, if any of these contracts are malicious, they could re-enter the factory. But since the factory doesn't have any state changes after these calls (except for totalNftMintCount which is incremented before the loop), maybe it's safe. For example, after minting the NFTs, the totalNftMintCount is already updated. If a reentrant call creates another market, the totalNftMintCount would be correct. But if the minting fails after incrementing, the count would be wrong. However, the require statement after nfthub.mint ensures that if minting fails, the transaction reverts, so totalNftMintCount is rolled back.

Wait, in the loop where they mint NFTs:

for (uint256 i = 0; i < _tokenURIs.length; i++) {
    uint256 _tokenId = i + totalNftMintCount;
    require(
        nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
        ""Nft Minting Failed""
    );
}

Then totalNftMintCount += _tokenURIs.length;

So the totalNftMintCount is incremented after the loop. So if the loop completes successfully, then totalNftMintCount is updated. If any mint fails, the entire transaction reverts, so the totalNftMintCount remains unchanged. That's safe.

Another thing: the setNftHubAddress function allows the owner to change the nfthub address and set totalNftMintCount to a new value. If the owner sets totalNftMintCount to a lower value, it could cause tokenId collisions when new markets are created. For example, if the current totalNftMintCount is 100, and the owner sets it to 50, the next market's tokens would start at 50, but those token IDs might already exist in the nfthub. That's a critical issue because it would allow overwriting or duplicating token IDs. So the setNftHubAddress function should not allow decreasing totalNftMintCount or ensure that the new value is not less than the current. However, in the current code, the owner can pass any _newNftMintCount, which could be lower than the existing totalNftMintCount. This is a vulnerability as it can lead to duplicate token IDs.

Wait, the function is:

function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount) external onlyOwner {
    require(address(_newAddress) != address(0));
    nfthub = _newAddress;
    totalNftMintCount = _newNftMintCount;
}

So the owner can set totalNftMintCount to any value, even lower than before. If they set it to a lower value, the next market creation will mint tokens starting from that lower value, which might already have been minted before. This would cause token ID conflicts in the nfthub. That's a critical vulnerability because it allows the owner to create NFTs with duplicate IDs, leading to loss of existing NFTs or overwriting.

Another issue: access control. The onlyGovernors modifier allows governors or the owner to perform certain functions. However, the owner is separate from the uberOwner. The uberOwner can change the reference contract and the uberOwner itself. So there are multiple privileged roles (owner, uberOwner, governors) which might have overlapping or unclear permissions, leading to potential privilege escalation if any of these are compromised.

In the changeUberOwner function, the current uberOwner can transfer ownership to another address. If the uberOwner's private key is compromised, the attacker can take over this function and set a malicious reference contract.

In the setPotDistribution function, the owner can change how the pot is distributed. If this is done after markets are created, it might affect the distribution for existing markets. But if the markets read the potDistribution from the factory at the time of their creation, changing it later wouldn't affect existing markets. However, looking at the code, the getPotDistribution function is part of the IRCFactory interface and is called by the markets via override. Wait, the markets might be reading the current potDistribution from the factory, which would mean that changing the distribution affects all markets, including existing ones. That's a problem because a market's distribution should be fixed at creation time. For example, if a market is created with a certain distribution, and later the owner changes the factory's distribution, the market would use the new values, leading to unexpected behavior. This is a vulnerability as it allows the owner to change the terms of existing markets.

Wait, looking at the code: the IRCMarket's initialize function probably stores the pot distribution at the time of creation. Let me check. The RCFactory's createMarket function calls IRCMarket(_newAddress).initialize(...). The parameters passed include the artist, affiliate addresses, etc., but not the potDistribution. So the market contract must be reading the potDistribution from the factory via getPotDistribution(). So if the factory's potDistribution is changed after a market is created, that market would use the new distribution values. This is a critical vulnerability because it allows the factory owner to alter the revenue distribution of all existing markets, potentially diverting funds to different parties after the market has been created.

That's a big issue. Markets should have their distribution parameters fixed upon creation, not dynamically read from the factory which can change.

Another thing: the realitio and arbitrator addresses can be changed by the owner. If these are changed after markets are created, existing markets that rely on these addresses for dispute resolution would be affected. For example, if a market uses the realitio address stored at creation time, then changing the factory's realitio address wouldn't affect existing markets. But if the market calls getOracleSettings() from the factory each time, then changing the factory's settings would affect all markets. So the vulnerability depends on how the market contracts use these settings.

Looking at the getOracleSettings function in RCFactory, it returns the current realitio, arbitrator, and timeout. If the market calls this function each time it needs to interact with the oracle, then changing these values in the factory would affect all markets. For example, if the owner changes the arbitrator to a malicious one, future disputes in existing markets would use the new arbitrator. That's a vulnerability because it changes the rules after the market is created.

In summary, the main vulnerabilities I can see are:

1. **Reference Contract Not Initialized**: If `referenceContractAddress` is not set before calling `createMarket`, the clone will fail, but there's no check in `createMarket` to ensure it's set.

2. **Incorrect Pot Distribution Sum**: The `setPotDistribution` function allows the sum of distributions to be less than 1000, potentially leaving funds unallocated or causing incorrect distribution.

3. **NFT Token ID Collision**: The `setNftHubAddress` function allows the owner to set `totalNftMintCount` to a lower value, leading to duplicate token IDs when new markets are created.

4. **Dynamic Pot Distribution Affects Existing Markets**: If markets read the pot distribution from the factory dynamically, changing the distribution affects all markets, even existing ones.

5. **Oracle Settings Change Affects Existing Markets**: Changing `realitio`, `arbitrator`, or `timeout` in the factory affects all markets that rely on these settings, potentially altering their operation after deployment.

6. **Centralization Risks**: The uberOwner and owner have significant control, including changing critical contract addresses, which could be abused if compromised.

7. **Governor Privilege Escalation**: The governors and owner have the power to approve markets, artists, etc., which might lead to approval of malicious actors if compromised.

8. **Unchecked Zero Address Approvals**: When approvedArtistsOnly is true, using address(0) as the artist is allowed, which might not be intended and could lead to funds being sent to a zero address.

9. **Dependency on External Contracts**: The factory interacts with several external contracts (treasury, nfthub, orderbook, realitio). If any of these are malicious or compromised, the factory's functionality could be affected.

10. **Reentrancy in External Calls**: While the factory doesn't have payable functions, external calls in `createMarket` could potentially be used for reentrancy if those contracts are malicious. However, since state changes happen before the calls, it might not be exploitable.

That's a lot. I need to list them all concisely."
,,,,,,,,4,8,,,0,3,9,31,