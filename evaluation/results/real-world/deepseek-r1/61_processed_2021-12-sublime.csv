nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
CreditLine.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",10034.0,1061.0,"[H-01] In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way
Current implementation to get the price is as follows:
“(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);”
But it should not consult `borrowToken / collateralToken`, rather it should consult the invers
  [H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens
It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator. However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.
Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.
  [M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender
Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.
  [M-08] Missing approve(0)
There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement at line 199).",4.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';



contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    
    address public savingsAccount;

    
    address public priceOracle;

    
    address public strategyRegistry;

    
    address public defaultStrategy;

    
    uint256 public protocolFeeFraction;

    
    address public protocolFeeCollector;

    
    uint256 public liquidatorRewardFraction;
    
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    
    event CreditLineAccepted(uint256 indexed id);

    
    event CreditLineReset(uint256 indexed id);

    
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CreditLineClosed(uint256 indexed id);

    
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    
    event PriceOracleUpdated(address indexed priceOracle);

    
    event SavingsAccountUpdated(address indexed savingsAccount);

    
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",7331.0,2,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Division by Zero in Collateral Deposit**  
   In the `_depositCollateralFromSavingsAccount` function, if a strategy returns zero tokens for a positive number of shares (e.g., due to a malicious or faulty strategy), the calculation `_liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)` will cause a division by zero, reverting the transaction and preventing collateral deposits.

2. **Incorrect Collateral Accounting via Malicious Strategies**  
   The contract relies on strategies registered in `IStrategyRegistry` to report accurate token/share ratios. A malicious strategy returning incorrect values for `getTokensForShares` can manipulate collateral calculations, leading to under/over-collateralization and incorrect liquidations.

3. **Price Oracle Manipulation Risk**  
   Critical functions like `calculateBorrowableAmount` and `liquidate` depend on the external `priceOracle` for price feeds. If the oracle is compromised or returns stale/inaccurate data, it could result in incorrect borrowing limits, unwarranted liquidations, or undercollateralized loans.

4. **Denial-of-Service (DoS) via Strategy Iteration**  
   Loops iterating over strategies (e.g., in `_depositCollateralFromSavingsAccount`, `_transferCollateral`) may consume excessive gas if too many strategies are registered, causing transaction failures and disrupting core functionalities like collateral deposits/withdrawals.

5. **Insufficient Handling of Strategy Fees**  
   The protocol fee calculation in `borrow` assumes the exact `_amount` is received, but strategies with withdrawal fees could reduce the actual `_tokenDiffBalance`, leading to lower-than-expected borrower receipts. While the code accounts for balance changes, this introduces reliance on strategy behavior.

6. **Unchecked Strategy Existence in Collateral Calculations**  
   The `calculateTotalCollateralTokens` function iterates over all strategies in the registry, including those not used by the credit line. If new strategies are added post-collateral deposit, this could lead to incorrect collateral sums if those strategies are faulty or malicious.

7. **Liquidation Incentive Miscalculation**  
   The `_borrowTokensToLiquidate` function calculates the liquidator's reward using `liquidatorRewardFraction` but does not ensure the remaining collateral after liquidation sufficiently covers the debt, potentially leaving bad debt if the reward fraction is too high.","### **Output**

---

**[H-01] In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way**

**Report Description**:  
The current implementation in `CreditLine#_borrowTokensToLiquidate` incorrectly consults the price oracle for the ratio of `borrowToken / collateralToken`. Instead, it should consult the inverse ratio (`collateralToken / borrowToken`). This misconfiguration could lead to incorrect price calculations, affecting the liquidation process and potentially causing financial losses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect price oracle usage in `CreditLine#_borrowTokensToLiquidate`. This is a critical oversight, as it directly impacts the accuracy of price calculations during liquidation.

---

**[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**

**Report Description**:  
When `autoLiquidation` is set to `false`, only the lender should be able to liquidate the credit line. However, the current implementation allows anyone to liquidate the position without supplying the required borrow tokens. This flaw enables malicious actors to steal collateral intended for the lender, resulting in significant financial losses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improper access control in the liquidation process. This is a high-severity vulnerability that could lead to substantial financial harm to lenders.

---

**[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**

**Report Description**:  
The `CreditLine.liquidate` function fails to transfer borrowed ETH to the lender, leaving the funds in the contract. While the funds are not lost, this oversight requires manual intervention to reconcile and transfer the funds, increasing operational complexity and risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of ETH not being transferred to the lender in the `CreditLine.liquidate` function. This is a medium-severity issue that could lead to operational inefficiencies.

---

**[M-08] Missing approve(0)**

**Report Description**:  
The contract calls `IERC20.approve()` without first setting the allowance to zero. Some tokens, like USDT, require the allowance to be reset to zero before approving a new amount. Failure to do so could cause transactions to revert when interacting with such tokens, leading to functional disruptions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing `approve(0)` calls. This is a medium-severity issue that could prevent the contract from functioning correctly with certain tokens.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way**  
- **[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**  
- **[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**  
- **[M-08] Missing approve(0)**

---

### **Conclusion**  
The `response_list` does not adequately address the issues identified in the `issue` report. Several high and medium-severity vulnerabilities, including incorrect oracle usage, improper access control, and missing token approval steps, are entirely missed. The responses provided focus on other potential vulnerabilities but fail to cover the critical issues outlined in the report. This highlights significant gaps in the security analysis and response coverage.",0,0,4,7,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called CreditLine and it's using Solidity 0.7.6. It imports several OpenZeppelin contracts and some other interfaces. The main purpose seems to be managing credit lines between lenders and borrowers, including collateral, borrowing, repayment, and liquidation.

First, I'll start by checking common vulnerabilities like reentrancy, even though the contract uses ReentrancyGuard. Let's see if there are any functions that might allow reentrancy despite the modifier. For example, the borrow function uses nonReentrant, but maybe there's a place where external calls are made before state changes.

Looking at the borrow function: after updating the state variables, it makes external transfers. Wait, the state is updated before the external calls, so that should be safe. The nonReentrant modifier should prevent reentrancy here. But maybe other functions have similar issues. Let's check the repay function. It also has nonReentrant. The _repay function makes external calls, but again, state changes happen before those calls. Hmm, maybe that's okay.

Next, check for integer overflows/underflows. The contract uses SafeMath, so that's covered. The variables are using .add and .sub, so SafeMath should prevent those issues.

Another common issue is access control. The contract uses OwnableUpgradeable and has modifiers like onlyOwner and onlyCreditLineBorrower/Lender. Let's see if any critical functions are missing access control. For example, the initialize function is called once, but since it's using the initializer modifier, that's okay. The functions like updateDefaultStrategy, updatePriceOracle, etc., are onlyOwner, which is correct.

Now, let's look at the liquidate function. It checks if the currentCollateralRatio is below the ideal. But how is the collateral ratio calculated? The calculateCurrentCollateralRatio function calls getLatestPrice from the priceOracle. If the price oracle is manipulated or returns incorrect prices, that could lead to incorrect liquidation. But that's more of an oracle risk, not a contract vulnerability per se.

Wait, there's a function called _borrowTokensToLiquidate which calculates the amount of borrow tokens needed to liquidate. It uses the price oracle's ratio. If the price is stale or manipulated, the liquidation might not be accurate. But again, that's external dependency.

Another thing: the protocolFeeFraction is applied when borrowing. The fee is calculated as _tokenDiffBalance.mul(protocolFeeFraction).div(10**30). If protocolFeeFraction is set too high by the owner, it could take a large portion of the borrowed amount. But that's a governance issue, not a code vulnerability.

Looking at the collateral management. When depositing collateral, the function _depositCollateralFromSavingsAccount loops through strategies. What if a strategy is malicious or returns incorrect shares? The contract relies on the IStrategyRegistry to provide valid strategies, but if a bad strategy is registered, that could affect the collateral calculation. However, the strategyRegistry is controlled by the owner, so that's a trust assumption.

In the withdrawCollateral function, it checks withdrawableCollateral. The calculation there depends on the current debt and collateral ratio. If the debt is not updated properly, someone might withdraw more collateral than allowed. Let's check the flow: when you borrow, the principal and lastPrincipalUpdateTime are updated. The interest is calculated based on the time elapsed. So as long as the interest accrual is correctly accounted for, the withdrawable amount should be accurate. But is there a scenario where the interest isn't updated before checking the collateral?

For example, in withdrawCollateral, the function calls withdrawableCollateral, which in turn calls calculateTotalCollateralTokens and calculateCurrentDebt. calculateCurrentDebt includes the interest accrued till the last update plus the new interest since then. So that's using the current block.timestamp, which is correct. So even if the lastPrincipalUpdateTime is old, the interest is calculated on the fly. That seems okay.

What about when the credit line is closed? The close function requires the principal and interest to be zero. So after repayment, the borrower or lender can close it. That's fine.

In the liquidate function, after transferring the collateral, the status is set to LIQUIDATED. But what if the transfer fails? The function uses _transferCollateral, which reverts on failure because of the require statements. So if the transfer doesn't go through, the whole transaction is reverted, so the state change (status to LIQUIDATED) won't happen. That's safe.

Another possible issue: when depositing collateral via _depositCollateralFromSavingsAccount, if the user has shares in multiple strategies, the code loops through each and transfers the necessary amount. But if the strategies are not ordered by liquidity, it might take from less optimal strategies first. However, that's more of an efficiency issue than a vulnerability.

Check for front-running possibilities. For example, in the accept function, if both parties need to accept, but the code allows either the borrower or lender to accept depending on who requested. The modifier checks that the sender is the correct party. But if the function can be front-run, but that's not a vulnerability in the code itself.

Looking at the receive() function: it requires that the sender is the savingsAccount. That's to prevent accidental ETH sends. But if someone sends ETH directly to the contract, it will revert unless it's from the savingsAccount. So that's safe.

What about the use of block.timestamp? It's used in calculating interest. Since block.timestamp can be manipulated by miners to some extent, but in practice, for loan durations of days or months, a few seconds/minutes variance isn't critical. Not a major vulnerability here.

In the repay function, when calculating _interestToPay, it subtracts creditLineVariables[_id].totalInterestRepaid from _totalInterestAccrued. If for some reason totalInterestRepaid exceeds _totalInterestAccrued, this could underflow. But since totalInterestRepaid is only updated in the same function when repaying, and _totalInterestAccrued is the sum of previous accrued plus new, it should always be that _totalInterestAccrued >= totalInterestRepaid. Let me check:

When you repay, the code does:

uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);

So _totalInterestAccrued is the sum of interestAccruedTillLastPrincipalUpdate and the newly calculated interest. Since totalInterestRepaid is the amount that has been repaid up to that point, it's possible that totalInterestRepaid could be greater than _totalInterestAccrued if, for example, interest rates were reduced, but in the code, the borrowRate is fixed per credit line. So the interest is calculated with the fixed rate. Therefore, as long as the interest calculation is correct, totalInterestAccrued should always be >= totalInterestRepaid, so no underflow. SafeMath would catch it if not, but in practice, the code should prevent that.

Another thing: in the borrow function, when the borrower takes out a loan, the protocol fee is taken from the borrowed amount. The code calculates _tokenDiffBalance as the balance after minus before, subtracts the fee, and sends the rest to the borrower. But if the actual amount received (due to fees in the strategy or something) is less than expected, the protocol fee calculation might be incorrect. For example, if the lender's strategy has withdrawal fees, then _tokenDiffBalance might not equal the _amount borrowed. So the protocol fee is based on the actual tokens received, which is correct. But the borrower might receive less than expected. However, the code accounts for that by using the actual difference in balance, which is correct.

In the _repay function, when repaying from the savings account, the code transfers the tokens from the user's savings account to the lender. If the user's savings account shares are insufficient, it reverts. That's handled by the for loop and the revert at the end if the amount isn't met. So that's safe.

Potential issues with the collateral calculations: the function calculateTotalCollateralTokens sums the tokens across all strategies. If a strategy is added later to the registry, but the credit line's collateral was deposited before that strategy was added, then when calculating total collateral, it would check the new strategies. However, the collateralShareInStrategy is only updated when collateral is deposited into a strategy. So if a new strategy is added, but the credit line hasn't deposited into it, it won't affect their total collateral. So that's okay.

Another possible issue: when liquidating, if autoLiquidation is enabled and the liquidator is not the lender, they need to send borrow tokens. The code checks if _borrowAsset is ETH and handles accordingly. But in the case of ERC20 tokens, it uses safeTransferFrom. However, the liquidate function is payable, which might be a problem if the borrow asset is not ETH. But the code only uses msg.value when the borrow asset is ETH. Otherwise, for ERC20, it uses safeTransferFrom. So that's okay. Wait, in the liquidate function, the code says:

if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
    uint256 _borrowTokens = _borrowTokensToLiquidate(...);
    if (_borrowAsset == address(0)) {
        uint256 _returnETH = msg.value.sub(_borrowTokens, ...);
        ...
    } else {
        IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
    }
}

But if the borrow asset is an ERC20, the liquidator must have approved the contract to spend their tokens. The code doesn't check if the transferFrom is successful. Wait, safeTransferFrom does check for success. So that's handled. However, the code doesn't check if the liquidator actually sent enough tokens. For example, if the liquidator calls liquidate but doesn't have enough tokens approved, the safeTransferFrom would fail and revert. So that's safe.

Wait, in the else clause, it's using safeTransferFrom(msg.sender, _lender, _borrowTokens). But the liquidator (msg.sender) needs to have approved this contract to spend their _borrowAsset. If they haven't, the transferFrom will fail. So the code assumes that the liquidator has approved the necessary amount. That's a usability issue but not a vulnerability. The function will revert if not approved, which is correct.

Now, looking for possible division issues. For example, in calculateInterest, the code does _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS). If _timeElapsed is very small, this could result in zero interest even if some should accrue. But that's a precision issue inherent to the design. Similarly, in other calculations, divisions could truncate, leading to small inaccuracies. But that's not a vulnerability, just a precision limitation.

Another thing: the idealCollateralRatio is set per credit line. If the idealCollateralRatio is too low, the credit line could be undercollateralized from the start. But that's a parameter set by the lender and borrower, so it's their responsibility.

Check for any functions that allow unauthorized access. For example, the accept function requires that the sender is the borrower or lender depending on who requested. The modifiers seem correct. The onlyCreditLineBorrower and onlyCreditLineLender modifiers check that msg.sender is the correct party.

In the depositCollateral function, the modifier ifCreditLineExists checks that the status is not NOT_CREATED. Only the borrower can deposit collateral (since the lender is explicitly excluded in _depositCollateral). Wait, in _depositCollateral, there's a require that creditLineConstants[_id].lender != msg.sender, so the lender can't deposit collateral. That's correct, as the borrower is the one providing collateral.

Is there a way to create a credit line with the same id? The creditLineCounter is incremented each time a new request is made via _createRequest. So each new credit line has a unique id. No risk of overwriting.

What about reusing a credit line after it's closed or liquidated? The status is set to CLOSED or LIQUIDATED, so functions that require ACTIVE status would fail.

In the repay function, after repaying, if the principal is zero, _resetCreditLine is called. That sets lastPrincipalUpdateTime and other variables to zero. But the status remains ACTIVE until close is called. So the borrower needs to call close after repayment. However, the close function requires that principal is zero and interest is fully repaid. So if the borrower repays completely, they can close it. If they don't, the credit line remains active, but with zero principal, which might not be intended. Wait, in the repay function, when _amount >= _totalCurrentDebt, it sets the principal to _totalCurrentDebt.sub(_amount), which would be zero. Then _resetCreditLine is called, which resets variables. However, the status is still ACTIVE. So after full repayment, the status is still ACTIVE. The borrower or lender must call close to set it to CLOSED. If they don't, the credit line remains active but with zero debt. That's a possible oversight. But the close function checks that principal is zero and interest is fully repaid. So even if the status is ACTIVE, the credit line can't be borrowed from again because the principal is zero, and borrowing requires the status to be ACTIVE and the borrowable amount to be positive. Since the principal is zero, calculateBorrowableAmount would depend on collateral, but with principal zero, the currentDebt would be interest related. Wait, the borrow function requires that the credit line is ACTIVE. If the principal is zero, then the currentDebt would be interestAccruedTillLastPrincipalUpdate + new interest - totalInterestRepaid. If the credit line was fully repaid, those variables should be zero. But if the status is still ACTIVE, someone could potentially borrow again if they deposit more collateral. But that's intended behavior. So after repayment, the borrower can choose to keep the credit line open and deposit more collateral to borrow again. So that's a feature, not a bug.

Another possible issue: when a credit line is LIQUIDATED, the collateral is transferred to the liquidator. But if the liquidator is a contract that doesn't handle ERC20 tokens or ETH properly, the transfer could fail. However, the _transferCollateral function uses the SavingsAccount's transfer or withdraw functions, which should handle that. If the _toSavingsAccount is true, the collateral is sent to the liquidator's savings account, which should be safe. If false, it's withdrawn directly, which could fail if the liquidator is a contract without a payable fallback for ETH. But the liquidate function allows the caller to choose whether to send to savings account. So the liquidator can choose the appropriate method. This is a potential issue for the liquidator, not the contract.

Now, let's think about possible DOS attacks. For example, in the _depositCollateralFromSavingsAccount function, if the user has collateral in many strategies, the loop could run out of gas. But the number of strategies is controlled by the strategyRegistry, which is managed by the owner. If too many strategies are added, depositing could become expensive. The owner should be cautious about adding too many strategies. However, that's a design choice rather than a vulnerability.

Another DOS possibility: when liquidating, the _transferCollateral loops through all strategies. If there are many strategies, this could consume a lot of gas. Again, depends on the strategyRegistry setup.

What about the use of SavingsAccountUtil.sol? Since it's an imported contract, if there's a vulnerability there, it could affect this contract. But the question is about vulnerabilities in the provided code, not dependencies.

Are there any missing checks? For example, in the request function, the _borrowLimit could be zero, which would make the credit line unusable. But the code doesn't check that _borrowLimit is positive. Similarly, _borrowRate could be zero, leading to no interest. However, that's up to the parties creating the credit line. The contract doesn't enforce minimums, which could be a problem, but it's a parameter setting issue.

In the calculateBorrowableAmount function, it returns zero if _maxPossible <= _currentDebt. But if the currentDebt is equal to the borrowLimit, then the borrowable amount is zero. That's correct.

Wait, in the liquidate function, after transferring all collateral to the liquidator, the code sets the status to LIQUIDATED. However, if the credit line had other collateral in different strategies, it's all transferred. The function uses _transferCollateral with _totalCollateralTokens, which loops through all strategies and transfers the entire amount. So after liquidation, the collateral is fully taken, and the status is updated. That's correct.

In the event that the priceOracle returns incorrect data (e.g., a very low price for collateral), the calculateCurrentCollateralRatio could be incorrect, leading to unwarranted liquidations or allowing undercollateralized borrowing. But this relies on the oracle's correctness, which is an external dependency.

Another possible issue is that the CreditLine contract holds ERC20 tokens and ETH. If there's a way to trap funds in the contract, that could be a problem. For example, if a credit line is closed but some tokens are left. However, the functions for withdrawing collateral and repaying should handle that. When a credit line is closed, the collateral should have been withdrawn, and the debt repaid. If not, the funds remain in the contract. But the contract's functions allow the borrower to withdraw collateral as long as the collateral ratio is maintained. So unless there's a bug in those functions, funds shouldn't be trapped.

In the _depositCollateral function, when the collateral asset is ETH (address(0)), it checks msg.value == _amount. However, if the user is depositing via a strategy (fromSavingsAccount), the ETH would have been handled by the savings account. Wait, in _depositCollateral, if _fromSavingsAccount is false, and the collateralAsset is address(0), it requires msg.value == _amount. Then it calls _savingsAccount.deposit{value: _amount}(...). So the ETH is sent to the savings account. But if _fromSavingsAccount is true, then the deposit is from the user's savings account, which should handle ETH as well. So that seems correct.

Wait, in the depositCollateral function, if _fromSavingsAccount is true, the code calls _depositCollateralFromSavingsAccount. Which in turn transfers from the user's savings account. But for ETH, how is that handled? The savingsAccount would need to have ETH in a strategy. The code might not handle ETH properly in that case, but the function uses the same logic as ERC20s. However, the SavingsAccount's deposit and withdraw functions should handle ETH correctly. This is dependent on the SavingsAccount implementation, which is not provided here. So assuming that the SavingsAccount handles ETH correctly, this should be okay.

Another possible issue: in the _depositCollateralFromSavingsAccount function, the code calculates the shares to transfer as _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy). If _tokenInStrategy is zero (which shouldn't happen since the user has liquidity shares), this would cause a division by zero. But since the user must have _liquidityShares, and _tokenInStrategy is derived from those shares via IYield(_strategy).getTokensForShares, which should return a positive amount if the shares are positive. However, if a strategy returns zero tokens for a positive number of shares, this would cause a division by zero. That's a potential vulnerability. For example, if a strategy is compromised and returns incorrect values, this could break the deposit function.

Yes, this is a possible issue. Let's look at the code in _depositCollateralFromSavingsAccount:

uint256 _tokenInStrategy = _liquidityShares;
_tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

uint256 _tokensToTransfer = _tokenInStrategy;
if (_activeAmount.add(_tokenInStrategy) >= _amount) {
    _tokensToTransfer = (_amount.sub(_activeAmount));
}
...
collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
    _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
);

If _tokenInStrategy is zero (i.e., getTokensForShares returns zero for some reason), then the division here would fail, causing a revert. However, if the user has _liquidityShares, the strategy should return a corresponding amount of tokens. But if a malicious strategy returns zero even when there are shares, this would cause a division by zero. Therefore, the contract depends on the integrity of the strategies registered in the strategyRegistry. If the strategyRegistry includes a faulty or malicious strategy, this could lead to failures in depositing collateral.

This is a vulnerability because the contract does not check that _tokenInStrategy is not zero before performing the division. However, since the strategyRegistry is controlled by the owner, it's up to the owner to ensure that only legitimate strategies are included. But if a strategy is compromised, this could be an issue.

Another possible division by zero is in calculateInterestAccrued. If _lastPrincipalUpdateTime is zero, it returns zero. Otherwise, _timeElapsed is block.timestamp - _lastPrincipalUpdateTime. If the credit line was just updated in the same block, _timeElapsed could be zero, leading to calculateInterest returning zero. That's acceptable, not a division by zero, since _timeElapsed is in the denominator. Wait, in calculateInterest, it's divided by YEAR_IN_SECONDS. If _timeElapsed is zero, then the division by YEAR_IN_SECONDS is okay, but the mul(_timeElapsed) would make the entire interest zero. That's correct, as no time has passed.

What about in calculateBorrowableAmount: there's a division by 10**_decimals. If _decimals is larger than 30, but the code uses 10**30. Wait, the code does:

_maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
    10**_decimals
);

So if _decimals is 18 (like most tokens), then 10**30 / 10^18 = 10^12. That scales up the value. But if the price oracle returns a _decimals value higher than 30, this would result in a division by a larger number, potentially leading to _maxPossible being smaller than intended. However, the price oracle's getLatestPrice function is supposed to return the ratio and decimals. If the oracle returns incorrect decimals, that's an oracle issue. For example, if the collateral asset has 18 decimals and the borrow asset has 6 (like USDC), the oracle would return the ratio scaled by some decimals. But the contract trusts the oracle's decimals value. If the oracle is wrong, this could lead to incorrect calculations. Again, this is an oracle risk, not a contract vulnerability per se.

Another possible issue is in the calculation of collateralShareInStrategy when depositing. The code uses:

_liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)

But if _tokenInStrategy is less than _tokensToTransfer (which is derived from the _amount parameter), this could result in shares being miscalculated. Wait, _tokensToTransfer is the amount to transfer, which is a portion of _tokenInStrategy. For example, if the user wants to transfer 100 tokens out of 200 in the strategy, the shares would be _liquidityShares * 100 / 200. That's correct. But if the strategy's getTokensForShares returns an incorrect value, the shares calculation would be wrong. Again, depending on the strategy's correctness.

In summary, the main vulnerabilities I can spot are:

1. Reliance on external contracts (strategies, price oracle, savings account) which, if compromised or incorrect, can lead to various issues like incorrect collateral calculations, division by zero, etc.

2. Division by zero in _depositCollateralFromSavingsAccount if a strategy returns zero tokens for existing shares.

3. The protocol fee is taken from the actual tokens received, which could be less than expected if there are fees in the strategy. However, this is handled correctly by measuring the balance difference.

4. Possible DoS in loops over strategies if too many are added, leading to out-of-gas errors.

But the question is to list vulnerabilities without mitigation. Let's list them formally:

- **Incorrect Collateral Calculation Due to Malicious Strategy**: If a strategy in the strategyRegistry returns incorrect token amounts for shares, it can cause incorrect collateral deposits or withdrawals, leading to potential loss of funds or incorrect liquidation.

- **Division by Zero in Collateral Deposit**: If a strategy returns zero tokens for a positive number of shares, the division in `_liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)` would fail, causing a revert and preventing collateral deposit.

- **Reliance on Price Oracle Accuracy**: The contract uses an external price oracle to determine collateral ratios. If the oracle provides incorrect prices, it could lead to incorrect borrowing limits, unwarranted liquidations, or undercollateralized loans.

- **Potential DoS in Strategy Iteration**: Looping over all strategies from the strategyRegistry during collateral deposit, withdrawal, or liquidation could consume excessive gas if too many strategies are registered, leading to failed transactions.

- **Improper Handling of ETH in SavingsAccount Transfers**: While the contract checks for address(0) (ETH) in some places, there might be edge cases where ETH is not correctly handled when interacting with the savings account, especially if the savingsAccount implementation has issues with ETH deposits/withdrawals.

Wait, but for the ETH handling, in the _depositCollateral function, when collateral is ETH and not from savings account, it checks msg.value. But if from savings account, it's handled via the savingsAccount's functions. So assuming the savingsAccount handles ETH correctly, this should be okay. Maybe that's not a vulnerability.

Another possible issue is in the liquidate function's autoLiquidation: if the liquidator is the lender, they don't need to send borrow tokens. But if they are not the lender and autoLiquidation is true, they must. However, the code checks the borrowAsset and transfers accordingly. If the borrowAsset is an ERC20 and the liquidator hasn't approved the contract, the transferFrom would fail. But this is a user error, not a contract vulnerability.

So, consolidating the vulnerabilities:

1. **Division by Zero in Collateral Deposit**: As explained, if a strategy returns zero tokens for shares.

2. **Incorrect Collateral Shares Due to Strategy Manipulation**: If a strategy is malicious and returns incorrect token amounts for shares, leading to incorrect collateral accounting.

3. **Oracle Manipulation Risk**: Reliance on the price oracle's accuracy for critical calculations.

4. **Potential DoS via Strategy Array Length**: Looping over a large number of strategies could cause transactions to run out of gas.

5. **Insufficient Access Control on Critical Parameters**: The owner can update key parameters like protocol fees, which could be set to excessive values, though this is an admin risk, not a code vulnerability.

Wait, but the owner is supposed to be a trusted entity, so changing parameters is a governance issue. Unless there's a function missing access control, but the functions like updateProtocolFeeFraction are onlyOwner.

Another possible issue is **Uninitialized Variables**: The contract is upgradeable (uses OwnableUpgradeable), but the initializer function is called once. However, since it's using the initializer modifier, that's okay.

**Reentrancy in External Calls**: Although the contract uses ReentrancyGuard, any functions making external calls after state changes should be checked. For example, in borrow, after updating state, transferring tokens via external calls. But since nonReentrant is used, this is mitigated.

Wait, but the nonReentrant modifier is applied to borrow, repay, depositCollateral, withdrawCollateral, liquidate. So reentrancy is guarded.

**Incorrect Protocol Fee Calculation**: If the actual tokens received (_tokenDiffBalance) is less than expected due to strategy withdrawal fees, the protocol fee is based on the actual received amount, which is correct. So this is not a vulnerability.

**Possible Front-Running on Accept**: When a credit line is requested, the counterparty can accept it. However, there's no protection against front-running here. For example, a malicious actor could front-run the accept transaction. But the accept function requires the correct party (borrower or lender) to call it, so front-running wouldn't help an attacker unless they are the authorized party.

So, the main vulnerabilities to list are:

1. Division by zero in collateral deposit when a strategy returns zero tokens for shares.

2. Reliance on external contracts (strategies, oracle, savings account) which may introduce risks if those contracts are faulty or malicious.

3. Potential denial-of-service via excessive strategies in loops.

4. Oracle manipulation leading to incorrect collateral ratios and liquidations.

5. Possible incorrect collateral share calculation if strategies report inaccurate token/share ratios.

But how to phrase these concisely?

Another angle: the CreditLine contract allows the lender to be a contract that could block repayments or liquidations by not implementing necessary functions. But this is a design choice.

Wait, in the liquidate function, when autoLiquidation is enabled and the liquidator is not the lender, the code transfers borrow tokens from the liquidator to the lender. If the lender is a contract that doesn't handle ERC20 tokens properly (e.g., lacks a receive function for ETH or doesn't handle ERC20 transfers), the transfer could fail, causing the liquidation to revert. However, this is a problem with the lender's setup, not the CreditLine contract itself.

Another point: the calculateBorrowableAmount function uses the idealCollateralRatio. If the idealCollateralRatio is set to zero, the borrowable amount would be the borrowLimit. But that would mean no collateral is needed, which is risky. However, the idealCollateralRatio is set when creating the credit line, so it's up to the lender and borrower to agree on this value.

I think the main vulnerabilities to list are:

- **Division by Zero in Collateral Deposit Handling**: If a strategy returns zero tokens for existing shares, causing a division by zero in _depositCollateralFromSavingsAccount.

- **Inaccurate Collateral Tracking Due to Malicious Strategies**: If a strategy maliciously reports incorrect token amounts for shares, leading to incorrect collateral accounting.

- **Reliance on Price Oracle for Critical Operations**: The contract's liquidation and borrowing limits depend on the price oracle's accuracy, which if compromised, can lead to incorrect liquidations or borrowing.

- **Denial of Service via Excessive Strategies**: Iterating over a large number of strategies in deposit, withdrawal, or liquidation functions could cause transactions to fail due to gas limits.

- **Potential Incorrect Interest Calculation on Repayment**: If the repayment function logic miscalculates the interest to be paid, but this seems handled correctly with SafeMath.

Wait, the interest calculation seems correct. The repayment function uses _totalInterestAccrued, which is the sum of stored interest and newly accrued. Subtracting the totalInterestRepaid gives the interestToPay. SafeMath ensures no underflow.

Another possible issue is **Unhandled Return Values of ERC20 Transfers**: The code uses SafeERC20's safeTransfer, which checks the return value, so that's not an issue.

So final list of vulnerabilities:

1. **Division by Zero in Collateral Deposit**: When transferring collateral from a strategy that reports zero tokens for existing shares.

2. **Incorrect Collateral Shares from Malicious Strategies**: Leading to incorrect collateral accounting.

3. **Price Oracle Dependency**: Inaccurate prices can affect borrowing limits and liquidations.

4. **DoS via Strategy Array Iteration**: Looping through many strategies could exhaust gas.

5. **Improper Handling of Strategy Withdrawals**: If strategies have fees or incorrect implementations, collateral calculations may be wrong.

But maybe the first two are the main code-level issues, while the others are more about external dependencies or design choices.","```
None.
```",0.0,0
SavingsAccountUtil.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            //pool
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",989.0,128.0,"[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss
The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`. However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).",1.0,"pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",979.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract code:

1. **Reentrancy Risk**: 
   - The `transferTokens` function uses `call{value: ...}` to send ETH, which forwards all remaining gas. This can lead to reentrancy attacks if the parent contract does not implement reentrancy guards (e.g., `ReentrancyGuard` from OpenZeppelin). The library itself does not enforce reentrancy protection, leaving dependent contracts vulnerable if not properly secured.

2. **Incorrect ETH Handling in Multiple Transactions**: 
   - If multiple ETH transfers are executed in a single transaction, each transfer checks `msg.value >= _amount` individually. However, the cumulative ETH required may exceed the contract's balance after initial transfers, causing subsequent transfers to fail. This can result in inconsistent state changes or partial execution of transactions.

3. **Unsafe ERC20 Approvals**: 
   - In `directSavingsAccountDeposit`, the code uses `safeApprove` without first resetting the allowance to zero. If a prior allowance exists (e.g., from a previous transaction), `safeApprove` will revert, causing the entire transaction to fail. This can disrupt deposit functionality if allowances are not managed properly.

4. **Fee-on-Transfer/Deflationary Token Handling**: 
   - The code assumes that the received token amount equals the `_amount` specified. For tokens with fee-on-transfer or deflationary mechanics, the actual received amount may be less than `_amount`, leading to incorrect approvals (e.g., approving more tokens than held) and potential failures in downstream operations (e.g., deposits).

5. **Deprecated Solidity Version**: 
   - The contract uses Solidity 0.7.6, which lacks built-in overflow/underflow checks. While `SafeERC20` may mitigate this for ERC20 operations, manual arithmetic (if present elsewhere in the codebase) could be vulnerable. Upgrading to Solidity 0.8.x is recommended for implicit safety checks.

6. **ETH Value Mismanagement**: 
   - When handling ETH, the code does not track cumulative transfers within a transaction. This can lead to scenarios where `msg.value` is split across multiple calls, potentially resulting in underfunded operations or unexpected reverts due to insufficient balance during execution.

7. **Lack of Return Value Validation**: 
   - Functions like `withdrawFromSavingsAccount` do not validate the return value of `_savingsAccount.withdraw` or `withdrawFrom`. If the underlying savings account returns incorrect values (e.g., due to a compromised strategy), the contract may proceed with invalid assumptions about withdrawn amounts.","---

**[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

**Report Description**:  
The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for a given `_asset`. However, `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()` but instead returns `_amount`. This means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when the price per share (pps) is not 1), potentially leading to incorrect calculations and fund loss.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of incorrect return values in `SavingsAccountUtil.depositFromSavingsAccount()`. While the response list includes issues like ""Lack of Return Value Validation,"" it does not cover the specific scenario where the function returns an incorrect value (`_amount` instead of the actual shares). This omission represents a gap in the response list's coverage of the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

--- 

The response list fails to address the specific issue of incorrect return values in `SavingsAccountUtil.depositFromSavingsAccount()`, leaving a critical gap in its coverage.",0,0,1,7,"Okay, let's take a look at this smart contract. The user wants me to list all vulnerabilities without suggesting mitigations. Alright, I'll start by reading through the code carefully to spot any potential issues.

First, the contract is using Solidity 0.7.6. I remember that older versions might have known vulnerabilities that have been fixed in newer versions. For example, Solidity 0.8.0 introduced checked arithmetic by default, which prevents integer overflows and underflows. Since they're using 0.7.6, they might be relying on SafeMath or not handling it at all. Let me check if they included SafeERC20, which does use SafeMath. Oh, right, they're importing SafeERC20 from OpenZeppelin. Wait, in 0.7.6, SafeERC20 might still use SafeMath under the hood. So maybe the SafeERC20 functions handle that, but other parts of the code that do manual calculations could have overflow issues. I should check if there are any places where arithmetic operations aren't using SafeMath.

Looking at the functions, there's a transferTokens function. In the case where the token is address(0) (ETH), they check if msg.value is >= _amount. If so, they send _amount to _to. Then, if msg.value is more than _amount, they refund the difference to msg.sender. But wait, when you use call{value: ...} in Solidity, it's better to handle reentrancy. However, since this is a library, maybe the parent contract uses ReentrancyGuard. Let me check the imports. Oh, they do import ReentrancyGuard, but the library itself doesn't inherit from it. So the actual contract using this library would need to implement ReentrancyGuard. But in the transferTokens function, when handling ETH, they perform external calls before updating the state. For example, sending ETH to _to and then sending the remainder back. If _to is a malicious contract, it could reenter the calling contract. Since this is a library, the vulnerability depends on how the parent contract uses it. But the library itself doesn't include reentrancy guards. So if the parent contract doesn't use checks-effects-interactions properly, this could be a reentrancy risk.

Another thing in transferTokens: when the token is ETH, the function checks msg.value >= _amount. However, if someone calls this function multiple times in a single transaction, the msg.value is the total Ether sent. So if this function is part of a larger operation, it might not correctly account for how much Ether is being used in each call. For example, if two calls are made, each requiring _amount of Ether, but the total msg.value is only enough for one, the second call would fail. But in this function, as long as each individual call's _amount is covered by msg.value, it's okay. Wait, no: if the function is called multiple times in the same transaction, each time it checks msg.value >= _amount. But msg.value is the total Ether sent for the entire transaction, so if multiple calls are made, each with _amount, it could drain more than intended. For example, suppose the contract has a function that calls transferTokens twice with _amount = 1 ETH each, and the user sends 1 ETH. Both calls would pass the require(msg.value >= 1 ETH) check, but the total Ether used would be 2 ETH, which is more than what was sent. That's a problem. Wait, no. Because in each transferTokens call, when handling ETH, they check if msg.value is >= _amount. But if you have two calls in the same transaction, each with _amount = 1 ETH, and the user sent 1 ETH, the first call would check 1 ETH >= 1 ETH (okay), then send 1 ETH to _to. Then, the second call would check 1 ETH >= 1 ETH again (since msg.value is still 1 ETH), but when it tries to send another 1 ETH, there's no Ether left in the contract, so the call would fail. Wait, but the contract's balance is only 1 ETH. So the first transfer would send 1 ETH to _to, and the second transfer would try to send another 1 ETH, but the contract's balance is already 0 (since the first transfer took the 1 ETH). So the second call would fail when trying to send, causing a revert. But the initial check would have passed because msg.value is 1 ETH. So this could lead to a situation where the initial checks pass but the actual transfers fail. But the problem here is that the code doesn't track how much Ether has been used in previous calls. So if multiple ETH transfers are made in the same transaction, the checks would pass but the actual transfers would fail due to insufficient balance. This could be an issue because the code relies on msg.value being exactly the sum of all _amounts for ETH transfers. Otherwise, the contract might not handle partial Ether usage correctly. So this is a vulnerability related to improper handling of Ether transfers, specifically multiple ETH transfers in one transaction leading to failed transactions or incorrect Ether forwarding.

Another point: in the transferTokens function, when _token is not ETH, the code uses safeTransferFrom. But if _from is not the same as msg.sender, then the contract must have been approved by _from to spend their tokens. However, in the library functions like directDeposit or depositFromSavingsAccount, when _from is not the contract itself, the code uses safeTransferFrom. This requires that the contract has been given allowance by _from. But the code doesn't check if the allowance is sufficient before performing the transfer. Wait, the SafeERC20's safeTransferFrom does check that the allowance is sufficient. So maybe that's handled. But the code could proceed under the assumption that the allowance is there, but if it's not, the transfer would fail. That's expected behavior, not a vulnerability.

Looking at the directSavingsAccountDeposit function: when the token is not ETH, they approve the strategy (or the savings account) to spend the tokens. But after approving, they call _savingsAccount.deposit. However, if the deposit function doesn't use the entire approved amount, the contract would still have an allowance left. This could be a problem if the contract is used again, as the strategy or savings account could potentially spend the remaining allowance without approval. For example, if the strategy is malicious or gets compromised, it could transfer tokens from this contract's allowance. So this is an approval front-running vulnerability. The code should ideally set the allowance to zero after the deposit to prevent residual allowances. But since they use safeApprove, which requires the current allowance to be zero, this might not work. Wait, OpenZeppelin's safeApprove function has a check that if the current allowance is not zero, the approve will fail. Wait, no: the safeApprove function is a wrapper around approve that checks for certain conditions. Let me check: the safeApprove function in SafeERC20 for Solidity 0.7.6. In older versions, safeApprove was used to mitigate the race condition in approve by requiring that the allowance is set to zero before changing it. So if the current allowance is non-zero, safeApprove will revert unless it's being set to zero. So in the code here, when they call IERC20(_token).safeApprove(_approveTo, _amount);, if there was a previous allowance, this would fail. So they need to first set the allowance to zero, then set it to _amount. But if the code is called multiple times, this could fail. For example, the first time they approve _amount, the second time they try to approve a different amount without resetting to zero first. So the code here might have an issue where the approval could fail if there's a residual allowance. However, in this specific case, since the tokens are transferred to the contract first (transferTokens(_token, _amount, _from, address(this))), and then approved, perhaps each call is handling a fresh amount. But if the same token is used multiple times, there could be residual allowances. For example, suppose the contract previously approved 100 tokens to the strategy, and then in a new deposit, it tries to approve 150. The safeApprove would fail because the existing allowance is 100. So the code should first set the allowance to zero and then to the new amount. But the code here only does safeApprove once. This is a potential vulnerability because the approval might fail if there's a previous allowance left. This can lead to failed deposits if the contract had previously approved some amount to the strategy or savings account.

Another issue: in the transferTokens function, when the token is ETH, the code sends the _amount to _to, and then sends the remaining ETH back to msg.sender. But in the case where _to is a contract that uses a fallback function which consumes a lot of gas, the transfer could fail due to out-of-gas. Using transfer is safer, but in Solidity 0.7.6, the code uses call, which forwards all remaining gas. This could expose the contract to reentrancy attacks if the parent contract doesn't handle it. Since this is a library, the actual contract using it should implement reentrancy guards, but if it doesn't, this could be a problem. So the use of call here without a reentrancy guard in the library could be a vulnerability if the parent contract isn't properly secured.

Additionally, in the transferTokens function, when _token is ETH and _to is not the contract itself, they send _amount via call. But if the _to address is a contract that doesn't accept Ether (no receive or fallback function), this transfer will fail and revert the entire transaction. However, that's expected behavior, but maybe the contract should handle such cases, but it's not a vulnerability per se.

Looking at the withdrawFromSavingsAccount function: when the _from is the contract itself, it calls _savingsAccount.withdraw. Otherwise, it calls withdrawFrom. However, there's no check on the return value of these functions. If the savings account's withdraw functions return a different amount than expected, or if they fail, this could lead to discrepancies. But since the functions are from an external interface (ISavingsAccount), perhaps they are trusted. However, if the savings account is malicious or has a bug, this could affect the contract's functionality. But this might be a trust assumption rather than a vulnerability in this code.

Another possible issue is that in the directSavingsAccountDeposit function, when the token is ETH, the code sets _ethValue to _amount and then calls _savingsAccount.deposit{value: _ethValue}(...). But if the token is ETH, the function would send _ethValue along with the deposit call. However, the code doesn't check if the _amount matches the actual ETH sent. Wait, in the transferTokens function, when the token is ETH, it transfers _amount to address(this). Then, in directSavingsAccountDeposit, for ETH, it sets _ethValue = _amount. So the contract's balance should have _amount of ETH, and then deposit is called with that value. But if the savingsAccount.deposit function expects the msg.value to be equal to _amount, then this should be okay. However, if there's a discrepancy between the transferred ETH and the _amount, that could be a problem. Wait, in transferTokens for ETH, the function transfers _amount to address(this) if _to is not address(this). Wait, no: in directSavingsAccountDeposit, the code calls transferTokens(_token, _amount, _from, address(this)), which for ETH would check that msg.value >= _amount. Then, in the case of ETH, it would send the _amount to address(this). Wait, no. Let me re-examine:

In transferTokens, when _token is address(0) (ETH), the code checks that msg.value >= _amount. Then, if _to is not address(this), it sends _amount to _to via call. Otherwise, if _to is address(this), it doesn't send anything. Wait, in the directSavingsAccountDeposit function, they call transferTokens with _to = address(this). So if the token is ETH, transferTokens will check that msg.value >= _amount. Then, since _to is address(this), it doesn't send the ETH anywhere. Instead, the ETH is kept in the contract's balance. Then, in the deposit call, they use {value: _ethValue}, which is _amount. So the deposit function is called with _ethValue (which is _amount) as the value. But the contract's balance would have the msg.value, which is at least _amount. But if multiple ETH operations are happening in the same transaction, this could be an issue. Wait, no: because transferTokens checks that msg.value >= _amount, but when token is ETH and _to is address(this), the code doesn't send ETH anywhere. So the contract's balance would have the _amount. Then, when deposit is called with {value: _ethValue}, which is _amount, that's correct. However, the code in transferTokens, when handling ETH, will refund any excess msg.value - _amount to msg.sender. Wait, yes. So after transferring _amount to address(this), if the msg.value was more than _amount, the code sends the excess back. But in the case of directSavingsAccountDeposit, the transferTokens call is for _from (the user) to address(this). So when _token is ETH, the code requires that msg.value (from the user) is >= _amount. Then, the contract keeps _amount and refunds the excess. Then, when calling deposit with {value: _ethValue}, which is _amount, the contract has that ETH, so it should work. But if there are multiple deposits in the same transaction, the msg.value checks could conflict, as previously mentioned.

Wait, but in the directSavingsAccountDeposit function, the transferTokens is called with _from being the user, and _to being address(this). So for ETH, this would require that the user sent enough ETH in the transaction (msg.value >= _amount), then the contract keeps the _amount, and deposits it into the savings account. Then any excess is sent back. So this part seems okay. But the problem arises when multiple ETH operations are in the same transaction. For example, if the contract is involved in multiple ETH transfers, each requiring a portion of the msg.value, but the checks are done per call, leading to possible over-checking.

Another possible issue: in the transferTokens function, when _token is not ETH, and _from is not address(this), it uses safeTransferFrom. However, if _from is a contract that charges a fee on transfers, the actual amount received by _to could be less than _amount. But the code returns _amount regardless. This could lead to discrepancies between the recorded transfer and the actual received amount. For example, if the token is a deflationary token with fees, the contract might assume that _to received _amount, but in reality, it's less. This could cause issues in functions that depend on the exact amount transferred. However, the SafeERC20's safeTransferFrom should handle the return value, ensuring that the transfer was successful. But some tokens don't follow the ERC20 standard properly and don't return a boolean. In such cases, using SafeERC20's functions could fail. But the code uses SafeERC20, which is supposed to handle those cases. However, if a token doesn't comply with ERC20 and isn't handled by SafeERC20, this could be a problem. But that's more of a token-specific issue rather than a vulnerability in the contract itself.

Another point: the library functions don't have any access controls. Since this is a library, the functions are internal, so they can only be called by the contract that uses the library. So the access control would depend on the parent contract. If the parent contract doesn't properly restrict access to functions that call these library functions, that could lead to vulnerabilities. But as a library, it's not responsible for access control, so this isn't a vulnerability in the library itself.

In the savingsAccountTransfer function, if _from is address(this), it calls _savingsAccount.transfer, otherwise transferFrom. But the transferFrom function in ISavingsAccount would need to have the proper approval from _from to this contract. The code doesn't check if the savings account has the necessary allowances. It assumes that the savings account's transferFrom will handle it. If the savings account doesn't check the allowance correctly, this could lead to unauthorized transfers, but that's an issue with the savings account, not this code.

In summary, the potential vulnerabilities I can spot are:

1. **Reentrancy in ETH Transfers**: The transferTokens function uses low-level call to send ETH, which can lead to reentrancy if the parent contract doesn't use reentrancy guards. Since the library doesn't implement ReentrancyGuard itself, any contract using this library's functions in a state-changing function without proper reentrancy protection is vulnerable.

2. **Improper Handling of ETH Value in Multiple Calls**: If multiple ETH transfers are made in the same transaction, the msg.value check in transferTokens may pass for each call, but the actual ETH available in the contract could be insufficient, leading to failed transactions. For example, if two separate calls each require 1 ETH, and the user sends 1 ETH, the checks pass but the second transfer fails.

3. **Unsafe ERC20 Approvals**: In directSavingsAccountDeposit, after transferring tokens to the contract, it approves the strategy or savings account to spend the tokens. However, safeApprove may fail if there's a residual allowance from a previous transaction. This can cause the deposit to revert if the previous allowance wasn't reset to zero before setting a new one.

4. **Use of Deprecated Solidity Version**: The contract uses Solidity 0.7.6, which is older and lacks built-in overflow checks. While SafeERC20 might handle some cases, manual arithmetic elsewhere (if any) could be vulnerable. However, in this specific code, most arithmetic is handled via external calls, but there's no explicit SafeMath usage except through SafeERC20.

5. **Insufficient Handling of Fee-on-Transfer Tokens**: The transferTokens function assumes that the received amount is exactly _amount, but if the token charges transfer fees, the actual received amount could be less. This could lead to discrepancies in the contract's accounting, especially if the code relies on the exact amount transferred.

6. **Potential Front-Running with Approvals**: The directSavingsAccountDeposit function approves the strategy/savings account for the exact _amount. If another transaction is made before the deposit is executed, the approval could be exploited. However, since the approval and deposit are done in the same transaction, this is mitigated unless there's a reentrancy elsewhere.

7. **No Check for Contract Existence in ETH Transfers**: When sending ETH to _to using a low-level call, there's no check if the address is a contract or if it can receive ETH. This could lead to funds being locked if sent to an incompatible address. However, the require(success) statement ensures that the transfer either succeeds or reverts, so funds aren't locked, but the transaction would fail.

I need to verify if these points are valid. Let's go through each again.

1. **Reentrancy**: Since the library functions use call.value() without a reentrancy guard, any contract using these functions in state-changing functions without protection is at risk. The library can't enforce this, so the vulnerability exists if the parent contract isn't secured.

2. **Multiple ETH Calls**: The code's transferTokens function checks msg.value >= _amount each time, but if called multiple times, the sum of _amounts could exceed msg.value, leading to potential underfunding in later calls. For example, first call uses 1 ETH, second call also tries to use 1 ETH but there's no ETH left. But the code in transferTokens sends the ETH first and then refunds the excess. Wait, the code checks msg.value >= _amount, then sends _amount to _to (if _to is not address(this)), and refunds the excess to msg.sender. So if you have two calls each with _amount = 1 ETH, and msg.value = 2 ETH, each call would send 1 ETH, and the refund after the first call would be 2 - 1 = 1 ETH. Then the second call would check msg.value (still 2 ETH) >= 1 ETH, but after the first call's refund, the contract's balance is 0, so sending another 1 ETH would fail. Wait, but the refund is sent back to msg.sender, so the contract's balance after first call is 0. The second call would check msg.value >= 1 ETH (which it is, since msg.value is 2 ETH), but when it tries to send 1 ETH to _to, the contract's balance is 0, so the transfer would fail. This would cause the entire transaction to revert. However, the code has a require(success) after the transfer, so the second call would revert. Therefore, the code would handle this scenario by reverting, but the user's msg.value must cover the sum of all _amounts for ETH transfers in the transaction. If the user sends exactly the sum, it's okay. But if they send more, the excess is refunded. However, if the sum of _amounts exceeds msg.value, the first transfers would deplete the contract's balance and later transfers would fail. So the code requires that each transfer's _amount is covered by msg.value individually, but if multiple transfers are made, this could be a problem. For example, if a transaction has two ETH transfers of 1 ETH each, but msg.value is 1 ETH, the first transfer would check msg.value >= 1 ETH (okay), send 1 ETH to _to, and then refund 0. Then the second transfer would check msg.value >= 1 ETH (still 1 ETH), but when trying to send another 1 ETH, the contract's balance is 0, so it would fail. Therefore, this code's ETH handling is vulnerable to multiple transfer calls in the same transaction that exceed the actual available ETH. This can lead to partial execution of transactions, which is a vulnerability.

3. **Unsafe Approvals**: Yes, using safeApprove without resetting the allowance to zero first can cause failures. For example, if the contract previously approved 100 tokens to the strategy, and then tries to approve 150 in a new transaction, safeApprove would fail because the current allowance is 100. The correct approach is to first set the allowance to zero and then to the new amount. But safeApprove doesn't allow that because it checks that the new allowance is zero when changing from a non-zero value. Wait, no: safeApprove is supposed to prevent the race condition by allowing setting to non-zero only when the current allowance is zero. So if there's a previous non-zero allowance, safeApprove will revert. Therefore, to update the allowance, the code must first set it to zero and then to the new value. But doing this in two separate transactions could introduce a race condition. However, in the same transaction, the code could set it to zero and then to the new value. But the code here does neither; it just tries to set it to _amount. If there was a previous allowance, this would revert. So the code is vulnerable to approval failures if there's a residual allowance from a previous transaction.

4. **Solidity Version**: Using 0.7.6 instead of 0.8.x means no built-in overflow checks. The code uses SafeERC20, which might use SafeMath internally. For example, safeTransfer and safeTransferFrom would handle the math. But if there's any manual calculations, like adding or subtracting, they could be vulnerable. Looking at the code, most functions pass the _amount through, so there's no arithmetic operations in this library. Therefore, maybe the Solidity version isn't a vulnerability here unless there are other parts of the code not shown. But in the given code, there's no arithmetic, so maybe this point is not applicable. Hmm.

5. **Fee-on-Transfer Tokens**: If the token takes a fee on transfer, the actual amount received by the contract (when transferring from _from) could be less than _amount. However, the code assumes that the transferred amount is exactly _amount. For example, in directSavingsAccountDeposit, after transfering _amount from _from to the contract, it approves _amount to the strategy. If the actual received amount is less (due to fees), the approval would be for more than the contract holds, and the deposit could fail or be incorrect. This is a vulnerability because the code does not account for possible fees on transfers, leading to incorrect approvals and potential failures.

6. **Approval Front-Running**: If the approval is set and then another transaction is mined before the deposit is called, an attacker could use the allowance. However, since the approval and deposit are in the same function (directSavingsAccountDeposit), and thus the same transaction, there's no front-running opportunity here. So this point might not be valid.

7. **Contract Existence Check**: When sending ETH via call, if the address is a contract without a receive function, the transfer will fail. However, the code requires that the transfer is successful, so the transaction would revert. This is not a vulnerability but a normal behavior. The funds aren't lost; the transaction just fails.

So refining the list:

1. **Reentrancy in ETH Transfers**
2. **Incorrect ETH Handling in Multiple Transfers**
3. **Unsafe ERC20 Approvals Leading to Failed Deposits**
4. **Fee-on-Transfer/Deflationary Token Handling**
5. **Use of Low-Level Call for ETH Transfers Without Reentrancy Guards**

Wait, the use of call is a reentrancy risk, which is covered in point 1. The ETH handling in multiple transfers is a separate issue. Fee-on-transfer tokens is another.

Another possible vulnerability: In the directSavingsAccountDeposit function, when the token is ETH, the code calls the savings account's deposit function with value _ethValue, which is _amount. However, the transferTokens function for ETH already transferred _amount to the contract, so the contract's balance is at least _amount. But if the savings account's deposit function requires exactly _amount, but the contract's balance is more, perhaps due to multiple deposits, this could lead to sending more ETH than intended. Wait, no. Because transferTokens for ETH checks msg.value >= _amount, and if _to is address(this), the contract's balance increases by msg.value, but then the code refunds msg.value - _amount to the user. Wait, no. Let's see: transferTokens is called with _from being the user, _to being address(this), and _amount.

If the token is ETH:

1. require(msg.value >= _amount) - the user must send at least _amount.
2. If _to (address(this)) is not the same as the contract (but in this case, it is), then send _amount to _to. Wait, no: in directSavingsAccountDeposit, transferTokens is called with _to = address(this). So for ETH, the code would check that msg.value >= _amount. Since _to is address(this), it does not send the ETH to _to (which is the contract itself). Then, if msg.value > _amount, it sends the excess back to msg.sender. So the contract's balance after transferTokens is exactly _amount. Then, when calling deposit with {value: _ethValue} (which is _amount), that's correct. So this part is okay. The ETH is properly accounted for.

Another thing: in transferTokens, when handling ETH, the code checks if msg.value >= _amount, and sends the _amount to _to (if _to is not the contract). However, if the function is called with _amount being zero, it returns 0. But if _amount is zero and the token is ETH, the code would check msg.value >= 0 (which is always true). Then, it would send zero ETH to _to, but if msg.value was sent, it would refund the entire msg.value. But this is a possible way for someone to send ETH to the contract and have it refunded, which is not a vulnerability per se, but could be a way to dust the contract. Not a big issue.

Putting it all together, the main vulnerabilities are:

1. **Reentrancy Risk**: Using low-level call for ETH transfers without reentrancy protection, which can be exploited if the parent contract doesn't implement checks.

2. **Multiple ETH Transfer Vulnerability**: If multiple ETH transfers are requested in a single transaction, each with _amount summing to more than msg.value, the initial transfers may deplete the contract's balance, causing subsequent transfers to fail.

3. **Unsafe ERC20 Approvals**: Using safeApprove without resetting allowances to zero first, leading to potential transaction reverts if previous allowances exist.

4. **Handling Fee-on-Transfer/Deflationary Tokens**: Assuming the received amount is equal to _amount, which may not be the case for tokens with transfer fees, causing incorrect approvals and potential deposit failures.

5. **Deprecated Solidity Version**: Using Solidity 0.7.6 which lacks built-in overflow checks, though the current code may not have explicit arithmetic operations vulnerable to this.

So I need to list these in the answer.","```
None.
```",0.0,0
Pool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",10152.0,1045.0,"[H-03] denial of service
if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls `SavingsAccountUtil.transferTokens` which will transfer to `msg.sender`, `msg.value` (of `withdrawLiquidity`, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.
  [M-03] Collateral can be deposited in a finished pool
The `_depositCollateral` function doesn't check the status of the pool so collateral can be deposited in a finished loan. This can happen by mistake and all funds will be lost.",2.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';


contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, 
        ACTIVE, 
        CLOSED, 
        CANCELLED, 
        DEFAULTED, 
        TERMINATED 
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; 
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    
    mapping(address => LendingDetails) public lenders;

    
    PoolConstants public poolConstants;

    
    PoolVariables public poolVariables;

    
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        

        
        
        
        
        
        
        
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            
            _withdrawRepayment(msg.sender);
        }
        
        _burn(msg.sender, _actualBalance);

        
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    
    receive() external payable {}

    
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",7067.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Decimal Handling for Non-ERC20 Tokens**  
   The contract assumes the `borrowAsset` is an ERC20 token with a `decimals()` function. If `borrowAsset` is a non-ERC20 (e.g., ETH) or lacks this function, the token's decimals default to 18, causing miscalculations in shares and transfers when the actual asset has different decimals.

2. **Self-Lending via Unverified Lenders**  
   The `lend` function allows borrowers to fund their own loans through alternate addresses if the `lenderVerifier` is not set. This bypasses the borrower check, enabling manipulation of the pool's liquidity to meet withdrawal thresholds.

3. **Reentrancy Risk in `_beforeTokenTransfer`**  
   The `_withdrawRepayment` function is called during token transfers, which interacts with external ERC20 tokens. Malicious tokens with reentrant `transfer` functions could exploit this to re-enter the contract before state updates, leading to potential reentrancy attacks.

4. **Unrestricted Strategy in `lend` Function**  
   Lenders can specify arbitrary strategies when depositing. Malicious strategies could manipulate share calculations or drain funds, as the contract does not enforce validation of approved strategies.

5. **Centralization Risk with Owner Privileges**  
   The `terminatePool` function allows the owner to withdraw all collateral, posing a centralization risk if the owner acts maliciously or is compromised.

6. **Margin Call End Time Miscalculation**  
   The `getMarginCallEndTime` function may incorrectly reset the margin call expiration if the logic for `_marginCallDuration` is miscalibrated, potentially affecting collateral requirements.

7. **Missing Validation for Borrow/Collateral Assets**  
   The `initialize` function lacks checks to ensure `borrowAsset` and `collateralAsset` are valid ERC20 tokens. Invalid addresses could cause failures in deposit/withdrawal logic.

8. **Inconsistent State During Interest Calculation**  
   The `calculateCollateralRatio` relies on real-time interest calculations, which may become inconsistent if the loan status changes during transfers, affecting collateral adequacy checks.

These vulnerabilities range from technical risks (e.g., reentrancy, decimal handling) to systemic issues (e.g., self-lending, centralization).","### **[H-03] Denial of Service**

**Report Description**:  
If the borrow token is `address(0)` (ether), and someone calls `withdrawLiquidity`, it calls `SavingsAccountUtil.transferTokens`, which will transfer `msg.value` (of `withdrawLiquidity`) to `msg.sender`. Since `withdrawLiquidity` is an internal function, the liquidity provided will pay to themselves, and their liquidity tokens will still be burned. As a result, they will never be able to get their funds back, leading to a denial of service.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The denial of service vulnerability arises from the incorrect handling of ether transfers in `withdrawLiquidity`, which is not covered in the response list. This is a critical oversight, as it directly impacts the functionality and security of the contract.

---

### **[M-03] Collateral Can Be Deposited in a Finished Pool**

**Report Description**:  
The `_depositCollateral` function does not check the status of the pool, so collateral can be deposited in a finished loan. This can happen by mistake, and all funds will be lost.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of validation for pool status in `_depositCollateral` is a significant oversight, as it allows users to deposit collateral into finished pools, leading to potential loss of funds. This issue is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-03] Denial of Service**  
- **[M-03] Collateral Can Be Deposited in a Finished Pool**

---

### **Analysis of Gaps**  
The response list fails to address two critical issues from the issue report:  
1. **Denial of Service**: The issue arises from the incorrect handling of ether transfers in `withdrawLiquidity`, which is not covered in the response list. This is a significant oversight, as it directly impacts the functionality and security of the contract.  
2. **Collateral Deposit in Finished Pool**: The lack of validation for pool status in `_depositCollateral` is a significant oversight, as it allows users to deposit collateral into finished pools, leading to potential loss of funds. This issue is not covered in the response list.  

The response list focuses on other vulnerabilities, such as reentrancy, decimal handling, and centralization risks, but misses these critical issues. Addressing these gaps is essential for ensuring the security and functionality of the smart contract.",0,0,2,8,"Okay, I need to analyze the provided smart contract and list all the vulnerabilities. Let me start by reading through the code carefully. 

First, the contract is using Solidity 0.7.6. I remember that older versions might have known issues. For example, versions before 0.8.0 don't have built-in overflow checks, which can lead to arithmetic issues. The contract uses SafeMath, though, so maybe that's covered. But let me check if they're actually using SafeMath for all arithmetic operations. Looking at the code, they do have ""using SafeMath for uint256;"" so that's good. But maybe there are places where they don't use it, like in loops or other variables?

Next, the contract imports several OpenZeppelin contracts, including ReentrancyGuard. The modifiers like nonReentrant are used in some functions, which helps prevent reentrancy attacks. But I need to check if all functions that transfer funds or call external contracts are protected. For example, the lend function has nonReentrant, which is good. But other functions like liquidatePool also use it. So maybe reentrancy is covered here.

Looking at the initialize function: it's an upgradeable contract because it's using Initializable. However, the contract doesn't use a constructor but the initialize function. But upgradeable contracts can have issues if not properly secured, like someone else calling initialize again. But they have the initializer modifier, which should prevent multiple initializations. So that's probably okay.

In the _depositCollateral function, they use nonReentrant. Wait, the _depositCollateral is called by depositCollateral and _initialDeposit. Both should be nonReentrant. That's handled.

Now, looking at the _beforeTokenTransfer function. This is an override of ERC20's hook. They have some checks here. For example, they check if the recipient is the borrower and revert if so. But they also handle some logic related to margin calls and transferring extra liquidity shares. There's a call to _withdrawRepayment for both the sender and receiver when tokens are transferred. But if this function is called during a transfer, could that lead to reentrancy? Since the _withdrawRepayment function transfers tokens, maybe. But the _beforeTokenTransfer is called before the balances are updated, so maybe not. But the nonReentrant modifier isn't present here. However, the functions that call transfer (like withdrawRepayment) have nonReentrant. Wait, the _withdrawRepayment is called inside _beforeTokenTransfer, which is part of the ERC20 transfer. So if a malicious token is used as borrowAsset, its transfer could re-enter. But since borrowAsset is set during initialization and presumably is a trusted ERC20, maybe that's mitigated. But it's a risk if the borrowAsset is a malicious contract. However, the contract uses SafeERC20, which should handle that. Hmm, maybe not a vulnerability here, but worth noting.

Another thing in _beforeTokenTransfer: when transferring tokens between users, they recalculate effectiveInterestWithdrawn based on the current totalRepaidAmount. But since this is done during the transfer, if the totalRepaidAmount changes after this calculation, maybe there's an inconsistency. Not sure, but possible.

Looking at the cancelPool function. There's a call to _cancelPool with a penalty. The penalty calculation uses poolConstants.borrowRate, but if the borrowRate is very high, the penalty could be substantial. But this is part of the contract's intended functionality. Maybe not a vulnerability.

In the liquidateCancelPenalty function, they check if poolVariables.penaltyLiquidityAmount is 0. After setting it to _liquidationTokens, it's possible that another user could call this function again, but since penaltyLiquidityAmount is set before any transfers, maybe it's protected. But maybe there's a race condition here if multiple people try to liquidate. However, the require statement checks penaltyLiquidityAmount == 0, so only the first caller can proceed. That's okay.

The terminatePool function is onlyOwner. If the owner is a trusted entity, that's okay. But if the owner is malicious, they could terminate the pool and withdraw collateral. But that's a centralization risk, which is a vulnerability if the owner isn't supposed to have that power. The contract's design might require this, though.

In the liquidatePool function, they set the loanStatus to DEFAULTED. But if someone calls this when the loan isn't defaulted, the require statements check that. So that's okay.

Looking at the getMarginCallEndTime function: it adds _marginCallDuration.mul(2) to _marginCallEndTime. Wait, the code says if block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2)), then set to 0. But _marginCallDuration is fetched from the factory. The calculation might not be correct. For example, if the margin call duration is 7 days, then after 14 days, it resets. That's part of the logic, but maybe it's a bug if the intended duration is different.

In the _calculatePenaltyTime function, if block.timestamp is after loanWithdrawalDeadline, it uses _loanWithdrawalDeadline as the end time. Then, penaltyTime is repaymentInterval plus the difference. But if the repaymentInterval is large, this could lead to a very high penalty. But this is part of the contract's design.

Another thing: the contract uses try/catch when calling decimals() on the borrowAsset in the initialize function. If the borrowAsset doesn't have a decimals() function (like ETH), but in that case, the contract handles it. Wait, ETH isn't an ERC20, so if borrowAsset is address(0), but in the code, they try to call ERC20Upgradeable(_borrowAsset).decimals(). That would fail if _borrowAsset is address(0). But in the code, maybe the borrowAsset is always an ERC20. However, the receive() function is present, suggesting that maybe the contract can handle ETH. There's a check in withdrawLiquidity for address(0). So possible inconsistency if the borrowAsset is ETH but the code tries to call decimals() on it. That would cause a revert. For example, if the borrowAsset is ETH (address(0)), then ERC20Upgradeable(address(0)).decimals() would fail, causing the try/catch to execute the empty catch block. Thus, the decimals wouldn't be set. But ERC20Upgradeable uses 18 decimals by default if not set. Wait, the code has __ERC20_init which sets the name and symbol, but decimals are initialized to 18. Then, the try block tries to set it to the borrowAsset's decimals. If that fails, it remains at 18. But if the borrowAsset is ETH (which isn't an ERC20), then the decimals would be 18, which might be incorrect. That's a possible issue. For example, if the borrowAsset is a token with 6 decimals, but the pool token uses 18, leading to incorrect accounting. That's a vulnerability because the PT tokens would have the wrong decimals, leading to miscalculations in shares and transfers.

Another issue: in the initialize function, the line poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod); and loanWithdrawalDeadline is set as block.timestamp.add(...). If the _collectionPeriod is set incorrectly, the loan could start in the past. But the parameters are provided during initialization. However, if the _collectionPeriod is zero, loanStartTime would be the current block time, which might not be intended. But that's up to the caller.

In the withdrawBorrowedAmount function, the require statements check that the pool is in COLLECTION status and that the current time is after loanStartTime. Wait, loanStartTime is set to block.timestamp.add(_collectionPeriod) during initialize. So if the collection period is, say, 1 week, loanStartTime is in the future. Then, the borrower can withdraw after loanStartTime. But the code in withdrawBorrowedAmount requires that poolStatus is COLLECTION and loanStartTime < block.timestamp. But once the borrower calls withdrawBorrowedAmount, the status becomes ACTIVE. So that's okay. However, if the loanStartTime is not properly validated, but the parameters are set during initialization by the borrower, perhaps via the factory. So not sure.

Another possible issue: in the liquidateForLender function, after liquidating, the lender's shares are burned. But if the lender's balance is not zero, this could lead to inconsistencies. Wait, the function calls _burn(_lender, _lenderBalance), which should set their balance to zero. Then, delete lenders[_lender]. So that's okay.

Looking at the ERC20PausableUpgradeable. The contract can be paused, and _beforeTokenTransfer checks if paused. But who can pause? The onlyOwner modifier is on terminatePool, but pausing is handled by the ERC20PausableUpgradeable's internal functions. Wait, the contract inherits from ERC20PausableUpgradeable, which has a pause() function. But in the current code, there's no function to call pause except in _cancelPool and terminatePool, which call _pause(). So the pause is triggered when the pool is canceled or terminated. So pausing is controlled by the contract's own logic. That seems okay.

In the lend function, they check that the lender is not the borrower. But what if the borrower uses a different address? The check is that _lender != _borrower and _borrower != msg.sender. Wait, the parameters are _lender and msg.sender. So the function is called by someone (msg.sender) who is providing the _lender address. So if the borrower is the msg.sender but sets _lender to another address, it's allowed. But the code requires that _lender is not the borrower and msg.sender is not the borrower. Because the code says: require(_lender != _borrower && _borrower != msg.sender, 'L1'). So if the borrower tries to lend using their own address as _lender, it's blocked. But if the borrower uses another account, they could bypass this. However, the lenderVerifier might check that. But if the lenderVerifier is not set, then the borrower can act as a lender through another address, which might be a way to manipulate the pool. That's a possible issue if the borrower can supply their own liquidity to meet the minBorrowFraction. For example, a borrower could create a pool, then use another account to lend to their own pool, allowing them to withdraw the funds. This would be a vulnerability as it allows self-lending, which might be against the intended design. The lenderVerifier is supposed to check if the lender is approved, but if it's not set (address(0)), then any lender can participate. So in that case, the borrower can use a different address to fund their own loan. This is a central point but depends on the verification process. If the lenderVerifier is properly set, then it's not an issue. But if not, it's a vulnerability.

Another thing: in the liquidatePool function, the code transfers the collateral to the liquidator. But how is the collateral calculated? It uses the _collateralLiquidityShare which is the sum of base and extra shares. Then converts to tokens. Then calculates the corresponding borrow tokens. If the price oracle provides an incorrect ratio, this could lead to incorrect liquidation amounts. But that's dependent on the oracle's accuracy, which is a known external risk. If the oracle is compromised, the contract could be vulnerable. But that's outside the contract's control.

Reentrancy in the _beforeTokenTransfer: as mentioned earlier, when transferring tokens, the _withdrawRepayment is called, which does a transfer. If the borrowAsset is a malicious contract with a callback, it could re-enter. However, since the transfer is done using SafeERC20's safeTransfer, which should handle reentrancy, maybe that's mitigated. But the _beforeTokenTransfer is part of the ERC20 transfer process, which is before the actual balance update. So if the _withdrawRepayment is called here, and the token transfer re-enters, it could cause unexpected behavior. For example, during a transfer, if the token's transferFrom calls back into the contract, the state might not be updated yet. This is a possible reentrancy vector. Let me check: the _withdrawRepayment function calls calculateRepaymentWithdrawable, which depends on the lender's balance. But in the _beforeTokenTransfer, the transfer hasn't been completed yet (it's before the actual transfer). So the lender's balance is still the original value. If during the _withdrawRepayment, the lender's balance is modified again via another function, it could lead to inconsistencies. However, since the _withdrawRepayment is called within a transfer, which is protected by the nonReentrant modifier in withdrawRepayment, but the _beforeTokenTransfer itself is not protected. Wait, the _beforeTokenTransfer is part of the ERC20's transfer function, which may not have the nonReentrant modifier. So if during a transfer, the _withdrawRepayment is called, which then does a token transfer, and the token is malicious, it could re-enter the contract. For example, suppose Alice transfers tokens to Bob. During the transfer's _beforeTokenTransfer, the contract calls _withdrawRepayment(Alice) and _withdrawRepayment(Bob). If either of these withdrawals involve a malicious token that calls back into the contract's transfer function, it could cause reentrancy. Since the _beforeTokenTransfer is not protected by nonReentrant, this is a possible vulnerability. But how severe is this? The functions that call transfer (like transfer, transferFrom) would be part of the ERC20 functions, and if they're not protected by nonReentrant, this could be an issue. However, the contract uses ReentrancyGuard, but the ERC20's transfer function isn't marked with nonReentrant. So the _beforeTokenTransfer is part of the transfer function, which isn't protected by nonReentrant. Therefore, this is a possible reentrancy vulnerability.

Another possible issue: in the _deposit function, when using _fromSavingsAccount, it calls SavingsAccountUtil.depositFromSavingsAccount. If the savings account has a reentrancy issue, but since the contract uses nonReentrant in functions that call _deposit, maybe it's mitigated. But the _deposit function itself isn't protected, but it's called from functions that are (like lend, depositCollateral, etc.), which have nonReentrant modifiers. So maybe not an issue.

Also, the initialize function is external and initializable. But since it's using the initializer modifier, it can only be called once. So that's safe.

In the liquidateCancelPenalty function, after setting poolVariables.penaltyLiquidityAmount = _liquidationTokens, the contract transfers tokens from the liquidator. Then calls _withdraw. But if the _withdraw fails, the state is already updated. However, since it's using a nonReentrant modifier and checks that penaltyLiquidityAmount was 0 before, maybe this is handled.

Looking at the getEquivalentTokens function: it uses the price oracle to convert between tokens. If the price oracle returns incorrect values (e.g., due to manipulation), the contract could calculate wrong amounts. But that's an oracle risk, which is a common issue but not a code vulnerability per se.

Another thing: the contract uses block.timestamp for deadlines and loan start times. This can be slightly manipulated by miners, but usually, it's considered acceptable unless the time windows are very tight.

Now, compiling the list of vulnerabilities found:

1. **Incorrect ERC20 Decimals Handling**: In the initialize function, when setting up the decimals for the pool token, if the borrowAsset is not an ERC20 (e.g., ETH), the try/catch will fail, and the decimals will default to 18. If the actual borrow asset has a different decimal count, this leads to incorrect token amounts and calculations. For example, using a borrowAsset with 6 decimals (like USDC) would result in the pool token using 18 decimals, causing miscalculations in shares and transfers.

2. **Potential Self-Lending by Borrower**: The lend function checks that the lender (_lender) is not the borrower and that the msg.sender is not the borrower. However, if the borrower uses a different address to act as a lender, they can still fund their own loan. This is especially a problem if the lenderVerifier is not properly set (address(0)), allowing the borrower to manipulate the pool's liquidity and meet the minimum required to withdraw funds.

3. **Reentrancy in Token Transfers via _beforeTokenTransfer**: The _beforeTokenTransfer function calls _withdrawRepayment for both the sender and receiver, which involves transferring tokens. If the borrowAsset is a malicious ERC20 token with a callback in transfer, it could re-enter the contract during the transfer, potentially leading to reentrancy attacks. Since the ERC20's transfer functions are not protected by nonReentrant modifiers, this could allow an attacker to manipulate the contract's state mid-transfer.

4. **Uninitialized Pool Token Decimals**: If the borrowAsset's decimals() function reverts or is not present (as in the case of ETH), the pool token's decimals remain uninitialized, defaulting to 18. This could lead to incorrect decimal handling if the borrowAsset has a different number of decimals, affecting share calculations and token amounts.

5. **Incorrect Margin Call End Time Calculation**: The getMarginCallEndTime function checks if block.timestamp is greater than _marginCallEndTime + 2 * _marginCallDuration, but the code adds _marginCallDuration.mul(2) to _marginCallEndTime. If the intention was to check if the current time is beyond the margin call end time plus twice the duration, the code is correct. However, if the logic was supposed to be different, this could be a bug. For example, if the margin call duration is the time the lender has to respond, adding twice might not be intended. However, this depends on the contract's design.

6. **Centralization Risk with Owner Privileges**: The terminatePool function can only be called by the owner, who can withdraw all collateral without penalty. If the owner is malicious or compromised, they could terminate the pool and steal the collateral. This centralization risk might be against the intended decentralized nature of the protocol.

7. **Possible Arithmetic Overflows Without SafeMath**: Although SafeMath is used for uint256, there are instances where other types (like uint8 in decimals) could cause issues. However, since the contract uses Solidity 0.7.6, which has implicit SafeMath for uint256, but older versions may not. Wait, in Solidity 0.7, arithmetic operations don't have built-in overflow checks, but the contract uses SafeMath for uint256. So all uint256 operations should use SafeMath. But variables of smaller types (e.g., uint8) could overflow. For example, in the decimals handling, if the borrowAsset's decimals() returns a value larger than 255, but that's unlikely. So maybe not a vulnerability here.

8. **Lack of Input Validation in initialize Function**: The initialize function does not validate that _borrowAsset and _collateralAsset are valid ERC20 tokens. If invalid addresses are provided (e.g., zero address or non-contract addresses), subsequent calls could fail, leading to a DoS. However, this would depend on the factory contract's input validation.

9. **Inconsistent State During Token Transfer**: During token transfers, the _beforeTokenTransfer function updates the effectiveInterestWithdrawn for both sender and receiver based on the current totalRepaidAmount. However, if the totalRepaidAmount changes after this calculation but before the transfer is completed, it could lead to inconsistencies. But since the transfer is atomic, this is unlikely unless external calls interfere.

10. **Missing Access Control on Pause Functionality**: The contract inherits ERC20PausableUpgradeable, which has internal _pause and _unpause functions. However, the provided contract doesn't expose these functions with proper access control, meaning they can't be called except through the existing logic (like _cancelPool and terminatePool). So this might not be a vulnerability unless there's a way to trigger them unauthorized.

After considering these points, the main vulnerabilities to list are:

1. Incorrect ERC20 Decimals Handling when borrowAsset is not an ERC20.
2. Potential Self-Lending by Borrower using a different address.
3. Reentrancy in _beforeTokenTransfer due to external calls during token transfers.
4. Centralization Risk with Owner's ability to terminatePool and withdraw collateral.
5. Possible Margin Call End Time Calculation Error.

But need to verify which of these are actual vulnerabilities versus design choices or false positives.

For example, the self-lending is a vulnerability only if the lenderVerifier is not properly enforced. If the lenderVerifier is set, then it's mitigated. But if it's not, then the borrower can self-lend. So the contract's vulnerability here is that when lenderVerifier is not set, the borrower can fund their own loan, leading to possible fraud.

The decimals issue is a real problem if the borrowAsset has a different decimal count than 18 and the try/catch fails. For example, if the borrowAsset is USDC (6 decimals) but the pool token uses 18, then the accounting would be off by 12 orders of magnitude. This would break the logic for shares, repayments, etc.

The reentrancy in _beforeTokenTransfer is a possible issue if the token being transferred allows reentrancy. Since the _withdrawRepayment function uses SafeERC20's safeTransfer, which should handle this, but the _beforeTokenTransfer is part of the ERC20 transfer which isn't protected by nonReentrant. However, since the functions that call transfer (like transfer, transferFrom) are part of ERC20 and not marked with nonReentrant, this is a possible issue. For example, during a transfer, if the token's transfer calls back into the contract, the state may not have been updated yet, leading to reentrancy attacks.

The centralization risk with the owner's ability to terminate the pool and withdraw collateral is a vulnerability if the protocol is intended to be decentralized. The owner could misuse this privilege.

The margin call end time calculation may not be an error, depending on the intended logic. The code checks if block.timestamp is greater than the marginCallEndTime plus twice the marginCallDuration. If the marginCallDuration is the time given to the lender to respond, then adding twice might not be correct, but this is speculative.

Other possible issues: 

- The initialize function uses .add(_collectionPeriod) to set loanStartTime. If _collectionPeriod is very large, this could overflow. However, since SafeMath is used, it would revert. But in Solidity 0.7, SafeMath is not enabled by default for uint256, but the contract uses SafeMath for uint256 via the using statement. So additions are checked.

- In the cancelPool function, if the borrower cancels after loanWithdrawalDeadline, they can do so only if certain conditions are met. However, the code has a require(msg.sender == borrower) only if loanWithdrawalDeadline > block.timestamp. Otherwise, anyone can call cancelPool? Let's check:

In cancelPool(), after checking if the pool is in COLLECTION status, the code checks if _loanStartTime < block.timestamp and if the totalSupply is less than minBorrowFraction. If so, it calls _cancelPool(0). Otherwise, if _loanWithdrawalDeadline > block.timestamp, requires msg.sender is borrower. If _loanWithdrawalDeadline <= block.timestamp, then anyone can call cancelPool(). So after the deadline, anyone can cancel the pool. But what if the pool is in COLLECTION and past the deadline? Then anyone can cancel, which might be intended. But if the borrower hasn't withdrawn, this allows cancellation. That's part of the design.

Another thing: the _deposit function has a parameter _poolSavingsStrategy which is passed in some cases. In the lend function, the strategy is provided as an argument. If a malicious strategy is provided, it could cause issues. However, the _deposit function uses the poolSavingsStrategy when _toSavingsAccount is true, but in the lend function, _toSavingsAccount is false. Wait, in the lend function, the _deposit is called with _toSavingsAccount=false. So the strategy provided by the lender is used for depositing from the lender's savings account. But if the lender can specify any strategy, including a malicious one, it could lead to loss of funds. However, the code in the _deposit function, when _fromSavingsAccount is true, uses the _strategy provided. If the lender can pass a malicious strategy, then when depositing from their savings account, they could potentially manipulate the shares. For example, a strategy that mints extra shares. But this would depend on the SavingsAccountUtil functions properly validating the strategy. However, if the strategy is not validated, this is a vulnerability. But the pool's code may assume that strategies are trusted, perhaps enforced by the factory. If not, this is a problem. So the lend function allows a lender to specify any strategy when depositing from their savings account. If the strategy is malicious, it could steal funds or mint incorrect shares. This is a possible vulnerability if the strategy isn't validated by the contract or factory.

But looking at the code, the lend function's parameters include _strategy. The function doesn't check if the strategy is valid or approved. So a lender could pass a malicious strategy address, leading to potential loss of funds. For example, when _fromSavingsAccount is true, the lender's funds are moved via the strategy. If the strategy is malicious, it could perform a reentrancy attack or manipulate the shares. However, the _deposit function's SavingsAccountUtil.depositFromSavingsAccount function would interact with the strategy. If the strategy is not part of the protocol's approved list, this could be a problem. This is a vulnerability if the contract doesn't enforce that the strategy is valid.

In the initialize function, the poolSavingsStrategy is set, but in the lend function, the _strategy is provided by the lender. So this allows lenders to choose different strategies for their deposits. If strategies are not properly vetted, this could be risky. However, the code may intend for lenders to use their own strategies. But if a malicious strategy is used, it could affect the pool's accounting. For example, if the strategy doesn't correctly account for shares, the lender could deposit less tokens but receive more shares, leading to an unfair advantage. This is a vulnerability if the pool doesn't restrict strategies to trusted ones.

Therefore, the vulnerabilities are:

1. **Incorrect Decimal Handling for Non-ERC20 Borrow Assets**: Leading to miscalculations in token amounts.

2. **Self-Lending Vulnerability**: Borrowers can fund their own loans via alternate addresses when lenderVerifier is not set.

3. **Reentrancy in Token Transfers via _beforeTokenTransfer**: Due to external calls during token transfer hooks.

4. **Malicious Strategy in lend Function**: Lenders can specify arbitrary strategies, potentially leading to loss of funds or incorrect share calculations.

5. **Centralization Risk with Owner's terminatePool Function**: Owner can withdraw all collateral, leading to potential misuse.

6. **Insufficient Validation of Margin Call End Time**: Potential miscalculation leading to incorrect margin call expirations.

But need to verify each.

Final list after evaluating:

- The decimal handling when the borrow asset's decimals call fails is a vulnerability.

- The self-lending via alternate addresses when lenderVerifier is not enforced.

- Reentrancy in _beforeTokenTransfer via malicious ERC20 tokens.

- Unrestricted strategy in lend allowing malicious strategies.

- Owner's centralization risk.

These are the main vulnerabilities.","```
None.
```",0.0,0
YearnYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into YVault
 * @author Sublime
 **/
contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        //mint vault
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        //lock collateral in vault
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1949.0,240.0,"[H-04] Yearn token <> shares conversion decimal issue
The yearn strategy `YearnYield` converts shares to tokens by doing pricePerFullShare * shares / 1e18:
``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
    if (shares == 0) return 0;
    // @audit should divided by vaultDecimals 
    amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
}
```
But Yearn's `getPricePerFullShare` seems to be in `vault.decimals()` precision, i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same as the underlying token decimals",1.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';


contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    mapping(address => address) public override liquidityToken;

    
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1345.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Storage Layout Corruption**  
   - **Issue**: The contract inherits from both `OwnableUpgradeable` (upgradeable) and `ReentrancyGuard` (non-upgradeable), causing storage layout conflicts. The `ReentrancyGuard`'s `_status` variable and `OwnableUpgradeable`'s `_owner` variable compete for the same storage slot, leading to state corruption.  
   - **Impact**: Reentrancy protection is compromised, and critical variables like ownership may be overwritten, enabling reentrancy attacks and loss of control over the contract.

2. **Undefined Event `SavingsAccountUpdated`**  
   - **Issue**: The contract emits `SavingsAccountUpdated` in `_updateSavingsAccount`, but the event is not declared anywhere.  
   - **Impact**: Transactions invoking `initialize` or `updateSavingsAccount` will revert at runtime, breaking core functionality.

3. **Reentrancy Risk in `unlockShares`**  
   - **Issue**: The `unlockShares` function lacks the `nonReentrant` modifier and uses `safeTransfer` to send tokens. If the `savingsAccount` is malicious and the token implements callbacks, reentrancy attacks could occur.  
   - **Impact**: Potential reentrancy leading to fund theft or state manipulation if the `savingsAccount` is compromised.

4. **Division by Zero in `getSharesForTokens`**  
   - **Issue**: If `getTokensForShares(1e18, asset)` returns zero (e.g., due to an uninitialized or failed vault), `getSharesForTokens` will divide by zero.  
   - **Impact**: Function calls revert, causing denial-of-service in dependent systems or UIs.

5. **Incorrect Vault Withdrawal Handling**  
   - **Issue**: `emergencyWithdraw` assumes the vault sends withdrawn assets directly to the contract. If the vault sends assets elsewhere, `received` will be zero, resulting in failed transfers or loss of funds.  
   - **Impact**: Incorrect asset tracking during withdrawals, potentially locking funds permanently.

6. **Outdated Compiler and Libraries**  
   - **Issue**: Uses Solidity 0.7.6 with deprecated SafeMath (not inherently a vulnerability but increases reliance on legacy code).  
   - **Impact**: Increased risk of undetected issues due to outdated dependencies.

7. **Insecure `approve` Usage in `_depositERC20`**  
   - **Issue**: Uses `approve(0)` followed by `approve(amount)` instead of OpenZeppelin’s `safeApprove`. While compliant with most ERC20s, it may fail for tokens requiring strict allowance checks (e.g., USDT).  
   - **Impact**: Deposit failures for non-compliant tokens, blocking user interactions.

8. **Centralized Emergency Withdrawals**  
   - **Issue**: The `emergencyWithdraw` function allows the owner to withdraw all assets arbitrarily.  
   - **Impact**: Centralization risk; a malicious or compromised owner can drain all funds.

These vulnerabilities range from critical (storage corruption, undefined events) to medium severity (reentrancy, division errors).","### **[H-04] Yearn token <> shares conversion decimal issue**

**Report Description**:  
The `YearnYield` strategy converts shares to tokens using the formula `pricePerFullShare * shares / 1e18`. However, Yearn's `getPricePerFullShare` returns values in `vault.decimals()` precision, meaning the correct formula should be `pricePerFullShare * shares / (10 ** vault.decimals())`. The current implementation assumes a fixed precision of `1e18`, which is incorrect if the vault's decimals differ from 18. This discrepancy can lead to incorrect token calculations, potentially causing financial losses or accounting errors when interacting with Yearn vaults.

**Match in Response List**:  
**No match found**. The response list does not address the issue of incorrect decimal handling in the `YearnYield` strategy's token-to-shares conversion.

**Validation**:  
**Incorrect**. The response list does not identify or address the issue of incorrect decimal handling in the `YearnYield` strategy. This is a critical oversight, as the mismatch in decimal precision can lead to significant financial discrepancies. Solidity best practices emphasize the importance of correctly handling token decimals, especially when interacting with external protocols like Yearn.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-04] Yearn token <> shares conversion decimal issue**",0,0,1,8,"Okay, let me take a look at this smart contract and try to identify any vulnerabilities. Hmm, the contract is called YearnYield and it's using OpenZeppelin's OwnableUpgradeable, ReentrancyGuard, and some SafeERC20 and SafeMath libraries. It interacts with a yVault for deposits and withdrawals.

First, I'll start by checking common issues. Since the contract uses initializable, it's an upgradeable contract. But wait, the initialize function is called with __Ownable_init() and then transfers ownership. But in OpenZeppelin's upgradeable contracts, the owner is set in the __Ownable_init during initialization. However, here they call super.transferOwnership(_owner) after initializing. That might be okay, but maybe there's a risk if the initializer isn't properly secured. However, the initializer modifier is present, so maybe that's fine.

Looking at the modifiers, there's a onlySavingsAccount modifier that checks the sender is the savingsAccount address. The savingsAccount is set by the owner. So if the owner is compromised, they could change the savingsAccount to a malicious address. But that's more of an admin risk rather than a code vulnerability.

Now, looking at the emergencyWithdraw function. It's onlyOwner and nonReentrant. It withdraws assets to a specified wallet. The problem here might be that the owner can withdraw any asset at any time, which could be a centralization risk. But the question is about vulnerabilities in the code, not trust issues. So maybe that's not a vulnerability per se, but more of a design choice.

Next, the lockTokens function. If the asset is ETH, it checks that msg.value equals the amount. Then it deposits into the vault. But what if the vault's depositETH function doesn't use all the sent ETH? For example, if the vault's depositETH requires a specific amount but the contract sends msg.value, there might be leftover ETH. However, in this case, the code uses the amount variable which is passed as an argument. Wait, but in the function, when asset is address(0), they require msg.value == amount. So the user sends ETH equal to the amount, which is then passed to _depositETH. But in _depositETH, the code calls IyVault(vault).depositETH{value: amount}(); which uses the entire amount. So that should be okay. But maybe if the vault's depositETH function doesn't handle the entire amount, but that's an external dependency issue. Not sure if that's a vulnerability here.

Another thing: in _depositERC20, the function first approves 0 and then the amount. This is a common pattern to handle tokens that require resetting approval. But some tokens might not handle this correctly. However, using SafeERC20's safeApprove might be better, but the code uses approve directly. Wait, the code is using SafeERC20 for IERC20, but when they do IERC20(asset).approve(vault, 0), that's using the standard approve function. The SafeERC20 library has safeApprove which is safer. So using approve instead of safeApprove might be a vulnerability here. Because some tokens may not revert on failed approvals, leading to potential issues. For example, if the previous approval was non-zero, and you try to set it to a new non-zero value without first setting to zero, some tokens (like USDT) require that. But the code here does approve(0) first, then approve(amount), which should be compliant. But using safeApprove would be safer to handle those cases. So maybe this is a potential issue.

In the unlockShares function, it transfers the asset (which is the liquidity token) to the savingsAccount. But what if the asset is not a valid ERC20? The code uses safeTransfer, which is from SafeERC20, so that should check for success. So that's probably okay.

Looking at the getSharesForTokens function. It calculates shares as (amount * 1e18) / getTokensForShares(1e18, asset). Wait, getTokensForShares with 1e18 shares would return the price per full share multiplied by 1e18, divided by 1e18, which is the price per share. So getTokensForShares(1e18, asset) returns the price per share. Then shares = (amount * 1e18) / price per share. But division can lead to truncation. However, this is a common approach. But if the price per share is very low, this could lead to incorrect share calculations. But maybe that's how the vault works. Not sure if this is a vulnerability or just normal behavior.

Another point: the contract uses SafeMath, but since Solidity 0.8, SafeMath isn't needed. However, the pragma is 0.7.6, so SafeMath is necessary. So that's okay.

ReentrancyGuard is used, and nonReentrant modifiers are present in the functions that perform external calls. But let's check which functions have the modifier. The lockTokens and unlockTokens functions have nonReentrant, as well as emergencyWithdraw. That's good.

But in the unlockShares function, there's no nonReentrant modifier, but it transfers the asset. Since the asset is a liquidity token (like a yVault token), transferring it should be safe, unless the token has a callback mechanism. But ERC20 transfers generally don't have reentrancy issues. So maybe it's okay. Although, if the liquidity token is malicious and has a hook, it could re-enter. But since the contract uses nonReentrant in other functions, maybe unlockShares should have it too. But since it's using safeTransfer which is a standard ERC20, perhaps it's considered safe. However, if the savingsAccount is a contract that does something on receiving tokens, it could re-enter. But the onlySavingsAccount modifier ensures that only the savingsAccount can call unlockShares, so maybe the reentrancy is controlled. Not sure if this is a vulnerability.

Another thing: the emergencyWithdraw function allows the owner to withdraw any amount from the vault. The function checks the balance of the liquidityToken in this contract and withdraws that amount. But if the contract's balance of the liquidityToken is not the total shares, perhaps due to multiple deposits, this might not account for all shares. Wait, no: the code does IERC20(investedTo).balanceOf(address(this)) which is the correct way to get the current shares. Then it withdraws that amount. So that's correct.

In _depositETH, after depositing, it calculates sharesReceived as the difference in balance. That's correct. Same for _depositERC20. Similarly for withdrawals, they check the difference in balance. That seems okay.

The receive() external payable function allows the contract to receive ETH. But when would that happen? For example, if someone sends ETH directly, it would be stuck unless there's a function to handle it. But the contract's functions that handle ETH are specific. However, if the vault's withdrawETH function sends ETH to the contract, that's handled. But in the unlockTokens function, when asset is ETH, they withdraw and send to savingsAccount. So maybe the receive function is necessary here.

Another potential issue: the contract uses the Initializable and OwnableUpgradeable. Since it's an upgradeable contract, the state variables should be in the correct order, but I don't think that's an issue here. However, the contract doesn't use a constructor because it's upgradeable. Instead, it uses the initialize function, which is correct.

Wait, the OwnableUpgradeable's __Ownable_init() sets the owner to msg.sender. But then the initialize function calls super.transferOwnership(_owner). But in the context of upgradeable contracts, the initializer is called by the deployer, so the owner would be set to the deployer first, and then transferred to _owner. However, the code uses super.transferOwnership(_owner), which is using the OwnableUpgradeable's transferOwnership function. But in the initialize function, the contract is using OwnableUpgradeable's functions. That should be okay, but maybe there's a front-running vulnerability here if the initialize is called multiple times, but the initializer modifier prevents that.

Another thing: the liquidityToken mapping is set by the owner via updateProtocolAddresses. If the owner sets a malicious vault address, then deposits could be stolen. But again, that's an admin risk. However, in the code's context, the owner is trusted to set the correct vault addresses. So that's not a code vulnerability per se.

What about the getTokensForShares function? It uses IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18). The pricePerFullShare is a common way vaults calculate the value, but if the vault's price is manipulable (like in some cases where the vault is a low liquidity pool), then the returned value could be incorrect. But this is dependent on the vault's implementation, not this contract's code. So maybe not a vulnerability here.

In the unlockShares function, transferring the asset (liquidity token) to the savingsAccount. But the function is called by the savingsAccount, which is supposed to be a trusted contract. However, if the savingsAccount is malicious, they could drain the contract's liquidity tokens by calling unlockShares. But the onlySavingsAccount modifier ensures that only the savingsAccount can call it. So if the savingsAccount is compromised, that's a problem. But again, it's a trust issue rather than a code vulnerability.

Wait, in unlockShares, if the contract holds shares for multiple users, transferring the shares to savingsAccount would mix them. But the contract's design might be such that the savingsAccount manages all shares. It's possible that the contract is designed to hold shares collectively and the savingsAccount tracks individual users' shares. So if the contract is acting as a middleman, the savingsAccount has to properly account for each user's shares. If not, there could be accounting errors. But this is a design flaw, not a code vulnerability.

Looking for possible reentrancy again. The nonReentrant modifier is used in lockTokens, unlockTokens, and emergencyWithdraw. But unlockShares doesn't have it. When unlocking shares, the code does IERC20(asset).safeTransfer(savingsAccount, amount);. The safeTransfer function is from SafeERC20, which uses a low-level call and checks the return value. If the asset is a malicious ERC20 token that calls back into the contract, it could potentially re-enter. But since the liquidityToken is set by the owner, and assuming the owner sets legitimate vault tokens, this might not be an issue. However, if the owner sets a malicious liquidityToken, then when unlockShares is called, the safeTransfer could re-enter. But the nonReentrant modifier isn't present here, so a reentrancy attack could occur. However, unlockShares has the onlySavingsAccount modifier, so only the savingsAccount can call it. If the savingsAccount is a malicious contract that calls back into unlockShares during the transfer, it could re-enter. For example, during the safeTransfer, the savingsAccount's onERC20Received function could call unlockShares again. Since nonReentrant is not present on unlockShares, this could allow reentrancy. But the unlockShares function is protected by onlySavingsAccount, not by nonReentrant. So if the savingsAccount is compromised, they could re-enter. But this is a possible reentrancy vulnerability if the savingsAccount is malicious. However, given that the savingsAccount is supposed to be a trusted contract set by the owner, maybe this is considered a trust issue. But from a code perspective, it's a vulnerability because the unlockShares function doesn't have nonReentrant, allowing reentrancy if the savingsAccount is malicious.

Another point: in the emergencyWithdraw function, when the asset is ETH, it calls _withdrawETH, which in turn calls IyVault(vault).withdrawETH(amount). Then the received ETH is calculated as the difference in the contract's balance. However, if the vault's withdrawETH function doesn't send all the ETH immediately, or sends it via a transfer (which could fail), the received calculation might be incorrect. For example, if the vault uses a withdraw function that doesn't send ETH directly but uses a push mechanism, but in the code, _withdrawETH uses the balance difference. If the vault's withdrawETH function correctly sends ETH to the contract, then the balance difference would be accurate. But if the vault's function has a reentrancy issue itself, that could affect this contract. However, the nonReentrant modifier is applied to emergencyWithdraw, so the contract's functions are protected. But the vault's functions could have their own issues, which is outside the scope here.

What about the use of SafeMath? Since the contract is using Solidity 0.7.6, and SafeMath is included, all arithmetic operations should be using SafeMath. Let's check the code. For example, in getTokensForShares, shares.mul(...).div(1e18). Since using SafeMath, division is safe, but multiplication could overflow. But SafeMath would catch that. So that's okay.

Another possible issue: in the getSharesForTokens function, shares is calculated as (amount * 1e18) / getTokensForShares(1e18, asset). But if getTokensForShares returns zero, this would cause a division by zero. For example, if the liquidityToken[asset] is not set, or if the vault's getPricePerFullShare returns zero. So if an asset is not configured properly (liquidityToken not set), calling getSharesForTokens could revert due to division by zero. But since the function is external and view, an attacker could cause a revert in this function, but it's not a vulnerability that allows fund theft. It's more of a potential denial-of-service if the frontend relies on this function without proper checks.

Also, in updateProtocolAddresses, the owner can set liquidityToken for any asset. If an incorrect vault is set for an asset, users depositing that asset would have their funds sent to the wrong vault. That's an admin risk, but again, not a code vulnerability.

Looking at the event declarations. The event ProtocolAddressesUpdated is emitted when updateProtocolAddresses is called. The event parameters include the asset and protocolToken. However, the event SavingsAccountUpdated is emitted in _updateSavingsAccount, but looking at the code provided, the event is not declared in the contract. Wait, the code includes the line 'emit SavingsAccountUpdated(_savingsAccount);' in _updateSavingsAccount, but the event isn't declared in the contract code shown. That would cause a compilation error. Because the contract doesn't define the SavingsAccountUpdated event. So that's a bug. The code tries to emit an event that isn't declared. That's definitely a vulnerability.

So, in the initialize function and _updateSavingsAccount, they emit SavingsAccountUpdated, but the event isn't declared in the contract. The events declared are ProtocolAddressesUpdated, LockedTokens, UnlockedTokens, UnlockedShares. The SavingsAccountUpdated is missing. So this would cause the contract to fail to compile, but if it's deployed somehow, the emit would fail, reverting the transaction. But assuming that the code is supposed to have that event, it's a mistake.

Another possible issue: the contract uses the override keyword in the liquidityToken mapping, which suggests that the IYield interface defines a liquidityToken function. The mapping is declared as mapping(address => address) public override liquidityToken;. The public visibility will automatically create a getter function that matches the interface. But if the IYield interface expects a different function signature, this could cause an issue. For example, if the interface expects a function liquidityToken(address) external view returns (address), then the mapping's getter is correct. So probably okay.

In the lockTokens function, when asset is not ETH, it transfers the asset from the user to the contract. Then deposits into the vault. But if the user has approved more than the amount, the transferFrom would still only transfer the amount. But since the code uses safeTransferFrom, that should be okay.

Another point: the contract imports from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol' but also imports from non-upgradeable ReentrancyGuard, SafeERC20, SafeMath. Mixing upgradeable and non-upgradeable contracts can cause issues because upgradeable contracts should use upgradeable versions of libraries to avoid storage conflicts. For example, ReentrancyGuard from the standard contracts is not upgradeable, and using it in an upgradeable contract might lead to storage layout issues if the guard has its own storage variables. However, ReentrancyGuard from OpenZeppelin doesn't have storage variables in the standard version. Wait, the standard ReentrancyGuard uses a uint256 private _status; variable. If the contract is upgradeable and uses the non-upgradeable ReentrancyGuard, then the storage layout could clash if the parent contracts have variables that aren't accounted for in the upgradeable contract's storage. So in this case, since the contract is Initializable and uses OwnableUpgradeable (which is upgradeable), but ReentrancyGuard is from the non-upgradeable contracts, this could lead to storage layout conflicts. Because the non-upgradeable ReentrancyGuard's _status variable would be stored in a different slot than expected in an upgradeable contract. This is a critical vulnerability because storage layouts in upgradeable contracts must be append-only and carefully managed. Mixing non-upgradeable and upgradeable contracts can break the storage layout, leading to critical vulnerabilities where variables are overwritten or accessed incorrectly.

So this contract inherits from ReentrancyGuard, which is not the upgradeable version. Therefore, the _status variable in ReentrancyGuard would be stored at a different position than if it were using the upgradeable version. Since OwnableUpgradeable is an upgradeable contract, and YearnYield is Initializable, the storage layout starts from the first slot. The ReentrancyGuard's _status variable would be stored at slot 0 (assuming no other variables before it), but in the upgradeable context, the Initializable contract uses a storage slot for initialized and initializing, and OwnableUpgradeable has _owner. So the storage variables would clash. For example, OwnableUpgradeable's _owner is at slot 0 (since it's the first variable in the upgradeable contract), but ReentrancyGuard's _status would also try to be at slot 0 if it's the first variable in the contract. This would cause a storage collision, leading to critical vulnerabilities where the _owner and _status variables overwrite each other's storage slots.

This is a major issue. The contract uses ReentrancyGuard from the non-upgradeable OpenZeppelin contracts, which is incompatible with upgradeable contracts. Therefore, the storage layout is corrupted, making the contract's reentrancy guard ineffective and potentially allowing reentrancy attacks despite the nonReentrant modifier. Additionally, the _owner variable from OwnableUpgradeable could be stored in the same slot as _status, leading to ownership being overwritten or other critical storage corruption.

Another storage issue: the contract declares 'address payable public savingsAccount;' which is a state variable. In upgradeable contracts, the order of state variables must remain consistent across upgrades. Since the contract is Initializable, and uses OwnableUpgradeable (which has _owner in their storage), then savingsAccount is the next variable. But if ReentrancyGuard is added, its variables would be in between. However, since ReentrancyGuard is not upgradeable, this would mess up the storage.

Therefore, the main vulnerabilities are:

1. **Storage Layout Corruption** due to mixing upgradeable and non-upgradeable contracts (ReentrancyGuard), leading to critical storage collisions.
2. **Missing Event Declaration** for SavingsAccountUpdated, causing runtime errors when the event is emitted.
3. **Use of approve instead of safeApprove** in _depositERC20, which could fail for tokens that require safeApprove.
4. **Potential Reentrancy in unlockShares** if the savingsAccount is malicious and the liquidity token allows callbacks.
5. **Division by Zero in getSharesForTokens** if getTokensForShares returns zero, leading to reverts.

Let me verify each of these again.

First, the storage layout issue is critical. Using non-upgradeable ReentrancyGuard in an upgradeable contract is a big problem. The ReentrancyGuard has a _status variable at slot 0, but OwnableUpgradeable's _owner is at slot 0 (since upgradeable contracts use their own storage layout). This collision means that when the ReentrancyGuard checks or modifies _status, it's actually interacting with the _owner variable, rendering the reentrancy guard ineffective. This is a critical vulnerability allowing reentrancy attacks even with the nonReentrant modifier.

Second, the SavingsAccountUpdated event is emitted but not declared, which would cause a compile-time error. If the code was deployed somehow, the transaction would revert when trying to emit the event. This is a high-severity issue because the function calls that emit the event would fail, preventing the contract from being initialized or updated properly.

Third, the use of approve instead of safeApprove. OpenZeppelin's SafeERC20 provides safeApprove which handles tokens that require the allowance to be set to zero first. However, the code does IERC20(asset).approve(vault, 0); followed by IERC20(asset).approve(vault, amount);. For most tokens, this is sufficient, but some tokens (like USDT) require the allowance to be zero before changing it. However, the code does set it to zero first, so it should be okay. Wait, SafeERC20's safeApprove function includes checks for this scenario. But the code isn't using safeApprove, it's using the standard approve. So even though they set to zero first, some tokens might still not handle it correctly. For example, if the current allowance is non-zero, and you first set to zero and then to a new value in separate txs, but here it's done in the same tx. However, some tokens (like USDT) only allow approve to be called when the current allowance is zero. In such cases, the code's approach of approve(0) followed by approve(amount) in the same transaction would fail because after the first approve(0), the second approve(amount) would be called when the current allowance is zero. Wait, no: after the first approve(0), the allowance is zero. Then, the second approve(amount) is allowed. So even for tokens that require the allowance to be zero first, this should work. So maybe this is not a vulnerability. Thus, maybe point 3 is invalid.

Fourth, the unlockShares function lacks the nonReentrant modifier. If the savingsAccount is a malicious contract that re-enters during the safeTransfer, it could call back into the contract's functions. However, since unlockShares is only callable by the savingsAccount, and the nonReentrant modifier is on other functions, maybe the risk is limited. For example, if the savingsAccount calls unlockShares again during the transfer, the second call would be allowed because unlockShares doesn't have nonReentrant. This could allow recursive calls. But since the function is only callable by the savingsAccount, it's up to the savingsAccount's behavior. However, if the savingsAccount is compromised, this could be a reentrancy vector. But the likelihood is low unless the savingsAccount is malicious. So this is a potential vulnerability but might be considered low severity depending on context.

Fifth, division by zero in getSharesForTokens. If getTokensForShares(1e18, asset) returns zero, the division would fail. This could happen if the vault's price per share is zero, which could be due to a malfunctioning vault or a vault that hasn't been initialized. This would cause the function to revert, but it's a view function, so it doesn't directly impact the contract's state. However, any contract or UI relying on this function would fail when this happens. This is a medium-severity issue as it could lead to denial of service in dependent systems.

Other issues:

- In the emergencyWithdraw function, the code calls IyVault(vault).withdrawETH(amount); when the asset is ETH. The received variable is calculated based on the balance difference. However, if the vault's withdrawETH function doesn't send ETH to the contract but to another address, the received would be zero, and the function would proceed to send zero ETH to _wallet. But the code checks received after withdrawal and sends it. So if the vault's withdrawal doesn't send ETH to this contract, received would be zero, and the function would effectively do nothing. This could lead to loss of funds if the vault's withdrawal function is misconfigured.

- The contract uses the Initializable pattern but doesn't have a constructor with the initializer modifier. However, since it's an upgradeable contract, the constructor should be empty and marked with the initializer modifier. Wait, in the given code, the contract has an initialize function marked with initializer. The constructor in upgradeable contracts is replaced by the initialize function, so this part is correct.

Another thing to check: the use of super.transferOwnership(_owner) in the initialize function. Since the contract uses OwnableUpgradeable, the __Ownable_init() function initializes the owner to msg.sender (the deployer), and then the code transfers ownership to _owner. However, in the context of upgradeable contracts, using transferOwnership in the initialize function is correct if the intent is to set the owner to a different address than the deployer. So that's okay.

So compiling all the issues, the main vulnerabilities are:

1. **Storage Collision Due to Non-Upgradeable ReentrancyGuard**: The contract inherits from ReentrancyGuard (non-upgradeable) and OwnableUpgradeable (upgradeable), causing storage layout conflicts. This can lead to critical vulnerabilities like disabled reentrancy protection and corrupted state variables.

2. **Undefined Event SavingsAccountUpdated**: The contract emits an event that is not declared, leading to runtime errors when the function is called.

3. **Potential Reentrancy in unlockShares**: Lack of nonReentrant modifier allows reentrancy if the savingsAccount is malicious and the token supports callbacks.

4. **Division by Zero in getSharesForTokens**: If getTokensForShares returns zero, the division will revert, causing potential denial-of-service.

5. **Incorrect Handling of Vault Withdrawals**: If the vault's withdrawal functions do not send ETH/ERC20 tokens to the contract, the received amount would be zero, leading to loss of funds during emergencyWithdraw.

6. **Use of Deprecated SafeMath and Solidity Version**: While not a vulnerability per se, using an older Solidity version (0.7.6) without the built-in overflow checks (relying on SafeMath) is outdated, but since SafeMath is used correctly, it's not a vulnerability.

The most critical issues are the storage collision and the undefined event.","```
None.
```",0.0,0
AaveYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into Aave protocol
 * @author Sublime
 **/
contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of wethGateway used to deposit ETH to aave
     */
    address public wethGateway;

    /**
     * @notice address of protocolDataProvider which provides info about aTokens related to any token
     */
    address public protocolDataProvider;

    /**
     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token
     */
    address public lendingPoolAddressesProvider;

    /**
     * @notice address of savings account contract
     */
    address payable public savingsAccount;

    /**
     * @notice aave referral code to represent sublime
     */
    uint16 public referralCode;

    /**
     * @notice emitted when aave protocol related addresses are updated
     * @param wethGateway address of wethGateway
     * @param protocolDataProvider address of protocol data provider
     * @param lendingPoolAddressesProvider address of lending pool addresses provider
     */
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    /**
     * @notice emitted when aave referral code is updated
     * @param referralCode updated referral code
     */
    event ReferralCodeUpdated(uint16 referralCode);

    /**
     * @notice verifies if savings account invoked the contract
     */
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice To initialize the contract addresses interacting with this contract
     * @dev can only be initialized once
     * @param _owner address of owner
     * @param _savingsAccount address of the savings account contract
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider the address of ProtocolDataProvider
     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider
     **/
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return aToken address of liquidity token
     **/
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    /**
     * @notice used to update savings account address
     * @dev only owner can update
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update aave protocol related addresses
     * @dev only owner can update
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider address of protocol data provider
     * @param _lendingPoolAddressesProvider address of lending pool addresses provider
     */
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice used to update referral code
     * @dev only owner can update
     * @param _referralCode updated referral code
     */
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @notice Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //lock collateral
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //approve collateral to vault
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        //lock collateral in vault
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        //lock collateral
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        //withdraw collateral from vault
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",2772.0,335.0,"[H-05] Aave's share tokens are rebasing breaking current strategy code
When depositing into Aave through the `AaveYield.lockTokens` contract strategy, one receives the sharesReceived amount corresponding to the diff of aToken balance, which is just always the deposited amount as aave is a rebasing token and 1.0 aToken = 1.0 underlying at each deposit / withdrawal.
Note that this `sharesReceived` (the underlying deposit amount) is cached in a `balanceInShares` map in SavingsAccount.deposit which makes this share static and not dynamically rebasing anymore:
  [M-07] AaveYield: Misspelled external function name making functions fail
- liquidityToken
- _withdrawETH
- _depositETH
Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`",2.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';


contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public wethGateway;

    
    address public protocolDataProvider;

    
    address public lendingPoolAddressesProvider;

    
    address payable public savingsAccount;

    
    uint16 public referralCode;

    
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    
    event ReferralCodeUpdated(uint16 referralCode);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",1924.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Division by Zero in `getTokensForShares`**:  
   If the contract's aToken balance is zero and a non-zero `shares` value is provided, the calculation `div(IERC20(aToken).balanceOf(address(this)))` will revert due to division by zero. This can occur if the contract has not yet deposited any assets into Aave.

2. **Unsafe ERC20 `approve` Usage**:  
   The contract directly uses `approve` instead of OpenZeppelin's `safeApprove`, which can fail for non-compliant ERC20 tokens (e.g., USDT) that do not return a boolean. This could cause transactions to revert unexpectedly.

3. **Division by Zero in `getSharesForTokens`**:  
   If `getTokensForShares(1e18, asset)` returns zero (e.g., when the contract has no aTokens), the division `div(getTokensForShares(...))` will revert, making the function unusable for new assets until deposits occur.

4. **Stranded Native ETH**:  
   Direct ETH transfers to the contract (outside of `lockTokens`) become irrecoverable via `emergencyWithdraw`, as it only withdraws aWETH-converted ETH. This leaves native ETH stuck in the contract.

5. **Unrestricted ERC20 Withdrawal via `unlockShares`**:  
   The `unlockShares` function allows the savings account to withdraw any ERC20 token held by the contract, including non-aTokens. This could lead to unintended loss of funds if the contract holds other tokens.

6. **Centralization Risks**:  
   The contract owner can update critical addresses (e.g., `wethGateway`, `protocolDataProvider`) and withdraw all funds via `emergencyWithdraw`. If compromised, this could result in fund loss.

7. **Missing Reentrancy Guard on `emergencyWithdraw`**:  
   While other functions use `nonReentrant`, `emergencyWithdraw` lacks this protection. Though limited to the owner, a malicious owner could exploit reentrancy during ETH transfers.

8. **Outdated Solidity Version (0.7.6)**:  
   Older compiler versions may contain unpatched bugs. While SafeMath is used, newer versions (e.g., 0.8.x) offer integrated overflow checks and security improvements.

9. **Inconsistent ETH Handling**:  
   The contract assumes ETH is always wrapped via WETHGateway, but direct ETH transfers are not properly managed, leading to inconsistencies in asset tracking.","### **[H-05] Aave's share tokens are rebasing breaking current strategy code**

**Report Description**:  
When depositing into Aave through the `AaveYield.lockTokens` contract strategy, the `sharesReceived` amount corresponds to the difference in `aToken` balance. However, since Aave is a rebasing token, `1.0 aToken = 1.0 underlying` at each deposit/withdrawal. The `sharesReceived` (the underlying deposit amount) is cached in a `balanceInShares` map in `SavingsAccount.deposit`, making this share static and not dynamically rebasing. This design flaw can lead to incorrect accounting of user balances, especially when Aave's rebasing mechanism adjusts the underlying token value.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of Aave's rebasing tokens and the static caching of `sharesReceived`. This is a critical oversight, as it directly impacts the contract's ability to accurately track user balances over time. The response list focuses on other vulnerabilities but misses this specific issue entirely.

---

### **[M-07] AaveYield: Misspelled external function names making functions fail**

**Report Description**:  
The `AaveYield` contract contains misspelled external function names (`liquidityToken`, `_withdrawETH`, `_depositETH`), which will cause these functions to fail when called. Additionally, the conditional call to `IWETHGateway(wethGateway).getAWETHAddress()` is not properly implemented, leading to potential failures in ETH handling.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of misspelled function names or the improper implementation of the conditional call to `getAWETHAddress`. These are critical errors that would cause the contract to malfunction, but they are not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-05] Aave's share tokens are rebasing breaking current strategy code**  
- **[M-07] AaveYield: Misspelled external function names making functions fail**

---

### **Analysis of Gaps**  
The response list fails to address two critical issues from the issue report:  
1. The static caching of Aave's rebasing tokens, which leads to incorrect accounting of user balances.  
2. The misspelled function names and improper implementation of the conditional call in the `AaveYield` contract, which would cause the contract to fail.  

These gaps indicate a lack of coverage for issues related to token rebasing and function implementation errors, which are essential for the secure and correct operation of the smart contract.",0,0,2,9,"Okay, let's take a look at this smart contract. The user wants me to list all the vulnerabilities without suggesting mitigations. Let me start by reading through the code carefully.

First, I notice that the contract is using Solidity 0.7.6. That's a bit older. I should check if there are any known issues with that version. Maybe compiler bugs, but I'm not sure yet.

The contract imports OpenZeppelin libraries like OwnableUpgradeable, ReentrancyGuard, SafeERC20, and SafeMath. OwnableUpgradeable suggests this is an upgradeable contract, which might have initialization issues if not handled properly. Let me check the initialize function.

The initialize function calls __Ownable_init() and then transfers ownership to _owner. Wait, in upgradeable contracts, using transferOwnership in the initialize might not be the standard approach. Usually, the initializer would set the owner directly. But maybe that's okay here. Not sure if that's a vulnerability yet.

Looking at modifiers, there's a onlySavingsAccount modifier. The emergencyWithdraw function is onlyOwner, which is good. The lockTokens and unlockTokens functions have the onlySavingsAccount modifier, so they can only be called by the savings account address. That's a permission check, so if that's set correctly, it's fine. But if the savings account is compromised, that's a problem.

The emergencyWithdraw function allows the owner to withdraw any asset to their wallet. Since the owner is a privileged role, if they turn malicious, they can drain funds. But maybe that's by design. The user might consider it a centralization risk, but not a vulnerability per se unless there's a way for unauthorized access.

Looking at the _depositETH function, it uses IWETHGateway's depositETH. The code checks msg.value == amount when asset is ETH. That's correct. But when depositing ETH, they use the WETH gateway. However, the receive() function is present, so maybe someone can send ETH directly, but since the functions are protected by onlySavingsAccount, maybe not. However, any ETH sent directly to the contract outside of the lockTokens function would be stuck unless there's a way to recover it. But the emergencyWithdraw can handle that, so maybe not a big issue.

In the _depositERC20 function, they approve the lendingPool for the amount. But they first set approval to zero. Since some tokens (like USDT) require resetting approval from non-zero to non-zero, using SafeERC20's safeApprove might be better. But here they do approve(0) followed by approve(amount). That should work for most tokens, but maybe there's a front-running risk here. If someone can call the deposit function and the approval is reset before the deposit happens, maybe an attacker could interfere. But that's a bit of a stretch. Not sure if that's a vulnerability.

In the _withdrawETH function, they approve the wethGateway to spend the aWETH tokens. Then call withdrawETH. Wait, the aWETH is the aToken, right? So by approving the gateway, they're allowing it to transfer those tokens. But the correct approach would be to interact with the Aave protocol correctly. Maybe the gateway is supposed to handle that. Assuming the gateway is trusted, but if the gateway is malicious, that's a problem. But the gateway address is set by the owner, so if the owner sets a malicious gateway, that's a vulnerability. But the owner is already a trusted role here.

Looking at the getTokensForShares function, there's a calculation involving scaledBalanceOf and liquidityIndex. Let me check the formula. The code does scaledBalanceOf multiplied by liquidityIndex, then multiplied by shares, divided by aToken balance. Wait, scaledBalanceOf is the scaled balance, and liquidityIndex is the cumulative index. The actual balance should be scaledBalance * liquidityIndex. But the formula here is (scaledBalanceOf * liquidityIndex) * shares / aToken balance. Hmm, maybe this is incorrect. Let me think.

The aToken balance of the contract is the actual balance (since aTokens are 1:1 with the underlying, considering the interest). The scaledBalance is the balance divided by the liquidity index. So to get the underlying amount for shares, perhaps the formula should be shares multiplied by (total underlying) divided by (total aTokens). Wait, maybe the getTokensForShares function is trying to calculate how much underlying tokens correspond to a certain number of shares. If shares represent the aToken amount, then each share is 1:1 with the aToken. But the code here seems to be using a different approach. Let me see:

The code says:

amount = scaledBalanceOf * liquidityIndex * shares / aToken.balanceOf

But scaledBalanceOf is the scaled balance, which when multiplied by liquidityIndex gives the actual aToken balance. So scaledBalanceOf * liquidityIndex = aToken.balanceOf (approximately). Then, shares * (scaledBalanceOf * liquidityIndex) / aToken.balanceOf would be shares * aToken.balanceOf / aToken.balanceOf = shares. So this would make amount = shares. That can't be right. Wait, maybe I'm misunderstanding the variables here.

Alternatively, maybe the formula is trying to compute the proportion of shares relative to the total aTokens. For example, if the contract has X aTokens, and someone has Y shares, then the underlying amount is (Y / X) * (total underlying). But how is the total underlying calculated from aTokens? Since aTokens are pegged 1:1 plus interest, the aToken balance is already the value including interest. So perhaps the getTokensForShares function is wrong.

Wait, if shares are the aTokens themselves, then 1 share = 1 aToken. But in the code, when you deposit, you get shares equal to the aTokens received. For example, in _depositETH, sharesReceived is the difference in aToken balance before and after. So shares are aTokens. Therefore, to get the underlying tokens for shares, it's 1:1. But the code here is doing a more complex calculation. That seems incorrect. So if the contract's aToken balance is, say, 100 aTokens, and someone has 10 shares, then the amount should be 10 aTokens worth of underlying. But the code's formula might not be correct. This could be a critical issue leading to incorrect share calculations, which would affect user funds.

Let me think again. The function getTokensForShares is supposed to return how much underlying tokens correspond to a given number of shares. If shares are aTokens, then it's simply shares * exchange rate. But aTokens already accrue interest, so 1 aToken should be equal to 1 underlying token plus interest. Wait, no: aTokens increase in value over time as interest accrues. So the balance of aTokens doesn't change, but each aToken's value in terms of the underlying increases. Wait, no, actually, aTokens are designed such that each aToken's balance represents the underlying amount plus interest. So when you deposit 1 DAI, you get 1 aDAI, and over time, your aDAI balance remains 1, but when you redeem, you get more DAI. Wait, no: actually, aTokens are rebasing tokens. So the balance of aDAI increases over time. Wait, no, AAVE uses a different approach. The scaledBalance is the balance divided by the liquidity index. The actual balance is scaledBalance * liquidityIndex. So the aToken's balanceOf is the actual amount, which is scaledBalance multiplied by the current liquidity index. Wait, maybe I'm getting confused here.

Let me check AAVE's documentation. In AAVE v2, the aToken's balanceOf returns the actual amount of underlying that the user can redeem. The scaledBalance is the balance divided by the liquidity index. The scaledBalance is stored, and when calculating the actual balance, it's scaledBalance * liquidityIndex. So when a user's aToken balance is queried, it's the scaledBalance multiplied by the current liquidity index.

In the getTokensForShares function, the code is:

amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
    IERC20(aToken).balanceOf(address(this))
);

Wait, let's parse this. Let's say the contract's scaledBalance is S, liquidity index is L. Then the actual aToken balance is S * L. Then, the code is doing (S * L) * shares / (S * L) = shares. So the amount would be shares. But that would mean getTokensForShares(shares) returns shares, which is the same as the aToken balance. That can't be right. Wait, maybe I made a mistake here. Let me think with numbers.

Suppose the contract has 100 aTokens (balanceOf is 100). The scaled balance is S = 100 / L (assuming current liquidity index is L). Then the formula becomes (S * L) * shares / 100 = (100) * shares / 100 = shares. So getTokensForShares(shares) returns shares. That would mean that the function is saying that for each share, you get 1 token. But that's only true if the aToken's balance is 100 and shares are part of that. But shares in this context are the aTokens themselves. So if shares are aTokens, then yes, 1 share would equal 1 token. But that seems redundant. However, the problem comes when the contract's aToken balance doesn't match the actual underlying. Wait, perhaps this function is supposed to calculate the underlying tokens corresponding to the shares (aTokens), considering the interest. But since aTokens already account for interest, the aToken balance is the exact amount of underlying. Therefore, this function's calculation is incorrect because it's multiplying scaledBalance by liquidity index (which gives the current aToken balance) and then multiplying by shares and dividing by the aToken balance. That simplifies to shares. So the function returns shares, which would be correct only if 1 share equals 1 underlying token. However, when you deposit, sharesReceived is the aToken balance difference. So shares are aTokens. Therefore, when you have shares number of aTokens, the underlying amount is shares. So this function is redundant, but correct in that case. Wait, maybe I'm missing something here.

Alternatively, perhaps the function is intended to convert shares (which are aTokens) into the underlying tokens, which should be 1:1. Therefore, if shares are aTokens, then the function should return shares. But in that case, why is this function doing this complex calculation? Maybe there's a misunderstanding here, and the actual formula is wrong. Let me check the variables again.

The function getTokensForShares is supposed to return the amount of underlying tokens that correspond to the given number of shares. If the shares are aTokens, then the amount is equal to the shares multiplied by the exchange rate. Wait, but in AAVE, the exchange rate is 1 aToken = 1 underlying token (plus interest). Wait, no. The aToken's balanceOf already includes the accrued interest. For example, if you deposit 1 DAI, you get 1 aDAI. Over time, the aDAI balance remains 1, but when you redeem, you get 1 DAI plus interest. Wait, no, actually, in AAVE v2, the aToken's balance increases over time. So the aToken balance itself represents the principal plus interest. Therefore, if the contract has 100 aTokens, that's exactly 100 underlying tokens plus the accrued interest. Wait, no. Let me check.

In AAVE, the aToken's balanceOf() returns the amount of underlying tokens plus interest. So if you deposit 1 DAI, you get 1 aDAI. As interest accrues, your aDAI balance increases. Therefore, when you call redeem, you get the current aDAI balance in underlying DAI. So the aToken balance is the actual amount you can redeem. Therefore, the getTokensForShares function should return shares, because shares are the aToken amount. So the code's calculation here seems to be overcomplicating it and possibly introducing an error. For example, if the contract's aToken balance is 100, and the user is asking for shares = 50, the code would compute:

amount = (scaledBalance * liquidityIndex) * shares / aToken.balanceOf(address(this))

But scaledBalance * liquidityIndex is equal to the aToken balance. So it's (aTokenBalance) * shares / aTokenBalance = shares. So amount = shares. But that's redundant. Therefore, this function is returning shares, which is the same as the aToken balance. However, the function is supposed to return the underlying tokens, which is exactly the aToken balance. So in that case, the function is correct. Wait, but that would mean the code's getTokensForShares is just returning the shares, which is the same as the aToken balance. But then why have this function? Maybe the shares are not aTokens. Wait, let's check how shares are calculated.

In the lockTokens function, when depositing, sharesReceived is the difference in aToken balance after deposit. So shares are aTokens. Therefore, when unlocking, the shares are aTokens, and the amount of underlying is the same as the aToken balance. So getTokensForShares(shares) should return the underlying tokens equivalent to the aToken shares. But according to the code, it returns shares. That's correct only if 1 aToken equals 1 underlying token. But that's not the case because aTokens accrue interest. Wait, no. The aToken's balance includes the interest. So 1 aToken is always equal to 1 underlying token plus interest. So when you have an aToken balance of X, you can redeem X underlying tokens. Therefore, the getTokensForShares function should simply return shares (the aToken amount), but the code here is doing a calculation that results in shares. So it's correct, but the code is unnecessarily complex. Wait, but maybe the code is incorrect because of how the scaledBalance and liquidity index are used.

Wait, the code uses the scaledBalanceOf the contract multiplied by the liquidity index. That gives the contract's aToken balance. Then multiplied by shares, divided by the aToken balance. So that's (aTokenBalance * shares) / aTokenBalance = shares. So this function returns shares. But the function is supposed to return the underlying tokens. Therefore, this function is correct only if the shares are equal to the underlying tokens. However, in reality, the aToken balance (shares) already represents the underlying tokens plus interest. Therefore, the function is correctly returning the amount of underlying tokens. Wait, but why is the code written this way? Because if the contract's aToken balance is zero, this would cause a division by zero. Let's check that.

In getTokensForShares, if shares is zero, it returns zero. Otherwise, if aToken.balanceOf(address(this)) is zero, the division would fail. But the function is only called when shares are non-zero. So if the contract has no aTokens, but someone calls getTokensForShares with shares>0, the function would revert. That's a possible issue. For example, if all aTokens are withdrawn, but someone tries to call this function with shares, it would divide by zero. So that's a division by zero vulnerability here.

Another issue: in getTokensForShares, the code uses scaledBalanceOf(address(this)), which is the scaled balance of the contract. Then multiplied by liquidityIndex (which is the current index). That product is the actual aToken balance of the contract. Then multiplied by shares and divided by the aToken balance. So this is equivalent to shares. Therefore, the code's calculation is redundant and could be simplified to return shares. However, if during the execution, the aToken balance changes (like in a different block), the value could be different. But since this is a view function, it uses the current state. Wait, but the scaledBalanceOf and liquidityIndex are from the current state. So the calculation is correct in that it's using the current aToken balance (as scaledBalance * liquidityIndex), then multiplying by shares and dividing by the current aToken balance. So this is shares * (aTokenBalance / aTokenBalance) = shares. Therefore, the code's formula is equivalent to shares. But why? Maybe this is a mistake, and the intended formula was different. For example, maybe the shares are not the aToken balance but some other representation. If that's the case, the formula would be incorrect. Let me check how shares are handled.

When you deposit, sharesReceived is the aToken balance after minus before. So shares are aTokens. Therefore, if the contract holds 100 aTokens, and you deposited 10 aTokens, you have 10 shares. Therefore, when you want to convert shares to underlying tokens, it's simply the aToken amount, which is shares. But in reality, the aTokens are already worth the underlying plus interest. Therefore, the code's formula is incorrect because it doesn't account for the interest. Wait, but the aToken's balance already includes the interest. Therefore, if the contract holds X aTokens, then the total underlying is X. Therefore, if you have Y shares (aTokens), then the underlying is Y. Therefore, getTokensForShares should return Y. But the code is returning Y, but via a complex formula that divides by the total aToken balance. However, this formula is only correct if the shares are proportional to the total aToken balance. Wait, no. Let's say the contract has 100 aTokens (total), and you have 10 shares. Then according to the code, the amount is 10. But if the contract's aToken balance is 100, then the formula is (100 * 10) / 100 = 10. Correct. But if another user deposits and the contract's aToken balance increases, then the shares would be diluted. Wait, but shares are tracked per user in the savings account, right? Wait, no. This contract seems to manage the shares as the aTokens themselves. So if the savings account tracks how many aTokens each user has, then when the contract's aToken balance increases (because another user deposited), existing users' shares (aTokens) would be the same, but the underlying per share would decrease. Wait, no. Because each user's shares are their own aTokens. Wait, maybe the contract is designed such that when you deposit, you receive shares equal to the aTokens minted, and those shares are tracked by the savings account. Therefore, each user's shares correspond to their aTokens. Then, when the contract's aToken balance increases (due to interest), each aToken is worth more. Wait, but in AAVE, the aToken balance increases over time as interest is accrued. So if the contract holds aTokens, those aTokens automatically earn interest. Therefore, the value of each share (aToken) increases over time. Therefore, to calculate the underlying tokens for a given number of shares, you need to multiply the shares by the current exchange rate (which is 1 aToken = X underlying, where X increases over time). However, in the code's getTokensForShares function, it's not considering that the aTokens themselves have accrued interest. Wait, but the aToken's balanceOf already includes the interest. So if the contract has 100 aTokens, that's 100 underlying plus interest. Therefore, to get the underlying amount for shares, it's simply shares. Because each aToken is redeemable for 1 underlying plus interest. Wait, but that's not correct. Because when you deposit 1 underlying token, you get 1 aToken. As interest accrues, the aToken's balance remains 1, but when you redeem, you get 1 + interest. Wait, no. In AAVE v2, the aToken's balance increases over time. So for example, if you deposit 1 DAI, you get 1 aDAI. Then, as interest accrues, your aDAI balance increases. So when you call balanceOf, it returns the current amount including interest. Therefore, the aToken balance is the exact amount of underlying you can redeem. Therefore, if the contract has 100 aTokens, then it can redeem 100 underlying tokens. Therefore, the getTokensForShares function is correct in returning shares, because each share is an aToken, which is 1 underlying (plus interest). Wait, but then the code's calculation is not necessary. But if the code's calculation simplifies to shares, then why the complex formula? It seems redundant and possibly introducing a division by zero if aToken.balanceOf is zero. For example, if the contract has no aTokens, and someone calls getTokensForShares with shares>0, the function will revert due to division by zero. That's a vulnerability.

Another potential issue is the use of SafeMath. Since Solidity 0.8.0, SafeMath is integrated into the language, but the contract is using 0.7.6 and SafeMath. That's okay, but it's an older version, and the SafeMath functions are being used via the library. However, the code uses .mul and .div, which are SafeMath functions. So that's handled.

Looking at the emergencyWithdraw function: when the asset is ETH, it calls _withdrawETH(amount), which withdraws the aWETH and converts to ETH. Then sends the received ETH to the owner's wallet. However, in _withdrawETH, the code approves the wethGateway to spend the aWETH tokens. But after withdrawal, the aWETH is burned, and ETH is received. However, the code here might not handle the approval correctly. For example, if the withdrawal amount is more than the contract's aWETH balance, the approve would allow the gateway to spend more than available, but the actual withdrawal would fail. But since the code checks the amount against the aToken balance in emergencyWithdraw (amount = IERC20(liquidityToken(_asset)).balanceOf(address(this))), then it's safe. Because amount is the balance, so the approval is set to that exact amount. So that's okay.

Another possible issue is reentrancy. The contract uses ReentrancyGuard, which is good. The unlockTokens and lockTokens functions have the nonReentrant modifier. However, in the emergencyWithdraw function, which is onlyOwner, there's no nonReentrant modifier. But since it's only callable by the owner, maybe that's considered safe. However, if the owner is malicious, they could perform a reentrancy attack. But since the owner is a privileged role, this is a centralization risk rather than a vulnerability.

Another thing to note: the initialize function can be called externally by anyone, but it has the initializer modifier. Since it's using OpenZeppelin's Initializable, the initializer modifier ensures that the function can only be called once. However, the function also calls __Ownable_init(), which is the initializer for OwnableUpgradeable. That should be correct. However, after initializing, the function transfers ownership to _owner via super.transferOwnership(_owner). That might be redundant because __Ownable_init() already sets the owner to the deployer, but then transferOwnership is called. But since the function is supposed to set the owner to _owner, this is correct. However, in upgradeable contracts, transferring ownership during initialization should be done via the initializer, which this code does. So that's okay.

The contract uses the _msgSender() function from OwnableUpgradeable, which is correct for upgradeable contracts to use ContextUpgradeable.

In the liquidityToken function, if the asset is address(0), it returns the aWETH address via IWETHGateway(wethGateway).getAWETHAddress(). Otherwise, it uses the protocolDataProvider. But if the wethGateway is incorrect or malicious, this could return a wrong address, leading to issues. However, the wethGateway is set by the owner, so again, a centralization risk.

The unlockShares function transfers the asset (which is the aToken) directly to the savingsAccount. But if the aToken is a malicious contract, this could be a problem. However, the protocolDataProvider is supposed to provide valid aToken addresses. If an incorrect aToken is used, it could lead to loss of funds. But this relies on the protocolDataProvider being correctly configured, which is again a trust assumption on the owner's setup.

In the _depositERC20 function, after transferring the asset to the contract, they approve the lendingPool for the amount. However, if the asset is a malicious ERC20 that executes code on approval, this could allow for an attack. But since the asset is presumably a valid ERC20 (like through the Aave protocol), this might not be an issue. Still, using safeApprove could be better, but the code uses approve(0) followed by approve(amount), which is the recommended way to handle tokens that require resetting allowances.

Another possible issue is that the contract doesn't check the return values of external calls. For example, when calling IERC20.approve, some tokens return a boolean, and not checking it could lead to failures. However, the SafeERC20 library's safeApprove is used, which checks the return value. Wait, looking at the code: in _depositERC20, they use IERC20(asset).approve. But the IERC20 is using SafeERC20, which is imported. Wait, the code has:

using SafeERC20 for IERC20;

So IERC20's functions are wrapped with SafeERC20, which includes safeApprove. But in the code, they do IERC20(asset).approve(lendingPool, 0); and then IERC20(asset).approve(lendingPool, amount);. Since SafeERC20's approve is safeApprove, which checks for success. Wait, no: the SafeERC20 library adds safeTransfer, safeTransferFrom, and safeApprove. So if the code is using IERC20's approve directly, it's not using the SafeERC20's safeApprove. Therefore, the code is not checking the return value of approve, which could lead to silent failures. For example, if the token's approve function doesn't return a boolean (like USDT), the call would revert in Solidity 0.7.6 because the return data isn't checked. Wait, in Solidity 0.7.6, when you call a function that returns a value, but the contract doesn't return anything, it would cause a revert. However, if the code is using IERC20's approve function, which is supposed to return a boolean, but some tokens (like USDT) don't return a boolean, then the approve call would fail, causing a revert. Therefore, using SafeERC20's safeApprove is necessary here. But in the code, they are not using safeApprove; they are using approve directly. So this is a vulnerability. Because for tokens that do not return a boolean from approve, the call would revert. However, in the code, the asset is supposed to be an Aave-supported token, which should be compliant. But if the owner sets a non-compliant token, this could fail. But that's more of a configuration issue. However, the code as written uses approve without checking the return value, which is unsafe. Therefore, this is a vulnerability.

Similarly, in _withdrawETH, they do IERC20(...).approve(wethGateway, amount). Again, not using safeApprove. So the same issue applies here. If the aWETH token is non-compliant (doesn't return boolean), this would revert. But aWETH is a trusted token, so maybe it's not an issue. But since the code allows for any asset, including potentially non-compliant ones, this is a vulnerability.

Another issue is in the getSharesForTokens function. It calculates shares as (amount.mul(1e18)).div(getTokensForShares(1e18, asset)). If getTokensForShares(1e18, asset) returns zero (for example, if the contract has no aTokens), this would cause a division by zero. However, the getTokensForShares function returns zero if shares is zero. But in getSharesForTokens, amount is passed as an argument. If getTokensForShares(1e18) returns zero, then this division would revert. This could happen if the contract has no aTokens, making the function revert for any amount. This is a potential division by zero vulnerability.

Let me summarize the vulnerabilities I found so far:

1. Division by zero in getTokensForShares if the contract's aToken balance is zero and shares is non-zero.
2. Use of approve instead of safeApprove, leading to potential reverts with non-compliant tokens.
3. Division by zero in getSharesForTokens if getTokensForShares(1e18, asset) returns zero.
4. Incorrect calculation in getTokensForShares leading to wrong value if the formula is incorrect (though my initial analysis suggests it's redundant but correct, but the division by zero is a problem).
5. Centralization risks where the owner can update critical addresses (wethGateway, protocolDataProvider, etc.) to malicious ones, leading to fund loss.
6. The contract uses Solidity 0.7.6, which might have known issues, but I'm not sure of specific vulnerabilities in that version.

Wait, let's double-check each point.

For point 1: If the contract's aToken balance is zero and someone calls getTokensForShares with shares > 0, the code would divide by zero. For example, if the contract has no aTokens, but shares are passed as non-zero, the denominator IERC20(aToken).balanceOf(address(this)) is zero, leading to division by zero. This would cause the function to revert. However, the function is marked as view, so it's not a state-changing issue, but it could break front-ends or integrations that rely on this function not reverting. However, if shares are zero, it returns zero. So if the contract has no aTokens, and someone calls getTokensForShares with shares=0, it returns zero. But if shares are non-zero and the contract has no aTokens, it reverts. That's a possible denial-of-service if other systems rely on this function not reverting for certain inputs.

For point 2: Using approve instead of safeApprove. For example, in _depositERC20, the code does:

IERC20(asset).approve(lendingPool, 0);
IERC20(asset).approve(lendingPool, amount);

But IERC20 is using SafeERC20, which has safeApprove. However, the code isn't using safeApprove; it's calling approve directly. The SafeERC20's approve is safeApprove, which is a separate function. Therefore, the code here is using the standard approve function, which for non-compliant tokens (like USDT) that don't return a boolean, will revert because Solidity 0.7.6 expects a return value. So in such cases, the approve would fail. But since Aave tokens should be compliant, maybe this isn't an issue. However, if the asset is a non-compliant token, this would cause the transaction to revert. Therefore, the code should use safeApprove to handle such cases.

Point 3: getSharesForTokens calls getTokensForShares(1e18, asset). If this returns zero (e.g., when the contract has no aTokens), then (amount * 1e18) / 0 would revert. Therefore, this function will revert if the contract has no aTokens for the given asset. This could be a problem if the contract hasn't deposited any tokens yet, and someone tries to calculate shares.

Point 4: The formula in getTokensForShares might be incorrect. As per earlier analysis, it might return shares, which would be correct if shares are aTokens. But the formula's division by the aToken balance could be incorrect in some cases. For example, if the contract has aToken balance, but the user's shares are a fraction. Wait, shares are the aTokens received upon deposit. So if the contract has 100 aTokens, and a user deposited 10, then sharesReceived is 10. The user's shares are 10, and getTokensForShares(10) should return 10, which the formula does. However, if another user deposits 10, the contract's aToken balance is 20, and the formula would compute (scaledBalance * liquidityIndex) * shares / 20. If scaledBalance * liquidityIndex is 20 (the current aToken balance), then (20 * 10)/20 = 10. So even if another user deposits, the calculation remains correct. Wait, no. Suppose the contract's aToken balance is 100 (from user A's deposit). Then user B deposits, adding 100 aTokens, making the total 200. When user A wants to compute getTokensForShares(100), the formula would be (scaledBalance * L) * 100 / 200. But scaledBalance * L is the aToken balance (200). So (200 * 100) / 200 = 100. Which is correct. So the formula works even after multiple deposits. However, the formula seems to be proportional to the shares divided by the total aToken balance. Wait, no. The formula is (scaledBalance * L) * shares / aTokenBalance. But scaledBalance * L is equal to aTokenBalance. So the formula is (aTokenBalance * shares) / aTokenBalance = shares. Therefore, regardless of the total aToken balance, the formula returns shares. That's correct. Therefore, the formula is redundant but correct. However, the division by aTokenBalance is risky when aTokenBalance is zero, leading to division by zero. So the real issue is division by zero in getTokensForShares when the contract has no aTokens.

Point 5: The owner can update critical addresses like wethGateway, protocolDataProvider, etc. If the owner is malicious or compromised, they can set these addresses to malicious contracts, leading to fund loss. This is a centralization risk, but since the question is about vulnerabilities, and centralization is a design choice, it depends on context. However, in a decentralized context, this is a vulnerability. If the contract is supposed to be trustless, then this is an issue. Otherwise, if the owner is a trusted entity, it's a risk but not a code vulnerability.

Point 6: Using an older Solidity version (0.7.6) might have unpatched bugs. For example, Solidity 0.8.0 introduced checked arithmetic by default, but in 0.7.6, they rely on SafeMath. However, the code uses SafeMath, so that's covered. Other bugs might exist, but I don't recall specific ones in 0.7.6.

Another potential issue: The code has a receive() function, so it can accept ETH. However, in functions like lockTokens, when asset is ETH, it requires msg.value == amount. But if someone sends ETH directly to the contract (not through lockTokens), it would stay in the contract. The emergencyWithdraw function allows the owner to withdraw ETH, but if the contract is holding ETH not wrapped into aWETH, then the owner can withdraw it. However, in normal operation, the contract should wrap all ETH into aWETH, but if someone sends ETH directly, it would be treated as unwrapped. But since the emergencyWithdraw function checks liquidityToken(_asset) (which for ETH is aWETH), but if the asset is ETH, then in emergencyWithdraw, it withdraws from aWETH. So any ETH sent directly to the contract would not be accounted for and would be stuck unless the owner calls emergencyWithdraw with asset=ETH, which would withdraw aWETH, not the native ETH. Therefore, native ETH sent directly to the contract would be stuck. However, the contract has a receive function, so someone could send ETH, which would be stuck unless the owner uses another method to recover it. But the emergencyWithdraw function for asset=ETH would withdraw from aWETH, not the contract's native ETH balance. Therefore, native ETH sent directly to the contract is stuck. This is a potential issue if users accidentally send ETH directly.

So another vulnerability: The contract's ETH balance (not wrapped into aWETH) is unrecoverable via emergencyWithdraw, leading to locked funds.

Another possible issue: The unlockShares function transfers the asset (which is supposed to be an aToken) to the savingsAccount. However, there's no check that the asset is indeed an aToken. If the savings account calls unlockShares with a non-aToken asset, it could lead to loss of funds. But the unlockShares function is only callable by the savingsAccount, so it depends on the savingsAccount's implementation. However, the function lacks validation on the asset, assuming it's a valid aToken. If the savingsAccount is malicious or compromised, it could call this function with any ERC20 token, draining the contract's balance of that token. For example, if the contract holds some other ERC20 tokens (not aTokens), the savingsAccount could call unlockShares with that token's address and withdraw all of them. Therefore, the unlockShares function should ensure that the asset is a valid aToken. Otherwise, it's a vulnerability allowing the savings account to steal any ERC20 token held by the contract.

Similarly, in the unlockShares function, if the contract holds any ERC20 tokens (not aTokens), the savingsAccount can transfer them out. For example, if someone mistakenly sends ERC20 tokens to the contract, the savingsAccount can call unlockShares to take them. But if the savingsAccount is trusted, this might be acceptable. However, if the savingsAccount is compromised, this is a vulnerability.

Also, in unlockShares, the code doesn't check if the asset is a valid aToken. Therefore, the savingsAccount can withdraw any ERC20 token that the contract holds. This is a vulnerability if the contract is supposed to only hold aTokens. Any other tokens in the contract can be stolen by the savingsAccount.

Another issue is in the emergencyWithdraw function: when the asset is ERC20, it calls _withdrawERC, which withdraws from the aToken. However, the emergencyWithdraw function is intended to withdraw the aTokens, not the underlying. Wait, no: the emergencyWithdraw function is supposed to withdraw the underlying tokens. Let me see:

In emergencyWithdraw, if the asset is ETH, it calls _withdrawETH(amount), which withdraws aWETH to ETH. Then sends the ETH to the wallet. For ERC20, it calls _withdrawERC, which withdraws the underlying ERC20 from Aave. However, the amount parameter here is the amount of aTokens to redeem. Because in emergencyWithdraw, the code gets the aToken balance (amount = IERC20(liquidityToken(_asset)).balanceOf(address(this))). So if the contract has 100 aTokens, it would withdraw 100 underlying tokens. But this function allows the owner to withdraw all aTokens, converting them to underlying and sending to the wallet. This is correct. However, if the contract holds other ERC20 tokens (not aTokens), the owner cannot withdraw them via emergencyWithdraw, but the savingsAccount can via unlockShares. So if the contract accidentally receives other ERC20 tokens, they can be stolen via unlockShares.

Putting it all together, the vulnerabilities are:

1. **Division by Zero in `getTokensForShares`**: If the contract's aToken balance is zero and `shares` is non-zero, the division `div(IERC20(aToken).balanceOf(address(this)))` will cause a division by zero, reverting the transaction.

2. **Unsafe Use of `approve`**: The contract uses `approve` instead of `safeApprove` from SafeERC20, which can lead to failures with non-compliant ERC20 tokens (e.g., USDT) that don't return a boolean from `approve`.

3. **Division by Zero in `getSharesForTokens`**: If `getTokensForShares(1e18, asset)` returns zero (when the contract has no aTokens), the division will revert due to division by zero.

4. **Incorrect Handling of Native ETH**: If native ETH is sent directly to the contract (not via `lockTokens`), it becomes stuck as there's no way to withdraw it using `emergencyWithdraw` (which only handles aWETH).

5. **Unrestricted ERC20 Withdrawal in `unlockShares`**: The `unlockShares` function allows the savings account to withdraw any ERC20 token held by the contract, not just aTokens, potentially leading to loss of funds if the contract holds other tokens.

6. **Centralization Risks**: The contract owner has significant control (can update critical addresses, perform emergency withdrawals), which could lead to loss of funds if the owner is malicious or compromised.

7. **Potential Reentrancy in `emergencyWithdraw`**: The `emergencyWithdraw` function lacks a reentrancy guard, though it's only callable by the owner. However, if combined with a malicious owner and a callback in the `_wallet.call`, it could lead to reentrancy attacks, though the impact is limited given the owner's privileges.

8. **Outdated Solidity Version**: Using Solidity 0.7.6 may expose the contract to known compiler bugs or issues that have been patched in later versions.

9. **Incorrect Liquidity Token Handling for ETH**: The `liquidityToken` function assumes that WETH is the only ETH representation, but if the contract receives native ETH outside of the expected flow, it isn't handled correctly.","```
None.
```",0.0,0
SavingsAccount.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';

/**
 * @title Savings account contract with Methods related to savings account
 * @notice Implements the functions related to savings account
 * @author Sublime
 **/
contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of the strategy registry used to whitelist strategies
     */
    address public strategyRegistry;

    /**
     * @notice address of the credit lines contract
     */
    address public creditLine;

    /**
     * @notice mapping from user to token to strategy to balance of shares
     * @dev user -> token -> strategy (underlying address) -> amount (shares)
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    /**
     * @notice mapping from user to token to toAddress for approval to amount approved
     * @dev user => token => to => amount
     */
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    /**
     * @notice modifier to check if address is the credit line
     * @param _caller address to check if credit line
     */
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    /**
     * @dev initialize the contract
     * @param _owner address of the owner of the savings account contract
     * @param _strategyRegistry address of the strategy registry
     * @param _creditLine address of the credit line contract
     **/
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    /**
     * @notice used to update credit line contract address
     * @dev only owner can update
     * @param _creditLine updated address of credit lines
     */
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    /**
     * @notice used to update strategy registry address
     * @dev only owner can update
     * @param _strategyRegistry updated address of strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to deposit tokens into strategy via savings account
     * @dev if token is address(0), then it is Ether
     * @param _amount amount of tokens deposited
     * @param _token address of token contract
     * @param _strategy address of the strategy into which tokens are to be deposited
     * @param _to address to deposit to
     */
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    /**
     * @dev Used to switch saving strategy of an _token
     * @param _currentStrategy initial strategy of token
     * @param _newStrategy new strategy to invest
     * @param _token address of the token
     * @param _amount amount of tokens to be reinvested
     */
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _from address from which tokens will be withdrawn
     * @param _to address to which token should be withdrawn
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    /**
     * @notice used to withdraw a token from all strategies
     * @param _token address of token which is to be withdrawn
     */
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    /**
     * @notice used to approve allowance to an address
     * @dev this is prone to race condition, hence increaseAllowance is recommended
     * @param _amount amount of tokens approved
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    /**
     * @notice used to increase allowance to an address
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _to address of the address approved to
     */
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used to decrease allowance to an address
     * @param _amount amount of tokens allowance is decreased by
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _from address of the lender of the credit line which is being replenished
     */
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    /**
     * @notice used to transfer tokens
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        //update allowance
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        //reduce sender's balance
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to query total tokens of a token with a user
     * @param _user address of the user
     * @param _token address of token
     * @return _totalTokens total number of tokens of the token with the user
     */
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",4178.0,482.0,"[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues
Full withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for AaveYield. That is, as the whole amount is required to be moved at once from Aave, both withdrawAll and switchStrategy will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues. `withdrawAll` will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system. `switchStrategy` will subtract full number of shares for the _amount requested from the old strategy, while adding lesser partial number of shares for _tokensReceived to the new one with the same effect of freezing user's funds within the system.
  [H-08] Possibility to drain SavingsAccount contract assets
A malicious actor can manipulate `switchStrategy()` function in a way to withdraw tokens that are locked in SavingsAccount contract (the risk severity should be reviewed)",2.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';


contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public strategyRegistry;

    
    address public creditLine;

    
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",3020.0,2,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unsafe ERC20 Approval in `switchStrategy`:**
   - The contract uses `safeApprove` when approving tokens for a new strategy without resetting the allowance to zero first. If the strategy already has a non-zero allowance, this will cause the transaction to revert, preventing users from switching strategies.

2. **ETH Locked in Contract for Non-ETH Deposits:**
   - When depositing ERC20 tokens, the contract does not check if `msg.value` is zero. If users accidentally send ETH alongside an ERC20 deposit, the ETH remains stuck in the contract with no mechanism to recover it.

3. **Unvalidated Strategies in Transfer Functions (`transfer` and `transferFrom`):**
   - Transferring shares does not validate if the strategy is registered. Users can transfer shares for strategies not in the registry, potentially interacting with malicious or deprecated strategies during withdrawals.

4. **Cross-Function Reentrancy Risk:**
   - Although `nonReentrant` modifiers are used, malicious strategies could call back into unprotected functions (e.g., `approve`, `transfer`), leading to unexpected state changes during deposits, withdrawals, or strategy switches.

5. **Denial of Service (DoS) in `getTotalTokens`:**
   - If any strategy in the registry reverts when `getTokensForShares` is called, the entire `getTotalTokens` function will fail, making it impossible to retrieve the total token balance.

6. **Incorrect Shares Calculation During Transfers:**
   - The `transfer` and `transferFrom` functions rely on strategies to convert token amounts to shares. If a strategy is compromised or misconfigured, share calculations could be manipulated, leading to incorrect balance updates.

7. **Lack of Strategy Validity Check During Withdrawals:**
   - Withdrawals from strategies no longer in the registry are allowed, potentially enabling interactions with deprecated or malicious strategies if they were previously approved.","### **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**

**Report Description**:
The `withdrawAll` and `switchStrategy` functions in the `SavingsAccount` contract do not account for potential liquidity issues in the underlying yield strategies (e.g., AaveYield). If the strategy lacks sufficient liquidity, partial withdrawals may occur, but the contract incorrectly treats them as full withdrawals. This leads to incorrect accounting and can freeze user funds within the system. Specifically:
- `withdrawAll` deletes the user's entry, locking their funds in the strategy despite partial withdrawal.
- `switchStrategy` subtracts the full number of shares from the old strategy but adds only a partial number of shares to the new one, effectively freezing the user's funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of liquidity-related fund freezing in `withdrawAll` or `switchStrategy`. The identified vulnerabilities in the response list focus on other aspects, such as unsafe ERC20 approvals, ETH locking, and reentrancy risks, but do not cover the specific liquidity and accounting issues described in the report.

---

### **[H-08] Possibility to drain SavingsAccount contract assets**

**Report Description**:
The `switchStrategy` function in the `SavingsAccount` contract can be manipulated by a malicious actor to drain assets locked in the contract. The exact mechanism of the exploit is not detailed, but the severity of the risk is highlighted, suggesting a potential vulnerability in the strategy-switching logic.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the potential for asset draining via the `switchStrategy` function. While the response list identifies issues like unsafe ERC20 approvals and cross-function reentrancy risks, it does not cover the specific exploit described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**
- **[H-08] Possibility to drain SavingsAccount contract assets**

---

### **Conclusion**
The `response_list` does not adequately address the issues identified in the `issue` report. Specifically, it misses critical vulnerabilities related to liquidity-related fund freezing and asset draining in the `SavingsAccount` contract. The responses focus on other security concerns but fail to cover the core risks described in the report.",0,0,2,7,"Okay, let's start analyzing this smart contract. The first thing I notice is that it's using Solidity 0.7.6. I should check if there are any known vulnerabilities with that version. Also, they're importing some OpenZeppelin contracts, which are generally safe, but maybe there's something specific here.

Looking at the contract structure: it's called SavingsAccount, inherits from OwnableUpgradeable, ReentrancyGuard, and implements some interfaces. The initializer function sets up the owner, strategy registry, and credit line. There's a modifier onlyCreditLine that checks if the caller is the creditLine address.

Let's check for reentrancy issues. The contract uses ReentrancyGuard and has nonReentrant modifiers on several functions like deposit, withdraw, etc. So maybe that's covered. But maybe there's a place where they forgot to add the modifier?

Next, looking at the deposit function. It calls _deposit, which then calls _depositToYield. In _depositToYield, if the token is address(0) (ETH), it checks that msg.value equals _amount. That seems correct. Then it calls IYield(_strategy).lockTokens with the ETH value. But what if the strategy is malicious? Since the strategy is checked against the strategyRegistry, which is supposed to have approved strategies. But if the registry allows a bad strategy, that could be a problem. But that's maybe a dependency issue, not this contract's fault.

In the switchStrategy function: they subtract the amount from the current strategy, unlock tokens, then deposit into the new strategy. There's a SafeMath sub, which is good. They use nonReentrant here. But when unlocking tokens from the current strategy and then locking into the new strategy, is there a possibility of reentrancy in between? Since the nonReentrant modifier is on the outer function, but the actual calls to the strategies happen inside. If the strategy's unlockTokens or lockTokens functions are malicious and call back into the contract, maybe they could bypass the nonReentrant? Hmm, but ReentrancyGuard only prevents functions with the same modifier from being called. If the strategy's functions don't call back into the same contract's functions that have nonReentrant, then maybe it's safe. But this is a potential risk if the strategy is untrusted. However, the contract relies on the strategyRegistry to have valid strategies, so maybe this is considered a trusted call. But if the registry is compromised, this could be a problem.

Looking at the withdraw functions. The withdraw function converts the amount to shares using getSharesForTokens, subtracts from balanceInShares, then calls _withdraw. In _withdraw, depending on _withdrawShares, it either unlocks shares or tokens. Then transfers the amount. The _transfer function handles ETH and ERC20. For ETH, it uses call with value, which is safe in Solidity 0.7.6? But there's a check for success. However, in Solidity versions before 0.8.0, using .call{value}() without specifying gas could lead to out-of-gas issues, but here they just check success. Also, the possibility of reentrancy here? Since they use nonReentrant on the outer function, and the _transfer is the last step, maybe it's okay. But if the token is ERC777 or another with callbacks, transferring the token could trigger a reentrant call. However, since the nonReentrant modifier is on the withdraw function, any reentrant call to another function with nonReentrant would be blocked. But if the reentrant call is to a function without the modifier, maybe there's an issue. But the contract uses SafeERC20, which is for ERC20, which doesn't have callbacks. So maybe ERC20 transfers are safe. However, if the token is a malicious ERC20 that calls back into the contract, and the contract has a function without nonReentrant that can be exploited, that could be a problem. But looking at the functions, most of them have nonReentrant. For example, deposit has nonReentrant, so if during transfer, the ERC20 calls back into deposit, it would be blocked by the nonReentrant. So maybe this is mitigated. But perhaps the approve function could be called during a transfer, but that's unlikely to cause a vulnerability.

Another thing to check is the use of SafeMath. The contract uses SafeMath for uint256, so overflows should be handled. But since Solidity 0.8.0 has built-in overflow checks, but here it's 0.7.6, so SafeMath is necessary. They seem to be using .add and .sub, so that's good.

In the withdrawAll function: it loops through all strategies from the registry. For each, if the balance is non-zero, it unlocks tokens and deletes the balance. Then transfers the total. But what if during the loop, one of the strategies' unlockTokens fails? The entire transaction would revert. So if one strategy is problematic, the user can't withdraw from any. But maybe that's intended? Also, in the loop, it checks if the strategy is not address(0). But the strategyRegistry's getStrategies should return valid addresses. However, if the registry returns a list that includes address(0), this could cause issues. But the registry is supposed to be managed by the owner, so maybe that's a trust issue.

In the switchStrategy function: after unlocking tokens from the current strategy, they approve the new strategy for the token (if it's not ETH). But in the code, when the token is not address(0), they do IERC20(_token).safeApprove(_newStrategy, _tokensReceived);. Wait, but safeApprove is used, which is from SafeERC20. However, the safeApprove function is used here. But if there was a previous allowance, this could fail. Because safeApprove checks that the current allowance is zero or the same as the current call. Wait, no: safeApprove is a wrapper that sets the allowance to the given value, but it requires that the current allowance is zero if changing from a non-zero value. So if the new strategy was previously approved, this would fail. For example, if the user is switching strategies multiple times, each time they might have an existing allowance. This would cause the safeApprove to revert. Because when you call safeApprove, if the current allowance is not zero, it requires that you first set it to zero. So the code here may have an issue when the new strategy already has an allowance. This could cause the transaction to revert. That's a potential vulnerability here.

For example, if the contract previously approved strategy B for 100 tokens, and later when switching to strategy B again, the safeApprove would try to set it to 100 again, but since the current allowance is 100, it would work. Wait, no: safeApprove is implemented as:

function safeApprove(IERC20 token, address spender, uint256 value) internal {
    require((value == 0) || (token.allowance(address(this), spender) == 0),
        ""SafeERC20: approve from non-zero to non-zero allowance""
    );
    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
}

So if the current allowance is non-zero and the new value is non-zero, it will revert. So in the code when they do safeApprove(_newStrategy, _tokensReceived), if there's already an existing allowance for _newStrategy, this would fail. That's a problem. Because when switching strategies, the contract might have already approved the new strategy in a previous operation, leading to a failure here. This is a vulnerability because the transaction would revert when trying to switch to a strategy that was previously approved. The solution would be to first set the allowance to zero and then to the new value, but the code doesn't do that. So this is an issue.

Another point: in the _depositToYield function, when the token is address(0) (ETH), they check that msg.value == _amount. However, when the token is not ETH, they don't check that msg.value is zero. So if a user calls deposit with a token that's not ETH but sends ETH, the msg.value will be non-zero, but the code will proceed. However, since in the _depositToYield function, the code only assigns _ethValue when _token is address(0). Otherwise, _ethValue is zero. So when a user deposits an ERC20 token but sends ETH, the code will take the msg.value (ETH) and send it to the strategy via lockTokens{value: _ethValue}, which is zero in this case, so the ETH sent by the user will remain in the contract. But the code doesn't check that msg.value is zero when the token is not ETH. This means that users can accidentally send ETH along with an ERC20 deposit, which would be stuck in the contract. This is a potential issue because the contract's ETH balance can accumulate, and there's no function to withdraw it. Since the receive() function is present, anyone can send ETH, but if it's not handled properly, it could be locked. So this is a vulnerability where ETH sent in non-ETH deposits is not refunded and remains in the contract.

Also, in the withdraw function, when _withdrawShares is true, the code retrieves the liquidity token from the strategy. Then unlocks shares. But if the liquidity token is address(0), that would be a problem. The code checks that _tokenReceived != address(0), which is correct. But what if the strategy returns a wrong token? Well, the strategy is supposed to be registered, but if the strategy is malicious or faulty, that could be an issue. But that's a dependency on the strategy registry's correctness.

Another thing: the getTotalTokens function is marked as external override returns (uint256). However, this function iterates over all strategies and for each, calls IYield(_strategyList[i]).getTokensForShares. But this function is an external call. If any of the strategies are malicious and revert on this call, then getTotalTokens would revert. Since getTotalTokens is an external function, this could cause the entire call to fail if any strategy is problematic. But since strategies are supposed to be vetted by the registry, maybe it's not a big issue, but still a potential DoS on the getTotalTokens function.

In the transfer function, when transferring shares, they subtract from the sender's balance and add to the receiver's. But they use the strategy's getSharesForTokens to convert the _amount into shares. However, the code checks if _strategy is not address(0). Wait, when _strategy is address(0), does that mean something? Looking at the code, perhaps _strategy can be address(0) to represent no strategy (like direct tokens?), but in other parts of the code, strategies are checked against the registry. But if a user can transfer using a strategy that's not in the registry, that might be a problem. For example, in the transfer function, if someone uses a strategy that's not in the registry, then balanceInShares would track it, but the strategy might not be valid. Wait, the transfer function allows transferring any strategy, even if it's not registered. Because in transfer, they don't check if the strategy is in the registry. However, when depositing, the strategy must be in the registry. But transferring shares for a strategy that's no longer in the registry (or was never there) could allow invalid strategies to be used. For example, if a strategy was removed from the registry, users could still transfer their shares. This might be intentional, but perhaps it's a vulnerability if the strategy is considered invalid but shares are still tracked. However, when trying to withdraw or switch from such a strategy, the code would check if the new strategy is in the registry, but the old one might not be. For example, if a strategy is removed from the registry, users can still transfer their shares but not deposit into it. However, when they try to withdraw, the code would call IYield(_strategy).unlockTokens, which could be a problem if the strategy is malicious or non-existent. So allowing transfer of shares for invalid strategies could lead to issues when users try to withdraw. However, this depends on the registry's management. But the code doesn't check the strategy's validity during transfer, which could be an issue.

Another possible issue: in the deposit function, the event Deposited is emitted with _sharesReceived. However, if the strategy's lockTokens function returns a different number of shares than expected, the event would reflect that. But that's up to the strategy's implementation, so it's probably okay.

In the switchStrategy function, after unlocking tokens from the current strategy, they have:

_ethValue = _tokensReceived; only if _token is address(0). Then they call lockTokens on the new strategy with _ethValue. But if the token is ETH, then _tokensReceived is in ETH, and the code sends that as value. But when unlocking from the current strategy, if the token is ETH, unlockTokens would return ETH, which is then sent to the new strategy via lockTokens{value: _ethValue}. But the SavingsAccount contract must have enough ETH balance to cover this. Wait, when unlocking from the current strategy, the SavingsAccount should receive the ETH. Let's see: in the switchStrategy function, after unlocking, the SavingsAccount should have the ETH, then when calling lockTokens on the new strategy, they pass _ethValue (which is _tokensReceived, the amount of ETH unlocked). So the SavingsAccount would need to have that ETH balance. Since the SavingsAccount is the one calling unlockTokens on the current strategy, which would send ETH to the SavingsAccount (if _token is ETH), then when calling lockTokens on the new strategy with {value: _ethValue}, the SavingsAccount would send that ETH. That should be correct. But if the current strategy's unlockTokens doesn't send the ETH to the SavingsAccount, this would fail. But assuming that IYield's unlockTokens returns the tokens to the caller (SavingsAccount), then this is okay.

Another potential issue: in the withdrawFrom function, the event emitted is Withdrawn(_from, msg.sender, ...), but the parameters in the event might not match. Wait, the event is Withdrawn(from, to, ...), but in this case, it's _from (the owner of the funds) and msg.sender (the caller). However, the third parameter is the amount, then token, strategy, etc. But the event's parameters might be correct as per the interface. But the main thing is that when someone calls withdrawFrom, the event logs the _from as the user and the msg.sender as the caller, which is correct.

Check for access control issues. The onlyCreditLine modifier is used on increaseAllowanceToCreditLine. The creditLine address is set by the owner. So if the creditLine is compromised, it can increase allowances for any user. That's a potential centralization risk, but it's by design. However, if the creditLine contract has a vulnerability, it could be exploited.

Another thing: the initialize function calls super.transferOwnership(_owner), but since the contract is using OpenZeppelin's OwnableUpgradeable, which is designed for upgradeable contracts, the __Ownable_init() initializes the owner to the deployer, and then transferOwnership is called. However, in the code, super.transferOwnership(_owner) would call the function in OwnableUpgradeable, which sets the owner to _owner. So the initial owner is correctly set. But since the contract is upgradeable, there might be other risks, but the question is about vulnerabilities in this contract, not the upgradeability pattern itself.

Check for possible front-running or approval race conditions. The approve, increaseAllowance, decreaseAllowance functions follow the standard pattern, using SafeMath. So they should be safe from those issues.

In the transferFrom function, after checking the allowance, they convert _amount to shares if the strategy is not address(0). Then subtract from the _from's balance and add to _to's. But if the strategy is invalid (not in the registry), then converting the amount to shares would call IYield(_strategy).getSharesForTokens, which could fail if the strategy is not a contract. However, the code doesn't check if the strategy is valid here. So transferring from a non-registered strategy could lead to errors. For example, if the strategy is a malicious contract, or doesn't implement the IYield interface, the call to getSharesForTokens could fail or return incorrect values. This could allow an attacker to create a fake strategy and manipulate share calculations. Since the transfer and transferFrom functions do not check if the strategy is registered, this is a vulnerability. Users could transfer shares for strategies that are not approved, leading to potential miscalculations or exploits.

In summary, the vulnerabilities I found so far are:

1. **Incorrect ERC20 Approval in switchStrategy**: Using safeApprove on the new strategy without resetting the allowance first can cause the transaction to revert if there's an existing non-zero allowance. This can prevent users from switching strategies if the new strategy was previously approved.

2. **Unchecked ETH in non-ETH deposits**: When depositing an ERC20 token, if the user sends ETH along with the transaction, the ETH is not handled and remains in the contract. This can lead to locked ETH.

3. **Strategy validity not checked during transfers**: The transfer and transferFrom functions allow transferring shares for strategies that are not registered. This can lead to using invalid or malicious strategies, causing issues when withdrawing or interacting with those strategies.

4. **Potential DoS in getTotalTokens**: If any strategy in the registry reverts when getTokensForShares is called, the entire getTotalTokens function will revert, causing denial of service for that function.

5. **Use of deprecated SafeERC20.safeApprove**: As mentioned earlier, safeApprove can fail if there's an existing allowance. This is a known issue and requires setting the allowance to zero first before setting a new allowance.

6. **Possible Reentrancy via Strategy Interactions**: Although the contract uses nonReentrant modifiers, if a strategy's unlockTokens or lockTokens function is malicious and calls back into the SavingsAccount contract's functions that don't have the nonReentrant modifier, it could lead to reentrancy attacks. However, since most external functions are marked with nonReentrant, this risk is mitigated but not entirely eliminated if there are functions without the modifier.

7. **Incorrect Event Emission in withdrawFrom**: The event parameters might be swapped, but need to check the interface. If the event logs the from and to addresses incorrectly, it could lead to off-track logging, but this is more of a minor issue.

Let me confirm each point again.

For the ERC20 approval issue in switchStrategy: Yes, when the token is not ETH, the code does IERC20(_token).safeApprove(_newStrategy, _tokensReceived). If there's an existing allowance for _newStrategy, this will revert. For example, if the user previously switched to the same new strategy, and there's an existing allowance, the safeApprove would fail. This would prevent the switch, which is a problem.

For the ETH in non-ETH deposits: Yes, if a user deposits an ERC20 token and mistakenly sends ETH, the ETH will be stuck in the contract. There's no way to recover it unless the contract has a function to withdraw ETH, which it doesn't. The receive() function allows ETH to be sent, but there's no withdrawal mechanism for the owner or anyone else to retrieve it.

Strategy validity during transfers: The transfer and transferFrom functions do not check if the strategy is in the registry. So even if a strategy is removed from the registry, users can still transfer shares. When they try to withdraw from that strategy, the code checks if the strategy exists in the registry (I think in withdraw, they don't check the strategy registry. Let me check: in withdraw, they call IYield(_strategy).getSharesForTokens. So if the strategy is not in the registry, but is a valid IYield contract, it would proceed. However, in the deposit function, they check the strategy is in the registry, but other functions like withdraw don't check. So transferring to a non-registered strategy is possible, and withdrawing from it is allowed as long as the strategy is a valid contract. This could be a vulnerability if the strategy is malicious but not registered. For example, an attacker could create a strategy that's not in the registry, have a user transfer shares to another user, and then when the recipient tries to withdraw, the malicious strategy could steal funds. However, the deposit function requires the strategy to be registered, so the attacker can't deposit into the malicious strategy, but transfer allows moving shares from a registered strategy to a non-registered one. Wait, but how would the shares for a non-registered strategy exist? Only if the strategy was previously registered and then removed. Then users could transfer their existing shares. So if the strategy was removed from the registry, but users still have shares, they can transfer them. Withdrawing from that strategy would still call IYield on it, which could be malicious. So this is a vulnerability because the contract allows interaction with strategies that are no longer in the registry, which could be risky if those strategies are compromised.

DoS in getTotalTokens: If any strategy reverts when getTokensForShares is called, the entire getTotalTokens function will revert. This could be used by an attacker to make the function unusable by adding a strategy that reverts on that call.

Possible Reentrancy via Strategy Interactions: For example, during a deposit, the code calls IYield(_strategy).lockTokens. If this function is malicious and calls back into the SavingsAccount's deposit function, which has a nonReentrant modifier, the reentrant call would be blocked. But if it calls another function without the modifier, maybe it could proceed. However, most functions (deposit, withdraw, etc.) have the modifier. Functions like approve, transfer, transferFrom do not. So if during the strategy's lockTokens, a reentrant call is made to transferFrom, which modifies balances, it could lead to an attack. However, since the nonReentrant is on the outer function, but inner calls could still call other functions. For example, during a deposit (nonReentrant), the strategy's lockTokens is called. If that calls back into transferFrom, which is allowed because transferFrom doesn't have nonReentrant. This could allow reentrancy attacks. For example, suppose during deposit, the strategy calls transferFrom, which modifies balances. Depending on the logic, this could be exploited. But since the deposit is still in progress, the state might not be updated yet, but the transferFrom could manipulate balances. This is a potential reentrancy vulnerability despite the nonReentrant modifier, because the modifier only protects against reentrancy into the same function. So cross-function reentrancy is possible.

For example:

1. User deposits into a malicious strategy.
2. The deposit function calls the strategy's lockTokens.
3. The strategy calls back into the SavingsAccount's transferFrom function.
4. The transferFrom function modifies balances while the deposit is still processing.
5. This could lead to inconsistent state or allow the attacker to double-spend or something similar.

This is a possible vulnerability if the strategy can perform reentrant calls to other functions in SavingsAccount.

Another example: during a withdraw, after reducing the balance, the code calls the strategy's unlockTokens, which could call back into the contract's approve function, changing allowances. But approve doesn't have a reentrancy guard. However, changing allowances during a withdraw may not directly lead to a vulnerability unless combined with other actions. But the point is that functions without nonReentrant could be called reentrantly during a strategy interaction, leading to unexpected behavior.

So, cross-function reentrancy is a possible issue here.

Another issue: the contract uses Initializable and OwnableUpgradeable, which are part of an upgradeable contract pattern. However, the contract doesn't have any storage gaps, which are recommended for upgradeable contracts to allow future versions to add variables without causing storage collisions. However, since the user didn't ask for mitigations, just to list vulnerabilities, this is more of a best practice issue rather than a vulnerability, unless the contract is intended to be upgradeable and lacks necessary precautions. But the presence of initializable suggests it's an upgradeable contract, and missing storage gaps could be a vulnerability if the contract is upgraded without considering storage layout. But this might be outside the scope of the current analysis, which focuses on the given code.

Also, the contract uses the override keyword on functions, but the Solidity version is 0.7.6. The override keyword was introduced in 0.8.0, but actually, I think it's available in 0.6.0 and onwards. Wait, checking: Solidity 0.6.0 introduced the override keyword. So in 0.7.6, it's valid. So that's not an issue.

Another thing: the balanceInShares mapping is public, which generates getter functions. This is not a vulnerability per se, but could expose sensitive information. However, that's by design.

In the switchStrategy function, after unlocking tokens, if the token is ERC20, the code approves the new strategy for the tokens. However, if the new strategy is malicious, it could drain the approved tokens. But since the approval is for exactly the tokens received, and the code immediately uses the approval in the lockTokens call, the exposure is limited to that transaction. However, if the lockTokens function doesn't use the entire allowance, the remaining allowance could be used by the strategy in the future. For example, if the strategy is approved for 100 tokens but only uses 90, the remaining 10 could be transferred later. But since the SavingsAccount contract's approval is only done in this function, and each time it's set to the exact amount, this is mitigated. However, the safeApprove issue remains as previously noted.

Another possible vulnerability: incorrect shares calculation during transfer. In the transfer function, if the strategy is not address(0), the code converts _amount to shares using IYield(_strategy).getSharesForTokens(_amount, _token). However, if the strategy uses a different conversion rate, the actual shares transferred could be incorrect. For example, if the strategy's getSharesForTokens returns a different amount than expected, the balanceInShares could be manipulated. But this depends on the strategy's implementation, which is supposed to be trusted via the registry. However, this is a potential point of failure if the strategy is malicious or buggy.

In the withdrawAll function that takes a token and strategy, the code deletes the balanceInShares after unlocking tokens. However, if the unlockTokens call fails, the balance would still be deleted, leading to loss of funds. Wait, no: in withdrawAll, the code is:

uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];
if(_sharesBalance == 0) return 0;
uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);
delete balanceInShares[msg.sender][_token][_strategy];
_transfer(_amount, _token, payable(msg.sender));

If IYield(_strategy).unlockTokens reverts, the entire transaction is reverted, so the delete doesn't happen. So that's safe. However, if unlockTokens returns a value but doesn't actually transfer the tokens (e.g., a malicious strategy), then _transfer would attempt to send _amount tokens, which the contract may not have, leading to a failed transfer. But the code uses SafeERC20's safeTransfer, which checks the return value. So if the strategy's unlockTokens doesn't actually transfer the tokens to the SavingsAccount, then the safeTransfer would fail. So this is handled.

So, summarizing the confirmed vulnerabilities:

1. **Unsafe ERC20 Approval in switchStrategy**: Using safeApprove without resetting the allowance to zero first can cause transaction reverts if there's an existing allowance.

2. **ETH Locked in Contract for non-ETH Deposits**: Depositing ERC20 tokens with sent ETH results in locked ETH in the contract with no way to recover.

3. **Unvalidated Strategies in Transfer Functions**: Transferring shares for strategies not in the registry allows interaction with potentially malicious or invalid strategies.

4. **Cross-Function Reentrancy Risk**: Malicious strategies could reenter functions without nonReentrant modifiers during deposit/withdraw/switch operations.

5. **Denial of Service in getTotalTokens**: If any strategy reverts on getTokensForShares, the entire function call fails.

6. **Potential Front-Running in Allowance Changes**: Although not explicitly found, the functions use SafeMath and follow standard patterns, so maybe not. But cross-function reentrancy is the main issue.

So these are the main vulnerabilities.","```
None.
```",0.0,0
PriceOracle.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     **/
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param token address of token for which price feed is added
     * @param priceOracle addrewss of the price feed for the token
     **/
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",2032.0,223.0,"[H-09] `PriceOracle` Does Not Filter Price Feed Outliers
Function `getLatestPrice()`
If for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.
In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.",1.0,"pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    
    mapping(bytes32 => address) public uniswapPools;

    
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",1404.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Decimal Handling Leading to Price Miscalculations**  
   - The contract uses a separate `decimals` mapping populated via `getDecimals()`, which may return `0` for non-compliant ERC20 tokens. This can cause incorrect scaling in `getChainlinkLatestPrice`, as the calculation relies on `10**decimals[token]`, leading to undervalued/overvalued prices.

2. **Uniswap TWAP Averaging Period Defaults to Zero**  
   - The `uniswapPriceAveragingPeriod` is uninitialized (defaults to `0`), causing `OracleLibrary.consult()` to return spot prices instead of time-weighted averages. This makes the price susceptible to manipulation via flash loans or short-term volatility.

3. **Fixed Liquidity Amount in Uniswap Price Queries**  
   - `getUniswapLatestPrice` uses a fixed `10**30` as the input amount for price quotes. This unrealistic value may cause inaccurate pricing in low-liquidity pools or tokens with non-standard decimals, potentially leading to overflow/underflow errors.

4. **Stale Price Fallback to Manipulable Uniswap Prices**  
   - If Chainlink feeds return stale data (e.g., due to `answeredInRound < roundID`), the contract falls back to Uniswap prices. If the Uniswap TWAP period is unset (`0`), this creates a risk of using easily manipulated spot prices.

5. **Lack of Validation for Uniswap Pool Addresses**  
   - `setUniswapFeedAddress` does not verify if the provided pool is a valid Uniswap V3 pool. An invalid or malicious pool address could return incorrect ticks, leading to erroneous price data.

6. **Insecure ERC20 Decimals Handling**  
   - If a token's `decimals()` function reverts or is missing, `getDecimals()` returns `0`, causing the `decimals` mapping to store `0`. This results in incorrect scaling during Chainlink price calculations (e.g., treating an 18-decimal token as 0 decimals).

7. **Over-Reliance on Owner Configuration**  
   - Critical parameters (e.g., Chainlink feeds, Uniswap pools, TWAP period) require manual setup by the owner. Misconfiguration (e.g., forgetting to set the TWAP period) leaves the contract vulnerable by default.

8. **Potential Integer Overflow/Underflow in Price Calculation**  
   - While `SafeMath` is used, the complex scaling in `getChainlinkLatestPrice` (e.g., `10**30`) could exceed integer limits if token decimals are improperly configured, leading to reverts or incorrect prices.","### **[H-09] `PriceOracle` Does Not Filter Price Feed Outliers**

**Report Description**:  
The `getLatestPrice()` function in the `PriceOracle` contract does not filter out malformed or outlier prices returned by the Chainlink oracle. This could occur due to oracle manipulation or malfunctions, leading to unintended consequences for users. The lack of mitigation mechanisms for price outliers creates a substantial attack surface, as user economics could be adversely affected by unsustainable price movements. Implementing safeguards to filter or validate price data is crucial to ensure the reliability of the oracle.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. None of the responses in the `response_list` address the issue of filtering or validating price feed outliers in the `PriceOracle` contract. While the responses cover related vulnerabilities such as incorrect decimal handling, stale price fallbacks, and insecure ERC20 decimals handling, they do not specifically address the need for outlier detection or mitigation mechanisms in the price feed data. This is a critical gap, as the absence of such safeguards exposes the contract to significant risks from manipulated or malfunctioning oracles.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-09] `PriceOracle` Does Not Filter Price Feed Outliers**",0,0,1,8,"Okay, let's take a look at this PriceOracle contract and try to find any vulnerabilities. Hmm, first, I'll start by going through the code step by step.

The contract imports several libraries and interfaces, like Chainlink's AggregatorV3Interface and Uniswap's OracleLibrary. It's using OpenZeppelin's OwnableUpgradeable, which suggests it's an upgradeable contract. There's also SafeMath being used, which is good for preventing overflows, but since they're using Solidity 0.7.6, maybe that's necessary. Wait, but Solidity 0.8.x has built-in overflow checks. But that's a compiler version issue rather than a vulnerability.

Looking at the state variables: there's a uniswapPriceAveragingPeriod which is a uint32. Then there's a mapping for chainlinkFeedAddresses, which maps tokens to their PriceData (oracle address and decimals). Another mapping called decimals for tokens, which seems redundant because PriceData already has decimals. Oh wait, in the struct PriceData, there's a decimals field, but then there's a separate decimals mapping. That might be a problem. Like, when setting the chainlink feed, they store priceOracleDecimals in chainlinkFeedAddresses[token].decimals, but also set decimals[token] via getDecimals(token). Wait, the getDecimals function is trying to get the token's ERC20 decimals. But for Chainlink feeds, maybe the feed's decimals are different from the token's. So storing both might be correct, but maybe there's a confusion here. Let's see in the getChainlinkLatestPrice function.

In getChainlinkLatestPrice, they use _feedData1.decimals and _feedData2.decimals (which are from the Chainlink feed's decimals) and then multiply by 10**decimals[den] and divide by 10**decimals[num]. Wait, decimals[den] is the ERC20 decimals of the denominator token, and decimals[num] is the ERC20 decimals of the numerator. But when you have a price feed, the calculation might not account for token decimals properly. Let me check the formula:

price = (price1 * 10^feed2Decimals * 1e30) / (price2 * 10^feed1Decimals) * 10^denDecimals / 10^numDecimals.

Hmm, so Chainlink's price feeds typically return the price with their own decimals. For example, if feed1 is BTC/USD with 8 decimals, price1 is the number in 8 decimals. Similarly for feed2. Then combining those with the ERC20 decimals of num and den. Maybe this formula could have scaling errors. For instance, if the feeds have different decimals than the tokens, the calculation might not scale the price correctly. That could lead to incorrect price values. That's a possible vulnerability.

Another thing: in getChainlinkLatestPrice, when checking the Chainlink feed's answeredInRound, the code checks if answeredInRound < roundID. But according to Chainlink's documentation, if answeredInRound is less than roundID, it means the price is from a previous round and might be stale. So that check is correct. However, the code returns (0,0) in that case, which would cause the getLatestPrice to fallback to Uniswap. But if the Chainlink feed returns stale data, the contract might use an incorrect or outdated price. Wait, no, because if it's stale, they return (0,0) and proceed to check Uniswap. But maybe the Chainlink feed is considered more reliable, and if it's stale but returns a non-zero price, this could be an issue. However, the code here correctly checks for answeredInRound >= roundID. Wait, no: they check if answeredInRound < roundID, which would mean the data is stale, so they return (0,0). That's correct. So that part is okay.

Moving on to the getDecimals function. It tries to get the decimals of the token, and if it fails, returns 0. But in the setChainlinkFeedAddress function, decimals[token] is set to getDecimals(token). If the token doesn't implement decimals() correctly (e.g., some tokens might not follow the standard and cause a revert), the getDecimals would catch it and return 0. Then decimals[token] would be 0, which would cause division by zero in getChainlinkLatestPrice when multiplying 10**decimals[den] or dividing by 10**decimals[num]. For example, if a token's decimals is 0, then 10**0 is 1, but if the decimals mapping returns 0 for a token that actually has 18 decimals, that's an issue. Wait, the getDecimals function is called when setting the chainlink feed. So if a token doesn't return decimals properly, decimals[token] would be 0. Then, in the price calculation, when you have 10**decimals[den], if decimals[den] is 0, that's 1. But if the token actually has 18 decimals, but the code uses 0, then the scaling would be wrong. For example, if the denominator token has 18 decimals but the code uses 0, then 10**0 is 1, which would under-scale the price. So this could lead to incorrect price calculations. That's a vulnerability because tokens with non-standard decimals implementations could cause incorrect scaling.

Next, looking at the Uniswap part. The getUniswapLatestPrice uses OracleLibrary.consult with uniswapPriceAveragingPeriod. If the averaging period is not set, it uses the default value of 0. But the uniswapPriceAveragingPeriod is initialized where? The variable is declared as uint32, but in the code, it's not initialized in the initialize function. So when the contract is deployed, uniswapPriceAveragingPeriod is 0. Using a zero period for the TWAP (Time-Weighted Average Price) could mean that the price is taken from the most recent tick, which is equivalent to the spot price and vulnerable to manipulation. TWAPs are supposed to use a period long enough to prevent such manipulation. So if the averaging period is 0, that's a problem. The owner can set it via setUniswapPriceAveragingPeriod, but if they forget, it defaults to 0, leading to insecure price feeds. That's a critical vulnerability.

Another issue with the Uniswap price feed: in getUniswapLatestPrice, they call OracleLibrary.getQuoteAtTick with 10**30 as the amount. The comment says they return 30 decimals. But if the tokens have different decimals, how does this scaling work? For example, if num is USDC (6 decimals) and den is WETH (18 decimals), then 10^30 of num would be an unrealistic amount. However, the getQuoteAtTick function's parameters are the tick, the amount of the base token (num), and the base and quote tokens. The function should return the equivalent quote token amount. But using 10^30 might be problematic if the actual liquidity in the pool is low. For instance, if the pool doesn't have enough liquidity to support such a large amount, the price could be incorrect or manipulated. Using a fixed amount like 1e18 might be better, but here 1e30 is used. However, the scaling here might lead to overflows or incorrect prices if the tokens have high decimals. Also, the function returns 30 as the decimals, but that might not match the actual decimals of the tokens. For example, if the tokens have 18 and 6 decimals, the actual price decimals would depend on the calculation, but returning 30 might not be accurate. This could lead to incorrect price scaling when used elsewhere in the system.

Looking at the getUniswapPoolTokenId function: it sorts the tokens by their address to create the pool ID. That's correct because Uniswap pools are identified by the sorted token addresses.

In the getLatestPrice function, it first tries Chainlink, then Uniswap. If neither exists, it reverts. That's okay. But if Chainlink returns (0,0) because of a stale price, then it falls back to Uniswap. However, if the Uniswap price is also not available, it reverts. But if the Uniswap price is available but manipulable (due to 0 averaging period), then the system could use a manipulated price.

Another vulnerability is in the setChainlinkFeedAddress function. It allows the owner to set the priceOracle for a token, but there's no validation that the priceOracle address is actually a valid Chainlink aggregator. If the owner mistakenly sets a malicious contract here, it could return arbitrary prices. However, since it's an onlyOwner function, it's a trust issue. But in terms of vulnerabilities, if the owner is compromised, this could be a problem, but that's more of an admin key risk rather than a code vulnerability. Unless there's a way for a non-owner to set the feed, which there isn't.

In the setUniswapFeedAddress function, they check that token1 != token2. But there's no check that the pool address is a valid Uniswap V3 pool. If an invalid pool is set, the consult function might fail or return incorrect data. However, again, this is an admin responsibility. But if the pool is not a valid Uniswap V3 pool, calling OracleLibrary.consult could revert or return incorrect ticks, leading to wrong prices. This could be a vulnerability if the owner sets a malicious or incorrect pool.

Looking at the decimals mapping: there's a separate decimals mapping that's set in setChainlinkFeedAddress. But for tokens that aren't set via this function, their decimals would remain uninitialized. However, in getChainlinkLatestPrice, decimals[num] and decimals[den] are used. If those tokens haven't had their decimals set via setChainlinkFeedAddress, the decimals mapping would return 0. For example, if someone calls getLatestPrice for two tokens that have Chainlink feeds set, but their decimals weren't properly stored (maybe the setChainlinkFeedAddress wasn't called for them), then decimals[num] would be 0. Wait, no: the setChainlinkFeedAddress function is called per token. So when you set the Chainlink feed for a token, you also set decimals[token] via getDecimals(token). So if a token hasn't had its Chainlink feed set, then decimals[token] would be 0. But in getChainlinkLatestPrice, the code uses the decimals mapping for the num and den tokens. However, the function is supposed to be called for tokens that have Chainlink feeds, but maybe there's a case where the feeds exist but decimals weren't set. Wait, no: when you set the Chainlink feed via setChainlinkFeedAddress, it sets decimals[token] = getDecimals(token). So if the token's decimals() function works, it's set correctly. If not, decimals[token] is 0, leading to possible division by zero or incorrect scaling.

Another thing: the getDecimals function returns 0 if the token's decimals() call fails. Then, when setting decimals[token], it could be 0. For tokens that actually have 18 decimals (like ETH), but if their decimals() function is not called correctly (e.g., because the token is address(0), which is handled as 18), but in getDecimals, if the token is address(0), it returns 18. Wait, no: in getDecimals, if _token is address(0), return 18. So for the native token (ETH), decimals is 18. Otherwise, try to get decimals from ERC20. If that fails, return 0. So in decimals mapping, when set via setChainlinkFeedAddress, it calls getDecimals(token), which for address(0) would return 18. But the problem is if the token is a ERC20 that doesn't implement decimals() correctly. For example, a token that doesn't have the decimals() function would cause getDecimals to return 0, and thus decimals[token] would be 0. Then, in the price calculation, when you have 10**decimals[den], which is 10^0 =1, but if the actual token has 18 decimals, this would scale incorrectly. For example, if the denominator token should have 18 decimals but is considered 0, the price would be multiplied by 1 (instead of 1e18), leading to a much lower price than actual. This is a critical issue because tokens with non-compliant decimals would cause incorrect price calculations.

Another possible issue is reentrancy, but since all functions are view or onlyOwner, and there are no external calls besides the Chainlink and ERC20 decimals calls. However, the latestRoundData function is called on external oracles, which could theoretically be malicious, but Chainlink feeds are trusted. However, if a malicious oracle is set (via setChainlinkFeedAddress), it could cause reentrancy. But since the getChainlinkLatestPrice is a view function, maybe reentrancy isn't possible here. So probably not a vulnerability here.

In the setChainlinkFeedAddress function, the code retrieves AggregatorV3Interface(priceOracle).decimals(). But if the priceOracle address is not a valid AggregatorV3Interface, this call would revert, causing the entire transaction to fail. However, since this function is onlyOwner, it's up to the owner to set valid addresses. But if the owner accidentally sets a wrong address, the transaction would revert. So this is more of an input validation issue. However, the code doesn't check if priceOracle is a contract or not. For example, if the owner sets an EOA address, the decimals() call would fail, causing the transaction to revert. So the function does have some validation through the AggregatorV3Interface call. But if the priceOracle is a contract that doesn't implement decimals(), it would revert. So the function requires that the priceOracle is a compliant Aggregator, which is correct.

In summary, the vulnerabilities I can see are:

1. Incorrect handling of token decimals leading to price miscalculations. If a token's decimals cannot be retrieved (returns 0), the scaling in getChainlinkLatestPrice would be wrong. For example, if a token has 18 decimals but the code uses 0, then 10**0 is 1, which would incorrectly scale the price.

2. Uniswap TWAP averaging period defaulting to 0, making the price susceptible to manipulation. If the owner doesn't set a proper averaging period, the consult function uses the latest tick, which is equivalent to spot price and can be easily manipulated.

3. Using a fixed amount of 1e30 in getUniswapLatestPrice which could lead to incorrect quotes if the pool doesn't have sufficient liquidity. Large amounts can cause inaccurate price quotes due to slippage or liquidity constraints.

4. The decimals mapping is set based on the ERC20's decimals, but if the token doesn't implement it correctly, leading to incorrect scaling in price calculations.

5. Potential division by zero in getChainlinkLatestPrice if decimals[num] is 0. For example, if num is a token with decimals set to 0 in the mapping, then 10**decimals[num] would be 1, but if the actual token has higher decimals, the division would reduce the price incorrectly. Wait, division by 10^0 is 1, so no division by zero here, but incorrect scaling.

6. If both tokens in a Chainlink feed are set, but one of them has a stale price (answeredInRound < roundID), then the function falls back to Uniswap. However, if Uniswap's price is based on an averaging period of 0, it might use a manipulated price. This creates a scenario where a stale Chainlink feed could lead to using an insecure Uniswap price.

7. Lack of validation in setUniswapFeedAddress that the provided pool address is a valid Uniswap V3 pool. If an invalid pool is set, consult could fail or return incorrect data, leading to wrong prices.

So the main vulnerabilities are related to incorrect decimal handling, insecure default TWAP period, potential liquidity issues in Uniswap price quotes, and reliance on proper admin setup without sufficient validation.","```
None.
```",0.0,0
NoYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to query liquidity token for a given asset
     * @param _asset address of the asset
     * @return _tokenAddress address of the lqiudity token for the asset
     **/
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    /**
     * @notice Used to lock tokens in the protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from the protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return tokensReceived received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",1322.0,165.0,"[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()
“function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received)”
`received` is not being assigned prior to L81, therefore, at L81, received is 0.
As a result, the `emergencyWithdraw()` does not work, in essence.


[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract
The `emergencyWithdraw` function is implemented in all yield sources to allow the onlyOwner role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on _asset which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the NoYield contract in the event of an emergency.
  [M-06] NoYield.sol Tokens with fee on transfer are not supported
There are ERC20 tokens that charge fee for every transfer() or transferFrom().
In the current implementation, NoYield.sol#lockTokens() assumes that the received amount is the same as the transfer amount, and uses it to calculate sharesReceived amounts.
As a result, in `unlockTokens()`, later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance.",3.0,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';


contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",786.0,2,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Token Transfer in `emergencyWithdraw`:**
   - **Issue:** The `emergencyWithdraw` function transfers `received` (which is uninitialized and defaults to `0`) instead of `amount`. This results in no tokens being transferred, even though the function returns `amount` as the received value.
   - **Code Reference:**
     ```solidity
     IERC20(_asset).safeTransfer(_wallet, received); // Incorrect (uses uninitialized 'received')
     received = amount; // Return value is correct, but transfer is invalid
     ```

2. **Inconsistent ETH Handling in `lockTokens`:**
   - **Issue:** When `asset` is `address(0)` (ETH), the function checks `msg.value` from the caller (`savingsAccount`), not the `user` parameter. This means the `savingsAccount` (not the intended `user`) must supply ETH, breaking the ERC20/ETH consistency and potentially leading to loss of funds.
   - **Code Reference:**
     ```solidity
     require(msg.value == amount, 'Invest: ETH amount'); // msg.value is from savingsAccount, not 'user'
     ```

3. **ETH Locking Risk:**
   - **Issue:** The contract lacks a `receive()` or `fallback()` function, making it impossible to receive ETH outside of `lockTokens`. If ETH is forcibly sent (e.g., via `selfdestruct`), it becomes irretrievably stuck.

4. **Incorrect Share/Token Accounting (Design Flaw):**
   - **Issue:** The `getTokensForShares` and `getSharesForTokens` functions return a 1:1 ratio, implying no yield or fees. While this may be intentional for a ""NoYield"" contract, it could lead to integration risks if external systems expect dynamic share calculations.

5. **Ownership Transfer Risk in Initialization:**
   - **Issue:** The `initialize` function transfers ownership via `super.transferOwnership(_owner)`, which could conflict with the inherited `OwnableUpgradeable` initialization. While not directly exploitable, this pattern is unconventional in upgradeable contracts.","### **Output**

---

**[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Report Description**:  
The `emergencyWithdraw` function in `NoYield.sol` does not assign a value to `received` before using it in the token transfer. As a result, `received` defaults to `0`, causing the function to fail to transfer any tokens. This renders the `emergencyWithdraw` function ineffective.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Token Transfer in `emergencyWithdraw`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the uninitialized `received` variable in the `emergencyWithdraw` function. It correctly explains that the function transfers `0` tokens due to the uninitialized value, which aligns with the reported issue.

---

**[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**

**Report Description**:  
The `emergencyWithdraw` function in the `NoYield` contract does not handle ETH withdrawals correctly. ETH is treated as a zero address asset, but the function attempts to call `IERC20(_asset).safeTransfer`, which will revert if `_asset` is the zero address. This prevents ETH from being withdrawn in emergencies.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of ETH withdrawal in the `emergencyWithdraw` function. This is a critical oversight, as it prevents the contract from functioning as intended in emergencies.

---

**[M-06] NoYield.sol Tokens with fee on transfer are not supported**

**Report Description**:  
The `NoYield.sol` contract does not account for ERC20 tokens that charge a fee on transfer. The `lockTokens` function assumes the received amount is equal to the transfer amount, which is incorrect for fee-on-transfer tokens. This discrepancy can lead to insufficient balance errors in `unlockTokens`, preventing users from withdrawing their tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of fee-on-transfer tokens in the `NoYield.sol` contract. This is a significant oversight, as it can lead to user funds being locked in the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**
- **[M-06] NoYield.sol Tokens with fee on transfer are not supported**

--- 

### **Conclusion**

The response list partially addresses the issues in the `NoYield.sol` contract but misses critical vulnerabilities related to ETH withdrawals and fee-on-transfer tokens. These gaps highlight the need for a more comprehensive review of the contract's functionality and edge cases.",1,0,2,5,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. First, I'll go through each function and see if there's anything that stands out.

Starting with the imports and inheritance. The contract uses OpenZeppelin's OwnableUpgradeable, ReentrancyGuard, and Initializable. Also, it's using SafeERC20 and SafeMath. Since it's an upgradeable contract, that's something to note, but maybe not a vulnerability by itself. Let me check if the initializer is properly set. The initialize function calls __Ownable_init() and then transferOwnership. Wait, they're using super.transferOwnership(_owner), which might be okay, but I need to make sure that's the right way in upgradeable contracts.

Looking at the modifiers. The onlySavingsAccount modifier checks if the sender is the savingsAccount address. That's used in functions like lockTokens. The savingsAccount is set via initialize and can be updated by the owner. So maybe if the owner is malicious, they could change the savingsAccount address. But since the owner is supposed to be trusted, that's a trust issue rather than a vulnerability. However, if there's no timelock or event for changing savingsAccount, maybe there's a risk of a front-running attack or a rug pull. Wait, the updateSavingsAccount function emits an event, so that's tracked, but maybe the emergencyWithdraw could be a problem.

The emergencyWithdraw function allows the owner to withdraw any ERC20 token to a specified wallet. The problem here is that in the code, they transfer 'received' instead of 'amount'. Wait, the code says:

uint256 amount = IERC20(_asset).balanceOf(address(this));
IERC20(_asset).safeTransfer(_wallet, received);
received = amount;

But 'received' here is uninitialized. Because received is declared as a return variable (returns (uint256 received)), then in the code, they first do safeTransfer with 'received', which is 0, and then assign received = amount. That's a bug. The transfer is sending 0 tokens, and then returning the amount. So the function would not actually send the tokens, but the owner might think they did. That's a critical issue. The intended behavior is to transfer 'amount' to _wallet, but instead, it's transferring 'received', which is 0 at that point.

Another thing to check is the use of payable addresses. The savingsAccount is a payable address. When transferring ETH, in the _unlockTokens function, if the asset is address(0) (ETH), they call savingsAccount.call{value: received}(''). But there's a reentrancy guard modifier on the functions that call _unlockTokens. Since the functions unlockTokens and unlockShares have the nonReentrant modifier, maybe that's safe. But what if the savingsAccount is a malicious contract that could do something else? However, since onlySavingsAccount modifier is in place, maybe that's considered trusted. Still, using .call without gas limits could be a problem for out-of-gas errors, but maybe not a vulnerability here.

Looking at the lockTokens function. It handles both ERC20 and ETH. For ETH, it checks that msg.value == amount. If the asset is address(0), the user has to send ETH. But when the function is called by savingsAccount (onlySavingsAccount modifier), does that mean the savingsAccount is the one sending the ETH? Or is the 'user' parameter the one who is charged? Wait, the lockTokens function is called by the savingsAccount (due to onlySavingsAccount), and the parameters include 'user' and 'asset'. If the asset is ETH, then the msg.value must equal the amount. But since the function is called by the savingsAccount, the savingsAccount is the one sending the ETH, not the 'user'. However, the code says IERC20(asset).safeTransferFrom(user, address(this), amount); for ERC20, which would transfer from the user to the contract. But for ETH, the savingsAccount is sending the ETH, not the user. That's a discrepancy. Because for ERC20, the user's tokens are being pulled via transferFrom, which requires approval. But for ETH, the msg.value is coming from the savingsAccount, not the user. That could be a problem because the intention might be that the user is locking their own ETH, but in this code, the savingsAccount is the one sending ETH. So if the savingsAccount calls lockTokens with asset as ETH, they have to provide the ETH themselves, which might not be intended. That's a logical error or a vulnerability where the ETH is not coming from the user but from the savingsAccount.

Also, in the emergencyWithdraw function, after transferring 0 tokens (due to the bug), the received variable is set to amount. So the return value would be correct, but the actual transfer didn't happen. So the owner would think they received the tokens, but they didn't. That's a major issue.

Another thing: the functions getTokensForShares and getSharesForTokens just return the input amount, implying a 1:1 ratio. That's probably by design if this is a ""NoYield"" contract, but if that's intended, maybe there's no issue. But if other parts of the system expect these functions to calculate something differently, that could be a problem, but not a vulnerability in the contract itself.

Also, in the unlockTokens and unlockShares functions, they both call _unlockTokens. The unlockTokens is supposed to return tokensReceived, and unlockShares returns received. Since they both call the same internal function, perhaps there's confusion between shares and tokens here. But in this contract, shares and tokens are 1:1, so maybe it's okay, but if the contract is supposed to handle different share mechanisms, that could be an issue. However, given the context of NoYield, maybe it's intentional.

Reentrancy is guarded by the nonReentrant modifier, which is good. So even though they use .call for ETH transfers, the nonReentrant should prevent reentrancy attacks.

Other possible issues: the initialize function can be called externally, but it's using the initializer modifier, which should prevent it from being called multiple times. Since it's an upgradeable contract, that's handled properly.

Another thing to check is if the contract is receiving ETH but doesn't have a receive() or fallback() function. If someone sends ETH directly to the contract address outside of the lockTokens function, it would get stuck. But since the contract only handles ETH through the lockTokens function (which requires the savingsAccount to call it and send ETH along), maybe that's acceptable. However, if there's a way for ETH to be sent to the contract without going through lockTokens, it would be stuck. So the contract lacks a receive function, but in Solidity 0.7.6, if a contract receives ETH without a payable function, the transaction would revert. Wait, no. The contract doesn't have any receive or fallback functions. So if someone tries to send ETH to the contract directly, the transaction would fail. But since the only way ETH is supposed to come in is via lockTokens (which is payable and checks msg.value), maybe that's okay. But in the case where someone sends ETH via a selfdestruct or coinbase transaction, the contract would hold the ETH but wouldn't be able to process it. However, that's an external consideration and might not be a vulnerability in the contract's code.

In summary, the main vulnerabilities found are:

1. The emergencyWithdraw function transfers 0 tokens due to a variable mix-up (transferring 'received' instead of 'amount').

2. The lockTokens function for ETH (address(0)) incorrectly pulls ETH from the savingsAccount instead of the user, leading to inconsistent behavior between ERC20 and ETH handling.

3. Potential ETH getting stuck if sent outside of lockTokens, but since the contract isn't supposed to receive ETH that way, it's a possible issue but depends on usage.

The most critical one is the emergencyWithdraw bug. Then the ETH handling in lockTokens.","```
1. Incorrect Token Transfer in `emergencyWithdraw`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of true positives in the ranked list of predictions**:
   - The true positive is: ""Incorrect Token Transfer in `emergencyWithdraw`"".
   - This appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at the rank where the true positive appears**:
   - At rank 1, there is 1 true positive out of 1 prediction.
   - Precision at rank 1 (\( P@1 \)) = \( \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where it appears.
   - AP = \( P@1 = 1.0 \).

**Output**:
```
1.0
```",1
PoolFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';

/**
 * @title Pool Factory contract with methods for handling different pools
 * @notice Implements the functions related to Pool (CRUD)
 * @author Sublime
 */
contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    /*
     * @notice Used to define limits for the Pool parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /**
     * @notice function definition of the pool contract
     */
    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(""initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)""))

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public poolImpl;

    /**
     * @notice address of the contract storing the user registry
     */
    address public override userRegistry;

    /**
     * @notice address of the contract storing the strategy registry
     */
    address public strategyRegistry;

    /**
     * @notice address of the latest implementation of the extension logic
     */
    address public override extension;

    /**
     * @notice address of the latest implementation of the repayment logic
     */
    address public override repaymentImpl;

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public override priceOracle;

    /**
     * @notice address of the savings account used
     */
    address public override savingsAccount;

    /**
     * @notice the time interval for the lenders to make contributions to pool
     */
    uint256 public override collectionPeriod;

    /**
     * @notice the time interval for the borrower to withdraw the loan from pool
     */
    uint256 public override loanWithdrawalDuration;

    /**
     * @notice the time interval for the active stage of the margin call
     */
    uint256 public override marginCallDuration;

    /**
     * @notice Fraction of the requested amount for pool below which pool is cancelled
     */
    uint256 public override minBorrowFraction;

    /**
     * @notice the fraction used for calculating the liquidator reward
     */
    uint256 public override liquidatorRewardFraction;

    /**
     * @notice the fraction used for calculating the penalty when the pool is cancelled
     */
    uint256 public override poolCancelPenaltyMultiple;

    /**
     * @notice Contract Address of no yield
     */
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    /*
     * @notice Used to mark assets supported for borrowing
     */
    mapping(address => bool) isBorrowToken;

    /*
     * @notice Used to mark supported collateral assets
     */
    mapping(address => bool) isCollateralToken;

    /**
     * @notice Used to keep track of valid pool addresses
     */
    mapping(address => bool) public override poolRegistry;

    /*
     * @notice Used to set the min/max borrow amount for Pools
     */
    Limits poolSizeLimit;

    /*
     * @notice Used to set the min/max collateral ratio for Pools
     */
    Limits idealCollateralRatioLimit;

    /*
     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools
     */
    Limits borrowRateLimit;

    /*
     * @notice used to set the min/max repayment interval for Pools
     */
    Limits repaymentIntervalLimit;

    /*
     * @notice used to set the min/max number of repayment intervals for Pools
     */
    Limits noOfRepaymentIntervalsLimit;

    /**
     * @notice functions affected by this modifier can only be invoked by the Pool
     */
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    /**
     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool
     */
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    /**
     * @notice returns the owner of the pool
     */
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    /**
     * @notice used to initialize the pool factory
     * @dev initializer can only be run once
     * @param _admin address of admin
     * @param _collectionPeriod period for which lenders can lend for pool
     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts
     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained
     * @param _poolInitFuncSelector function signature for initializing pool
     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30
     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30
     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30
     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee
     * @param _protocolFeeCollector address where protocol fee is collected
     * @param _noStrategy address of the no strategy address
     */
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    /**
     * @notice used to setImplementation addresses
     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke
     * @param _poolImpl address of the implementation address of pool
     * @param _repaymentImpl address of the implementation address of repayments
     * @param _userRegistry address of the user registry where users are verified
     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted
     * @param _priceOracle address of the price oracle
     * @param _savingsAccount address of the savings account contract
     * @param _extension address of the extension contract for pools
     */
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    /**
     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request
     * @param _poolSize loan amount requested
     * @param _borrowToken borrow asset requested
     * @param _collateralToken collateral asset requested
     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower
     * @param _borrowRate interest rate provided by the borrower
     * @param _repaymentInterval interval between the last dates of two repayment cycles
     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan
     * @param _poolSavingsStrategy savings strategy selected for the pool collateral
     * @param _collateralAmount collateral amount deposited
     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet
     * @param _salt random and unique initial seed
     */
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    // @dev These functions are used to avoid stack too deep
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    // @dev These functions are used to avoid stack too deep
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    /**
     * @notice invoked to check if pool parameters are within thresholds
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    /**
     * @notice used to update the list of supported borrow tokens
     * @param _borrowToken address of the borrow asset
     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset
     */
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    /**
     * @notice used to update the list of supported Collateral tokens
     * @param _collateralToken address of the Collateral asset
     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset
     */
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    /**
     * @notice used to update the pointer to Initializer function of the proxy pool contract
     * @param _functionId updated function definition of the proxy pool contract
     */
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    /**
     * @notice used to update the Pool.sol logic
     * @param _poolLogic the address of the new Pool logic contract
     */
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    /**
     * @notice used to update the user registry
     * @param _userRegistry address of the contract storing the user registry
     */
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    /**
     * @notice used to update the strategy registry
     * @param _strategyRegistry address of the contract storing the strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the implementation of the repayment logic
     * @param _repaymentImpl address of the updated repayment.sol contract
     */
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    /**
     * @notice used to update contract address of nostrategy contract
     * @param _noStrategy address of the updated noYield.sol contract
     */
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    /**
     * @notice used to update the implementation of the price oracle logic
     * @param _priceOracle address of the updated price oracle contract
     */
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the extensions contract
     * @param _extension address of the updated extensions contract
     */
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    /**
     * @notice used to update the savings account contract
     * @param _savingsAccount address of the updated savings account contract
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the collection period of the Pool
     * @param _collectionPeriod updated value of the collection period
     */
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    /**
     * @notice used to update the loan withdrawal duration by owner
     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration
     */
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    /**
     * @notice used to update the active stage of the margin call of the Pool
     * @param _marginCallDuration updated value of the margin call duration
     */
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    /**
     * @notice used to update the min borrow fraction by owner
     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30
     */
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    /**
     * @notice used to update the reward fraction for liquidation of the Pool
     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30
     */
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the pool cancel penalty multiple
     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30
     */
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    /**
     * @notice used to update the fraction of borrowed amount charged as protocol fee
     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the address in which protocol fee is collected
     * @param _protocolFeeCollector updated address of protocol fee collector
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the thresholds of the pool size of the Pool
     * @param _min updated value of the minimum threshold value of the pool size
     * @param _max updated value of the maximum threshold value of the pool size
     */
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collateral ratio of the Pool
     * @param _min updated value of the minimum threshold value of the collateral ratio
     * @param _max updated value of the maximum threshold value of the collateral ratio
     */
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the Pool
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the repayment interval of the Pool
     * @param _min updated value of the minimum threshold value of the repayment interval
     * @param _max updated value of the maximum threshold value of the repayment interval
     */
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the number of repayment intervals of the Pool
     * @param _min updated value of the minimum threshold value of the number of repayment intervals
     * @param _max updated value of the maximum threshold value of the number of repayment intervals
     */
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    /**
     * @notice used to query protocol fee fraction and address of the collector
     * @return protocolFee Fraction multiplied by 10**30
     * @return address of protocol fee collector
     */
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",6187.0,746.0,"[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it
If a borrower calls the `createPool` function with a non-zero value, but also includes an ERC20 token address for `_collateralToken`, then the Ether value sent will be locked in the PoolFactory contract forever.
In the `_createPool` function, a `_collateralToken` address other than the zero address will set the `amount` variable to zero. That amount variable will be passed to `create2` which will send 0 wei to the newly created Pool contract.
“uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;”",1.0,"pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';


contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    
    struct Limits {
        uint256 min;
        uint256 max;
    }

    
    bytes4 public poolInitFuncSelector; 

    
    address public poolImpl;

    
    address public override userRegistry;

    
    address public strategyRegistry;

    
    address public override extension;

    
    address public override repaymentImpl;

    
    address public override priceOracle;

    
    address public override savingsAccount;

    
    uint256 public override collectionPeriod;

    
    uint256 public override loanWithdrawalDuration;

    
    uint256 public override marginCallDuration;

    
    uint256 public override minBorrowFraction;

    
    uint256 public override liquidatorRewardFraction;

    
    uint256 public override poolCancelPenaltyMultiple;

    
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    
    mapping(address => bool) isBorrowToken;

    
    mapping(address => bool) isCollateralToken;

    
    mapping(address => bool) public override poolRegistry;

    
    Limits poolSizeLimit;

    
    Limits idealCollateralRatioLimit;

    
    Limits borrowRateLimit;

    
    Limits repaymentIntervalLimit;

    
    Limits noOfRepaymentIntervalsLimit;

    
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",3731.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unchecked `msg.value` for Non-ETH Collateral**  
   - **Description**: When creating a pool with a non-ETH collateral token (`_collateralToken != address(0)`), the contract does not ensure that `msg.value` is zero. Users sending ETH in this scenario will irreversibly lose their funds, as the ETH remains stuck in the `PoolFactory` contract.  
   - **Location**: `createPool` function.  

2. **Centralization Risks**  
   - **Description**: Critical parameters (e.g., `userRegistry`, `priceOracle`, `strategyRegistry`) and token approvals (e.g., `isBorrowToken`, `isCollateralToken`) are controlled solely by the owner. A compromised owner account could manipulate these settings to bypass security checks or deploy malicious pools.  
   - **Impact**: Full trust in the owner is required, violating decentralization principles.  

3. **Storage Inconsistency for Destroyed Pools**  
   - **Description**: The `poolRegistry` mapping does not remove entries when pools are destroyed. Destroyed pools remain marked as valid, potentially causing other systems to interact with invalid/non-existent pools.  
   - **Location**: `poolRegistry` mapping and pool creation/destruction logic.  

4. **Outdated Compiler Version**  
   - **Description**: The contract uses Solidity 0.7.6, which lacks security fixes and features present in newer versions (e.g., 0.8.x). This increases the risk of undetected compiler-level vulnerabilities.  

5. **Missing Zero-Address Checks**  
   - **Description**: Critical address updates (e.g., `_updateProtocolFeeCollector`, `_updateUserRegistry`) do not validate if the new address is `address(0)`. This could lead to accidental or intentional assignment of invalid addresses, disrupting protocol functionality.  

6. **Insufficient Handling of ETH in Proxy Deployment**  
   - **Description**: The `_deploy` function forwards ETH to the Proxy contract during pool creation. If the Proxy’s constructor is not payable or mishandles ETH, funds could be locked or lost. This depends on the external `Proxy.sol` implementation (not shown).  

7. **Reliance on External Contract Validity**  
   - **Description**: The contract assumes that external dependencies (e.g., `userRegistry`, `priceOracle`, `strategyRegistry`) are correctly implemented and secure. Compromised or misconfigured external contracts could lead to protocol-wide exploits.  

8. **Incorrect Collateral Token Pair Assumption**  
   - **Description**: The check `_borrowToken != _collateralToken` does not account for wrapped/derivative tokens (e.g., WETH vs. ETH). This may allow unintended collateral-borrow pairs if such tokens are whitelisted.  

9. **No Enforcement of Limits When Min/Max Are Zero**  
   - **Description**: The `isWithinLimits` function allows any value if both `_min` and `_max` are zero. Misconfiguration by the owner (e.g., setting all limits to zero) could disable parameter constraints entirely.  

10. **Lack of Input Validation in `createPool`**  
    - **Description**: The function does not verify if `_collateralAmount` is non-zero for non-ETH collateral tokens, potentially allowing undercollateralized pools if the pool initialization does not enforce transfers.  

11. **Risk of Stale/Oracle Manipulation**  
    - **Description**: The dependency on `priceOracle` for token price feeds introduces risks of incorrect pricing (e.g., stale data, manipulation), affecting loan terms and collateral requirements.  

These vulnerabilities range from critical (e.g., fund loss via `msg.value`) to operational risks (e.g., centralization). Each poses varying levels of threat depending on the protocol’s setup and external dependencies.","### **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

**Report Description**:  
If a borrower calls the `createPool` function with a non-zero value but includes an ERC20 token address for `_collateralToken`, the Ether value sent will be locked in the `PoolFactory` contract forever. In the `_createPool` function, a `_collateralToken` address other than the zero address sets the `amount` variable to zero. This `amount` variable is passed to `create2`, which sends 0 wei to the newly created `Pool` contract. As a result, the Ether remains stuck in the `PoolFactory` contract with no mechanism to retrieve it.

**Match in Response List**:  
Matches with the issue titled **""Unchecked `msg.value` for Non-ETH Collateral""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of Ether being locked in the `PoolFactory` contract when `msg.value` is sent with a non-ETH collateral token. It correctly explains the risk of irreversible fund loss due to the lack of validation for `msg.value` in this scenario. This aligns with the issue description and Solidity best practices, which emphasize validating `msg.value` when handling Ether transfers.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

---

The response list effectively covers the issue described in the report, providing a clear and accurate explanation of the vulnerability and its implications. No additional gaps or mismatches were identified.",1,0,0,11,"Okay, let's start by looking at the code. The contract is PoolFactory, which seems to handle creating pools. It's using Solidity 0.7.6, which is a bit old. I remember that newer versions have security fixes, so maybe that's an issue.

First, let's check the imports. They're using OpenZeppelin's OwnableUpgradeable. But wait, the contract is Initializable and OwnableUpgradeable, so this is an upgradeable contract. But in Solidity 0.7.6, the upgradeable contracts might not have the latest security features. Also, the initialize function is external. That's a problem because anyone could call it if it's not properly protected. Wait, no, the initializer modifier is used, which should prevent reinitialization. But since it's called once, maybe that's okay.

Looking at the initialize function, they're transferring ownership to _admin. But the function is external. If someone calls this before the contract is initialized, they could take ownership. But since it's using the initializer modifier, it can only be called once. So maybe that's safe. Hmm.

Next, the createPool function has a modifier onlyBorrower which checks if the user is valid via IVerification(userRegistry).isUser. But if the userRegistry is set to a malicious contract, that could be a problem. But since only the owner can set userRegistry via setImplementations, maybe that's a centralization risk. If the owner is compromised, they can set a malicious userRegistry.

Looking at the createPool function: they check if the collateralToken is address(0) (Ether) and require that msg.value equals collateralAmount. But if the collateralToken is not address(0), they don't check msg.value. That's okay because the collateral would be ERC20 tokens. But wait, when collateralToken is address(0), they require msg.value == collateralAmount. However, in _createPool, they pass amount = _collateralToken == address(0) ? _collateralAmount : 0. Then, in _deploy, they use create2 with that amount. So when deploying the pool, they send Ether equal to collateralAmount. But create2's value is the amount sent during deployment. So if the pool's constructor is payable, that's okay. But if the pool is not expecting Ether, this could be an issue. Wait, the SublimeProxy is being created. The Proxy's code would handle the data, but if the proxy's constructor is payable, then the Ether is stored there. The pool's initialization would have to handle that. But this depends on the Proxy contract's code, which isn't shown here. So maybe that's a potential vulnerability if not handled correctly.

Another thing: when creating the pool, they use _collateralAmount and check if it's sent when collateral is ETH. But if the user is creating a pool with a non-zero collateralToken (ERC20), they need to transfer the ERC20 tokens. However, the code here doesn't handle ERC20 transfers. It just checks that the collateral is valid. So where is the ERC20 transfer happening? It's possible that the pool's initialization function handles transferring the collateral from the borrower. But if that's not properly enforced, the borrower might not actually transfer the collateral, leading to a pool without the required collateral. So maybe the code here doesn't check that the borrower has approved the transfer or actually sends the tokens, leading to a possible undercollateralized pool.

Wait, in the parameters for createPool, there's a _transferFromSavingsAccount flag. Maybe the SavingsAccount contract is supposed to handle the collateral transfer. But without seeing the pool's initialization code, it's hard to tell. If the Pool contract doesn't properly handle the collateral transfer based on this flag, there could be issues.

Looking at the _encodePoolInitCall, it includes _collateralAmount and _transferFromSavingsAccount. So the pool's init function would handle that. But if the pool's code has a vulnerability in handling that, then the factory's code is okay. But since we're only looking at the factory, maybe not. So maybe the issue here is that the factory doesn't ensure that the collateral is correctly deposited. For example, if the _transferFromSavingsAccount is false, does the borrower have to send the collateral to the pool? The code here doesn't check that; it's up to the pool to handle. So if the pool's init function doesn't properly transfer the collateral, that's a problem. But the factory can't be responsible for that. Hmm.

Another point: the use of create2 with a salt that includes msg.sender and _salt. The salt is provided by the user. So a user could front-run the creation of a pool with the same parameters and salt, but that's mitigated by including msg.sender in the salt. Wait, the salt is keccak256(abi.encodePacked(_salt, msg.sender)), so each user's salt is unique even if they use the same _salt. So front-running might not be possible here.

Reentrancy: The createPool function doesn't have any external calls after deploying the pool. The checks are done before deployment, and the _deploy function uses create2. Since create2 doesn't involve external calls that could re-enter, maybe reentrancy isn't an issue here.

Access control: The onlyBorrower modifier checks that the user is verified by the userRegistry. But if the userRegistry is compromised, this check is bypassed. Since the owner controls userRegistry, a malicious owner could allow anyone to create pools. Centralization risk.

The _deploy function uses assembly to create2. If there's a collision in the salt, it could fail, but since the salt includes msg.sender and the provided _salt, collisions are unlikely.

Another vulnerability: the initialize function can only be called once due to the initializer modifier. But if the contract is upgraded, and the new implementation's initialize is called again, that could reset variables. But since it's an upgradeable contract, the owner should handle upgrades properly. However, if the contract isn't part of a proper upgradeable pattern (like Transparent Proxy), there could be issues.

The contract uses mappings for isBorrowToken and isCollateralToken, which the owner can update. If the owner adds a malicious token (e.g., a fake ERC20), users might be tricked into using it. But that's more of a trust issue in the owner rather than a code vulnerability.

The PriceOracle check in createPool requires that the price feed exists for the collateral and borrow token pair. If the PriceOracle is compromised or returns incorrect prices, it could affect loan terms, but again that's dependent on external contracts.

In the _updateProtocolFeeCollector function, the protocolFeeCollector can be set by the owner. If set to a wrong address, fees go there. But that's an admin function, so centralization risk.

Another possible issue is that the createPool function uses msg.value when collateralToken is address(0). However, if the collateralToken is not address(0), but the user sends ETH anyway, the ETH would remain in the factory contract. Because in createPool, the only time they check msg.value is when collateralToken is address(0). Otherwise, they don't check, so if someone sends ETH when creating a pool with a non-ETH collateral, the ETH is stuck in the factory. That's a problem. For example, if a user mistakenly sends ETH but uses USDC as collateral, the ETH sent would not be handled and would be lost.

Yes, that's a vulnerability. The function should check that if collateralToken is not address(0), then msg.value must be zero. Otherwise, any ETH sent in that case would be locked in the contract. Let me check the code again:

In createPool, the first check is:

if (_collateralToken == address(0)) {
    require(msg.value == _collateralAmount, '...');
}

But there's no else clause that requires msg.value == 0. So if _collateralToken is not zero (e.g., an ERC20 token), but the user sends ETH, msg.value is not checked. So the ETH stays in the PoolFactory contract. Since the createPool function is payable, users can send ETH here, but if the collateral isn't ETH, the ETH isn't used. This leads to accidental ETH loss.

That's definitely a vulnerability. Users could lose funds by sending ETH when they shouldn't.

Another thing: the _deploy function uses create2 with the specified amount. If collateralToken is ETH, then amount is _collateralAmount, which is equal to msg.value (as checked). Then, during deployment, that amount is sent to the created contract. But the Proxy contract's constructor (SublimeProxy) might not handle the ETH properly. If the Proxy isn't payable, the deployment would fail. But since the code uses create2 with value, the constructor must be payable. However, the Proxy.sol is imported, but its code isn't shown. Assuming the Proxy can accept ETH, then it's okay. But if not, the deployment would fail, and the ETH would remain in the factory. But since the code is using create2 with the amount, if the Proxy's constructor isn't payable, the deployment would revert, and the ETH would be returned. Wait, no. When you use create2, if the contract creation fails (e.g., because the constructor is not payable but you send ETH), the ETH is not returned; it's lost. Because in EVM, if a contract creation fails, any sent Ether is lost. So if the Proxy's constructor is not payable and the code is trying to send ETH during creation, the transaction would revert, but the ETH is already consumed. Wait, no. If the contract creation fails, the entire transaction reverts, so the msg.value would be refunded. Wait, no. Let me clarify: If a contract creation (via new, create, or create2) includes value and the contract's constructor is not payable, the transaction will revert, and any Ether sent will be returned. Because the entire transaction is reverted. So in that case, the user's ETH would be safe. So maybe that's not an issue here. But if the Proxy's constructor is payable, the ETH is forwarded to the Proxy. Then, the Pool's initialization function would need to handle that ETH properly. If the Proxy doesn't handle ETH, maybe it's locked there. But again, since the code isn't shown, it's hard to tell. However, the main issue here is the missing check for msg.value when collateralToken is not ETH.

Other possible issues: The code uses delegatecall in the Proxy, which is standard, but if the poolImpl is malicious or compromised, it could selfdestruct or change storage. But the poolImpl is set by the owner, so again centralization risk.

Another thing: The protocolFeeCollector and protocolFeeFraction are set by the owner. If the fee is too high, it could affect users, but that's a business risk, not a code vulnerability.

Function visibility: The initialize function is external, which is correct because it's called once. The other functions have appropriate modifiers (onlyOwner).

In the _updateProtocolFeeCollector function, there's no check for address(0). If the owner sets it to address(0), fees would be burned. But maybe that's intentional.

The isWithinLimits function allows min and max to be 0. So if, for example, min is 0 and max is 100, then values between 0 and 100 are allowed. But if min is 0 and max is 0, it returns true, which means any value is allowed. That could be a problem if the owner sets both min and max to 0 for a limit, effectively removing the limit. For example, if poolSizeLimit's min and max are both 0, then any pool size is allowed. But that's up to the owner's configuration. Not a code vulnerability per se, but a misconfiguration risk.

The use of Initializable and OwnableUpgradeable suggests that this is part of an upgradeable contract suite. However, in Solidity 0.7.6, there might be storage layout issues if the contract is upgraded and new variables are added. But as long as the inheritance and variable ordering are maintained during upgrades, this is manageable. However, if not handled properly, storage collisions could occur.

The contract has a mapping poolRegistry to track valid pools. When a pool is created, it's added here. But there's no function to remove a pool, except when the pool destroys itself via the onlyPool modifier. However, the contract doesn't have a function for pools to deregister themselves. So if a pool is destroyed, how is it removed from poolRegistry? The Proxy might have a selfdestruct, but the PoolFactory's poolRegistry would still have it as true. So even if a pool is destroyed, poolRegistry[pool] remains true. That could lead to issues if other contracts rely on this mapping to check if a pool is active. For example, a destroyed pool could still be considered valid.

Another point: The createPool function uses the userRegistry to check if the borrower is valid. However, if the userRegistry is updated after a pool is created, existing pools might have borrowers that are no longer valid. But since the check is only at creation time, that's acceptable. The ongoing validity of borrowers isn't enforced.

Potential denial-of-service in createPool: If the parameters are such that the pool cannot be created (e.g., due to limits set by the owner), the function would revert. But that's expected behavior.

The function _deploy uses inline assembly with create2. There's a check that addr != address(0), which ensures that deployment succeeded. So if the deployment fails (e.g., out of gas, invalid bytecode), the transaction reverts.

In summary, the vulnerabilities I can see are:

1. **Unchecked msg.value for Non-ETH Collateral**: When creating a pool with a collateral token that isn't ETH (address(0)), the function doesn't check that msg.value is zero. If users mistakenly send ETH, it remains in the contract and is lost.

2. **Centralization Risks**: The contract relies heavily on the owner to set critical parameters and contracts (like userRegistry, strategyRegistry, priceOracle). If the owner's account is compromised, an attacker could manipulate these to create malicious pools or bypass checks.

3. **Storage Inconsistency for Destroyed Pools**: If a pool self-destructs, the PoolFactory's poolRegistry still lists it as valid, which might lead to inconsistencies in other parts of the system that rely on this mapping.

4. **Potential Proxy Contract Issues**: Since the Proxy contract's code isn't provided, there might be vulnerabilities in how the Proxy handles the forwarded ETH during deployment or delegatecalls to the pool implementation. However, this is dependent on the external Proxy contract.

5. **Outdated Compiler Version**: Using Solidity 0.7.6 might expose the contract to known bugs fixed in later versions. While not a direct vulnerability in the code, it's a risk factor.

6. **No Check for Address(0) in Updates**: Functions like _updateProtocolFeeCollector or _updateUserRegistry don't check if the new address is non-zero, which could lead to accidental or intentional setting of critical addresses to invalid ones.

7. **Incorrect Collateral Token Pair Check**: The code checks that _borrowToken != _collateralToken. However, this doesn't account for tokens that wrap others (e.g., WETH and ETH). If such a pair is allowed, it could lead to unintended behavior, but this depends on the system's design.

8. **Missing Events for Critical Operations**: Some state-changing functions (like _updateSupportedBorrowTokens) emit events, but others like setting protocolFeeCollector and protocolFeeFraction do emit events. Wait, looking at _updateProtocolFeeCollector, it does emit an event. Maybe all state changes have events. Hmm, need to check. For example, the setImplementations function calls multiple update functions which emit events. So events seem covered.

9. **Incorrect Price Oracle Usage**: The createPool function checks if the price oracle supports the collateral and borrow token pair. However, if the oracle returns stale or incorrect data, the pool's terms could be miscalculated. This is an external dependency issue.

10. **Potential Front-Running with Salt**: Even though the salt includes msg.sender, if a user uses a predictable _salt value, someone could front-run the transaction with the same salt and msg.sender. However, since msg.sender is part of the salt, another user can't front-run unless they have the same address. So this is unlikely.

So the main vulnerabilities are points 1, 2, 3, 5, and 6, with 1 being the most critical as it can lead to direct loss of funds.","```
1. Unchecked `msg.value` for Non-ETH Collateral
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is `Unchecked msg.value for Non-ETH Collateral`, which appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank itself.
   - \( P@1 = \frac{1}{1} = 1.0 \)

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the Average Precision (AP) is simply the precision at rank 1.
   - \( AP = 1.0 \)

**Output**:
```
1.0
```",1
,,,,,,,,11,6,,,2,0,15,70,,,,