nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using `timeUnlockERC721()`. This is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()). Because of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).   [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval. Impact 1: The approval is not removed (set to false) after a transfer in transferERC721(). So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.
Impact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.
  [H-03] Approval for NFT transfers is not removed after transfer
The `Visor.transferERC721` does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
  [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.
The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time. Recommend using a mapping (e.g., mapping(address=>Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.   [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2. While the contract uses Uniswap’s TransferHelper library function safeTransfer in other places for ERC20 tokens, or OpenZeppelin’s saferTransferFrom for ERC721 tokens (both of which call the token’s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token’s transferFrom() call without checking for its return value.
The impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.
  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).   [M-03] `timelockERC721Keys` could exceed the block size limit
On line 504 of Visor.sol, looping through the `timelockERC721Keys` could exceed the block size limit
Recommend transfer by index instead of token ID",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";


contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

   
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

   
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }


    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }


    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }


    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }


    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }


    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }


    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }


    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,"Here is the list of vulnerabilities identified in the provided smart contract:

1. **Reentrancy in `rageQuit` Function**  
   The `rageQuit` function makes an external call to the delegate contract before removing the lock. If the delegate's `rageQuit` function re-enters the `Visor` contract, the lock is still active, potentially allowing unintended state changes or bypassing checks.

2. **Improper Initialization with Multiple Initializers**  
   The contract has two initializer functions (`initialize` and `initializeLock`), both using the `initializer` modifier. This could allow multiple initializations if not properly controlled, leading to inconsistent ownership or state setup, especially if called in an unintended order.

3. **Lock Removal on Failed `rageQuit` Execution**  
   If the delegate's `rageQuit` call fails or reverts, the lock is still removed from the contract. This could result in the locked tokens being freed even if the delegate's critical logic (e.g., releasing collateral) was not executed, breaking trust assumptions.

4. **Stale Keys in Timelock Arrays**  
   When timelocks (ERC20/ERC721) are removed, their keys remain in the `timelockERC20Keys` and `timelockERC721Keys` arrays. This bloats the arrays over time, increasing gas costs for iterations and causing inefficiencies, though it doesn't directly compromise security.

5. **Insufficient Access Control in `transferERC721`**  
   The `transferERC721` function allows any approved address to transfer NFTs without explicitly ensuring the caller has authority over the specific NFT, relying on loop checks that may not cover all timelock scenarios comprehensively.

6. **Signature Replay Vulnerability**  
   While the contract uses a nonce to prevent signature replays, the `_nonce` is a single global counter. If multiple functions share the same nonce space, it could inadvertently allow replay across different functions (though the current setup appears to mitigate this).

7. **Incorrect Event Emission in `timeLockERC721`**  
   The `timeLockERC721` function emits `TimeLockERC20` instead of `TimeLockERC721`, leading to incorrect event logging and potential off-chain tracking issues.","### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:  
If an NFT token is timelocked using `timeLockERC721()` and later transferred out of the vault using `transferERC721()` without explicitly unlocking it via `timeUnlockERC721()`, the `timelockERC721s[key]` entry for that NFT is not deleted. If the same NFT is later moved back into the vault without a timelock, the vault logic still considers it timelocked with the older/stale recipient address. This causes the `transferERC721()` call to fail unless the caller controls the stale recipient address, effectively rendering the NFT permanently stuck in the vault.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves a missing deletion of a timelock key, leading to a permanent lock of the NFT. This is a critical oversight in the contract's state management and is not covered in the response list.

---

### **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**

**Report Description**:  
NFT transfer approvals set in `approveTransferERC721()` are never reset to `false`, and there is no mechanism to revoke such approvals.  
**Impact 1**: If an NFT is moved back into the owner's vault, the previous/compromised delegate can transfer it again without requiring a new approval.  
**Impact 2**: If a delegate becomes compromised or untrustworthy after approval but before transfer, the owner loses the NFT because the approval cannot be revoked.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrevocable NFT transfer approvals. This is a significant security flaw that could lead to loss of assets and is not covered in the response list.

---

### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:  
The `Visor.transferERC721` function does not reset the approval for the NFT after a transfer. An approved delegatee can move the NFT out of the contract once. If the NFT is later deposited back into the same vault, the first delegatee can steal the NFT and move it out of the contract a second time.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unremoved NFT transfer approvals. This is a critical oversight in the contract's approval management and is not covered in the response list.

---

### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:  
The `_removeNft` function uses an unbounded loop to iterate through the `nfts` array. A malicious user could send many NFTs to the vault, causing the array to grow excessively large. If the NFT to be removed is at the end of the array, the function could consume excessive gas or even exceed the block gas limit, leading to a denial of service (DOS) for legitimate users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unbounded loops in the `_removeNft` function. This is a significant vulnerability that could lead to DOS attacks and is not covered in the response list.

---

### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:  
The `timeLockERC20()` function directly uses the `transferFrom()` call without checking its return value. Some ERC20 tokens return `false` on failure instead of reverting. If the `transferFrom()` call fails but the return value is not checked, the vault logic assumes the transfer was successful and updates the `timelockERC20Balances` accordingly. This could lead to discrepancies in token balances and potential fund loss for recipients.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unhandled return values in the `timeLockERC20()` function. This is a medium-severity vulnerability that could lead to fund loss and is not covered in the response list.

---

### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:  
The `transferERC721` function does not clean the `timelockERC721s` mapping, unlike `timeUnlockERC721`, which deletes the corresponding entry. This could lead to stale timelock keys being used later, causing inconsistencies in the vault's administration and potentially allowing unintended actions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of uncleaned timelock keys in the `transferERC721` function. This is a medium-severity vulnerability that could lead to state inconsistencies and is not covered in the response list.

---

### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:  
The `timelockERC721Keys` array is iterated over in the `Visor.sol` contract. If the array grows too large, it could exceed the block gas limit, causing transactions to fail. This is a potential DOS vector, especially if the array is not managed efficiently.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unbounded iteration over the `timelockERC721Keys` array. This is a medium-severity vulnerability that could lead to DOS and is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**  
- **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**  
- **[H-03] Approval for NFT transfers is not removed after transfer**  
- **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**  
- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**  
- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**  
- **[M-03] `timelockERC721Keys` could exceed the block size limit**  

The response list does not address any of the issues in the issue report, leaving significant vulnerabilities unaddressed.",0,0,7,7,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called Visor, and it seems to be a universal vault that handles ERC20 and ERC721 tokens with some locking and timelock features. 

First, I'll start by checking the Solidity version. The pragma is 0.7.6, which is a bit older. I should check if there are any known issues with that version. But since the question is about vulnerabilities in the code itself, maybe the version isn't the main issue here unless the code uses deprecated features or has compatibility problems.

Looking at the imports, they use OpenZeppelin libraries like SafeMath, ERC20, ERC721, etc. OpenZeppelin is generally secure, but the version might matter. The contract also imports from other local files like EIP712, ERC1271, OwnableERC721, etc. I need to check if those are used correctly.

The Visor contract implements several interfaces: IUniversalVault, EIP712, ERC1271, OwnableERC721, Initializable, and IERC721Receiver. Let's go through each function and see if there's anything suspicious.

Starting with the state variables. There's a _nonce variable, a mapping _locks for LockData, and an EnumerableSet for lockSet. Then there's a struct Nft and an array nfts, which tracks the NFTs stored. There are mappings for nftApprovals and erc20Approvals, which probably handle delegated transfers. Then there are structures and mappings for timelocked ERC20 and ERC721 tokens.

Looking at the functions:

The initialize function sets the owner via OwnableERC721._setNFT(msg.sender). Wait, OwnableERC721's owner is set via an NFT? That might be a potential issue if the ownership is tied to an NFT, but maybe that's intended. However, the initializer is external and can be called once due to the initializer modifier. But there's an initializeLock function that's also external initializer. Wait, the contract has two initialize functions? That could be a problem because the initializer modifier is supposed to be called only once, but having two separate functions with initializer might allow reinitialization. Let me check.

Wait, the Visor contract has an initialize() function that's external and overrides an initializer. Then there's another function initializeLock() that's also external initializer. So if someone calls initializeLock(), then initialize(), both would run, which could lead to issues. But maybe initializeLock is part of some proxy pattern? Not sure. But having multiple initializers might be a vulnerability if they can be called multiple times, leading to reinitialization attacks.

Moving on. The receive() function is external payable, which is normal for handling ETH.

The _addNft and _removeNft functions manage the nfts array. In _removeNft, when removing an element, it replaces it with the last element and pops. However, the loop runs from 0 to len, which could be optimized, but more importantly, if the array is large, this could be gas-intensive. But that's a gas issue, not a vulnerability. However, if an attacker can cause the array to grow indefinitely, that's a problem. But since adding NFTs is controlled via onERC721Received, which is only called when the contract receives an NFT, maybe it's manageable.

The calculateLockID function hashes delegate and token addresses, which seems okay.

The lock and unlock functions handle permissions with signatures. They use _nonce to prevent replay attacks. The lock function adds to the balance, and checks if the token balance is sufficient. The unlock function decreases the balance or removes the lock. Both functions increment _nonce, which is good for preventing replay. But I need to check if the signature verification is correctly implemented. The modifier onlyValidSignature is used, which I assume checks the permission. If the permission is generated correctly, then it's okay. But if there's a flaw in how the hash is generated or the signature is validated, that could be a problem.

The rageQuit function allows the owner to delete a lock and notify a delegate. It uses a try-catch block when calling rageQuit on the delegate. If the delegate is a contract that uses up all the gas (RAGEQUIT_GAS is 500,000), it might fail, but the function proceeds anyway. That's probably acceptable, but if the gas limit is too low, some legitimate calls could fail. Not sure if that's a vulnerability or just a design choice.

The transferERC20 function checks that the balance is sufficient after considering locked and timelocked amounts. However, the check is using add(amount) for the locked balance. Wait, the line is:

require(IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]), ...);

Wait, getBalanceLocked returns the sum of all locked balances for that token. Then adding the amount being transferred (since transferring increases the required balance?), wait, that doesn't make sense. Wait, when you transfer out, the locked and timelocked amounts should remain, so the contract must have enough balance to cover those locked amounts plus the amount being transferred. Wait, no. Let me think: the contract's balance must be at least the sum of all locked tokens (getBalanceLocked(token)) plus the timelocked balances (timelockERC20Balances[token]) plus the amount being transferred. Because when you transfer, you subtract that amount from the contract's balance. But the locked and timelocked amounts are supposed to be reserved. So the check should be:

current balance >= locked + timelocked + amount to transfer.

But in the code, it's written as (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]). Which is equivalent to locked + amount + timelocked. That seems correct. Because you need to have enough balance to cover the locked, timelocked, and the amount you're about to transfer out. So the check is correct.

The delegatedTransferERC20 function allows a delegate to transfer tokens if they have approval. The code checks if the msg.sender is not the owner, then checks erc20Approvals. Then subtracts the amount from the approval. However, the subtraction uses .sub(amount), but if the approval is exactly the amount, it will set it to zero. But SafeMath's sub will handle underflow. So that's okay. However, if there's a reentrancy here, but since it's using SafeMath and transferring after updating the approval, maybe not. The transfer is done via TransferHelper.safeTransfer, which is a library that checks the return value. So reentrancy is unlikely here.

The transferETH function uses safeTransferETH, which is okay. Only the owner can call it.

The approveTransferERC721 function sets nftApprovals for a delegate. Then the transferERC721 function checks if the sender is the owner or has approval. Then checks if the NFT is in a timelock. For each timelock key in timelockERC721Keys, if the tokenId is locked, it checks if the timelock has expired and if the sender is the recipient. However, the loop iterates over all timelockERC721Keys for that nftContract. But if an NFT has multiple timelocks (which shouldn't happen), this could be a problem. Wait, the timeLockERC721 function uses a key made from recipient, nftContract, tokenId, expires. So each timelock for the same token would have different expires or recipient, but the same tokenId. However, when transferring, the code checks all timelocks for that nftContract and sees if any of them have the same tokenId. If any of them are not expired, it would block the transfer unless the sender is the recipient. But if there are multiple timelocks for the same tokenId, this could allow someone to bypass if at least one is expired. Wait, the code says:

for each key in timelockERC721Keys[nftContract]:
   if tokenId == timelockERC721s[key].tokenId:
      require(expires <= now or recipient is msg.sender)

But if there are multiple timelocks for the same tokenId, each with different expires, the code would check each of them. If any of them are not expired and the sender is not the recipient, the transfer is blocked. Wait, no. Suppose a token has two timelocks. One expires at time 100, another at 200. Current time is 150. For the first timelock, expires (100) <= 150 → okay. For the second, expires (200) > 150 → require that the sender is the recipient. If the sender is not the recipient of the second timelock, the require would fail. So even if one timelock is still active, the transfer is blocked unless the sender is the recipient of that active timelock. That seems correct.

The onERC721Received function adds the NFT to the nfts array. That's okay as it's part of the ERC721 standard.

timeLockERC721 is onlyOwner. It creates a new timelock entry and transfers the NFT into the contract. But wait, the function uses IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId). But the msg.sender here is the owner of the Visor contract. But when the owner calls timeLockERC721, they must own the NFT to transfer it into the contract. That's correct.

timeUnlockERC721 is called by the recipient after the expires time. It deletes the timelock and transfers the NFT out. However, the function does not check if the timelock exists. For example, if someone calls timeUnlockERC721 with parameters that don't match any existing timelock, the key would not exist, and deleting it would be a no-op. But the code requires that the timelock's expires is <= block.timestamp and that the sender is the recipient. If the timelock doesn't exist, then timelockERC721s[key].expires would be zero, so the require(expires <= block.timestamp) would fail unless block.timestamp is zero, which is impossible. So that check should prevent calling with non-existent keys.

timeLockERC20 is similar. The owner locks ERC20 tokens with an expiration. It transfers the tokens into the contract. The key is a hash of recipient, token, amount, expires. But the same recipient, token, amount, and expires would produce the same key. So the code checks that the timelockERC20s[key].expires is zero before creating a new one. That's good.

timeUnlockERC20 allows the recipient to claim the tokens after expiration. It checks the balance and transfers. However, the code deletes the timelock entry and subtracts from timelockERC20Balances. But there's a potential issue here: when you have multiple timelocks for the same token, the timelockERC20Balances[token] is the sum of all amounts. When you unlock one, it subtracts the amount. But if there's a way to call timeUnlockERC20 multiple times for the same key, that could lead to underflow or multiple transfers. But the code deletes the timelock entry after transferring, so it can't be called again. However, what if someone calls timeUnlockERC20 with the same parameters again? Since the entry is deleted, the timelockERC20s[key].expires would be zero, so the require would fail. So that's okay.

Now looking for vulnerabilities:

1. Reentrancy: The contract uses SafeMath and transfers are done via safeTransfer, which checks success. Most external calls are done at the end of functions, following checks-effects-interactions. For example, in rageQuit, the external call is done before updating the state. Wait, in rageQuit, the code calls delegate.rageQuit() and then removes the lock. If the rageQuit function on the delegate reenters the Visor contract, the lock is still present. That could be a problem. For example, if during rageQuit, the delegate calls back into the Visor's unlock function, which would see that the lock is still there. But since rageQuit is only callable by the owner, maybe it's not a big issue. However, reentrancy here could allow the delegate to manipulate the state before the lock is removed. This could be a potential vulnerability.

2. ERC721 Callback: The onERC721Received function adds the NFT to the nfts array. However, if a malicious NFT contract calls this function multiple times or in a way that causes the array to be manipulated, but since it's part of the ERC721 standard, the function should only be called when the contract receives an NFT. So that's probably safe.

3. Timelock key collisions: The keys for timelocks are generated using keccak256(recipient, token, amount, expires) for ERC20, and (recipient, nftContract, tokenId, expires) for ERC721. If the same parameters are used, the key will collide, preventing duplicates. The code checks that the timelock entry doesn't exist before creating a new one, which is correct.

4. Integer Overflows/Underflows: The contract uses SafeMath, so that's covered.

5. Access Control Issues: The onlyOwner modifier is used in several functions. The owner is set via OwnableERC721, which is initialized in the initialize function. The initialize function is external and initializer, so it can only be called once. However, there's another initializeLock function that's also initializer. If someone calls initializeLock first, then initialize, would that affect ownership? Let me check.

The initializeLock function is empty except for the initializer modifier. The initialize function calls OwnableERC721._setNFT(msg.sender). If the Visor contract is deployed via a proxy, the initializer functions can be called separately. But if someone calls initializeLock first, then initialize, then OwnableERC721._setNFT(msg.sender) would set the owner to the caller. But since initializer can only be called once per function, the initialize function can only be called once. However, having multiple initializers could lead to ownership being set incorrectly if not properly handled. This might be a vulnerability if the initial setup is not done correctly, allowing a malicious actor to become the owner.

Wait, the initialize function is called with initializer modifier, which is from OpenZeppelin's Initializable. The initializer modifier makes sure the function is called only once. But the initializeLock function also has initializer. So if the contract is deployed normally (not through a proxy), both functions can be called once each. However, if the contract is meant to be used with a proxy, the proxy's initializer would call one function, but having multiple initializers is a known issue. The OpenZeppelin documentation warns against having multiple initializer functions because it can lead to someone initializing the contract multiple times. In this case, if someone calls initializeLock(), then initialize(), both would execute, which might not be intended. For example, the initialize() function sets the owner via OwnableERC721._setNFT(msg.sender). If the contract is initialized twice, but that's prevented by the initializer modifier. Wait, each function has its own initializer. So the initializeLock() can be called once, and initialize() can be called once. So the owner would be set in initialize(), but initializeLock() does nothing except mark itself as initialized. That's probably not a problem, unless there's some dependency between them.

But the main issue is that having multiple initializer functions can lead to improper initialization if not handled properly. For example, if the contract is supposed to be initialized via initialize(), but someone calls initializeLock() first, which doesn't set the owner, then the owner remains unset until initialize() is called. But since the initializeLock() function is empty, maybe it's a leftover from a previous version. This could be a vulnerability if the contract's initialization is not properly handled, leading to an uninitialized owner.

6. Timelock Balance Accounting: In the timeLockERC20 function, the code adds the amount to timelockERC20Balances[token]. When timeUnlockERC20 is called, it subtracts the amount. But if there's a way to have the same key (same recipient, token, amount, expires) created multiple times, this could cause the balance to be incorrect. However, the code checks that the timelock doesn't already exist before adding, so duplicates are prevented. So that's safe.

7. Lock Data Management: The lock and unlock functions manage the _locks mapping and _lockSet. When unlocking, if the balance becomes zero, the lock is removed. However, in the lock function, when adding to an existing lock, it uses _locks[lockID].balance.add(amount). The require statement checks if the contract's balance is sufficient. However, if the contract's balance is reduced externally (e.g., someone transfers tokens out), then the locked amounts might exceed the actual balance. The checkBalances() function is meant to check this, but it's an external view. There's no mechanism to automatically adjust or prevent over-locking if the balance drops. So, if the contract's ERC20 balance is reduced (e.g., via a transfer that doesn't go through the contract's functions), the locked amounts could become invalid. For example, if someone uses transferERC20 to send out tokens, but the locked amounts are not adjusted, leading to a situation where getBalanceLocked(token) is higher than the actual balance. However, the transferERC20 function checks that the balance is sufficient considering locked and timelocked amounts. So as long as all token transfers go through the contract's functions, this is okay. But if someone sends tokens directly to the contract or withdraws via another method (like a hidden function), this could break the accounting. However, the contract doesn't have any functions that allow arbitrary transfers without checking the locked amounts, except for the rageQuit function which is owner-only. So this might be a design consideration rather than a vulnerability.

8. ERC721 Timelock Removal: When timeUnlockERC721 is called, it deletes the timelock entry. However, the code doesn't remove the key from timelockERC721Keys[nftContract]. The timelockERC721Keys array would still have the key, but the mapping entry is deleted. So the keys array could have stale entries pointing to deleted timelocks. When iterating over timelockERC721Keys in transferERC721, it would check each key. If the timelock has been deleted (expires is zero), the require would fail. So in the loop:

for each key in timelockERC721Keys[nftContract]:
   if tokenId == timelockERC721s[key].tokenId:
      require(expires <= block.timestamp, ""NFT locked and not expired"");
      require(recipient == msg.sender, ...);

If the timelock has been deleted (i.e., timelockERC721s[key].expires is zero), then the first require would check 0 <= block.timestamp, which is always true. Then the second require checks if the sender is the recipient (which was stored in the timelock). But since the timelock has been deleted, timelockERC721s[key].recipient is address zero. So the require would fail unless msg.sender is address zero, which is impossible. Therefore, after a timelock is deleted, the key remains in timelockERC721Keys, but checking it would not block the transfer. However, the problem is that the key is not removed from the array, leading to possible bloating of the array and increased gas costs when iterating. This is a gas inefficiency but not a security vulnerability. However, if a timelock is deleted but the key remains, and then a new timelock is created with the same parameters (same recipient, nftContract, tokenId, expires), the key would be re-added to the array. But the code in timeLockERC721 checks that the timelock doesn't exist before adding, so duplicates are prevented. So this is more of a gas issue than a vulnerability.

9. Signature Replay: The lock and unlock functions use a nonce to prevent replay attacks. Each successful call increments _nonce, so the same signature can't be reused. That's secure.

10. ERC20 Approval Check in timeLockERC20: The function checks that the owner has approved the contract to spend the amount. However, the code uses IERC20(token).allowance(msg.sender, address(this)) >= amount. Since the function is only callable by the owner (onlyOwner modifier), msg.sender is the owner. So the owner must have approved the Visor contract to spend their tokens. That's correct.

11. ERC721 Safe Transfers: The transferERC721 function uses safeTransferFrom, which is correct. However, in the timeUnlockERC721 function, after deleting the timelock, it uses safeTransferFrom to send the NFT to the recipient. That's correct.

12. Ownership Transfer: The contract uses OwnableERC721, which likely ties ownership to an NFT. If the ownership can be transferred by transferring the NFT, that's intended. But if there's a way to become the owner without holding the NFT, that's a problem. The _getOwner() function returns OwnableERC721.owner(), which depends on the NFT's owner. So that's as designed.

Potential vulnerabilities identified so far:

- Multiple initializer functions (initializeLock and initialize) which could lead to improper initialization if not handled correctly, especially if the owner isn't set properly.

- Reentrancy in rageQuit function: The external call to delegate.rageQuit() is made before removing the lock. If the delegate's rageQuit function reenters the Visor contract, the lock is still present, which could allow unintended interactions.

- In the timeUnlockERC20 function, the code checks that the balance is sufficient, but the check is:

require(IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount), ...);

Wait, looking back:

The timeUnlockERC20 function has:

require(
    IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
    ""Insufficient balance""
);

But the actual code in timeUnlockERC20 is:

require(
    IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
    ""Insufficient balance""
);

Wait, no. Let me check the original code. The user provided code for timeUnlockERC20 is:

function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

  require(
    IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
    ""Insufficient balance""
  );

  bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
  require(
    timelockERC20s[key].expires <= block.timestamp,
    ""Not expired yet""
  );

  require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
  
  delete timelockERC20s[key];

  timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
  TransferHelper.safeTransfer(token, recipient, amount);
  emit TimeUnlockERC20(recipient, token, amount, expires);
}

Wait, the require statement is checking that the contract's balance is >= getBalanceLocked(token) + amount. However, the timelockERC20Balances[token] is also a part of the reserved balance. Because when you lock tokens via timeLockERC20, you add the amount to timelockERC20Balances[token]. So the total reserved balance should be getBalanceLocked(token) + timelockERC20Balances[token].

But in the timeUnlockERC20 function, the code checks getBalanceLocked(token).add(amount), but not including timelockERC20Balances. That's a problem. Because when you timeUnlockERC20, you are releasing the timelocked amount. The code should ensure that the contract has enough balance to cover the remaining locked and timelocked amounts after the transfer. Wait, no. The timelocked balance is part of the reserved balance. When you unlock, you subtract the amount from timelockERC20Balances[token], then transfer the amount. So the require should check that the contract's balance is at least (getBalanceLocked(token) + (timelockERC20Balances[token] - amount) + amount) = getBalanceLocked(token) + timelockERC20Balances[token]. But since the code is transferring the amount, the actual check should be that the contract's balance is sufficient to cover the remaining locked and timelocked amounts after the transfer. However, in the code, the require is checking that the balance is >= getBalanceLocked(token) + amount. But the getBalanceLocked(token) is the sum of all locked balances, and the timelockERC20Balances[token] is being reduced by amount. So the required balance after transfer would be getBalanceLocked(token) + (timelockERC20Balances[token] - amount). But the actual balance before transfer is getBalanceLocked(token) + timelockERC20Balances[token], and after transferring amount, it's (balance) - amount. So the require in the code is checking that balance >= getBalanceLocked + amount. Which would be true because balance is getBalanceLocked + timelockERC20Balances (assuming correct accounting). But the code here is not considering that timelockERC20Balances may have other entries. For example, suppose there are two timelocks for the same token, each with amount 100. The timelockERC20Balances[token] is 200. When unlocking one, the code subtracts 100, making it 100. The require checks balance >= locked + 100. But if locked is 50, then balance needs to be >= 150. But the actual balance is 200 (original) - 100 (transferred) = 100. Which would be less than 150, causing the require to fail. Wait, but how?

Wait, the code is transferring the amount (100) out. The contract's balance before transfer is (locked) + (timelockERC20Balances) = 50 + 200 = 250. After transferring 100, balance is 150. The locked (50) and remaining timelock (100) sum to 150, which matches the new balance. But the require statement is checking if the balance before transfer is >= locked (50) + amount (100) = 150. Since the balance before transfer is 250 >= 150, it passes. But after transferring 100, the balance is 150, which should cover locked (50) + remaining timelock (100). So the require is sufficient. However, the code doesn't check the remaining timelock balances. The check in the code ensures that after transferring, the locked amounts are still covered. Because getBalanceLocked(token) is the sum of all locked amounts, and timelockERC20Balances[token] is being decremented by the amount. The require is ensuring that even after this transfer, the contract's balance is enough to cover the locked amounts plus this amount (which is being transferred). But I'm not sure. Let me think again.

The code in timeUnlockERC20 requires that the current balance is at least getBalanceLocked(token) + amount. The amount is the amount being transferred. The getBalanceLocked is the sum of all locked amounts. The timelockERC20Balances[token] is being reduced by amount. So after the transfer, the remaining balance must cover getBalanceLocked(token) + (timelockERC20Balances[token] - amount). 

But the require statement is checking balance >= getBalanceLocked(token) + amount. Since balance is (before transfer) getBalanceLocked(token) + timelockERC20Balances[token]. So:

balance_before = getBalanceLocked + timelockERC20Balances

require(balance_before >= getBalanceLocked + amount) → which is always true as timelockERC20Balances >= amount (since the timelock entry has amount and the code subtracts that from timelockERC20Balances). Wait, the timelockERC20s[key].amount is the amount being unlocked, and timelockERC20Balances[token] is the total of all timelocked amounts. So when you call timeUnlockERC20, you are removing one timelock with 'amount', so timelockERC20Balances[token] -= amount. Therefore, the require is checking balance_before >= getBalanceLocked + amount. Since balance_before is getBalanceLocked + timelockERC20Balances_before. So the check is getBalanceLocked + timelockERC20Balances_before >= getBalanceLocked + amount → timelockERC20Balances_before >= amount. But since the timelock entry has amount, and timelockERC20Balances is the sum of all entries, then timelockERC20Balances_before must be >= amount. However, if there are multiple entries, this could be true. For example, if two entries of 50 each, and amount is 100, the timelockERC20Balances_before would be 100, and the check would pass. But after subtracting 100, it would underflow. Wait, no: in the code, the key's amount is part of the timelockERC20Balances. So when you create a timelock with amount 100, timelockERC20Balances increases by 100. If you try to unlock that, the code subtracts 100. However, if there's another timelock for the same token with a different key, the timelockERC20Balances would still have that. But the code in timeUnlockERC20 is specific to a key. So when you call timeUnlockERC20, you have to specify the exact recipient, token, amount, expires. Therefore, the amount being unlocked must match the timelock's amount. Therefore, the timelockERC20Balances is correctly decremented by the same amount. Therefore, the require check in timeUnlockERC20 is redundant because balance_before is getBalanceLocked + timelockERC20Balances_before. And since timelockERC20Balances_before includes the amount being unlocked, the require check balance_before >= getBalanceLocked + amount is equivalent to timelockERC20Balances_before >= amount, which is true because that's part of the sum. However, this check is not sufficient to ensure that after the transfer, the remaining balance is sufficient for other locks and timelocks. Because after transferring, the balance is balance_before - amount. But the required balance after transfer would be getBalanceLocked + (timelockERC20Balances_before - amount). So balance_after should be >= getBalanceLocked + (timelockERC20Balances_before - amount). Substituting balance_after = balance_before - amount = (getBalanceLocked + timelockERC20Balances_before) - amount. The required is getBalanceLocked + timelockERC20Balances_before - amount. So balance_after = required. Therefore, the check in the code is unnecessary because it's automatically satisfied. However, the code includes the check, which may be redundant but not a vulnerability. However, if the code didn't have this check, it could allow transfers even if the contract's balance is insufficient. But with the check, it's ensuring that balance_before >= getBalanceLocked + amount. But since balance_before is getBalanceLocked + timelockERC20Balances_before, and timelockERC20Balances_before >= amount (since the timelock exists), this check is redundant. However, if there's a bug in the timelockERC20Balances accounting, this check could catch it. But in normal conditions, it's redundant. However, this isn't a vulnerability, just redundant code.

Another potential issue: when transferring ERC20 tokens via transferERC20 or delegatedTransferERC20, the code checks that the balance is sufficient considering locked and timelocked amounts. But if a timelock is added after transferring tokens out, it could lead to a situation where the timelock's amount exceeds the available balance. However, the timelock functions (timeLockERC20) transfer tokens into the contract, so when creating a timelock, the tokens are taken from the owner and added to the contract's balance. Therefore, as long as timeLockERC20 is used correctly, the balance should be sufficient. However, if someone uses a malicious token that doesn't transfer the actual tokens (e.g., a fake ERC20), this could be a problem. But that's an external dependency, not a vulnerability in the contract.

Other thoughts: The Visor contract holds NFTs and ERC20 tokens. If the owner is compromised, all funds can be drained. But that's an inherent risk in any contract with ownership control. The contract allows delegated transfers with approvals, which could be risky if approvals are too generous. For example, if a delegate is approved for a large amount, they could transfer out tokens. But that's a feature, not a vulnerability, as long as the approval is given correctly.

Another possible issue: In the rageQuit function, after calling delegate.rageQuit(), the code proceeds to delete the lock. If the delegate's rageQuit() function fails, the lock is still deleted. However, the try-catch block captures the error and proceeds. This means that even if the delegate's rageQuit fails, the lock is removed. This could lead to the locked funds being freed even if the rageQuit didn't execute properly. For example, if a lock exists, and rageQuit is called, but the delegate's rageQuit fails, the lock is removed, allowing the owner to transfer the tokens out without the delegate's permission. This could be a vulnerability if the delegate's rageQuit is supposed to handle some critical logic before allowing the lock to be removed. However, the function is only callable by the owner, so it's up to the owner to handle this correctly. This could be a design choice rather than a vulnerability.

Final list of vulnerabilities:

1. **Reentrancy in rageQuit Function**: The external call to the delegate's rageQuit is made before removing the lock, which could allow reentrant calls to manipulate the contract's state while the lock is still active.

2. **Improper Initialization with Multiple Initializers**: The presence of both initialize() and initializeLock() functions with the initializer modifier could lead to improper initialization if not handled correctly, potentially leaving the contract in an inconsistent state.

3. **Insufficient Balance Check in timeUnlockERC20**: The require statement in timeUnlockERC20 checks the balance against getBalanceLocked + amount, but doesn't account for the remaining timelocked balances. However, upon closer inspection, this might not be an issue due to the way balances are managed. (This might not be a vulnerability after all.)

4. **Stale Keys in timelockERC721Keys**: When a timelockERC721 is removed, the key is not deleted from the timelockERC721Keys array, leading to possible gas inefficiencies and bloated arrays. This is a gas issue but not a security vulnerability.

5. **Lock Removal on Failed rageQuit**: If the delegate's rageQuit function fails, the lock is still removed, potentially allowing the owner to withdraw tokens without proper handling. This could be considered a logic error or design flaw.","```
None.
```",0.0,0