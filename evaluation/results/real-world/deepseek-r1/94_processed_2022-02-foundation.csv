nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
NFTMarketReserveAuction.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797.0,677.0,"[H-01] NFT owner can create multiple auctions
function `createReserveAuction()`
NFT owner can permanently lock funds of bidders.
  [M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`
The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();

error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);

error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();

error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);

error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();

error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);

error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();

error NFTMarketReserveAuction_Not_Matching_Seller(address seller);

error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();


abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  
  struct ReserveAuction {
    
    address nftContract;
    
    uint256 tokenId;
    
    address payable seller;
    
    uint256 duration;
    
    uint256 extensionDuration;
    
    
    uint256 endTime;
    
    
    address payable bidder;
    
    
    uint256 amount;
  }

  
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  
  
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  
  uint256[5] private __gap_was_config;

  
  uint256 private immutable DURATION;

  
  
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          

          if (auction.seller != originalAddress) {
            
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    
    _transferToEscrow(nftContract, tokenId);

    
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, 
      payable(0), 
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  
  
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;

        
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      

      if (auction.amount > amount) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      
      unchecked {
        
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        
        
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        

        if (auction.seller != seller) {
          
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        
        _finalizeReserveAuction(auctionId, false);

        
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      
      _finalizeReserveAuction(auctionId, true);
    }
  }

  
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  
  uint256[1000] private __gap;
}",3541.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Constructor Usage in Upgradeable Contract**  
   - The contract uses a constructor to set the immutable `DURATION` variable, which is incompatible with upgradeable contract patterns (e.g., proxies). Proxies do not execute constructors, leading to uninitialized state variables. This breaks functionality if deployed via a proxy.

2. **Unsafe NFT Transfer Handling**  
   - If `_transferFromEscrow` (from `NFTMarketCore`) uses `transferFrom` instead of `safeTransferFrom`, NFTs could be sent to contracts not implementing `onERC721Received`, resulting in permanent loss of tokens. This depends on the parent implementation.

3. **Insufficient Funds Handling for Failed Transfers**  
   - When refunding bidders via `_sendValueWithFallbackWithdraw`, if the recipient cannot accept ETH (e.g., a contract without a payable fallback), funds may remain stuck in the contract. The contract must ensure a withdrawal mechanism tracks owed balances; improper implementation risks locked funds.

4. **Admin Account Migration Denial-of-Service (DoS)**  
   - The `adminAccountMigration` function iterates over an unbounded array of `listedAuctionIds`, risking gas exhaustion and failed transactions for large arrays, disrupting administrative operations.

5. **Lack of Auction Finalization Enforcement**  
   - After an auction ends, the NFT remains in escrow until manually finalized. If not finalized, the NFT could remain locked indefinitely. While bidders can trigger finalization via transfer, reliance on external calls introduces retention risk.

6. **Inconsistent Auction State During Transfers**  
   - If `_transferFromEscrow` fails after deleting auction data in `_finalizeReserveAuction`, the auction is removed without transferring the NFT, potentially leaving it stranded in escrow. However, reverts would undo deletion, mitigating this risk.

7. **Missing Auction Existence Checks**  
   - Functions like `cancelReserveAuction` and `updateReserveAuction` assume valid auctions exist but only check `auction.seller != address(0)` indirectly. Explicit checks for auction validity (e.g., mapping existence) are missing, risking state inconsistencies.

8. **Inadequate Bidder Replacement Checks**  
   - When updating a bid, the contract does not verify if the new bidder is distinct from the seller, potentially allowing self-bidding to manipulate auctions. However, the reserve price and bid increments likely prevent this.

9. **Timestamp Reliance for Auction Deadlines**  
   - The use of `block.timestamp` for auction end times is miner-manipulable, though impact is minimal given typical auction durations. This is a low-severity issue.","### **[H-01] NFT owner can create multiple auctions**

**Report Description**:  
The `createReserveAuction()` function allows the NFT owner to create multiple auctions for the same NFT. This can lead to a situation where bidders' funds are permanently locked if the owner exploits this behavior. The issue arises due to insufficient checks to prevent multiple auctions for the same NFT, creating a potential financial risk for bidders.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of multiple auctions being created for the same NFT, nor does it mention the risk of bidders' funds being permanently locked. This is a critical oversight, as the issue poses a significant financial risk to users.

---

### **[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`**

**Report Description**:  
The `adminAccountMigration()` function updates the `auction.seller` address but fails to update `buyPrice.seller`. This inconsistency creates a deadlock where the new address cannot cancel the auction or withdraw the NFT without the compromised account first canceling the buy price. The issue is only recoverable if the new account is migrated back to the compromised account, and `cancelBuyPrice()` is called before migrating back.

**Match in Response List**:  
Matches with the issue titled **""Admin Account Migration Denial-of-Service (DoS)""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of gas exhaustion and failed transactions due to iterating over an unbounded array in `adminAccountMigration`. However, it misses the critical issue of the `buyPrice.seller` not being updated, which creates a deadlock scenario. While the response partially addresses the function's risks, it does not fully capture the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] `adminAccountMigration()` Does Not Update `buyPrice.seller`**

**Missed Issues from Issue Report**:  
- **[H-01] NFT owner can create multiple auctions**

---

### **Analysis of Gaps**  
The response list fails to address the high-severity issue of multiple auctions being created for the same NFT, which can lead to bidders' funds being permanently locked. This is a significant oversight, as it directly impacts user funds and contract integrity. Additionally, the response to the `adminAccountMigration()` issue is incomplete, as it does not address the deadlock scenario caused by the failure to update `buyPrice.seller`. These gaps highlight the need for more comprehensive vulnerability identification and response.",0,1,1,9,"Okay, let's see. I need to list all the vulnerabilities in this smart contract. The user mentioned not to include mitigations, just the vulnerabilities. Let's start by reading through the code carefully.

First, the contract is called NFTMarketReserveAuction. It's using Solidity 0.8.0 and imports several OpenZeppelin and custom libraries. Let's check for common issues like reentrancy, access control, arithmetic issues, etc.

Looking at the constructor, there's a DURATION variable set, which is immutable. They check if the duration is within MAX_MAX_DURATION and above EXTENSION_DURATION. But since DURATION is set in the constructor and immutable, maybe that's okay. Not sure yet.

The adminCancelReserveAuction function is only callable by foundation admins. It deletes the auction and transfers the NFT back. It also sends back the bid amount if there's a bidder. But what if the bidder is a contract that can revert on receiving Ether? The _sendValueWithFallbackWithdraw might handle that, but I need to check. Oh, the SendValueWithFallbackWithdraw is used here, which probably uses a withdrawal pattern. So maybe that's safe.

In createReserveAuction, they transfer the NFT to escrow. The auction is stored with the seller's address. The _transferToEscrow is a function from NFTMarketCore, which probably handles the transfer. If that's using safeTransferFrom, that's good. But maybe there's a reentrancy issue here? But the function is marked nonReentrant, so that's handled.

Looking at the placeBidOf function. When someone places a bid, they check if the amount is sufficient. The code uses _sendValueWithFallbackWithdraw for returning previous bids. But what if the originalBidder is a contract that doesn't handle withdrawals properly? Like, if the send fails, maybe the funds are stuck. But the function uses a withdrawal pattern, so maybe that's mitigated. However, if the fallback fails, the transaction would revert, but the code uses send with a gas limit. So maybe the originalBidder could be a contract that uses up all the gas, causing the transfer to fail, leading to a revert. Wait, but in the code, after updating the auction's bidder and amount, they send the original bid back. If that send fails, does the whole transaction revert? Because if so, the state changes (updating the auction) would be rolled back. But in this code, they've already updated the auction's state before sending the funds. So if sending fails, the transaction would revert, which is good because otherwise, the original bidder's funds would be lost. Wait, no: in Solidity, if you do a send and it fails, the transaction doesn't automatically revert unless you check the return value. But looking at _sendValueWithFallbackWithdraw, maybe it uses a low-level call and only logs if it fails, but doesn't revert. Let me check the SendValueWithFallbackWithdraw contract.

Looking at the SendValueWithFallbackWithdraw.sol import. If _sendValueWithFallbackWithdraw is similar to OpenZeppelin's Address.sendValue, but with a withdrawal pattern. If the transfer fails, maybe the Ether is kept in the contract, and the bidder has to withdraw it later. But in this context, if the transfer to the originalBidder fails, the auction's state has already been updated. So the new bid is in place, but the previous bidder's funds might not have been returned. That could lead to a situation where the previous bidder's funds are stuck. That's a vulnerability. For example, if the originalBidder is a contract without a payable fallback function, the transfer would fail, but the auction proceeds. The originalBidder's funds would remain in the contract, and they would have to call a withdraw function. But the code here doesn't track that. So this could lead to locked funds. That's a problem.

Another thing: the placeBidOf function uses feth.marketWithdrawFrom. What's feth? If feth is a token that allows the market to withdraw on behalf of the user, maybe there's an approval issue. Suppose the user didn't approve the market to spend their feth tokens. But in the code, when the user calls placeBidOf with an amount higher than msg.value, the contract tries to withdraw the delta from their feth balance. If the user hasn't deposited enough or approved the contract, this would fail. But since the function is nonReentrant and the feth.marketWithdrawFrom is called, perhaps that's handled. But maybe there's a reentrancy here if feth's marketWithdrawFrom allows reentrant calls. But since the function is nonReentrant, that's probably mitigated.

Another issue: the _finalizeReserveAuction function deletes the auction and transfers the NFT. If the transfer fails (e.g., if the recipient is a contract that doesn't accept ERC721), does the function handle that? The _transferFromEscrow function is called, which I assume uses transferFrom. If the NFT contract uses safeTransferFrom, then it could revert if the recipient can't receive. But in that case, the delete of the auction would have already happened, so the auction is invalidated, and the NFT transfer failed. That could lead to the NFT being stuck in escrow. Because once the auction is deleted, there's no way to finalize it again. So if the transfer fails during finalization, the NFT is lost in escrow. That's a critical vulnerability. For example, if the bidder is a contract that doesn't implement onERC721Received, then safeTransferFrom would revert, causing the entire _finalizeReserveAuction to revert. But wait, in the code, when they call _transferFromEscrow, which is in NFTMarketCore. Let me check the _transferFromEscrow function. The parent function might be using transferFrom or safeTransferFrom. If it's using safeTransferFrom, then if the recipient can't receive, the transaction would revert. But in the context of finalizeReserveAuction, if that happens, the auction is already deleted. Wait, no: the code deletes the auction first, then calls _transferFromEscrow. So if the transfer fails, the auction is already deleted. Then, the NFT is stuck in the escrow because the auction is gone. The escrow is supposed to hold NFTs only during auctions. But if the auction is deleted and the transfer fails, the NFT remains in escrow with no way to retrieve it. That's a big problem.

Wait, looking at the code in _finalizeReserveAuction:

delete nftContractToTokenIdToAuctionId[...];
delete auctionIdToAuction[...];

Then, if keepInEscrow is false, they call _transferFromEscrowIfAvailable. Wait, no: the code says:

if (!keepInEscrow) {
  NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
}

So if keepInEscrow is false, they attempt to transfer from escrow to the bidder. If that transfer fails (e.g., because the bidder is a contract that can't receive), then the function call would revert. But since the auction has already been deleted, the state is changed before the transfer. Wait, no: the delete operations are before the transfer. So if the transfer fails, the function would revert, and the delete operations would be rolled back. So the auction would remain, and the NFT would stay in escrow. So maybe that's okay. Let me double-check.

In _finalizeReserveAuction, the steps are:

1. Check if the auction has ended.
2. Delete the auction mappings.
3. If not keepInEscrow, call _transferFromEscrow.
4. Distribute funds.

If the _transferFromEscrow fails (reverts), then the entire transaction reverts. Therefore, the delete operations would be rolled back. So the auction remains in the mappings. So the NFT is still in escrow, and the auction is not deleted. That's safe. So maybe that's not a problem. The vulnerability would be if the transfer is not handled safely, but since the code deletes after the checks, and the transfer is done after deletion but within the same transaction, if it fails, the deletion is reverted. So that's okay.

Another possible issue: in the adminAccountMigration function, there's a loop over listedAuctionIds. If the list is very large, this could run out of gas. But since it's an admin function, maybe it's acceptable. However, it's still a potential DoS if the operator tries to migrate a large number of auctions in one transaction.

Looking at the updateReserveAuction function. The seller can update the reserve price as long as the auction hasn't started (endTime is 0). But if the auction has a bidder, does that affect anything? For example, if the seller increases the reserve price after someone has already placed a bid meeting the previous reserve. Wait, when the auction is created, the initial bid is the reserve price. Once someone places a bid that meets or exceeds the reserve, the auction starts (endTime is set). So if the auction hasn't started (endTime is 0), the seller can update the reserve price. However, if there was a bid at the old reserve price, but the auction hasn't started yet (no bids placed), then updating the reserve would change the required minimum. But in the code, when you create the auction, the initial 'amount' is the reserve price. If the auction hasn't started (endTime is 0), then placing a bid needs to meet or exceed the current 'amount'. So if the seller updates the reserve (amount) to a higher value, then subsequent bids would have to meet the new reserve. That's correct behavior. So no issue here.

Another point: in the placeBidOf function, when a bid is placed and the auction hasn't started (endTime is 0), the code checks if the bid is >= reserve. Then, it sets endTime to block.timestamp + duration. However, the duration is taken from the auction.duration, which was set when the auction was created (DURATION). But DURATION is an immutable variable set in the constructor. So all auctions have the same duration. Wait, looking at the ReserveAuction struct: duration is a parameter stored per auction. When creating an auction, the duration is set to DURATION, which is immutable. So all auctions have the same duration. But if the admin could change DURATION, but no—since DURATION is immutable, set in the constructor. So that's okay.

But wait, the code has a __gap_was_config storage variable, which is a mapping gap. Not sure if that's relevant.

Reentrancy: The functions are marked with nonReentrant from ReentrancyGuardUpgradeable. So reentrancy should be prevented. But need to check all external functions that modify state. For example, adminCancelReserveAuction has nonReentrant, as do createReserveAuction, etc. So reentrancy is mitigated.

Another issue: The use of block.timestamp. The code uses block.timestamp to set endTime, which can be manipulated by miners to a small degree, but in the context of an auction that's hours or days long, a few seconds difference might not matter. But it's a consideration, though not a vulnerability per se.

Now, looking at the _transferFromEscrowIfAvailable function. It checks if there's an auction for the NFT, and if not, calls super. But if there is an auction, it skips transferring. However, if an auction exists but has ended (endTime < block.timestamp), then the NFT should be transferred. Wait, the code in _transferFromEscrow checks if the auction exists. If the auction has endTime == 0 (not started), then it deletes the auction and invalidates it. But if the auction has endTime !=0 and has ended (auction.endTime < block.timestamp), then during _transferFromEscrow, when someone tries to transfer, it checks if the auction exists. The code says:

uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
if (auctionId != 0) {
  ReserveAuction storage auction = auctionIdToAuction[auctionId];
  if (auction.endTime == 0) {
    // Auction not started; seller can transfer.
    ...
  } else {
    // Auction in progress or ended. Check if seller is the bidder (if ended)
    if (auction.bidder != seller) {
      revert Not_Matching_Seller();
    }
    // Finalize auction and transfer.
    _finalizeReserveAuction(auctionId, false);
    return;
  }
}

Wait, in the _transferFromEscrow function (from NFTMarketCore?), the code here overrides it. So when transferring from escrow, if there's an active auction, it requires that the seller is the bidder (if the auction has ended). But if the auction has ended, then during finalization, the NFT should be transferred to the bidder. So if someone tries to transfer the NFT while an auction has ended but hasn't been finalized, maybe that's a problem. For example, after an auction ends, the seller can't transfer the NFT because the contract should have transferred it to the bidder upon finalization. But if the auction isn't finalized, the NFT remains in escrow. So the _transferFromEscrow function, when called, would check if there's an auction. If the auction has ended (endTime < block.timestamp), then it would check if the seller is the bidder. But after an auction ends, the bidder is the winner, so the seller shouldn't be the bidder. Therefore, this would revert, preventing the transfer. However, the code in _transferFromEscrow says: 

if (auction.endTime == 0) {
  // auction not started
} else {
  // auction in progress or ended
  if (auction.bidder != seller) {
    revert Not_Matching_Seller();
  }
  // Finalize auction
  _finalizeReserveAuction(...)
}

Wait, the 'seller' here is the parameter passed to _transferFromEscrow. So when the seller is trying to transfer the NFT, if there's an auction that has ended, the code checks if the bidder is the seller. That doesn't make sense. Because the seller is the original seller, and the bidder is the winning bidder. So after an auction ends, the seller can't transfer the NFT; only the bidder can finalize. But in this code path, if someone (the bidder) is trying to transfer, then auction.bidder should equal seller (the parameter). But in that case, when the auction has ended, the bidder can call transfer, which would trigger finalization, transferring the NFT to themselves. But if the bidder doesn't finalize, the NFT remains in escrow. However, the transfer function would allow the bidder to transfer it. But maybe the transferFromEscrow is only called when the owner is trying to transfer, which after the auction, the owner would be the bidder. But this part is a bit confusing. Maybe there's a scenario where the NFT is stuck if the auction is not finalized.

For example, if an auction ends, but no one calls finalizeReserveAuction, then the NFT remains in escrow. The bidder could call transfer, which would trigger _transferFromEscrow, which would check the auction. Since the auction exists and has ended, it would check if the seller (the one initiating the transfer) is the bidder. If yes, then it finalizes the auction and transfers the NFT. So the bidder can retrieve the NFT by initiating a transfer. That's okay.

Another possible issue: The code uses a mapping from nftContract and tokenId to auctionId. But if a token is transferred outside the contract (e.g., via a direct transfer), the auction may still exist, leading to inconsistencies. For example, if the seller transfers the NFT to someone else without canceling the auction, the auction would still exist, but the contract no longer holds the NFT. But since the NFT is held in escrow when the auction is created, this shouldn't happen. Because when creating the auction, the NFT is transferred to escrow. So unless the escrow allows transfers, which it shouldn't, the NFT is safely held. So if the escrow is properly managed, this shouldn't be an issue. But if there's a way to transfer the NFT out of escrow without canceling the auction, that's a problem. But the _transferToEscrow and _transferFromEscrow functions should handle that.

What about the possibility of duplicate auctions? Since the mapping is nftContractToTokenIdToAuctionId, each NFT can have only one auction at a time. So creating a new auction for the same NFT would overwrite the existing auctionId. So that's handled.

In the cancelReserveAuction function, the seller can cancel the auction only if it hasn't started (endTime is 0). Once a bid is placed and the auction starts (endTime is set), the seller can't cancel. That's correct. But what if the auction has ended but wasn't finalized? The seller can't cancel it then. The only way to get the NFT back is if the auction is finalized, which transfers it to the bidder. Or if the bidder never existed, the seller could cancel. Wait, in the createReserveAuction function, the initial bidder is set to payable(0) and amount is the reservePrice. So the auction starts when a bid meets the reserve. So if no bids are placed, the auction can be canceled by the seller, and the NFT is returned. That's correct.

Another possible issue: In the adminAccountMigration function, it loops through listedAuctionIds and checks if the auction's seller is the originalAddress. But if the auction has been updated to a new seller via a previous migration, this could cause issues. However, the function is supposed to be called by an admin to migrate accounts, so it's expected that they handle this correctly. But there's a potential for front-running if not properly handled. However, since it's an admin function, perhaps it's acceptable.

Looking for integer overflows/underflows: The contract uses Solidity 0.8.0, which has built-in overflow checks. So arithmetic operations are safe. For example, in:

auction.endTime = block.timestamp + auction.duration;

If block.timestamp is near the max uint256 value, adding duration could overflow. But in practice, block.timestamp is a 32-bit value in Solidity (but actually, it's a uint256), but given that durations are up to 1000 days, it's unlikely to overflow. Since 1000 days is about 2.5e8 seconds, added to a timestamp (which is currently around 1.6e9), the sum is 1.85e9, which is way below 2^256-1. So no overflow.

Another thing: The auctionId is generated via _getNextAndIncrementAuctionId(). How is this function implemented? If it's using a simple counter, then it's okay. But since the code isn't shown, maybe there's a vulnerability there. But in the given code, the function is abstract, so we can assume that the parent contracts implement it correctly. However, if the auctionId is predictable or can be manipulated, that's a problem. But since it's internal and presumably uses a counter, it's probably safe.

In the placeBidOf function, when the bid is higher than msg.value, the code uses feth.marketWithdrawFrom. If the feth contract allows arbitrary calls or has reentrancy, but since the function is nonReentrant, that's mitigated. But if feth is malicious or buggy, it could cause issues. But assuming feth is a trusted contract, this is okay.

Another vulnerability: Front-running bids. For example, when a user places a bid, someone else can front-run with a higher bid. But this is inherent in auction systems and not a vulnerability per se.

What about the event emission after state changes? For example, in adminCancelReserveAuction, the event is emitted after deleting the auction. That's correct, as the state is already updated.

Incorrect access control: Checking if functions have proper modifiers. For example, createReserveAuction is nonReentrant and only allows the msg.sender to create an auction. The cancelReserveAuction checks that the seller is msg.sender. The admin functions have onlyFoundationAdmin or onlyFoundationOperator modifiers, which are presumably correctly implemented.

Potential vulnerability: If an auction is created, but the NFT is not correctly transferred to escrow, leading to a situation where the contract doesn't hold the NFT but an auction exists. However, the createReserveAuction function calls _transferToEscrow, which should transfer the NFT to the contract's escrow. If that transfer fails (e.g., the caller doesn't own the NFT), the entire transaction would revert, so the auction isn't created. So that's handled.

Another possible issue: If the contract's escrow holds the NFT, but the escrow's ownership isn't correctly handled. For example, if the escrow is implemented as the market contract holding the NFT, then the contract must have the ability to transfer it. But assuming the _transferToEscrow uses safeTransferFrom, and the seller has approved the contract, this should work.

In the _finalizeReserveAuction function, when distributing funds, it calls _distributeFunds. If the distribution fails (e.g., a fee recipient is a contract that reverts on receiving funds), this could cause the entire transaction to revert. But the _distributeFunds function likely uses the same _sendValueWithFallbackWithdraw, which would not revert on failure but instead store the funds for withdrawal. However, if the distribution uses external calls that can revert, this could prevent the auction from finalizing. For example, if the creator fee is sent to a contract that reverts, the finalization would fail. However, the _distributeFunds function is part of NFTMarketFees, which may handle this with withdrawal patterns. If not, this could be a problem.

Another thing: If the reserve price is set in a token other than ETH, but the contract deals in ETH. Wait, looking at the code, all bids are in ETH (msg.value), so the reserve price is in ETH. So no issue there.

Potential denial-of-service (DoS) by a malicious bidder: A bidder could place a bid, and then when outbid, their funds are sent back. If they have a fallback function that consumes a lot of gas or reverts, the sending of funds could fail, causing the new bid to fail. However, the code uses _sendValueWithFallbackWithdraw, which attempts to send but if it fails, the Ether is stored for withdrawal. Therefore, the original bidder's Ether is stored, and the new bid can proceed. So the bidder's inability to receive Ether doesn't block the auction. But in the code for placeBidOf, after updating the auction's bidder and amount, the code tries to send the original bid back. If that send fails, the code would revert? Wait, no: the _sendValueWithFallbackWithdraw function is used. Let's assume that function does not revert on failure (maybe logs and moves on). Then, even if sending to the originalBidder fails, the new bid is accepted. The originalBidder's Ether is kept in the contract, which they can withdraw later. So the auction proceeds. Therefore, this is handled, and no DoS.

Wait, but in the code, after updating the auction, the originalBidder's funds are sent. If that send fails, would the transaction revert? It depends on how _sendValueWithFallbackWithdraw is implemented. If it's using Address.sendValue, which reverts on failure, then the entire transaction would revert, and the auction state would roll back. But the code may have a different implementation. For example, the SendValueWithFallbackWithdraw might use a withdrawal pattern where failed sends are stored in a withdraw balance. Let's check:

The SendValueWithFallbackWithdraw contract probably has a function to withdraw funds. If sending Ether to the originalBidder fails, the contract would keep track of the owed Ether and allow the originalBidder to withdraw it later. Therefore, the send does not revert, and the auction proceeds. In that case, even if the send fails, the auction is updated, and the originalBidder's funds are in the contract's balance. Therefore, the transaction does not revert, and the new bid is valid. This is safe.

So, what vulnerabilities have we identified so far?

1. **Incorrect Handling of Ether Transfers Leading to Locked Funds**: If a bidder is a contract that cannot receive Ether (e.g., no payable fallback function), then when they are outbid, the Ether transfer to them would fail. However, if the SendValueWithFallbackWithdraw contract uses a withdrawal pattern, the funds are kept in the contract, and the bidder must call a withdraw function to retrieve them. If the contract doesn't track these withdrawals properly, the funds could be lost. But according to the code, the _sendValueWithFallbackWithdraw is used, which might handle this correctly. However, if the function doesn't track each user's withdrawable balance, then the Ether could be lost. For example, if multiple failed sends happen, the contract's balance would accumulate, but users wouldn't know how much they can withdraw. So the vulnerability here is that failed transfers to bidders could result in their funds being locked in the contract without a proper accounting mechanism. But this depends on the implementation of SendValueWithFallbackWithdraw.

2. **NFT Lock in Escrow if Transfer Fails During Finalization**: If during _finalizeReserveAuction, the transfer of the NFT to the bidder fails (e.g., the bidder is a contract that doesn't implement onERC721Received), the function would revert. However, since the auction is deleted before the transfer, but the revert would undo the deletion, this is not a problem. But if the transfer is not handled safely (e.g., using transferFrom instead of safeTransferFrom), then an invalid recipient could cause the NFT to be stuck. Wait, in the code, when transferring the NFT, which function is used? Looking at the code:

In NFTMarketCore's _transferFromEscrow, it's using transferFrom, not safeTransferFrom. If the NFT contract requires safeTransferFrom (like ERC721), then transferring to a contract that doesn't implement the receiver would fail. Therefore, if the NFTMarketCore uses transferFrom, then the transfer could succeed even if the recipient can't handle it, which is incorrect. But if it uses safeTransferFrom, then transferring to a non-receiver contract would revert, which is correct. But if the code uses transferFrom, that's a vulnerability because it could send the NFT to a contract that can't handle it, leading to a locked NFT. But in the code given, the _transferFromEscrow function's implementation is not visible here. Assuming that the NFTMarketCore uses transferFrom instead of safeTransferFrom, that's a vulnerability. But if it uses safeTransferFrom, then the transfer would revert, preventing the NFT from being locked. So this depends on the parent contract's implementation.

Looking at the import statement: ""../libraries/AccountMigrationLibrary.sol"", which might be related. But without seeing the code for NFTMarketCore's _transferFromEscrow, it's hard to say. However, given standard practices, it's possible that the transfer is done safely. But if not, it's a vulnerability.

3. **Admin Account Migration Gas Limit DoS**: The adminAccountMigration function loops over an array of auction IDs. If the array is too large, the transaction could run out of gas, causing a denial of service. This could be exploited by an attacker to prevent the admin from migrating accounts, but since it's an admin function, the impact is limited. However, it's still a vulnerability.

4. **Auction Invalidation During Transfer**: When transferring an NFT that has an auction, if the auction hasn't started (endTime is 0), then transferring the NFT invalidates the auction. But if the auction has started (endTime != 0), then transferring the NFT is only allowed if the caller is the bidder. However, if the bidder is not the seller, they can't transfer the NFT, leading to potential issues if the bidder needs to take ownership. But according to the auction logic, once the auction is finalized, the NFT is transferred to the bidder. So this is handled.

5. **Lack of Auction Existence Check in placeBidOf**: The placeBidOf function checks if auction.amount == 0 to determine if the auction exists. However, if an auction is created with a reservePrice (amount) of zero, which is prevented by the onlyValidAuctionConfig modifier. The modifier checks that reservePrice != 0, so auction.amount will never be zero. Therefore, this check is safe.

6. **Incorrect Minimum Bid Calculation**: The getMinBidAmount function returns auction.amount (reserve price) if the auction hasn't started. Once it's started, it returns _getMinIncrement(auction.amount). The _getMinIncrement is presumably a function that calculates the minimum bid increment. If this function is incorrect (e.g., allowing bids lower than required), it could be a vulnerability. But since the code isn't shown, it's hard to tell. But assuming it's implemented correctly, this is fine.

7. **Replay Attacks in Admin Account Migration**: The adminAccountMigration function uses a signature to validate the migration. If the signature is not properly handled (e.g., not including nonces or chain ID), a replay attack could occur. However, the requireAuthorizedAccountMigration function in AccountMigrationLibrary should handle this. Without seeing the library's code, it's hard to say, but if implemented correctly, this is mitigated.

8. **Uninitialized Contract Risk**: Since this is an upgradeable contract (uses __gap), if the parent contracts are not properly initialized, there could be vulnerabilities. For example, if the ReentrancyGuardUpgradeable is not initialized, the reentrancy guard might not work. But the contract inherits from ReentrancyGuardUpgradeable and is marked as abstract, so the actual deployment should handle initialization.

Another possible issue: The use of immutable variables in a contract that's part of an upgradeable contract. The DURATION variable is immutable, which is set in the constructor. However, upgradeable contracts typically use proxies, and the constructor is not called on the proxy. But in this case, the contract is abstract and may be part of a non-upgradeable implementation contract. The constructor is valid for non-upgradeable contracts, but if this contract is meant to be upgradeable, using an immutable variable would be incorrect. Since the contract includes __gap variables, it's likely part of an upgradeable contract pattern, but the presence of a constructor with an immutable variable would make it non-upgradeable. This is a critical vulnerability if the contract is intended to be upgradeable, as the proxy would not have the DURATION set. However, the user provided code has a constructor with DURATION, which is immutable. This suggests that the contract is not upgradeable, but since it's using upgradeable dependencies (ReentrancyGuardUpgradeable), there's a contradiction. Therefore, this is a vulnerability: using a constructor with immutable variables in an upgradeable contract.

Wait, upgradeable contracts can't have constructors because the proxy doesn't run the constructor. Therefore, the contract's use of a constructor with an immutable variable (DURATION) makes it non-upgradeable, which may be a vulnerability if the contract is intended to be deployed behind a proxy. But the code uses upgradeable libraries like ReentrancyGuardUpgradeable. This is a mistake. The correct approach for upgradeable contracts is to use an initialize function instead of a constructor. Therefore, the presence of a constructor in an upgradeable contract is a vulnerability. However, the contract may not be intended to be upgradeable, but the inclusion of upgradeable libraries suggests otherwise. This is a critical vulnerability if the contract is part of an upgradeable system.

So summarizing the vulnerabilities:

1. **Use of Constructor in Upgradeable Contract**: The contract has a constructor that sets an immutable variable (DURATION), which is incompatible with upgradeable contracts that use proxies. This would cause the DURATION to be uninitialized in the proxy contract, leading to incorrect behavior.

2. **Insufficient Handling of Failed Ether Transfers**: If the SendValueWithFallbackWithdraw does not properly track owed Ether to users, failed transfers to bidders could result in locked funds. For example, if the contract doesn't have a mechanism for users to withdraw their Ether after a failed transfer, those funds would be stuck in the contract.

3. **Potential NFT Lock in Escrow Due to Unsafe Transfer**: If the _transferFromEscrow function uses transferFrom instead of safeTransferFrom, transferring an NFT to a contract that doesn't implement onERC721Received could result in the NFT being locked.

4. **Admin Account Migration Gas DoS**: The adminAccountMigration function could run out of gas if processing a large array of auction IDs, leading to a denial of service.

5. **Incorrect Auction Existence Check**: The code checks for auction.amount == 0 to determine if an auction exists. However, if an auction is created with a reserve price of zero (which should be prevented by the modifier), this check would fail. Since the modifier ensures reservePrice != 0, this is not a vulnerability.

6. **Upgradeable Contract Initialization Vulnerability**: If the contract is intended to be upgradeable but uses a constructor instead of an initialize function, it would be incorrectly initialized when deployed via a proxy.

7. **Lack of Withdrawal Pattern for FETH Funds**: When using feth.marketWithdrawFrom, if the FETH contract does not properly handle withdrawals or approvals, users might not have their funds correctly deducted, leading to under/overflows. However, this is dependent on the FETH implementation.

8. **Inadequate Access Control in Admin Functions**: The admin functions (adminCancelReserveAuction, adminAccountMigration) are protected by onlyFoundationAdmin and onlyFoundationOperator modifiers. If these modifiers are not correctly implemented, unauthorized access could occur. However, assuming these modifiers are correct, this is not a vulnerability.

Now, prioritize the actual vulnerabilities based on the code provided:

The key vulnerabilities are:

1. **Constructor in Upgradeable Contract**: The contract includes a constructor, which is not compatible with upgradeable contracts. Since the contract uses upgradeable dependencies (ReentrancyGuardUpgradeable) and has a __gap variable, it's intended to be upgradeable. The constructor will not be called when using a proxy, leading to uninitialized variables (DURATION). This is a critical vulnerability.

2. **Insufficient Handling of Failed Ether Transfers**: If the SendValueWithFallbackWithdraw does not track user balances, failed transfers could lock funds. For example, if a bidder cannot receive Ether, the Ether remains in the contract, but there's no way for them to withdraw it. However, if the SendValueWithFallbackWithdraw contract implements a withdrawal pattern, this is mitigated. Since the code includes ""SendValueWithFallbackWithdraw"", which likely uses such a pattern, this may not be a vulnerability. But without seeing the implementation, it's hard to confirm.

3. **Unsafe NFT Transfer**: If the _transferFromEscrow uses transferFrom instead of safeTransferFrom, leading to NFTs being sent to contracts that can't handle them. This is a vulnerability if the parent NFTMarketCore uses transferFrom instead of safeTransferFrom.

4. **Admin Account Migration Gas DoS**: The loop in adminAccountMigration could consume excessive gas, making it impossible to process large numbers of auctions.

Other possible issues:

- **Front-Running Bids**: As with any auction system, but this is a known issue and not a contract vulnerability.

- **Timestamp Dependence**: Reliance on block.timestamp for auction end times, but this is a minor concern.

The most critical vulnerabilities are the constructor in an upgradeable contract and unsafe NFT transfers.","```
None.
```",0.0,0
NFTMarketCreators.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363.0,268.0,"[H-02] Creators can steal sale revenue from owners' sales
In the function `_getCreatorPaymentInfo()`
All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.
Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.
  [M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array
The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and catch statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a try statement, the revert is actually not handled and it will not fall through to the empty catch statement.
 
[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns
Based on our research, `getRoyalties()` is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.
However, in the current implementation, it always assumes that `getRoyalties()` return in terms of BPS.",3.0,"pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();


abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable 
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  
  
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    

    
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch 
      {
        
      }
    }

    
    
    
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          

          
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch 
            {
              
            }
          }

          
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch 
            {
              
            }
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch 
          {
            
          }
        }
      } catch 
      {
        
      }
    }

    
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          
          recipients = new address payable[](1);
          recipients[0] = _creator;
          
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch 
    {
      
    }

    
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch 
    {
      
    }

    
  }

  
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  
  uint256[500] private __gap;
}",1579.0,1,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Insufficient Gas for External Calls**  
   The contract uses a fixed `READ_ONLY_GAS_LIMIT` for external calls (e.g., `royaltyInfo`, `getRoyalties`). If the gas limit is too low, these calls may fail, leading to incomplete royalty data and potential loss of royalties for creators.

2. **Incorrect Handling of Recipient Splits in Loops**  
   Loops iterating over royalty recipients (e.g., `for (uint256 i = 0; i < _recipients.length; ++i)`) may consume excessive gas if the array is large, causing transaction reverts. While the `try/catch` prevents reverts, this could result in skipped valid recipients.

3. **Dependence on Untrusted Registry Lookup**  
   The `royaltyRegistry.getRoyaltyLookupAddress` may return an override contract that could be malicious or improperly configured. Subsequent calls to this contract (e.g., `royaltyInfo`) might return incorrect or manipulated data.

4. **Misidentification of Creator Status**  
   The `isCreator` flag is set to `true` if the seller matches any recipient (e.g., `receiver == seller`). This inaccurately flags sellers as creators even if they are not the original creators, leading to improper attribution.

5. **Unhandled Empty Recipient Edge Case**  
   If all external calls fail to return valid recipients, the function returns empty arrays. This could bypass valid royalties, depriving creators of payments if no fallback mechanism exists.

6. **Order of Precedence in Royalty Standards**  
   The contract prioritizes `IRoyaltyInfo` over other standards (e.g., `IGetRoyalties`). Contracts implementing multiple standards may have royalties processed incorrectly due to unchecked conflicts.

7. **Potential Stale Data from Upgradeable Contracts**  
   As an upgradeable contract, inherited storage gaps (`__gap`) are used, but future upgrades could introduce storage layout mismatches if not carefully managed (though not directly exploitable in the current code).

These vulnerabilities could lead to incorrect royalty payments, failed transactions, or reliance on untrusted external contracts.","### **[H-02] Creators can steal sale revenue from owners' sales**

**Report Description**:  
In the function `_getCreatorPaymentInfo()`, all sales in the Foundation market pay creators 10% royalties on secondary sales. This applies to any NFT, not just those minted on Foundation. If royalty information was not defined during the NFT's deployment, it can be added using the Royalty Registry, which the market contract respects. However, an owner can change the royalty information right before a sale is completed, potentially redirecting royalties to themselves or another party, leading to unfair revenue distribution.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of owners manipulating royalty information via the Royalty Registry before a sale. This is a critical oversight, as it directly impacts the fairness and security of royalty distribution.

---

### **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**

**Report Description**:  
The `_getCreatorPaymentInfo()` function is used by `_distributeFunds()` during NFT sales. It employs `try` and `catch` statements to handle bad API endpoints. However, if the function reverts inside a `try` statement (e.g., due to an unbounded `_recipients` array), the revert is not properly handled, and it does not fall through to the empty `catch` statement. This could result in NFTs being locked in the contract.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Handling of Recipient Splits in Loops""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of excessive gas consumption due to large recipient arrays but does not address the specific problem of reverts inside `try` statements not being handled properly. This is a critical detail missed in the response.

---

### **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Report Description**:  
The `getRoyalties()` function is not a standardized API for NFT contracts, yet the current implementation assumes it returns values in terms of BPS (basis points). This assumption can lead to unfair royalty distribution among `creatorRecipients` if the `getRoyalties()` function returns non-standard values.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of non-standard `getRoyalties()` returns and their impact on royalty distribution. This is a significant gap, as it directly affects the fairness of payments to creators.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**

**Missed Issues from Issue Report**:  
- **[H-02] Creators can steal sale revenue from owners' sales**  
- **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

---

The response list fails to address two critical issues ([H-02] and [M-15]) and only partially covers one issue ([M-07]). This indicates significant gaps in the coverage, accuracy, and sufficiency of the responses.",0,1,2,7,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called NFTMarketCreators and it's an abstract contract that uses ReentrancyGuardUpgradeable. The main purpose seems to be handling royalty information for NFTs. Let's start by going through the code step by step.

First, the constructor takes an address _royaltyRegistry and checks if it supports the IRoyaltyRegistry interface. If not, it reverts. Then it initializes the royaltyRegistry. That part seems okay, ensuring that the registry is valid.

The main function here is _getCreatorPaymentInfo. It's trying to determine the royalty recipients and their splits for a given NFT. There are several checks here: first checking if the NFT contract supports IRoyaltyInfo, then IGetRoyalties, then using the royaltyRegistry to get an override contract, then IGetFees, ITokenCreator, and finally IOwnable. Each step tries to get royalty information and returns if it finds valid recipients.

Looking for vulnerabilities, common issues might include reentrancy, but since this is a view function and doesn't modify state, maybe that's not a problem here. Wait, the contract is using ReentrancyGuardUpgradeable, but the _getCreatorPaymentInfo function is a view function, so maybe that's not necessary here. But maybe other functions in the contract that aren't shown could be affected. However, since we're only looking at this code, maybe not.

Another thing is gas limits and out-of-gas errors. The code uses try/catch with a gas limit (READ_ONLY_GAS_LIMIT). If the called functions consume more gas than the limit, the calls will fail, but they are caught. However, if the gas limit is set too low, it might cause the function to not retrieve the correct royalty information, leading to incorrect payouts. That could be a vulnerability if the gas provided isn't sufficient for the external calls.

Also, in some of the loops, like in the IGetRoyalties section, there's a for loop that iterates over _recipients. The code checks if each recipient is not address(0) and if any is the seller. But in Solidity, loops that can have variable lengths could run into issues if the array is too large, causing the function to consume too much gas and revert. However, since this is a view function, maybe that's less of a concern here. But if the array is very large, the loop could run out of gas, leading to incorrect handling of recipients. But since it's in a try/catch, it would just skip and move on, which might leave recipients uninitialized or with default values.

Another point is that the function returns multiple times in different conditions. For example, if the first check (IRoyaltyInfo) finds a receiver that is the seller, it returns immediately. Otherwise, it proceeds to check other interfaces. However, there might be a scenario where multiple royalty standards are implemented, and the order of checking could lead to unexpected results. For example, if an NFT contract implements both IRoyaltyInfo and IGetRoyalties, but the first one returns a different recipient than the second, the function would prioritize the first one. That's not a vulnerability per se, but could lead to unexpected behavior if the contract relies on a different standard.

Looking at the ERC165 checks: the code uses supportsERC165Interface, which is from OZ's ERC165Checker. That's correct. But there's a possibility that the interface check could be spoofed if a contract returns true without actually implementing the interface properly. However, that's a general issue with ERC165 and not specific to this contract.

In the part where royaltyRegistry.getRoyaltyLookupAddress is called, it's possible that the overrideContract could be a malicious contract. If the registry returns a malicious contract address, subsequent calls to royaltyInfo or getRoyalties could execute arbitrary code. However, since the royaltyRegistry is set in the constructor and checked to support IRoyaltyRegistry, maybe that's trusted. But if the registry is compromised, it could lead to issues here. But the contract is immutable once deployed, so if the registry is secure, this might not be an issue.

Another thing is the use of the seller parameter. The function checks if any of the recipients is the seller and returns isCreator as true. But if the seller is not the creator but is one of the recipients, this could incorrectly mark them as the creator. However, according to the logic, the function returns isCreator as true if any of the recipients is the seller. For example, if the royalty receiver is the seller, then isCreator is true, even if they're not the actual creator. This might be intentional, but it's worth noting as a potential logic issue.

Also, when using the royaltyRegistry, if the overrideContract is different from the original nftContract, the code updates nftContract to the override and re-runs some checks. However, in the loop where it checks IRoyaltyInfo again after the override, there's a possibility that this could lead to infinite recursion if the override contract points back to the original. But the code doesn't loop here; it just checks once. So that's probably safe.

Looking at the try/catch blocks: any exceptions in the external calls are caught, which is good to prevent reverts, but could lead to the function proceeding with incomplete data. For example, if an external call fails, it skips that method and moves to the next. However, if all methods fail, the function might return empty recipients. The function seems to handle that by checking if recipients.length == 0 before proceeding to the next check, which is correct. But if all checks fail, the function would return empty recipients, which could lead to no royalties being paid, possibly a problem if royalties are expected.

Another point is that the code might not handle basis points correctly. For example, when calling IRoyaltyInfo's royaltyInfo with BASIS_POINTS as the sale price, but if the basis points are not correctly calculated, there could be errors in the royalty amounts. However, the code here is just retrieving the receiver and ignoring the amount (since the parameter is splitPerRecipientInBasisPoints), so maybe that's intentional.

There's also the issue of uninitialized variables. For example, splitPerRecipientInBasisPoints is declared but not initialized. If none of the conditions set it, it will return an empty array. That's okay as long as the calling function handles that, but if it expects the array to be the same length as recipients, it could cause issues. However, in the code, when recipients are set, the split is also set in the same block, so that's probably handled.

Lastly, the use of the private __gap variable in upgradeable contracts is a standard practice to reserve storage slots for future upgrades, so that's not a vulnerability.

So, compiling all these thoughts, the possible vulnerabilities are:

1. **Insufficient Gas for External Calls**: Using a fixed gas limit (READ_ONLY_GAS_LIMIT) for external calls might lead to failed calls if the required gas exceeds the limit, resulting in incomplete or incorrect royalty information.

2. **Incorrect Handling of Recipients and Splits**: If multiple royalty standards are implemented (e.g., both IRoyaltyInfo and IGetRoyalties), the order of precedence might lead to unexpected results. Additionally, loops over recipients could run out of gas if the array is too large, though within try/catch blocks.

3. **Reliance on External Registry**: The contract depends on the royaltyRegistry, which if malicious or compromised, could return harmful override contracts leading to incorrect royalty data.

4. **Potential Misidentification of Creator**: The isCreator flag is set based on whether the seller is a recipient, which might not accurately reflect if the seller is the actual creator, leading to incorrect isCreator return values.

5. **Unhandled Edge Cases**: If all external calls fail or return invalid data, the function might return empty recipients and splits, potentially bypassing royalty payments that should exist.","```
None.
```",0.0,0
NFTMarketOffer.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149.0,404.0,"[H-03] An offer made after auction end can be stolen by an auction winner
An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.
This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.
 
[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it
If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.
I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.
This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of setBuyPrice or createReserveAuction, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();

error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);

error NFTMarketOffer_Offer_Expired(uint256 expiry);

error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);

error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();


abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  
  struct Offer {
    
    
    uint32 expiration;
    
    uint96 amount;
    

    
    
    address buyer;
  }

  
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        
      }
    }
  }

  
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      

      
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      

      if (amount < _getMinIncrement(offer.amount)) {
        
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      
      
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    
    offer.buyer = msg.sender;
    
    offer.expiration = uint32(expiration);
    
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    
    delete nftContractToIdToOffer[nftContract][tokenId];
    
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) 
    {
      
    } catch {
      
      
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      
      _invalidateOffer(nftContract, tokenId);
    }
    
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      
      delete nftContractToIdToOffer[nftContract][tokenId];
      
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    
    return 1;
  }

  
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      
      return (address(0), 0, 0);
    }

    
    return (offer.buyer, offer.expiration, offer.amount);
  }

  
  uint256[1000] private __gap;
}",1815.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **ETH Value and Amount Parameter Mismatch in `makeOffer`**  
   The `makeOffer` function does not validate that `msg.value` equals the `amount` parameter. This allows users to lock an incorrect amount of ETH in the contract, potentially leading to loss of funds or incorrect offer values.

2. **Expiration Timestamp Truncation**  
   The `expiration` timestamp is stored as a `uint32`, which will overflow after the year 2106. This truncation can cause incorrect expiration times for offers placed beyond this date.

3. **Admin Array Length Mismatch in `adminCancelOffers`**  
   The function does not ensure the `nftContracts` and `tokenIds` arrays have equal lengths. Mismatched arrays can cause out-of-bounds errors or unintended behavior during loop execution.

4. **Insufficient Validation of ETH Sent in `makeOffer`**  
   The function does not check if `msg.value` is sufficient for the intended `amount`, risking underfunded or overfunded offers and improper locking of ETH.

5. **Potential Locked Funds in Expired Offers**  
   If the `feth` contract does not auto-unlock funds after expiration, admins may inadvertently leave funds locked by not canceling offers before they expire.

6. **Inconsistent State Risk in `_acceptOffer`**  
   If both `transferFrom` and `_transferFromEscrow` fail after funds are distributed (depending on `_distributeFunds` implementation), the transaction might not revert, leading to loss of NFT without refund.

7. **Lack of Excess ETH Refund in `makeOffer`**  
   Excess ETH sent to `makeOffer` is not refunded, potentially locking extra funds in the contract and causing user losses.

8. **Truncation of Offer Amount to `uint96`**  
   Storing `amount` as `uint96` limits offer values to ~7.9e28 wei (~79 billion ETH). While highly unlikely, this could theoretically restrict very large offers.

9. **Front-Running Opportunities**  
   Offers can be accepted before the transaction is mined, though this is a systemic blockchain issue rather than a contract-specific flaw.","### **Output**

---

**[H-03] An offer made after auction end can be stolen by an auction winner**

**Report Description**:  
An offer made for an NFT after an auction has ended, but before the winner has received the NFT, can be stolen by the auction winner. The `_transferFromEscrow` function, called by `_acceptOffer`, transfers the NFT to the winner, finalizing the auction. However, the user who made the offer does not receive the NFT, allowing the auction winner to obtain both the NFT and the offer amount at no additional cost, at the expense of the offer maker.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The described vulnerability involves a race condition where the auction winner can exploit the timing of offer acceptance and NFT transfer. This is a critical oversight, as it allows for the theft of both the NFT and the offer amount. The response list focuses on issues like ETH value mismatches, expiration truncation, and array length mismatches, none of which relate to this specific vulnerability.

---

**[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

**Report Description**:  
If an NFT is in escrow without an active `buyPrice` or auction, it can be stolen by any actor using the `makeOffer` and `acceptOffer` functions. A malicious user can monitor the contract and exploit this vulnerability to obtain any NFT for free, especially if the NFT was mistakenly sent to the contract. The severity is medium because normal usage of the system typically involves initializing either a `buyPrice` or auction structure, leaving only mistakenly sent assets exposed.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves the lack of safeguards for NFTs in escrow without active `buyPrice` or auction structures, allowing malicious actors to exploit the system. The response list focuses on issues like ETH value mismatches, expiration truncation, and array length mismatches, none of which relate to this specific vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-03] An offer made after auction end can be stolen by an auction winner**  
- **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

---

### **Conclusion**  
The `response_list` does not address the two critical issues identified in the `issue` report. Both vulnerabilities involve significant risks to the security and functionality of the smart contract, yet they are entirely overlooked in the response list. This indicates a substantial gap in the coverage and accuracy of the responses provided.",0,0,2,9,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. Hmm, it's an NFT market offer contract, so I need to check common issues like reentrancy, access control, arithmetic issues, etc. Let's start with the functions.

First, the acceptOffer function. It uses nonReentrant modifier, which is good against reentrancy. But wait, there's a call to transferFrom after deleting the offer. If the NFT transfer fails, like if the seller doesn't approve the contract, does it revert? The try/catch block is there. If the transfer fails, it calls _transferFromEscrow. But in the catch, it proceeds with transferring from escrow. Maybe that's okay if the escrow handles it, but maybe there's a case where the escrow transfer also fails. Not sure. Also, when transferring, if the buyer is a contract with a callback, could that cause reentrancy? But since the nonReentrant is on acceptOffer, maybe that's protected.

Looking at the makeOffer function. They use feth.marketLockupFor with value msg.value. The user sends ETH here. But how is the amount checked against msg.value? The parameters are amount, but the function is payable. Let's see, in makeOffer, when creating a new offer, they check if the existing offer is expired. Then they call feth.marketLockupFor with msg.value. Wait, the function is called with amount as a parameter, but the msg.value is passed to the feth function. So does the amount parameter equal the msg.value? If not, that's a problem. For example, if the user specifies an amount higher than msg.value, the feth function would not have enough ETH. Let me check the code again.

The makeOffer function has ""returns (uint256 expiration)"" and in the parameters, the user provides amount. Then, when creating the offer, they set offer.amount to uint96(amount). But the function is payable, and when they call feth.marketLockupFor{ value: msg.value }, they're passing msg.value. So the amount parameter is supposed to be the same as msg.value? Because otherwise, the ETH sent may not match the amount. That's a big issue. If someone calls makeOffer with amount higher than msg.value, the contract would lock a higher amount than the ETH sent. Because the code uses msg.value when calling feth.marketLockupFor, but the amount is set to the parameter. For example, if a user sends 1 ETH but sets amount to 2, then the feth contract is called with 1 ETH, but the offer's amount is 2. That would lead to a discrepancy. That's a critical vulnerability because the contract would record a higher offer amount than the actual ETH locked. This could allow attackers to place higher offers without providing sufficient funds.

Another thing in makeOffer: when updating an existing offer, they check if the new amount is at least the min increment. But how is _getMinIncrement implemented? If the function isn't present here, maybe it's inherited. Assuming it works, but if not, the check might be incorrect. But since the error is thrown, maybe that's okay. Not sure, but the main issue is the msg.value and amount mismatch.

Next, the adminCancelOffers function loops through arrays. Are the array lengths checked? The parameters are nftContracts and tokenIds arrays. The code uses a for loop with i < nftContracts.length. But what if the two arrays have different lengths? For example, if nftContracts has length 2 and tokenIds has length 3, the loop would run 2 times, but the third tokenId would be ignored. However, the function uses calldata arrays, which are checked by the compiler for matching lengths when called. Wait, no, Solidity doesn't automatically check that the lengths are the same. So if the admin passes arrays of different lengths, the loop would go up to the smaller length, leading to some tokenIds not being processed or causing an out-of-bounds error. Wait, no: the loop is from 0 to nftContracts.length, and for each i, it uses tokenIds[i]. So if nftContracts is longer than tokenIds, accessing tokenIds[i] would revert due to out of bounds. Similarly, if tokenIds is longer, but the loop only runs up to nftContracts.length, then some tokenIds are not processed. So this function requires that the admin passes arrays of equal length, but there's no check in the code. That's a vulnerability because if the admin makes a mistake, the transaction could revert, or process incorrectly. But since the admin is a trusted role, maybe it's a low risk, but still a potential issue.

In the _acceptOffer function, after deleting the offer, they call feth.marketWithdrawLocked. Then distributeFunds. Then, they try to transferFrom the seller to the buyer. If the seller no longer owns the NFT (maybe they transferred it after the offer was made), the transferFrom would fail, and the catch block calls _transferFromEscrow. But what if the escrow doesn't have the NFT either? Then the transfer would fail, and the buyer's funds would be released, but the NFT isn't transferred. This could result in the seller receiving the payment but not transferring the NFT. That's a critical issue because the buyer pays but doesn't get the NFT. However, the code is in a try/catch, so if the transferFrom fails, it proceeds to transfer from escrow. But if that also fails, the transaction would revert? Or does the _transferFromEscrow function handle that? The code says ""super._transferFromEscrow(...)"", which probably transfers from the market's escrow. If the NFT is not in escrow, then this would fail, causing the entire transaction to revert. But in the try block, if the transferFrom fails, the catch block would execute the _transferFromEscrow. So if the seller doesn't own the NFT and it's not in escrow, the transfer would fail, reverting the transaction. So maybe that's handled correctly. But I'm not sure. Let me see: the normal flow is that the seller is the msg.sender in acceptOffer, and they must own the NFT. But if they already transferred it, the transferFrom would fail. The code then tries to transfer from escrow. If the NFT was previously in escrow (like listed for sale), then it's transferred. But if not, then the transferFromEscrow would fail. So the transaction would revert, which is good because it prevents the seller from accepting an offer when they don't have the NFT. So maybe this is okay. But the problem arises if the escrow transfer doesn't check ownership correctly. But that's part of another contract.

Another thing: the Offer struct uses uint96 for amount and uint32 for expiration. Are there any overflows here? When setting expiration as uint32(expiration), if the returned expiration from feth.marketLockupFor is larger than uint32.max, it would truncate. But since expiration is a timestamp, and uint32 can hold up to around 2106 (since 32 bits is about 136 years past 1970), which is a problem because after 2106, the expiration would overflow. But that's a long time from now. Maybe it's acceptable, but technically it's a vulnerability because in 2106, the expiration would wrap around. However, the impact is low given the current time.

In adminCancelOffers, when deleting the offer, it checks if offer.expiration >= block.timestamp. But if the offer is already expired, it still deletes it but doesn't emit the event. Wait, no: the code deletes the offer regardless. Then, if the offer's expiration is >= block.timestamp, it unlocks the funds and emits Canceled event. So even if the offer is expired, the admin can delete it, but since the expiration is in the past, the unlock isn't done. Wait, no: the code inside the loop is:

Offer memory offer = nftContractToIdToOffer[...];
delete...;
if (offer.expiration >= block.timestamp) {
    feth.marketUnlockFor(...);
    emit...;
}

So even if the admin cancels an expired offer, the unlock isn't done. But if the offer is expired, the feth funds should already be unlocked. But in the Offer struct, when an offer expires, does the feth automatically unlock? Or does it need to be unlocked via some function? If the expiration has passed, maybe the funds are still locked until someone calls a function to unlock them. So if the admin cancels an expired offer, the code would delete it but not unlock the funds, assuming that after expiration, the funds are automatically unlocked. But maybe the feth contract requires that the market calls marketUnlockFor. If the offer expires, but the contract doesn't automatically unlock, then the funds remain locked. So if the admin cancels an offer that's already expired, they would not call marketUnlockFor, leaving the funds locked. However, in normal flow, when an offer expires, does the buyer have to manually withdraw? If the market doesn't handle unlocking expired offers, that's a problem. But this is part of the feth contract's logic. Not sure, but the current code in adminCancelOffers only unlocks if the offer is still active (expiration not passed). So if the admin cancels an expired offer, the funds would remain locked. That's a potential issue where expired offers' funds are stuck unless the admin cancels them before expiration. But maybe that's intended. However, the admin might not realize that and leave funds locked. But this is more of a UX issue than a vulnerability.

Looking at the _invalidateOffer function: it checks if the offer's expiration is >= block.timestamp. If so, deletes the offer, unlocks the funds, and emits an event. But if the offer was already expired, then invalidating it would do nothing. So if the offer is invalidated after expiration, the funds are not unlocked here. But again, depends on feth's handling of expiration.

Another thing: the Offer struct's buyer field. When a new offer is made, the buyer is set to msg.sender. But in the code where offers are replaced (when there's an existing offer), when a new offer is made, the previous buyer's funds are unlocked via feth.marketChangeLockup. So when a new offer replaces an old one, the old buyer's funds are unlocked. That's handled correctly. So no issue there.

Reentrancy in _acceptOffer: since the function is called within a nonReentrant function, and the external call (transferFrom) is in a try block. Even if the transferFrom calls back into the contract, the nonReentrant modifier would prevent reentrancy. So that's okay.

Another possible issue: in the _acceptOffer function, after distributing the funds, the code emits OfferAccepted. But if the transferFrom fails and the catch block is triggered, the NFT is transferred from escrow. However, the funds have already been distributed. Suppose the transferFrom fails, but the escrow transfer also fails for some reason. Then, the funds have been sent to the seller, but the NFT wasn't transferred. That would be a problem. Wait, no: the _transferFromEscrow is part of the super call. Let me check the code again.

In the try block: IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId). If that fails, it goes to the catch block, then calls _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender). The _transferFromEscrow is supposed to transfer the NFT from the escrow (market contract) to the buyer. But if the market contract doesn't hold the NFT, then this transfer would fail, reverting the transaction. So in that case, the funds would not have been distributed yet? Wait, no. The code first deletes the offer, withdraws the locked funds (feth.marketWithdrawLocked), then distributes the funds via _distributeFunds. Then attempts the transfer. So if the transfer fails and the escrow transfer also fails, the funds have already been distributed. That's a problem because the seller gets the money but the buyer doesn't get the NFT. That's a critical vulnerability.

Wait, let's step through:

In _acceptOffer:

1. Delete the offer.

2. Withdraw locked funds (feth.marketWithdrawLocked). This probably transfers the funds from the feth contract to the market or the seller.

3. Distribute funds to the seller, fees, etc. So the seller has already received the funds.

4. Try to transferFrom seller to buyer. If this fails, catch block calls _transferFromEscrow.

If the transferFrom fails (seller doesn't own the NFT), then the code proceeds to transfer from escrow. If the escrow has the NFT, then it's transferred. If not, the _transferFromEscrow would fail, reverting the transaction. However, the funds have already been distributed. Wait, no: the _distributeFunds is called before the transfer. So in this case, the funds are sent to the seller before ensuring the NFT is transferred. So if the transferFrom and _transferFromEscrow both fail, the transaction would revert, but since the funds were already distributed, wouldn't that leave the contract in an inconsistent state? No, because in Solidity, if a transaction reverts, all state changes are rolled back. Wait, no. The _acceptOffer is called within acceptOffer, which is nonReentrant. Let me see the flow:

- acceptOffer is called, which calls _acceptOffer.

- Inside _acceptOffer, steps are:

   - Delete the offer (state change).

   - Withdraw locked funds (state change in feth contract).

   - Distribute funds (transferring ETH to seller, fees, etc. So ETH is sent out).

   - Try to transfer NFT.

   - If transfer fails, call _transferFromEscrow.

If during the transferFrom or _transferFromEscrow, an exception is thrown, the entire transaction would revert, including the deletion of the offer and the distribution of funds. Wait, no. Because the code is in a try/catch block. The try block does the transferFrom; if it fails, the catch block is executed. But the catch block doesn't revert; it proceeds to call _transferFromEscrow. However, if _transferFromEscrow throws an exception (like if the escrow doesn't have the NFT), then the entire transaction would revert. Because exceptions bubble up unless caught. So in that case, the entire transaction would revert, undoing the deletion of the offer, the withdrawal of funds, and the distribution. So the funds would not have been sent. So that's okay. Wait, but when you send ETH via _distributeFunds, if that's done via a transfer, that's not revertible. Wait, how does _distributeFunds work? Let's look into the code. The _distributeFunds function probably sends ETH to the seller, foundation, and creator. If those are done via transfer or send, which don't revert the transaction, then even if the later transferFrom fails, the funds have already been sent. But if the _distributeFunds uses call with checks, like transferring and reverting on failure, then the entire transaction would revert if the distribution fails.

Assuming that _distributeFunds is implemented in NFTMarketFees and properly handles sending funds, if any of the transfers fail (e.g., sending to a contract that can't receive ETH), then the _distributeFunds would revert, causing the entire transaction to revert. Otherwise, if it uses send or transfer, which have gas limits and don't revert, then the funds could be sent, and the NFT transfer could fail later. But according to best practices, it's better to use call with a revert on failure. However, without seeing the implementation of _distributeFunds, it's hard to say. If _distributeFunds sends funds using transfer, which doesn't revert on failure, then even if the NFT transfer fails, the funds have been sent, and the transaction would proceed. That's a problem. So if the seller is a contract that can't receive ETH, the transfer would fail, but the code would proceed to try to transfer the NFT, which might also fail. But in the _distributeFunds function, if it's using safe transfer methods, then this would revert, and the entire transaction is rolled back. So it depends on how _distributeFunds is implemented. Since this contract is part of a system using OpenZeppelin's components, maybe it's using proper checks. But without seeing the code, it's a potential vulnerability.

Another possible issue is front-running. For example, when a user makes an offer, someone else could front-run and accept the offer before the user's transaction is mined. But that's a general issue in blockchain and not a contract vulnerability per se.

Also, the getMinIncrement function. If it's supposed to enforce a minimum increment over the previous offer, but the calculation is incorrect, that could allow users to replace offers with lower increments. But again, without seeing the implementation, it's hard to say. But the code here checks that the new amount is at least _getMinIncrement(offer.amount). If that function is correct, then it's okay.

Another thing: the Offer struct uses uint96 for amount. If the amount exceeds uint96.max, which is around 7.9e28 for 18 decimal tokens, but for ETH, which is 1e18 wei per ETH, 7.9e28 wei is 79 ETH. Wait, no: uint96 can hold up to 2^96-1, which is approximately 7.9e28. So for ETH (18 decimals), that's 7.9e10 ETH, which is way more than the total supply. So that's not a problem. So no overflow risk here.

In the makeOffer function, when a new offer is made, the expiration is set to uint32(expiration). The expiration is obtained from feth.marketLockupFor or marketChangeLockup. If the returned expiration is larger than uint32.max, it would be truncated. As mentioned earlier, this could cause the expiration time to be incorrect. For example, if the current block timestamp is 2^32, then expiration would wrap around to 0. But since 2^32 is about 2106 years, this is a theoretical issue but not practical in the near term. However, if the system expects to run beyond 2106, this is a problem. So this is a potential vulnerability due to truncation of the expiration timestamp.

Another issue: the adminCancelOffers function does not check that the same offer isn't being canceled twice in the same transaction. For example, if the admin passes duplicate entries in the nftContracts and tokenIds arrays, the same offer could be canceled multiple times. However, since the offer is deleted in the first iteration, subsequent iterations would process a zeroed offer. This is harmless but could emit multiple events. Not a security issue but a potential inefficiency.

Additionally, in the makeOffer function, if the user sends more ETH than required, the excess is not refunded. For example, when creating a new offer, if the user sends msg.value higher than the required amount, the extra ETH would be locked in the feth contract. The function passes msg.value to feth.marketLockupFor, which may use all the sent ETH. If the user overpays, the excess ETH is not returned. This could result in users losing ETH if they send more than needed. That's a vulnerability because it can lead to accidental loss of funds. The contract should check that msg.value equals the amount being locked, and refund any excess. However, in the code, when making a new offer, the amount is the parameter, and msg.value is passed to feth. So if the feth's marketLockupFor function requires that msg.value equals the amount, then the code would be correct. But if not, then the user's msg.value must exactly match the amount. For example, in the code, when creating a new offer, the user calls makeOffer with amount X, and sends msg.value X. Then the feth.marketLockupFor is called with msg.value X. If the feth function requires that the value matches the amount, then it's okay. Otherwise, the code may lock an incorrect amount. So the vulnerability here depends on how the feth contract's functions are implemented. If the makeOffer function doesn't ensure that msg.value == amount, then users could underpay or overpay, leading to incorrect locking of funds. For example, if the user sends more ETH than the amount specified, the excess is locked but the offer's amount is set to the parameter, not the actual ETH sent. That's a critical issue because the offer's amount would not reflect the actual funds locked. The user could specify a lower amount but send more ETH, leading to the offer being recorded as lower than actual, but the feth would lock the higher ETH. But the code passes msg.value to the feth function. So the amount in the offer is the parameter, but the actual ETH sent is msg.value. If the feth.marketLockupFor function uses the msg.value as the amount to lock, then there's a mismatch between the offer's amount and the locked ETH. For example, if the user calls makeOffer with amount=1 ETH but sends 2 ETH, the offer's amount is 1 ETH, but 2 ETH is locked. Then, when the offer is accepted, the seller would receive 1 ETH, and the remaining 1 ETH would be stuck in the feth contract. That's a major vulnerability. Therefore, the makeOffer function should ensure that msg.value == amount. Otherwise, there's a discrepancy. However, in the code, the function does not check that msg.value == amount. This is a critical vulnerability.

So summarizing the vulnerabilities:

1. **Incorrect Handling of ETH in makeOffer**: The makeOffer function does not check that msg.value equals the amount parameter, leading to possible discrepancies between the locked ETH and the recorded offer amount. This could result in loss of user funds or incorrect offer amounts.

2. **Truncation of Expiration Timestamp**: The expiration timestamp is stored as a uint32, which can cause overflow issues beyond the year 2106, leading to incorrect expiration times.

3. **Admin Array Length Mismatch**: The adminCancelOffers function does not check that the lengths of nftContracts and tokenIds arrays are equal, leading to potential out-of-bounds errors if they are not.

4. **Insufficient Funds Check in makeOffer**: When creating or updating an offer, the code may lock ETH without properly validating that the sent value matches the intended amount, leading to incorrect fund handling.

5. **Front-Running in Offer Acceptance**: While not a code vulnerability per se, the lack of commit-reveal schemes could allow front-running, but this is more of a protocol design consideration.

6. **Potential Fund Locking in Expired Offers**: If the feth contract doesn't automatically unlock funds after expiration, adminCancelOffers might not handle expired offers properly, leaving funds locked.

7. **Inconsistent State in _acceptOffer**: If both the transferFrom and _transferFromEscrow fail after funds have been distributed, but due to the try/catch, the transaction may not revert, leading to loss of NFT. However, this depends on how the _transferFromEscrow is implemented and if the distribution of funds can be reverted.

The most critical issues are points 1 and 4, where ETH sent does not match the amount specified, leading to loss of funds. Then point 3 could lead to reverts or incorrect processing by admins. Point 2 is a long-term issue but low risk currently. Point 7 depends on the implementation details of _distributeFunds and _transferFromEscrow.","```
None.
```",0.0,0
NFTMarketPrivateSale.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896.0,205.0,"[M-01] EIP-712 signatures can be re-used in private sales
Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call the function `buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.
The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.
  [M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT
The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.
  [M-12] Private sale spoofing
function buyFromPrivateSaleFor()
Similar to spoofing in finance, users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.
No funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature. It's also frustrating for the users if they try to accept the private sale but their transaction fails.",3.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();


abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  
  
  
  bytes32 private immutable DOMAIN_SEPARATOR;

  
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  
  
  string private constant NAME = ""FNDNFTMarket"";

  
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      
      

      
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    
    
    address payable seller = payable(nftContract.ownerOf(tokenId));

    
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    
    nftContract.transferFrom(seller, msg.sender, tokenId);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  
  uint256[1000] private __gap;
}",888.0,0,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Deadline Validation**  
   The code checks if `deadline > block.timestamp + 2 days`, but the error message (`NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max`) suggests a 24-hour limit. This inconsistency allows deadlines up to 48 hours, violating the intended restriction.

2. **Proxy Incompatibility via Constructor Initialization**  
   The `DOMAIN_SEPARATOR` is initialized in the constructor using `marketProxyAddress`. When deployed behind a proxy, the constructor runs only once (on the implementation contract), causing the `DOMAIN_SEPARATOR` to reference the implementation/proxy address incorrectly. This breaks EIP-712 signature validation in proxy setups.

3. **Immutable `DOMAIN_SEPARATOR` in Upgradeable Contract**  
   The `DOMAIN_SEPARATOR` is marked as `immutable`, making it unchangeable after deployment. In upgradeable proxy patterns, this prevents updates to the domain (e.g., changing `marketProxyAddress`), leading to stale signatures if the proxy address changes.

4. **Constructor Usage in Upgradeable Contract**  
   The contract uses a constructor, which is incompatible with standard upgradeable patterns (e.g., Transparent/UUPS Proxies). Constructors in implementation contracts are not executed when the proxy is deployed, leading to uninitialized or improperly initialized variables in the proxy context.

5. **Signature Replay Risk Across Forks**  
   While `DOMAIN_SEPARATOR` includes `chainId`, a network fork with the same `chainId` and contract address could allow signature replays. This is a low-risk edge case but still a theoretical vulnerability.

6. **Lack of FETH Balance Check**  
   The `marketWithdrawFrom` call assumes the user has sufficient FETH balance. If the user lacks balance, the transaction reverts, but there is no explicit check before attempting withdrawal, leading to potential unnecessary gas costs.

**Summary of Critical Issues:**  
The most severe vulnerabilities stem from the incorrect handling of `DOMAIN_SEPARATOR` in proxy environments and the constructor usage, which breaks upgradeability and signature verification. The deadline validation discrepancy also undermines intended business logic.","### **Output**

---

#### **[M-01] EIP-712 signatures can be re-used in private sales**

**Report Description**:  
The `buyFromPrivateSaleFor` function in the `NFTMarketPrivateSale` contract allows buyers to purchase NFTs using EIP-712 signatures provided by sellers. However, the function does not check if the signature has been used before. This allows signatures to be re-used within a small time window if the seller regains ownership of the NFT, leading to potential misuse of signatures and unauthorized NFT transfers.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of EIP-712 signature reusability. This is a critical oversight, as it directly impacts the security of private sales. The lack of a mechanism to prevent signature reuse violates Solidity best practices for secure signature handling.

---

#### **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Report Description**:  
The `buyFromPrivateSaleFor` function attempts to withdraw the required ETH from the buyer's unlocked FETH balance. However, if the buyer has an open offer on the same NFT, the funds remain locked until the offer expires. This prevents the buyer from using these funds for the private sale, causing the transaction to fail.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of locked funds due to open offers. This is a significant oversight, as it directly impacts the usability of the private sale feature. The lack of a mechanism to handle locked funds violates Solidity best practices for handling user balances.

---

#### **[M-12] Private sale spoofing**

**Report Description**:  
The `buyFromPrivateSaleFor` function is vulnerable to spoofing attacks. A user can create a private sale with a valid signature and then frontrun the transaction by transferring the NFT to a different wallet they control. While no funds are lost (as the NFT <> FETH exchange is atomic), this can disrupt third-party off-chain NFT markets and frustrate users whose transactions fail.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of private sale spoofing. This is a critical oversight, as it directly impacts the integrity of the private sale process. The lack of a mechanism to prevent spoofing violates Solidity best practices for secure transaction handling.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-01] EIP-712 signatures can be re-used in private sales**  
- **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**  
- **[M-12] Private sale spoofing**

---

### **Conclusion**  
The `response_list` does not adequately address the issues identified in the `issue` report. Critical vulnerabilities related to EIP-712 signature reuse, locked funds due to open offers, and private sale spoofing are entirely missed. These gaps highlight significant security and usability concerns that must be addressed to ensure the robustness of the smart contract.",0,0,3,6,"Okay, let's take a look at this smart contract and see what vulnerabilities might be present. I'm not an expert, but I'll try to go through it step by step.

First, the contract is called NFTMarketPrivateSale and it's using OpenZeppelin's upgradeable contracts. Wait, but they have a constructor here. Oh right, in upgradeable contracts, you should use initialize functions instead of constructors. But the constructor here is initializing DOMAIN_SEPARATOR. Hmm, maybe that's an issue because in proxy patterns, constructors aren't called when the contract is deployed as an implementation. So the DOMAIN_SEPARATOR might not be set correctly if this contract is used with a proxy. That could break the EIP-712 signature verification. That's a possible vulnerability.

Next, looking at the buyFromPrivateSaleFor function. There's a check for deadline being less than block.timestamp, which is correct. But then there's a check that deadline should not be more than block.timestamp + 2 days. Wait, the error says ""Can be offered for 24hrs max"", but the code checks if deadline > block.timestamp + 2 days. That's a discrepancy. So if someone sets the deadline to, say, 25 hours from now, the code allows it because 2 days is 48 hours. So the error message is wrong here, which could lead to longer deadlines than intended. That's a logical error and a vulnerability.

Another thing: when handling the amount and msg.value, the code checks if amount > msg.value. If so, it withdraws the delta from FETH. But if amount is less than msg.value, it reverts. Wait, the user is supposed to send exactly the amount. But what if msg.value is more than amount? The code reverts. But what if the user sends more ETH than required, the transaction will fail. That's correct, but maybe the error message is right. However, maybe there's a scenario where this could be a problem, but not sure.

Looking at the signature verification. They are using ecrecover to verify the seller's signature. The digest is created using DOMAIN_SEPARATOR, which was initialized in the constructor. But if this contract is used with a proxy, the DOMAIN_SEPARATOR would be set to the marketProxyAddress during constructor, but proxies use the implementation's constructor only once. So if the marketProxyAddress is the proxy address, then the DOMAIN_SEPARATOR would be based on that. Wait, the constructor takes marketProxyAddress as an argument. If this contract is the implementation, then the DOMAIN_SEPARATOR would be set with the proxy's address. But when the proxy is created, the implementation's constructor is called once. So maybe that's okay. However, if the proxy is upgraded and the verifyingContract (marketProxyAddress) changes, the DOMAIN_SEPARATOR would not update, leading to signature issues. Because DOMAIN_SEPARATOR is immutable, so it's set once in the constructor. If the proxy address changes, then signatures would break. That's a potential vulnerability if the proxy address can change but the DOMAIN_SEPARATOR doesn't, leading to invalid signature checks.

Another thing: when transferring the NFT, the code does nftContract.transferFrom(seller, msg.sender, tokenId). But this is done after checking the signature. However, the seller is the current owner, but between the time the signature was created and now, the seller might have transferred the NFT. So the code checks if the seller is the owner at the time of the function call. But in the signature, they include the seller's address (as the owner at signing time). Wait, the signature is generated by the seller, but the code here uses nftContract.ownerOf(tokenId) to get the seller address. So if the seller signs the message and then transfers the NFT to someone else, the current owner would be different, and the signature would still be considered valid because the code checks the current owner. Wait, no. Let me check: the digest includes the parameters nftContract, tokenId, buyer (msg.sender), amount, deadline. The seller is the one who signs this digest. But in the code, they get the seller as nftContract.ownerOf(tokenId). So when the user calls buyFromPrivateSaleFor, the current owner is the seller. If the seller had transferred the token after signing, then the current owner would not be the seller anymore, and the code would take the new owner as the seller. Wait, no. Wait, the code is doing:

seller = nftContract.ownerOf(tokenId) at the time of the function call. Then, the signature is verified to check if ecrecover(digest, v, r, s) == seller. So the signature must have been signed by the current owner (seller) at the time of the transaction. So if the original owner signs the message and then transfers the token, the new owner would be the seller, and the signature would need to be signed by the new owner, which they don't have. So that's okay. Wait, no. Let's say Alice owns the token, signs the message, and then transfers to Bob. Now, when someone tries to call buyFromPrivateSaleFor, the seller would be Bob (current owner), but the signature was signed by Alice. So the ecrecover would check if Alice == Bob, which would fail. So in that case, the signature check would fail, and the transaction would revert. That seems okay. So maybe that's not a vulnerability.

But wait, in the digest, the parameters include the buyer's address (msg.sender). So the signature is specific to a buyer. So if the buyer is msg.sender, then the signature can only be used by that specific buyer. However, the code here uses msg.sender as the buyer in the digest. So the signature is tied to the buyer's address. Therefore, if the seller signs for a specific buyer, only that buyer can execute the transaction. That's correct.

What about reentrancy? The function has the nonReentrant modifier, so that's protected. But when transferring the NFT via transferFrom, that's a safe function. So reentrancy here is probably not an issue.

Another possible issue: the use of chainid() in assembly. The contract uses chainid() in the DOMAIN_SEPARATOR. If the contract is deployed on a chain that might undergo a hardfork or chain ID change, this could break signatures. But that's a rare scenario. However, since DOMAIN_SEPARATOR is immutable, if the chain ID changes, the signatures would be invalid. But that's outside the contract's control.

Another thing: the BUY_FROM_PRIVATE_SALE_TYPEHASH is defined as keccak256(""BuyFromPrivateSale(...)""), but the parameters in the typehash must be exactly as specified in EIP-712. Let me check the parameters. The typehash is ""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"". The code uses abi.encode(...) for the struct. That should be correct if the parameters are in the right order.

Wait, the digest is created by abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline). So the parameters in the struct are in the order: nftContract (address), tokenId (uint256), buyer (address), price (uint256), deadline (uint256). That matches the typehash, so the encoding should be correct. So that's probably okay.

But what about the NAME constant? It's set to ""FNDNFTMarket"". If the name is part of the domain separator, changing the name would change the domain separator. But since it's a constant, that's fixed.

Another possible vulnerability: the code allows the seller to set any deadline up to 48 hours in the future (since the check is deadline > block.timestamp + 2 days). But the error message says 24 hours max. So if the deadline is set to 30 hours, it would pass the check (30h < 48h), but the error says 24h max. So the code's check is wrong. That's a vulnerability because it allows longer deadlines than intended by the error message. However, the error message is just a message, but the code logic is allowing up to 2 days, which may not be intended. The comment says ""24Hrs_Max"" but the code checks for 2 days. So that's a discrepancy, a logical error.

Another thing: when the function withdraws from FETH using feth.marketWithdrawFrom(msg.sender, delta), but what if the FETH contract doesn't have the necessary approval or the user doesn't have enough balance? The function would revert, which is handled. But perhaps there's a reentrancy issue here? But since there's a nonReentrant modifier, that's probably mitigated.

Also, the function transfers the NFT before distributing funds. The standard practice is to follow checks-effects-interactions, but here, the transfer happens before the funds are distributed. However, since the transfer is done via transferFrom, which is a known function, and the nonReentrant modifier is present, this might not be a problem. But if the NFT contract has a callback that could reenter, the state hasn't been updated yet. Wait, the NFT transfer is before the funds distribution. So after transferring the NFT, the contract distributes the funds. If the NFT's transferFrom function calls back into this contract, the nonReentrant modifier would prevent reentrancy. But since the modifier is on the function, any reentrant call would be blocked. So maybe this is safe.

Another possible issue: if the NFT contract's transferFrom function requires the seller to have approved this market contract. But in the current code, the seller is the owner, and the code calls transferFrom(seller, buyer, tokenId). So the seller must have approved this contract as an operator. Otherwise, the transferFrom would fail. However, since the seller is the current owner and they are executing the sale, maybe they have set approval. But if not, the transfer would fail. But the code doesn't check if the seller has approved the contract. So if the seller hasn't approved the contract, the transferFrom would revert. However, in this private sale scenario, the seller is expected to have approved the contract, but it's possible they haven't, leading to a failed transaction. But that's a user error, not a contract vulnerability.

Another thing: the event PrivateSaleFinalized includes the deadline, but that's already known. Not sure if that's an issue.

Also, the DOMAIN_SEPARATOR uses the marketProxyAddress passed into the constructor. But if the contract is intended to be used with a different proxy address later (e.g., after an upgrade), the DOMAIN_SEPARATOR would still be based on the original marketProxyAddress. This could lead to signature verification failures if the verifyingContract (marketProxyAddress) changes but the DOMAIN_SEPARATOR doesn't. Since DOMAIN_SEPARATOR is immutable, it's set once in the constructor. So if the proxy is upgraded and the verifyingContract address changes, the existing DOMAIN_SEPARATOR would no longer match, making all existing signatures invalid. That could be a problem if the marketProxyAddress is not supposed to be static. But maybe in this setup, the marketProxyAddress is the proxy's address and remains the same across upgrades. If that's the case, then it's okay. But if the proxy address changes, then it's a problem. However, proxies typically have a fixed address, so this might not be an issue.

Wait, in the constructor, marketProxyAddress is passed, and DOMAIN_SEPARATOR is created with that address as the verifyingContract. So if the contract is deployed as an implementation behind a proxy, the constructor would run once, and the DOMAIN_SEPARATOR would be based on the marketProxyAddress provided at that time. But proxies usually have their own address, so if marketProxyAddress is the proxy's address, then even if the implementation is upgraded, the DOMAIN_SEPARATOR remains correct. But if the constructor is part of the implementation and the proxy uses delegatecall, the constructor wouldn't run again. Wait, in the upgradeable contract pattern, constructors are replaced by initialize functions. But in this code, the contract has a constructor, which is not upgradeable-friendly. Because when the implementation contract is deployed, its constructor runs, setting DOMAIN_SEPARATOR with some marketProxyAddress. Then, when the proxy is created, the proxy's storage would not have DOMAIN_SEPARATOR set because the implementation's constructor is not called again. Wait, no. The proxy uses delegatecall to the implementation's functions. The implementation's constructor only runs when the implementation is deployed, not when the proxy is created. Therefore, the DOMAIN_SEPARATOR in the implementation's storage would have the marketProxyAddress set when the implementation was deployed. But the proxy's storage is separate. However, in this code, DOMAIN_SEPARATOR is declared as immutable. Immutable variables are stored in the code of the contract, not in storage. So when the implementation is deployed, the DOMAIN_SEPARATOR is set in the implementation's bytecode. Then, when the proxy uses the implementation, the immutable variable in the implementation's code is based on the marketProxyAddress passed during the implementation's deployment. But if the proxy's address is different, then the DOMAIN_SEPARATOR's verifyingContract would be the marketProxyAddress from the implementation's deployment, not the proxy's address. This is a problem because the EIP-712 domain separator should include the actual contract address that's verifying the signatures, which in the case of a proxy, should be the proxy's address, not the implementation's. Therefore, the DOMAIN_SEPARATOR is incorrectly computed because in the proxy context, the verifyingContract (marketProxyAddress) is the implementation's marketProxyAddress, not the proxy's address. This would cause all signatures to fail when the contract is used via a proxy, because the DOMAIN_SEPARATOR is based on the wrong address.

This is a critical vulnerability. For example, if the contract is deployed as an implementation behind a proxy, the DOMAIN_SEPARATOR would be computed using the marketProxyAddress provided to the implementation's constructor, which may not be the proxy's address. Therefore, the verifyingContract in the domain separator would be incorrect, leading to signature verification failures. The correct approach in upgradeable contracts is to use the proxy's address in the domain separator. But since the DOMAIN_SEPARATOR is immutable and set in the constructor of the implementation, which is only called once during deployment, when using a proxy, the proxy's address would not be used, leading to a mismatch. Therefore, the signature verification would fail because the domain's verifyingContract would not match the actual contract's address (the proxy).

This is a major issue because it would render all signatures invalid when the contract is used via a proxy. The fix would be to compute the DOMAIN_SEPARATOR in the initialize function using the current contract's address (i.e., address(this)), but since this contract is using a constructor, it's not compatible with the proxy pattern. Therefore, the use of a constructor here introduces a critical vulnerability when deployed behind a proxy.

Another issue: the code uses a gap variable __gap_was_DOMAIN_SEPARATOR, which suggests that this contract is upgradeable and was previously using a storage variable for DOMAIN_SEPARATOR but now it's immutable. However, since DOMAIN_SEPARATOR is now immutable, it's stored in the code, not in storage. But if this contract is part of an upgradeable contract, changing from a storage variable to an immutable variable would cause a storage layout conflict. For example, the previous version may have had DOMAIN_SEPARATOR in a storage slot that is now replaced by __gap_was_DOMAIN_SEPARATOR. However, since __gap_was_DOMAIN_SEPARATOR is a private variable and part of a gap, this might be intentional. But the main problem here is the use of an immutable variable in an upgradeable contract, which is not recommended because immutable variables are set at the implementation's deployment time and cannot be changed, leading to the incorrect DOMAIN_SEPARATOR when used with a proxy.

So summarizing the vulnerabilities:

1. **Incorrect Deadline Check**: The code checks if the deadline is more than 2 days in the future, but the error message states a 24-hour maximum. This allows deadlines up to 48 hours, conflicting with the intended 24-hour limit.

2. **Incorrect DOMAIN_SEPARATOR Construction in Proxy Context**: The DOMAIN_SEPARATOR is set in the constructor using a provided marketProxyAddress. When deployed behind a proxy, the constructor runs only once on the implementation contract, leading to DOMAIN_SEPARATOR being based on the wrong address (implementation instead of proxy). This breaks EIP-712 signature verification.

3. **Use of Constructor in Upgradeable Contract**: The contract uses a constructor, which is not compatible with upgradeable proxy patterns. Constructors in implementation contracts are only executed once, leading to incorrect initialization of immutable variables like DOMAIN_SEPARATOR when used with a proxy.

4. **Potential Signature Replay Across Chains**: The DOMAIN_SEPARATOR includes chainId, but if the contract is deployed on multiple chains with the same marketProxyAddress, signatures from one chain could be replayed on another. However, chainId is part of the domain separator, which mitigates this. So this might not be a vulnerability.

5. **Insufficient FETH Balance Check**: When withdrawing from FETH, the code doesn't check if the user has enough balance. If the user doesn't have sufficient FETH balance, the marketWithdrawFrom call will fail, reverting the transaction. This is handled, but perhaps it's a user experience issue, not a vulnerability.

6. **Incorrect Handling of msg.value**: The code requires that msg.value is exactly equal to amount. If the user sends more ETH, it reverts. But in the case where amount is less than msg.value, the excess is not refunded. Wait, no: the code says if amount < msg.value, revert. So the user must send exactly amount. But if they send more, the transaction reverts. That's correct. So no vulnerability here.

7. **Front-Running**: A seller could list an NFT for a private sale, but before the buyer executes the transaction, the seller transfers the NFT to another address. However, the code checks the current owner at transaction time, so the signature would no longer validate. So front-running is not possible here.

So the main vulnerabilities are the deadline check discrepancy, the DOMAIN_SEPARATOR not being correctly set when used with a proxy, and the use of a constructor in an upgradeable contract leading to incorrect initialization.","```
None.
```",0.0,0
SendValueWithFallbackWithdraw.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802.0,94.0,"[M-02] `withdrawFor` function may fail to withdraw ether recorded in pendingWithdrawals
The `NFTMarketFees` contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.",1.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();


abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  
  mapping(address => uint256) private pendingWithdrawals;

  
  event WithdrawPending(address indexed user, uint256 amount);
  
  event Withdrawal(address indexed user, uint256 amount);

  
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    
    
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      
      
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  
  uint256[499] private __gap;
}",353.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Failed Transfer Leading to Permanent Loss of Funds**  
   In `withdrawFor`, the contract uses `sendValue` (which returns `false` on failure instead of reverting) after resetting `pendingWithdrawals[user]` to zero. If the transfer fails (e.g., recipient is a contract that reverts, insufficient gas), the user’s funds are permanently lost, as their pending balance is already cleared.

2. **Unchecked Arithmetic in `pendingWithdrawals` Update**  
   The `pendingWithdrawals[user] += amount` operation in `_sendValueWithFallbackWithdraw` is performed in an `unchecked` block. While theoretically unlikely, this could allow an overflow if the accumulated value exceeds `type(uint256).max`, leading to incorrect accounting of pending withdrawals.

3. **Potential Reentrancy During `_sendValueWithFallbackWithdraw` Execution**  
   The `_sendValueWithFallbackWithdraw` function includes an external call (`user.call{...}`) that could execute arbitrary code. If this function is called by another function lacking reentrancy protection (e.g., `nonReentrant` modifier), it may enable reentrancy attacks. While `withdrawFor` uses `nonReentrant`, derived contracts calling `_sendValueWithFallbackWithdraw` without proper safeguards are at risk.

4. **Gas Limit Handling in Fallback Transfers**  
   The `gasLimit` parameter in `_sendValueWithFallbackWithdraw` could lead to failed transfers if set too low, forcing legitimate users to rely on the withdrawal mechanism unnecessarily. This is not a direct vulnerability but may result in poor usability or unintended fallback triggers.

These vulnerabilities expose risks of fund loss, arithmetic manipulation, and reentrancy depending on contract usage and implementation specifics.","### **Output**

---

**[M-02] `withdrawFor` function may fail to withdraw ether recorded in `pendingWithdrawals`**

**Report Description**:  
The `NFTMarketFees` and `NFTMarketReserveAuction` contracts use the `_sendValueWithFallbackWithdraw` function to send ether to various recipients (e.g., FoundationTreasury, CreatorRecipients, Seller, Bidder). If the receiver fails to receive ether due to reasons such as exceeding the gas limit or the receiver contract being unable to accept ether, the ether is recorded in the `pendingWithdrawals` variable. However, the `withdrawFor` function may fail to withdraw this recorded ether, leading to potential loss of funds or incorrect accounting.

**Match in Response List**:  
Matches with the issue titled **""Failed Transfer Leading to Permanent Loss of Funds""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `withdrawFor` function, where the use of `sendValue` (which returns `false` on failure instead of reverting) can lead to permanent loss of funds if the transfer fails. This aligns with the report's concern about the failure to withdraw ether recorded in `pendingWithdrawals`. The response correctly highlights the risk of clearing the pending balance before ensuring the transfer is successful, which is a critical security oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] `withdrawFor` function may fail to withdraw ether recorded in `pendingWithdrawals`**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---

### **Additional Notes**

The response list also identifies other vulnerabilities (e.g., unchecked arithmetic, potential reentrancy, gas limit handling) that are not explicitly mentioned in the provided issue. While these are valid concerns, they are not directly related to the specific issue described in the report. Therefore, they are not included in the match analysis for this task.",1,0,0,4,"Okay, let's look at this smart contract and try to find any vulnerabilities. The contract is called SendValueWithFallbackWithdraw and uses some OpenZeppelin upgradeable contracts. Hmm.

First, the contract uses ReentrancyGuardUpgradeable, which is good for preventing reentrancy attacks. The main functions here are withdraw, withdrawFor, and _sendValueWithFallbackWithdraw.

Looking at the withdrawFor function: it checks the user's pending withdrawal, sets it to zero, then sends the amount using sendValue. Since sendValue is used, which is from AddressUpgradeable, maybe it's using the safe transfer method. But sendValue returns a boolean indicating success. Wait, in the code here, after pendingWithdrawals[user] is set to zero, user.sendValue(amount) is called. What if the send fails? Then the user's funds are set to zero but the transfer didn't go through. Wait, but in Solidity, if a transfer fails, it reverts. Wait, no: sendValue is a low-level function that returns false on failure instead of reverting. Oh right! So if user.sendValue(amount) fails, then pendingWithdrawals[user] is already set to zero, so the user loses their funds. That's a problem. So if the sendValue fails, the contract's state is updated (pendingWithdrawals set to 0), but the funds weren't actually transferred. This is a critical vulnerability. So the user's balance is reset to zero, but the Ether wasn't sent. That's definitely a vulnerability. The contract doesn't handle the case where sendValue returns false.

Another thing: the _sendValueWithFallbackWithdraw function calls user.call with a gas limit. If that call fails, it adds the amount to pendingWithdrawals. But there's a possible reentrancy here. Wait, the function is called with some gasLimit. If the call fails, it adds to pendingWithdrawals. But since the withdrawFor function uses nonReentrant, maybe reentrancy is prevented. But let's check: during the initial call (like a transfer), if the user is a contract with a fallback that calls withdrawFor again, but since withdrawFor has nonReentrant, that would prevent reentrancy. But maybe during the _sendValueWithFallbackWithdraw call, if the user's code is executed (as part of the .call), can they reenter into another function? But the _sendValueWithFallbackWithdraw is called in the context of another function, perhaps. Wait, the _sendValueWithFallbackWithdraw is an internal function. So if another function calls this, like maybe a function that sends funds, during that call, when the user's code is executed (in the .call), they could reenter into the contract. But since the ReentrancyGuard is inherited, and assuming that the functions that call _sendValueWithFallbackWithdraw are using the nonReentrant modifier, maybe that's not an issue. But if the parent functions don't have the modifier, then there could be a reentrancy. Wait, the _sendValueWithFallbackWithdraw is internal, so it's up to the functions that call it to use the nonReentrant. The withdrawFor function has nonReentrant, but other functions that might call _sendValueWithFallbackWithdraw may not. For example, if there's a function that calls _sendValueWithFallbackWithdraw without nonReentrant, then during the external call (user.call), a malicious contract could reenter into that function. So this depends on how the parent contracts or other functions use _sendValueWithFallbackWithdraw. But the problem is that in the given code, the only functions using nonReentrant are withdraw and withdrawFor. The _sendValueWithFallbackWithdraw function is used in the case where sending Ether fails, but when it's called, it's possible that during the user.call, reentrancy could occur if the calling function isn't protected. So if another function in the contract calls _sendValueWithFallbackWithdraw without the nonReentrant modifier, then that could be a reentrancy vector. But since this is an abstract contract, maybe the functions that call _sendValueWithFallbackWithdraw are supposed to handle that. However, in the current code, the _sendValueWithFallbackWithdraw function is internal, so any function calling it would need to have the reentrancy guard. So possible reentrancy if that's not handled.

Another thing: the pendingWithdrawals mapping is updated in an unchecked block in _sendValueWithFallbackWithdraw. The line 'unchecked { pendingWithdrawals[user] += amount; }' – since it's in an unchecked block, but since amount is added, is there a possibility of overflow? Well, since the Ether is being sent, the amount would be the value being sent. If the contract's balance is sufficient, then adding to pendingWithdrawals could overflow if a user has a very large accumulated amount. But in practice, since Ether amounts are in wei, but Solidity's uint256 can hold up to 1e57 wei, which is way more than the total supply of Ether. So maybe overflow is not a real issue here. But technically, it's possible if pendingWithdrawals[user] + amount exceeds 2^256-1, which is very unlikely. However, using unchecked here skips the overflow check, so that's a potential vulnerability if there's a way to make that happen. So this is a possible integer overflow vulnerability, but the likelihood is extremely low. Still, from a strict security standpoint, it's a vulnerability.

Another thing: in withdrawFor, after setting pendingWithdrawals[user] to zero, the code uses user.sendValue(amount). If that fails, the user's pending balance is already zeroed out, so the funds are lost. Because sendValue returns false on failure but doesn't revert. So if the send fails (e.g., the user is a contract without a payable fallback, or it runs out of gas), the contract's state has already been updated, and the user's pending balance is zero. Therefore, their Ether is stuck in the contract forever. This is a major vulnerability because the user can't retry the withdrawal; their balance is zeroed out even if the transfer failed.

So the main vulnerabilities here are:

1. **Insufficient handling of failed transfers in withdrawFor:** Using sendValue which doesn't revert on failure, but the contract's state is updated before the transfer. If the transfer fails, the user's pending balance is lost.

2. **Unchecked arithmetic in _sendValueWithFallbackWithdraw:** The pendingWithdrawals is updated in an unchecked block, which could theoretically lead to overflows, although highly unlikely in practice.

3. **Potential Reentrancy in _sendValueWithFallbackWithdraw:** If a function calls _sendValueWithFallbackWithdraw without proper reentrancy protection, the external call could allow reentrancy attacks. However, since withdrawFor uses nonReentrant and the _sendValue... function is called when a transfer fails, maybe the context in which it's called is protected. But if other functions call _sendValue... without nonReentrant, that could be a problem. Since this is an abstract contract, the actual implementation's usage determines this risk.

Wait, but the function _sendValueWithFallbackWithdraw is internal, so any function in the contract or derived contracts can call it. If a derived contract has a function that calls _sendValue... without the nonReentrant modifier, then during the user.call, a reentrancy could happen. So the vulnerability here is that the internal function doesn't enforce reentrancy guards, relying on the caller functions to do so. If a caller function doesn't use the modifier, then it's vulnerable.

But in the current code, the only functions that we can see are withdraw and withdrawFor. The _sendValue... is used when a transfer fails. Wait, no: the _sendValue... is called when trying to send value, and if it fails, the amount is added to pendingWithdrawals. So the _sendValue... is likely used in functions that send Ether to users. For example, maybe a function that's supposed to pay a user, and if the transfer fails, it adds to their pending withdrawals. But when that initial transfer is made (the user.call), if the user is a malicious contract that reenters the contract, and if the calling function isn't protected by nonReentrant, then that's a reentrancy issue.

For example, suppose there's a function like payout() that calls _sendValueWithFallbackWithdraw. If payout() doesn't have nonReentrant, then when user.call is executed, the malicious contract could call back into payout(), leading to reentrancy. However, in the given contract, we don't have such a function; it's abstract. So this depends on how the derived contracts implement their functions. But since the current contract doesn't enforce that functions calling _sendValue... have nonReentrant, that's a potential vulnerability in the design, leading to possible reentrancy in derived contracts if not properly handled.

Another thing: the gasLimit parameter in _sendValueWithFallbackWithdraw is provided as an argument. If the gasLimit is too low, the transfer could fail even for legitimate contracts, causing the funds to be added to pendingWithdrawals unnecessarily. However, this is more of a gas griefing issue, but not a direct vulnerability in the contract itself. It depends on how the gasLimit is set by the calling function.

So summarizing the vulnerabilities:

1. **Failed Transfer in Withdraw Leading to Loss of Funds:** When withdrawFor is called, the pending balance is set to zero before attempting to send the Ether. If the send fails (e.g., recipient is a contract that reverts, or uses more than the gas provided), the user's funds are lost because the pending balance is already cleared. This is a critical issue.

2. **Unchecked Arithmetic in Pending Withdrawals:** The pendingWithdrawals[user] is incremented in an unchecked block, which could theoretically overflow. Although the chance is minimal, it's a vulnerability.

3. **Potential Reentrancy in _sendValueWithFallbackWithdraw:** If the function calling _sendValue... does not use a nonReentrant modifier, the external call could allow reentrancy attacks. However, since the current contract's functions that call _sendValue... (like in derived contracts) might not be protected, this is a possible issue.

Are there any other issues?

Looking at the error definition: SendValueWithFallbackWithdraw_No_Funds_Available(). If a user has zero balance, trying to withdraw reverts with this error. That's correct.

The events are emitted correctly: WithdrawPending when adding to pending, and Withdrawal when sending.

Another possible issue: the pendingWithdrawals is stored as a mapping, and when a user's pending balance is added to, it uses += in an unchecked block. If the same user has multiple failed transfers, their pending balance accumulates. That's intended, but the unchecked block is a minor issue as mentioned.

Wait, the line 'pendingWithdrawals[user] += amount;' is inside an unchecked block. So it's possible that if pendingWithdrawals[user] is close to max uint256, adding amount could overflow. But in practice, this is not feasible, but still a theoretical vulnerability.

Another thing: the contract is upgradeable (since it's using upgradeable contracts from OpenZeppelin). However, there's no constructor, but since it's an abstract contract, maybe that's intended. But upgradeable contracts need to avoid using constructors and use initializer functions. Since this is abstract, maybe the derived contracts handle that. Not a direct vulnerability here.

So the main issues are the failed transfer handling in withdrawFor leading to lost funds, the unchecked arithmetic, and potential reentrancy if functions calling _sendValue... aren't properly guarded.","```
1. Failed Transfer Leading to Permanent Loss of Funds
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Failed Transfer Leading to Permanent Loss of Funds"".
   - This true positive appears at **rank 1** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the **Average Precision (AP)** is simply the precision at rank 1.

**Output**:
```
1.0
```",1
FETH.sol,"/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670.0,779.0,"[M-03] Approve race condition in FETH
Front running attack in `approve()` function.
  [M-09] Missing receiver validation in withdrawFrom
The `FETH.withdrawFrom` function does not validate its to parameter. Funds can be lost if `to` is the zero address.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();

error FETH_Insufficient_Allowance(uint256 amount);

error FETH_Insufficient_Available_Funds(uint256 amount);

error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();


contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  
  struct AccountInfo {
    
    uint96 freedBalance;
    
    uint32 lockupStartIndex;
    
    LockedBalance.Lockups lockups;
    
    mapping(address => uint256) allowance;
  }

  
  mapping(address => AccountInfo) private accountToInfo;

  
  
  uint256 private immutable lockupDuration;
  
  uint256 private immutable lockupInterval;

  
  address payable private immutable foundationMarket;

  
  
  uint8 public constant decimals = 18;
  
  string public constant name = ""Foundation Wrapped Ether"";
  
  string public constant symbol = ""FETH"";

  
  
  event Approval(address indexed from, address indexed spender, uint256 amount);
  
  event Transfer(address indexed from, address indexed to, uint256 amount);

  
  
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  
  receive() external payable {
    depositFor(msg.sender);
  }

  
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  
  function deposit() external payable {
    depositFor(msg.sender);
  }

  
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      
      if (escrow.expiration == 0) {
        break;
      }

      
      unchecked {
        
        ++escrowIndex;
      }

      
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  
  
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    
    unchecked {
      
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    
    
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      
      revert FETH_Too_Much_ETH_Provided();
    }

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  
  
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      
      while (true) {
        
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    
    uint256 lockedCount;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          
          ++lockedCount;
        }
      }
    }

    
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    
    uint256 i;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function totalSupply() external view returns (uint256 supply) {
    
    return address(this).balance;
  }
}",3357.0,0,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unchecked Return Value for ETH Transfers**:
   - **Description**: The contract uses `sendValue` for ETH transfers in functions like `marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawFrom`, and `withdrawAvailableBalance` but does not check the return value. If the transfer fails (e.g., recipient is a contract without a payable fallback), the user's balance is reduced, but the ETH remains in the contract, leading to loss of funds.
   - **Impact**: Users may permanently lose access to their funds if transfers to certain addresses fail.

2. **Unbounded Loops Leading to Gas Exhaustion**:
   - **Description**: The loop in `_marketLockupFor` iterates to find an existing escrow slot or an empty one. If an account has many escrows with different expirations, this loop could consume excessive gas, causing transactions to revert due to out-of-gas errors.
   - **Impact**: Denial of Service (DoS) where legitimate users cannot lockup funds due to high gas costs.

3. **Potential DoS via Expired Lockups in `_freeFromEscrow`**:
   - **Description**: If an account accumulates many expired lockups, the `_freeFromEscrow` loop (triggered during transfers/withdrawals) could consume excessive gas. While creating expired lockups isn't directly possible via public functions, compromised `foundationMarket` could facilitate this.
   - **Impact**: Increased gas costs for users interacting with accounts having many expired lockups, potentially causing transaction failures.

4. **Incorrect Handling of Allowances**:
   - **Description**: The `approve` function is susceptible to front-running when reducing allowances, a known ERC20 behavior. However, this is not a vulnerability per se but a standard consideration.

**Note**: Other potential issues like integer overflows were analyzed but deemed non-critical due to Ethereum's practical constraints (e.g., ETH supply limits).","### **Output**

---

**[M-03] Approve race condition in FETH**

**Report Description**:
The `approve()` function in the FETH contract is susceptible to a front-running attack. This occurs when an attacker observes a pending transaction to reduce an allowance and quickly submits a transaction to spend the original allowance before the reduction takes effect. This can lead to unintended token transfers and potential loss of funds.

**Match in Response List**:
Matches with the issue titled **""Incorrect Handling of Allowances""**.

**Validation**:
**Partially Correct**. The response acknowledges the issue with the `approve` function and mentions the front-running behavior, which aligns with the reported issue. However, it downplays the severity by stating it is ""not a vulnerability per se but a standard consideration."" This misses the critical risk of unintended token transfers and potential loss of funds, which is a significant security concern.

---

**[M-09] Missing receiver validation in withdrawFrom**

**Report Description**:
The `withdrawFrom` function in the FETH contract does not validate the `to` parameter, which represents the recipient address. If `to` is the zero address, funds can be permanently lost, as transfers to the zero address are irreversible. This oversight could lead to accidental or malicious loss of funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing receiver validation in the `withdrawFrom` function. This is a critical oversight, as failing to validate the recipient address can result in irreversible loss of funds, which is a significant security vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-03] Approve race condition in FETH**

**Missed Issues from Issue Report**:
- **[M-09] Missing receiver validation in withdrawFrom**

---

### **Analysis and Recommendations**

- **Coverage**: The response list partially covers one of the two issues in the issue report. The issue related to the `approve` function is acknowledged but not fully addressed, while the issue related to the `withdrawFrom` function is entirely missed.
- **Accuracy**: The response list is partially accurate in identifying the `approve` race condition but fails to recognize its severity. The missing receiver validation issue is not addressed at all, indicating a gap in the analysis.
- **Sufficiency**: The response list is insufficient as it does not provide solutions or mitigations for the identified issues, particularly the critical vulnerability in the `withdrawFrom` function.

**Recommendations**:
1. **Address the `approve` Race Condition**: Implement a mitigation strategy, such as using the `increaseAllowance` and `decreaseAllowance` pattern, to prevent front-running attacks.
2. **Validate the `to` Parameter in `withdrawFrom`**: Add a check to ensure the `to` address is not the zero address before processing the withdrawal.
3. **Expand the Response List**: Include all identified vulnerabilities and provide detailed solutions or mitigations to ensure comprehensive coverage of security issues.",0,1,1,4,"Okay, let's take a look at this smart contract and see if I can find any vulnerabilities. The contract is called FETH, which stands for Foundation Wrapped Ether. It seems to handle locking up balances and allowing transfers with some escrow functionality. 

First, I'll start by reading through the code and trying to understand the main functions. The contract uses OpenZeppelin libraries, which are generally secure, but maybe there are issues in how they're implemented here. Let's go step by step.

Looking at the constructor, it initializes the foundationMarket address and checks if it's a contract. That's good. The lockupDuration is set, and there's a check to ensure it's a multiple of 24 intervals. If not, it reverts. That makes sense for time intervals.

Now, the receive function calls depositFor(msg.sender), which adds the received ETH to the sender's freedBalance. The depositFor function checks that the amount is non-zero and increments the freedBalance. The event Transfer is emitted, which is standard for ERC20-like tokens. But since this is a wrapped ETH, maybe there's an issue with the accounting here.

Looking at the transferFrom function, it checks if the to address is zero or the contract itself, which would revert. That's to prevent burning or sending to the contract. Then it calls _freeFromEscrow on the from account. This function seems to handle moving expired lockups into the freedBalance. Then it deducts the allowance and balance. Wait, but if the from account has some locked balances that have expired, they are moved to freedBalance before the transfer. That seems okay.

But maybe there's a reentrancy issue. Let's check functions that use sendValue. In Solidity, using sendValue (which is from AddressUpgradeable) is generally safe because it uses .call{value: amount}("""") and limits the gas, but if any of the external calls are made before state changes, that could be a problem. For example, in marketWithdrawFrom and withdrawFrom, they sendValue after deducting the balance. Since sendValue is the last operation, it's following checks-effects-interactions, so that's probably safe.

Another area to check is the loop in _freeFromEscrow. It iterates through escrow entries and moves expired ones to freedBalance. If there are a lot of expired entries, this loop could consume too much gas, leading to a denial of service. However, since the loop stops when it encounters an unexpired escrow, the number of iterations might be limited. But if someone has many expired escrows, this function could become expensive. But this is a potential gas exhaustion issue.

Looking at _marketLockupFor, which locks up funds. The expiration is calculated as lockupDuration + (block.timestamp.ceilDiv(lockupInterval) * lockupInterval). CeilDiv might round up, leading to a longer lockup than expected. Also, the code checks if msg.value is less than the amount, which is the ETH sent. If msg.value < amount, it uses the freedBalance to cover the difference. But if msg.value is more than amount, it reverts. So, the user needs to send exactly the amount when locking up, unless using existing freedBalance. That's correct.

Wait, in _marketLockupFor, if msg.value is less than amount, it subtracts the difference from freedBalance. But what if the user doesn't have enough freedBalance? The code checks accountInfo.freedBalance < delta and reverts. That's correct. However, if the msg.value is zero and the user is using all freedBalance, that's allowed. So no issue there.

Another thing is the loop in _marketLockupFor when adding to lockups. It starts from lockupStartIndex and increments until it finds an escrow with expiration equal to the new one. If not found, it creates a new entry. But if there are many entries, this loop could run out of gas. For example, if the account has many existing escrows with different expirations, this loop could iterate many times. That's a possible vulnerability because loops with unbounded size can cause transactions to fail, leading to DoS. However, the code uses lockups which might be a mapping or a sorted list. Wait, looking at the LockedBalance.Lockups library, which isn't provided here, but the code uses get and set methods. If the lockups are stored in a way that allows O(1) access, then maybe the loop isn't necessary. But in the current code, the loop starts from escrowIndex and increments, which could be a problem. Wait, the code says:

unchecked {
    for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
            // If expiration exceeds uint32, revert
            // Then set the escrow
            break;
        }
        if (escrow.expiration == expiration) {
            // Update existing escrow
            break;
        }
    }
}

So this loop could run indefinitely until it finds an existing escrow with the same expiration or a zero expiration. Wait, but if the escrows are stored in a way that their indices are sequential, then the loop would have to check each index until it finds an empty one. That's a problem because if all indices are filled, the loop would run out of gas. But how are the escrows stored? Without seeing the LockedBalance.Lockups implementation, it's hard to say. But if the lockups are a mapping, then the loop might not make sense. Wait, the Lockups might be a mapping from uint256 (index) to Lockup. If that's the case, then the loop could go on forever if there's no existing escrow with the desired expiration and no empty slot. Wait, no, because the code starts at lockupStartIndex, which is a uint32. So maybe the escrows are stored in a way that the indices are contiguous starting from lockupStartIndex, but if there's a gap, the loop might not find the existing expiration. Wait, this seems like a possible issue. The loop could iterate many times, leading to high gas costs and potential DoS. For example, if an attacker creates many escrows with different expirations, then when trying to add a new one, the loop would have to check each index until it finds an empty spot, which could be at a high index. This is a potential vulnerability related to unbounded loops causing gas exhaustion.

Another thing to check is the expiration calculation. lockupDuration is immutable, set in the constructor. The expiration is calculated as block.timestamp.ceilDiv(lockupInterval) * lockupInterval + lockupDuration. Wait, no: in _marketLockupFor, expiration is calculated as:

unchecked {
    expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
}

Wait, that's lockupDuration added to (block.timestamp divided by lockupInterval, rounded up) multiplied by lockupInterval. So, for example, if lockupInterval is 1 day (86400 seconds), then block.timestamp.ceilDiv(lockupInterval) gives the next day boundary. Then multiply by lockupInterval gives the start of that day. Then add lockupDuration (which is, say, 30 days). So the expiration is set to the start of the next interval plus the lockupDuration. But if lockupDuration is 30 days, this would be 30 days after the start of the next interval. Hmm. But maybe the intention is to have the expiration be a multiple of lockupInterval. However, there's a check that lockupDuration must be divisible by 24 intervals (since lockupInterval is lockupDuration / 24). Wait, in the constructor:

lockupInterval = _lockupDuration / 24;
if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
    revert FETH_Invalid_Lockup_Duration();
}

So lockupDuration must be a multiple of 24 intervals. So each interval is lockupDuration /24. So for example, if lockupDuration is 30 days, each interval is 1.25 days. Then, when calculating expiration, it's adding lockupDuration to the next interval boundary. But this seems like it could lead to expiration being set to a specific interval, but I'm not sure if there's an issue here. However, in the code, when setting expiration, there's a check:

if (expiration > type(uint32).max) {
    revert FETH_Expiration_Too_Far_In_Future();
}

Since expiration is a uint32, which is up to 4294967295. As of 2023, the current timestamp is around 1.6 billion. So if lockupDuration is set to a very large value, expiration could exceed uint32.max. But since lockupDuration is immutable, the contract deployer must ensure that the sum doesn't exceed this. But maybe in some cases, even with reasonable lockupDuration, the calculated expiration could be beyond uint32.max. That's a possible issue if not properly checked. However, the code does check this when creating a new escrow. So if expiration exceeds uint32.max, it reverts. That's handled.

Now, looking for reentrancy again. The sendValue function is used in several places. Since it's using AddressUpgradeable's sendValue, which uses a low-level call with limited gas (2300), reentrancy is prevented. So that's safe.

Another possible vulnerability is in the allowance mechanism. The approve function allows a spender to spend up to a certain amount. The transferFrom function checks the allowance if the caller is not the owner. However, there's a common vulnerability in ERC20 where the approve function is susceptible to front-running when changing allowances. For example, if a user changes an allowance from 5 to 3, a spender could use the 5 allowance before it's reduced. But this is a known issue and not a vulnerability per se, just a behavior to be aware of. The contract here uses the standard approach, so no specific vulnerability here.

What about integer overflows? The contract uses unchecked blocks in several places. For example, in depositFor:

unchecked {
    accountInfo.freedBalance += uint96(msg.value);
}

Since msg.value is a uint256, but freedBalance is a uint96. If the sum exceeds uint96, it will overflow. But since msg.value can't exceed uint96's max because in Ethereum, the maximum ether that can be sent in a transaction is way below 2^96 wei. Wait, 2^96 is about 7.9e28 wei, which is 7.9e10 ETH. So it's practically impossible for a single deposit to cause an overflow. So that's safe. Similarly, other unchecked operations seem safe because the values being added or subtracted are constrained by the logic (e.g., can't subtract more than the current balance).

Another area: the getLockups function. It loops through escrowIndex starting from lockupStartIndex until it finds a zero expiration. If there are many escrows, this could run out of gas when called externally. Since this is a view function, it's not a direct vulnerability, but it could cause the function to revert when called, which might affect external systems relying on it.

In the totalSupply function, it returns address(this).balance. But this includes both the locked and freed balances, which are tracked internally. However, the actual ETH in the contract should equal the sum of all freed balances plus all locked balances. If there's a discrepancy, the contract could be undercollateralized. But since all deposits are in ETH, and the contract uses sendValue to withdraw, as long as the accounting is correct, the totalSupply should match the contract's balance. However, if there's a bug in the accounting, like not properly tracking balances when moving from locked to freed, this could lead to inconsistencies. For example, if an escrow is not properly deducted when unlocked, the totalSupply (contract balance) might not match the sum of all balances, leading to possible insolvency.

Another potential issue is that when funds are locked, they are stored in the contract, and the _marketLockupFor function requires that either the msg.value is exactly the amount or the difference is taken from the freedBalance. But if someone calls this function and the msg.value is less than the amount, the contract uses the existing freedBalance. However, if the freedBalance is insufficient, it reverts. That's correct.

What about the use of sendValue? If the recipient is a contract with a fallback function that uses more than 2300 gas, the transfer will fail. This is a known issue with using transfer or send, but since the contract uses sendValue, which forwards all gas (but with a check), wait, no. The sendValue function from OpenZeppelin uses .call{value: amount}("""") which forwards all remaining gas. So if the recipient is a contract that uses a lot of gas, it could potentially cause the send to fail. However, this is a generic issue with ETH transfers and not specific to this contract. The contract's functions that send ETH (withdraw, marketWithdraw, etc.) could fail if the recipient is a contract that can't receive ETH. But that's expected behavior.

Now, looking at the function _removeFromLockedBalance. It allows the foundationMarket to unlock funds before expiration. However, if the expiration is in the future, the code checks that it's not expired. But when the foundationMarket calls marketUnlockFor, it can unlock funds even before the expiration. Since this function is only callable by the foundationMarket, which is a trusted contract, this is intentional. But if the foundationMarket is compromised, it could lead to unauthorized unlocking. However, this is a trust issue rather than a vulnerability in the FETH contract itself.

Another thing: the balanceOf function adds expired escrows to the balance. Wait, no. When you call balanceOf, it loops through the escrows starting from lockupStartIndex and adds the escrow.totalAmount to the balance only if the expiration is >= block.timestamp. Wait, no. Wait, the balanceOf function's code:

function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    unchecked {
        for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
            LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
            if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
                break;
            }
            balance += escrow.totalAmount;
        }
    }
}

Wait, no. Wait the loop breaks if escrow.expiration == 0 OR escrow.expiration >= block.timestamp. So if the escrow's expiration is less than block.timestamp (expired), it adds to the balance. Wait, no. Wait, the loop runs while escrow.expiration < block.timestamp. Wait, let's parse this code:

The loop starts at lockupStartIndex. For each escrowIndex, it gets the escrow. If the escrow's expiration is zero OR the expiration is >= block.timestamp, it breaks. So, the loop continues only if the escrow's expiration is non-zero AND expiration < block.timestamp. But in that case, the code adds escrow.totalAmount to the balance. Wait no. Wait, inside the loop:

balance += escrow.totalAmount is done only if the loop continues. But the loop condition is such that if the escrow is zero or not expired, the loop breaks. Wait, the code is:

unchecked {
    for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
            break;
        }
        balance += escrow.totalAmount;
    }
}

So, for each escrow starting from lockupStartIndex:

- If the escrow's expiration is zero, break. So, no more escrows.
- If the expiration is >= block.timestamp (not expired), break.
- Otherwise (expiration is < block.timestamp, i.e., expired), add to balance and continue.

Wait, no. Wait, the code inside the loop is:

get escrow.

If expiration is 0 OR expiration >= now: break. So loop breaks. So balance is not modified.

Only if expiration is non-zero and < now, then the code proceeds past the 'if' and adds to balance.

Wait no. The code is:

Inside the loop:

get escrow.

Check if expiration is 0 OR >= block.timestamp. If yes, break the loop. Otherwise, add escrow's totalAmount to balance, and increment escrowIndex.

Wait, no. The code is:

Inside the loop:

Check if (escrow.expiration == 0 || escrow.expiration >= block.timestamp). If yes, break. Otherwise, do nothing. Then increment escrowIndex.

Wait, no. Wait, after the 'if' condition, there's no 'else' clause. So if the condition is not met (i.e., expiration !=0 and expiration < block.timestamp), then the code does not break and proceeds to the next iteration. But in the code above, after the 'if' check, the loop continues, but there's no code between the 'if' and the end of the loop. Wait, no. The code as written:

for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
        break;
    }
    balance += escrow.totalAmount;
}

Wait, no. The code is:

If the escrow's expiration is 0 or >= now, break. Otherwise, add to balance and continue looping. Because after checking, if the escrow is expired (expiration < now), the code adds to balance and continues to the next escrowIndex. Wait, but the code adds to balance after the 'if' check. Wait, no. Wait, the code is:

Inside the loop:

1. Get escrow at escrowIndex.
2. Check if expiration is 0 or >= now. If yes, break. So loop stops.
3. If not, add escrow.totalAmount to balance.
4. Increment escrowIndex and repeat.

Wait, no. The code structure is:

for (;;) {
    get escrow.
    if (condition) break;
    balance += escrow.totalAmount;
}

So the code will add to balance only if the escrow exists (expiration !=0) and expiration < block.timestamp. Then increment escrowIndex and check the next one. But this will loop through all escrows starting from lockupStartIndex until it finds an escrow that's either zero or not expired.

But this is in the balanceOf view function. The balance includes the freedBalance plus all expired escrows. However, when a user calls transfer, the _freeFromEscrow function is called, which moves expired escrows into freedBalance. But in the balanceOf view function, the expired escrows are added to the balance but not moved to freedBalance. So there's a discrepancy between the internal accounting (where expired escrows are in lockups until _freeFromEscrow is called) and the balanceOf view. For example, if an escrow has expired but _freeFromEscrow hasn't been called yet, the balanceOf will include that escrow's amount, but the actual freedBalance hasn't been updated. However, when a transfer occurs, _freeFromEscrow is called, moving those expired escrows into freedBalance. So the balanceOf returns the correct total available balance (freed + expired), but the actual freedBalance hasn't been updated until a state-changing function is called. This is correct, but there's a potential issue if other contracts rely on the balanceOf without considering that some balances are in expired escrows but not yet freed. However, this is by design.

But wait, the _freeFromEscrow function is called during transfers, withdrawals, etc., which update the state. The balanceOf function's view includes expired escrows in the balance, but the actual freedBalance isn't updated until a transaction occurs. So if a user has expired escrows, their balanceOf will show the correct available balance, but until they perform a transfer or withdraw, the freedBalance isn't updated. This is intentional and not a vulnerability. However, if the expired escrows are not properly moved into freedBalance during state changes, that could be a problem. But the code seems to handle that correctly.

Another possible issue is in the transferFrom function. It calls _freeFromEscrow on the 'from' account, but not on the 'to' account. However, when transferring to 'to', the code adds the amount to their freedBalance. So if 'to' has expired escrows, they are not automatically freed, which is correct. The 'to' account's expired escrows would remain until they perform an action that triggers _freeFromEscrow. But the transferred amount is added to 'to's freedBalance directly. That's okay.

Now, let's think about possible vulnerabilities again. One possible issue is in the _marketLockupFor function where the loop to find an existing escrow with the same expiration could run out of gas if there are many escrows. Suppose an account has many escrows with different expirations. When adding a new escrow, the loop will iterate from lockupStartIndex upwards until it finds an empty slot or an existing escrow with the same expiration. If the account has a lot of escrows, this loop could consume a lot of gas and revert. For example, if an attacker creates 1000 escrows with different expirations, then adding a new escrow would require iterating through all 1000 entries until finding an empty slot. This is a potential denial-of-service attack vector.

Yes, this is a vulnerability. The loop in _marketLockupFor could have an unbounded number of iterations, leading to gas exhaustion. The code for adding a new lockup is:

unchecked {
    for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
            if (expiration > type(uint32).max) {
                revert FETH_Expiration_Too_Far_In_Future();
            }
            // Create new escrow
            accountInfo.lockups.set(escrowIndex, expiration, amount);
            break;
        }
        if (escrow.expiration == expiration) {
            // Add to existing escrow
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
            break;
        }
    }
}

This loop increments escrowIndex indefinitely until it finds either an empty escrow (expiration ==0) or one with the same expiration. If the account has many escrows with different expirations, this loop could iterate many times, using excessive gas and causing the transaction to fail. This is a vulnerability because an attacker could create multiple escrows with different expirations, making it impossible for the user to add new lockups without incurring high gas costs or reverting due to out-of-gas errors.

Another issue: the getLockups function returns all expiries and amounts for an account's lockups that are not expired. But in the loop, it starts from lockupStartIndex and checks each escrowIndex until expiration is zero. This could also be a gas-intensive operation for accounts with many lockups. However, since this is a view function, it doesn't affect the contract's state, but it could cause issues for frontends or other off-chain systems that call this function.

Another possible vulnerability is in the use of uint32 for lockupStartIndex. The lockupStartIndex is a uint32, which can hold up to 4 billion. If an account has more than 4 billion lockups, this would overflow, but that's practically impossible due to gas constraints. However, each lockup is stored with an index, and the code uses a uint256 for escrowIndex in loops, so it's not an issue here.

In the _freeFromEscrow function, the loop may process multiple expired escrows. If an account has many expired escrows, this function could consume a lot of gas when called during a transfer or withdrawal. This could lead to DoS if a user has too many expired escrows to process in a single transaction. For example, if an attacker sends many small lockups to a user's account with short durations, causing them to expire, the user's next transfer could require processing all of them, leading to high gas costs or failure. However, the user could mitigate this by periodically calling a function that triggers _freeFromEscrow, but the contract doesn't have such a public function. The only way to trigger _freeFromEscrow is through state-changing functions like transfer, which the user might not do regularly. This is a potential DoS vector where an attacker can make a user's transactions more expensive by flooding their account with expired lockups.

Yes, this is another vulnerability. If an attacker can create many expired lockups for a user's account, any subsequent transaction that calls _freeFromEscrow (like transfer or withdraw) will have to iterate through all the expired lockups, increasing gas costs and potentially causing the transaction to fail. Since the user can't control someone else locking up funds for them (if the lockupFor address is the user's address), an attacker could repeatedly call marketLockupFor with the victim's address and small amounts, each with a past expiration. Then, when the victim tries to transfer or withdraw, the _freeFromEscrow loop will have to process all these expired lockups, leading to high gas costs.

Wait, but marketLockupFor is only callable by foundationMarket. So unless the foundationMarket is compromised or allows arbitrary users to call this function, an attacker can't directly create lockups for other users. However, if the foundationMarket allows users to create lockups for others (e.g., as part of some marketplace functionality), then an attacker could potentially create many expired lockups for a victim's address.

Assuming that the foundationMarket allows users to lockup funds for others (like in a marketplace escrow), then this could be a problem. If the attacker can create many lockups with expiration times in the past, then the victim's account would have many expired lockups that need to be processed in _freeFromEscrow. However, creating a lockup with expiration in the past would require the expiration to be set to a time before the current block timestamp. Let's see how expiration is calculated in _marketLockupFor:

expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;

If lockupDuration is set to, say, 30 days, then the expiration is in the future. So an attacker can't create an expired lockup via the marketLockupFor function. However, the _marketUnlockFor function allows the foundationMarket to unlock funds even before expiration. But that requires the foundationMarket to call marketUnlockFor with an expiration that's in the future. If the foundationMarket is malicious or compromised, it could create expired lockups. But under normal operation, this shouldn't be possible.

Alternatively, if the foundationMarket allows users to create lockups with arbitrary expirations, then an attacker could set expiration to the past. But looking at the code in _marketLockupFor, the expiration is calculated based on the current block timestamp and lockupDuration, so it's always in the future. Therefore, the attacker can't create lockups that are already expired through legitimate functions. Therefore, the DoS via expired lockups isn't possible unless there's a way to create lockups with past expirations, which the current code doesn't allow. Hence, the _freeFromEscrow loop may not be a vulnerability under normal operation.

Another possible issue is the use of sendValue in the marketWithdrawFrom and withdrawFrom functions. If the recipient is a contract that doesn't handle incoming ETH, the transfer will fail, but the state has already been updated (balances deducted). This would result in the ETH being stuck in the contract, and the user losing access to their funds. For example, if a user withdraws to a contract that can't receive ETH, the sendValue would fail, reverting the transaction. Wait, no. sendValue returns a boolean, but in the code, it's not checked. For example:

// In marketWithdrawFrom:
payable(msg.sender).sendValue(amount);

If this fails (returns false), the code doesn't revert. So the state has already been updated (balances deducted), but the ETH wasn't sent. This would result in a loss of funds because the user's balance is reduced, but the ETH remains in the contract. This is a critical vulnerability.

Looking at the code for marketWithdrawFrom:

function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // Withdraw ETH
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
}

The sendValue is called without checking the return value. If the transfer fails (e.g., recipient is a contract without a payable fallback), the ETH remains in the FETH contract, but the user's balance has already been deducted. This means the user's funds are lost because their balance is reduced, but the ETH wasn't successfully transferred. This is a critical vulnerability.

Similarly, in marketWithdrawLocked:

function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // Withdraw ETH
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
}

Again, sendValue is used without checking the return value. Same issue here.

In withdrawFrom:

function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
) external {
    if (amount == 0) {
        revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
        _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // Withdraw ETH
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
}

Again, sendValue without checking the return value. If the transfer fails, the state has already been updated, leading to loss of funds.

This is a major vulnerability. The OpenZeppelin AddressUpgradeable's sendValue function returns a boolean indicating success. However, the code here doesn't check that return value, so failed transfers don't revert the transaction. This can result in the balances being deducted but the ETH not being sent, effectively stealing the user's funds.

Another instance is in withdrawAvailableBalance:

function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
        revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // Withdraw ETH
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
}

Again, sendValue is called without checking the return value.

This is a critical issue because it can lead to loss of user funds. The correct approach is to use a require statement or propagate the error. For example:

require(payable(msg.sender).sendValue(amount), ""Transfer failed"");

But the current code does not do this, leading to silent failures.

Another possible vulnerability is in the handling of allowances. The _deductAllowanceFrom function checks if the allowance is sufficient and deducts it. However, it uses a strict comparison when checking if the allowance is type(uint256).max. If the allowance is set to max, it doesn't get reduced. But this is standard ERC20 behavior. However, if the allowance is set to a very high value but not max, an attacker could use it multiple times until it's depleted. But this is not a vulnerability, just how allowances work.

Another potential issue is that the lockupDuration is set during construction and cannot be changed. If there's a need to adjust lockup periods, the contract would need to be upgraded. But since it's using a constructor, it's immutable. However, this is a design choice, not a vulnerability.

Another thing to note is that the contract uses a mix of uint96, uint32, and uint256 for different variables. For example, freedBalance is a uint96. If the total value exceeds uint96, it would overflow. But considering that 2^96 wei is about 7.9e28 wei (which is 7.9e10 ETH), this is extremely unlikely. However, if multiple deposits are made that sum beyond uint96, it would silently overflow. But the code uses unchecked blocks when adding to freedBalance. For example, in depositFor:

unchecked {
    accountInfo.freedBalance += uint96(msg.value);
}

If msg.value is larger than uint96 can hold (i.e., > 2^96 - 1), the addition will overflow. However, since each msg.value is the amount sent in a transaction, and given that the maximum possible ETH that can be sent in a transaction is way below 2^96 wei (since the total supply of ETH is ~1e24 wei), this overflow is impossible. So this is not a vulnerability.

In summary, the key vulnerabilities found are:

1. Unbounded loops in _marketLockupFor leading to gas exhaustion and DoS.
2. Use of sendValue without checking the return value, leading to silent failures and loss of funds.
3. Potential DoS via unbounded loops in _freeFromEscrow if an account has many expired lockups, but this depends on how lockups are created.
4. Incorrect balance calculation in balanceOf if escrows are expired but not yet processed, but this is by design and not a vulnerability.","```
None.
```",0.0,0
NFTMarketFees.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867.0,219.0,"[M-08] Primary seller can avoid paying the primary fee
A primary seller can circumvent the 15% fee and pay 5% as a secondary seller.
  [M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low
The creator payouts are capped at `MAX_ROYALTY_RECIPIENTS_INDEX`. It's currently set to 4 and only 5 creators are paid out. Other creators are ignored.",2.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  
  uint256[3] private __gap_was_fees;

  
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; 
  
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; 
  
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; 

  
  
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        
        uint256 totalShares;
        unchecked {
          
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              
              maxCreatorIndex = 0;
              break;
            }
            
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        
        creatorRev = price - foundationFee;
      } else {
        
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  
  uint256[1000] private __gap;
}",1195.0,0,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Truncation of Royalty Recipients Beyond Maximum Limit**  
   The contract truncates the list of royalty recipients if it exceeds `MAX_ROYALTY_RECIPIENTS_INDEX`, causing excluded recipients to lose their entitled funds. This occurs during secondary sales when distributing `creatorRev`, as only the first few recipients (up to the limit) receive their share, while the rest are ignored.

2. **Hardcoded Creator Royalty Percentage for Secondary Sales**  
   The contract enforces a fixed 10% royalty (`CREATOR_ROYALTY_BASIS_POINTS = 1000`) for secondary sales, overriding any on-chain royalty standards (e.g., EIP2981). This disregards the NFT contract's specified royalties, leading to incorrect payments to creators or rights holders.

3. **Lack of Validation for Creator Shares Sum**  
   The contract does not ensure that the sum of `creatorShares` is ≤ `BASIS_POINTS` (10,000). While individual shares are checked for overflow, an excessive total sum could result in unintended proportional distribution (e.g., shares summing to 150% would distribute funds proportionally rather than reverting invalid inputs).

4. **Incomplete Handling of Invalid Creator Shares**  
   If any `creatorShare` exceeds `BASIS_POINTS` (100%), the contract sends the entire `creatorRev` to the first recipient. This bypasses validation and may lead to unintended fund distribution if shares are misconfigured (e.g., accidental input errors).","### **[M-08] Primary seller can avoid paying the primary fee**

**Report Description**:  
A primary seller can circumvent the 15% fee and pay only 5% as a secondary seller. This issue arises due to a loophole in the fee calculation logic, allowing the primary seller to bypass the intended fee structure.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. There is no mention of fee circumvention or any related logic in the provided responses. This is a significant gap in the response list, as the issue highlights a critical vulnerability in the fee structure.

---

### **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Report Description**:  
The creator payouts are capped at `MAX_ROYALTY_RECIPIENTS_INDEX`, which is currently set to 4. This means only 5 creators are paid out, and any additional creators are ignored. This limitation can lead to unfair distribution of funds and potential disputes among creators.

**Match in Response List**:  
Matches with the issue titled **""Truncation of Royalty Recipients Beyond Maximum Limit""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the truncation of royalty recipients due to the `MAX_ROYALTY_RECIPIENTS_INDEX` limit. It correctly explains the impact of this limitation, which aligns with the issue report. The response covers the core vulnerability and its implications effectively.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-08] Primary seller can avoid paying the primary fee**

---

The response list effectively addresses the issue related to the truncation of royalty recipients but completely misses the issue regarding the circumvention of primary fees. This gap indicates a need for a more comprehensive review of the fee calculation logic in the smart contract.",1,0,1,4,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called NFTMarketFees and it's part of an NFT marketplace. It deals with distributing fees to creators, the foundation, and the seller. 

First, I'll start by understanding the main functions. The _distributeFunds function seems crucial. It calculates fees and sends payments to different parties. Let me check how the fees are calculated here. There are some basis points constants for fees, like 1000 for creator royalty, 1500 for primary foundation fee, and 500 for secondary. These are percentages divided by 100, so 1000 basis points would be 10%.

In the _getFees function, the code checks if the seller is the creator and if it's the first sale. If so, the primary fee (15%) is applied; otherwise, the secondary (5%). Then, foundationFee is calculated as (price * fee) / BASIS_POINTS. BASIS_POINTS is probably 10000, so that would make sense. 

Wait, when calculating creatorRev, if isCreator is true, then creatorRev is price minus foundationFee. But if it's not the creator, then creatorRev is (price * 1000) / 10000 (10%), and ownerRev is price - foundationFee - creatorRev. But what if the sum of foundationFee and creatorRev exceeds the price? That could lead to underflow or negative ownerRev. Let me check the math.

For example, if price is 100, foundationFee is 15 (15%), creatorRev is 10 (10%), then ownerRev would be 100 -15 -10 =75. That works. But if the foundation fee plus creatorRev is more than 100%, that's a problem. Since foundationFee can be 15% or 5%, and creatorRev is either (price - foundationFee) when isCreator and first sale, or 10% otherwise. Wait, when isCreator and first sale, creatorRev is price - foundationFee. So for the primary sale, creator gets 85% (price - 15% fee). That seems okay. 

But let's check when isCreator is true but it's not the first sale. Wait, no—the code says if isCreator and the first sale hasn't completed. So the first sale applies the primary fee. Then, after the first sale (marked as completed), subsequent sales use the secondary fee. So maybe the first sale is when the creator sells, and then secondary is others. 

Now, looking at the _distributeFunds function, when creatorFee is positive, it tries to distribute to multiple recipients. There's a loop that checks creatorShares, and if any share is greater than BASIS_POINTS (10,000?), it sets maxCreatorIndex to 0. But the shares are supposed to be parts of the total, right? Wait, the comment says that each share is in basis points. So if any share is over 100%, that's invalid, so the code breaks and sends everything to the first recipient. That's a possible issue if the shares are incorrectly set. But maybe that's intentional to handle invalid data.

Another thing: in the loop for distributing creator fees, if there are multiple recipients, the code sums up the shares. If totalShares is zero after checking each share, it sets maxCreatorIndex to 0. Then, in the distribution loop, for each recipient from index 1 to maxCreatorIndex, it calculates their share based on creatorFee * creatorShares[i] / totalShares. The remaining amount is sent to the first recipient. But if totalShares is zero, this division would cause a division by zero error. Wait, but in that case, the code sets maxCreatorIndex to 0, so the loop from i=1 to maxCreatorIndex (0) would not run. Then, creatorFee - totalDistributed (which is zero) is sent to creatorRecipients[0]. But if totalShares was zero, that's only possible if all shares were zero, which would have set maxCreatorIndex to 0. Then, creatorFee is sent to the first recipient. So maybe division by zero is avoided here.

Wait, in the code, the totalShares is calculated in an unchecked block. Let's look at the code:

unchecked {
  for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
    if (creatorShares[i] > BASIS_POINTS) {
      maxCreatorIndex = 0;
      break;
    }
    totalShares += creatorShares[i];
  }
}
if (totalShares == 0) {
  maxCreatorIndex = 0;
}

So if all creatorShares[i] are zero, totalShares would be zero, leading to maxCreatorIndex being 0. Then, when distributing, the loop runs from i=1 to maxCreatorIndex (0), so it doesn't execute. Then, creatorFee - totalDistributed (0) is sent to creatorRecipients[0]. But if creatorRecipients[0] is a valid address, this would send the entire creatorFee to them. However, if creatorRecipients is empty, then accessing creatorRecipients[0] would cause an out-of-bounds error. But in the _getFees function, when isCreator is true, creatorRev is price - foundationFee, which would require creatorRecipients to be non-empty. Otherwise, if creatorRecipients.length is zero, creatorRev would be zero. Wait, in _getFees, if creatorRecipients.length >0, then handle creatorRev. So if isCreator is true, but creatorRecipients is empty, creatorRev is set to price - foundationFee. But then, in the distribution code, when creatorRev is positive, it checks creatorRecipients.length. If it's zero, but creatorRev is positive, that would be a problem. Wait, no, in the code, in the _distributeFunds function, if creatorFee >0, then check creatorRecipients.length. But if creatorRecipients is empty, then creatorRev would be zero because in _getFees:

if (creatorRecipients.length > 0) {
  ... compute creatorRev ...
} else {
  ownerRevTo = seller;
  ownerRev = price - foundationFee;
}

So creatorRev would only be non-zero if creatorRecipients is non-empty. Therefore, in the distribution code, if creatorFee is positive, creatorRecipients must be non-empty, so accessing creatorRecipients[0] is safe. So that's probably okay.

Another point: the use of the unchecked block when adding creatorShares. Since it's in an unchecked block, if totalShares overflows, it would wrap around. However, since each share is checked to be <= BASIS_POINTS (10,000), and there's a limit on the number of recipients (MAX_ROYALTY_RECIPIENTS_INDEX, which is presumably a small number, maybe 5?), the sum of shares would be at most 10,000 * MAX_ROYALTY_RECIPIENTS. If MAX_ROYALTY_RECIPIENTS is high, this could overflow. But the code says MAX_ROYALTY_RECIPIENTS_INDEX is checked. For example, if maxCreatorIndex is set to MAX_ROYALTY_RECIPIENTS_INDEX (like 5), then even if each share is 10,000, totalShares would be 5*10,000=50,000. But BASIS_POINTS is 10,000, so 50,000 is manageable as a uint256. So overflow here is unlikely. So that's probably safe.

Another possible vulnerability: reentrancy. The contract uses SendValueWithFallbackWithdraw, which suggests that when sending ETH, it uses a withdrawal pattern to avoid reentrancy. The _sendValueWithFallbackWithdraw function probably uses a pull-over-push approach, which is safer. So maybe there's no reentrancy issue here.

What about front-running? For example, when a sale happens, someone could front-run the transaction to change the price, but that's more about the marketplace logic rather than this fee distribution code.

Another thing: the __gap variables are for upgradeable contracts, using the OpenZeppelin Initializable. The storage gaps are there to reserve space for future versions. That's standard practice, so no vulnerability there.

What about the mapping _nftContractToTokenIdToFirstSaleCompleted? It's used to track if the first sale is completed. If this is set to true in _distributeFunds, but perhaps there's a way to call _distributeFunds multiple times for the same token, causing the first sale flag to be set multiple times. However, _distributeFunds is likely called only once per sale. If another sale can be processed for the same token without transferring ownership, that could be an issue, but that depends on other parts of the contract not shown here.

Another thing: division before multiplication. For example, in (price * fee) / BASIS_POINTS. If the multiplication overflows, it could cause issues. But since price is in ETH, which has 18 decimals, multiplying by a fee that's up to 1500 (15%) for a price of, say, 1e24 wei would be 1e24 * 1500 = 1.5e27, which is way below the uint256 max (1e77). So overflow is not a problem here.

Wait, but for creatorRev, in the case where isCreator is true, creatorRev is price - foundationFee. So if foundationFee is more than price, this would underflow. But foundationFee is (price * fee) / BASIS_POINTS. Since fee is either 1500 or 500, and BASIS_POINTS is 10000, (price * 1500)/10000 would be up to 15% of price. So price - foundationFee would be 85% of price, which is positive. So underflow shouldn't happen here.

In the else case (not isCreator), creatorRev is (price * 1000)/10000 = 10% of price. Then ownerRev is price - foundationFee (5% secondary) - 10% = 85% of price. So that's okay. So underflow is prevented here.

Another thing: the code uses SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT and SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS. If these are too low, the transfers could fail, leading to funds stuck. But this is a design choice rather than a vulnerability.

Also, in the distribution loop, for multiple recipients, the code sends shares in a loop. If one of the sends fails (e.g., a recipient is a contract that reverts), the entire transaction would revert. However, the _sendValueWithFallbackWithdraw function might handle this by allowing recipients to withdraw later, which is what the SendValueWithFallbackWithdraw contract is for. So this is using a withdrawal pattern to avoid issues with sending to contracts that can't receive ETH. So that's handled, so no vulnerability here.

Another possible issue: if the creatorRecipients array is longer than allowed by MAX_ROYALTY_RECIPIENTS_INDEX, the code truncates it. For example, if there are 10 recipients, but MAX is 5, it will process up to index 5. However, the code checks if maxCreatorIndex is greater than MAX, then sets it to MAX. Then, in the loop, it processes up to maxCreatorIndex. But this could lead to some recipients not getting their shares. For example, if there are 6 recipients, maxCreatorIndex is set to 5 (if MAX is 5), and the loop runs from 1 to 5. Then recipient 0 gets the remainder. Wait, the code says:

for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
  ... send to creatorRecipients[i] ...
}
then send creatorFee - totalDistributed to creatorRecipients[0].

So if maxCreatorIndex is 5 (indexes 0 to 5), the loop runs from i=1 to 5. Then, recipient 0 gets the remainder. But the original shares are for all recipients, including index 0. However, in the code, the loop starts at i=1, so index 0 is handled separately. Wait, no. Let's look again:

The code loops from i=0 to maxCreatorIndex in the unchecked block when checking shares. Then, in the distribution loop, it starts at i=1. Wait, no:

Original code in the unchecked loop:

for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
  ... check each share ...
}

Then, the distribution loop:

for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
  ... send to creatorRecipients[i] ...
}

Then send the remainder to creatorRecipients[0]. So this implies that creatorRecipients[0] is the primary recipient, and others are secondary. But if the original shares included index 0, then in the totalShares calculation, index 0 is part of the sum. But when distributing, index 0's share is not considered in the loop; instead, the remainder is sent to index 0. That's incorrect. For example, if there are three recipients (indices 0, 1, 2), and shares are [5000, 3000, 2000], totalShares is 10000. The code would loop i=0 to 2 (if maxCreatorIndex is 2) to check the shares, sum them as 10000. Then, in distribution, loop from i=1 to 2. For each, share is (creatorFee * 3000)/10000 and (creatorFee * 2000)/10000. Total distributed would be 3000+2000 =5000 parts. Then, the remainder (creatorFee * 5000) is sent to index 0. But this is not correct. Because the original shares for index 0 was 5000, but in the code, the remainder is sent to index 0. However, in this case, the remainder is exactly the 5000 part. So it works. But why is the code structured this way?

Ah, perhaps the first recipient (index 0) is the main one, and the others are secondary. But the code treats index 0's share as the remainder. However, if the totalShares is the sum of all shares (including index 0), but the code only distributes shares starting from index 1, then the remainder sent to index 0 may not match the original share for index 0. 

For example, suppose shares are [2000, 3000, 5000], totalShares 10000. The code would loop i=0, 1, 2. Then in distribution, i=1 and 2. Their shares would be (creatorFee *3000)/10000 and (creatorFee *5000)/10000. Total distributed is 8000 parts. Remainder is creatorFee * 2000. So index 0 gets 2000 parts, which matches the original share. That works. 

Wait, yes. Because totalShares includes index 0's share. When the code loops from i=1, the sum of those shares is 3000+5000=8000. So the remainder is creatorFee - totalDistributed = creatorFee - (3000 +5000)/10000 * creatorFee = 2000/10000 * creatorFee. So index 0 gets their correct share. 

But what if the code truncates the maxCreatorIndex? For example, if there are 6 recipients (indices 0-5), and MAX is 5. Then, maxCreatorIndex is set to 5. The code loops from 0 to 5 to check shares and sum totalShares. Then, in distribution, loops from i=1 to 5. So indices 1-5 get their shares based on their portion of the totalShares (which includes index 0's share). Wait, no. The totalShares is sum from i=0 to maxCreatorIndex. Then, the loop distributes i=1 to maxCreatorIndex. So the remainder is sent to index 0. But index 0's share is part of the totalShares. Therefore, the calculation for each share in the loop is (creatorShares[i] / totalShares) * creatorFee. But since totalShares includes index 0's share, when we only distribute from i=1, their shares are a fraction of the total, and index 0 gets the remainder. This effectively gives index 0 their share as (creatorShares[0]/totalShares)*creatorFee. So it works out. Because sum of shares from 0 to maxCreatorIndex is totalShares. So if you distribute shares from 1 to maxCreatorIndex, their total is sum(creatorShares[1..n]/totalShares)*creatorFee. The remainder is sum(creatorShares[0]/totalShares)*creatorFee, which is sent to index 0. Therefore, the code correctly distributes according to the shares, even when the maxCreatorIndex is limited. 

However, if the maxCreatorIndex is truncated (like original array is longer than allowed), then the code only considers up to maxCreatorIndex. For example, if there are 10 recipients, but MAX is 5, the code would check up to index 5, sum their shares, and distribute to indices 1-5. Index 0 gets the remainder. But the original shares for indices 6-9 are ignored. This could be a problem if the creator intended more recipients but the code truncates them. However, the comment says that if there are more than MAX_ROYALTY_RECIPIENTS_INDEX, they limit to the first MAX. But that's a design decision, not a vulnerability. However, if the creator expects all recipients to be paid but the code truncates, that's a loss of funds for those recipients. But the code's logic here may be intentional to cap the number of recipients, which could be a potential issue if not documented. However, the question is about vulnerabilities, not design choices. So maybe this is a vulnerability if the contract allows more recipients than it can handle, leading to loss of funds. 

Wait, the code checks if maxCreatorIndex is greater than MAX_ROYALTY_RECIPIENTS_INDEX (which is likely 5, for example), then sets maxCreatorIndex to MAX. So if the original creatorRecipients has 6 entries, maxCreatorIndex would be set to 5. Then, when checking shares for i=0 to 5, and summing their shares. Any shares beyond index 5 are ignored. Thus, the code would not process those. This could result in those recipients beyond MAX not receiving their share. So if the creator specifies more recipients than the MAX, those beyond the MAX are excluded. This could be a vulnerability if the contract doesn't properly handle the number of recipients, leading to incorrect royalty distribution. However, the contract's comment says ""if maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX, set to MAX"" — but this is truncating the recipients, which could be a flaw. For example, a malicious creator could front-run the sale and set a large number of recipients, but the contract would only process up to MAX, potentially sending most of the royalty to the first recipient. But I'm not sure if this is considered a vulnerability or a known limitation. Since the code explicitly handles this, it's more of a feature, but if the creator expects all recipients to be paid and they aren't, that's a problem. However, the code is part of the NFTMarketCreators contract, which may enforce that the number of recipients is within the MAX. If not, then this is a vulnerability because it truncates the list of recipients. 

So possible vulnerabilities:

1. Truncation of royalty recipients beyond MAX_ROYALTY_RECIPIENTS_INDEX, leading to loss of funds for excluded recipients.

Another thing: the code uses a fixed CREATOR_ROYALTY_BASIS_POINTS of 1000 (10%) for secondary sales. If the actual royalty is supposed to be set by the creator (like EIP2981), then hardcoding 10% would be a problem. But looking at the code, in _getCreatorPaymentInfo, which is from NFTMarketCreators, perhaps that function retrieves the royalty info. If the code overrides the royalty to 10% regardless of the NFT's own royalty specification, that's a problem. For example, if an NFT specifies a 5% royalty, but this contract enforces 10%, then creators get more than intended. But according to the code here, in _getFees, when isCreator is false (secondary sale), creatorRev is (price * 1000) / 10000, i.e., 10%. So this contract is enforcing a 10% royalty on secondary sales, regardless of the NFT's own royalty. That's a possible issue if the contract is supposed to respect the NFT's royalty. This would mean that the contract doesn't comply with standards like EIP2981, leading to incorrect royalty payments. So that's a vulnerability because it doesn't respect the actual royalty percentage set by the NFT contract. 

So another vulnerability:

2. Hardcoded creator royalty fee (10%) for secondary sales, ignoring the NFT's actual royalty standard (e.g., EIP2981), leading to incorrect royalty payments.

Another possible issue: the first sale is tracked per NFT contract and token ID. But if the NFT is transferred back to the creator and sold again, would that count as a first sale? For example, after the first sale (marked as completed), if the creator buys back the NFT and sells it again, the contract would treat it as a secondary sale, applying the lower foundation fee. However, if the first sale is intended to be only when the creator initially sells, but the code marks it as completed after any sale (including if the seller is not the creator), that could be incorrect. Let's check when _nftContractToTokenIdToFirstSaleCompleted is set to true. It's set in _distributeFunds, which is called whenever a sale occurs, regardless of the seller. So even if a non-creator sells the NFT for the first time, it would mark the first sale as completed, and future sales would use the secondary fee. But the intention of primary vs secondary might be that the primary sale is the first sale by the creator, and secondary is any subsequent sale. If the code marks any first sale (even by a non-creator) as the first sale, then it's incorrect.

Looking at the code in _getFees: the isCreator variable comes from _getCreatorPaymentInfo, which probably checks if the seller is the creator. Then, if isCreator and first sale not completed, apply primary fee. Otherwise, secondary. So the first sale is when the creator sells it for the first time. But once any sale happens (creator or not), the first sale is marked as completed. Wait, no: in _distributeFunds, after the fees are distributed, the code sets _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true. So regardless of whether the seller is the creator or not, after the first sale (i.e., the first time _distributeFunds is called for that token), it's marked as completed. Then, subsequent sales will use the secondary foundation fee. 

But the intention might be that the primary fee applies only when the creator is selling for the first time. If the first sale is by a non-creator, then the primary fee would not apply. However, according to the code, the first sale is any sale, regardless of the seller. So even if the first sale is by a non-creator, the first sale is marked as completed, and future sales would use the secondary fee. This could be a vulnerability if the primary fee is intended only for the creator's first sale, but the code applies it to any first sale. For example, if a non-creator (like a marketplace) lists an NFT for the first time, the primary fee (15%) is applied, which might not be intended. 

But according to the code in _getFees: 

if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[...]) {
  fee = PRIMARY...
}

So the primary fee is only applied if the seller is the creator and it's the first sale. So if the first sale is by a non-creator, then isCreator is false, so the code uses the secondary fee. Then, after the sale, the first sale is marked as completed. Therefore, in subsequent sales, even if the creator is selling again, since first sale is completed, the secondary fee applies. 

Wait, that's correct. The primary fee is only applied when the seller is the creator AND it's the first sale. So if the first sale is by a non-creator, then isCreator is false, so secondary fee applies, and after that sale, first sale is marked as completed. Then, even if the creator sells it again, since the first sale is completed, the secondary fee is used. So that's correct. So the code correctly marks the first sale as completed after any sale, but the primary fee is only for the creator's first sale. 

Another possible issue: if the same token is sold multiple times in the same transaction (unlikely), but the flag is set after distribution, so subsequent calls would have the flag set. But that's a normal behavior.

Another thing: in the _getFees function, when isCreator is true and it's the first sale, creatorRev is price - foundationFee. But if the creator has multiple recipients, the code divides the creatorRev among them. However, if the sum of their shares is not 100%, the distribution might be incorrect. Wait, no. The code sums the shares and divides proportionally. For example, if the shares are [2000, 3000], total 5000. Then each gets 40% and 60% of creatorRev. So the code handles that. But if the shares don't add up to 100%, that's up to the creator. The code allows any sum, but the shares are relative. So if shares are [1000, 1000], total 2000, each gets 50%. But if the shares add up to more than 10000, the code breaks and sends everything to the first recipient. Which is a possible check, but the code allows for any total shares as long as individual shares don't exceed 10000. 

Wait, no. The code checks if any individual share is > BASIS_POINTS (10000). If any is, then maxCreatorIndex is set to 0. Then totalShares would be zero (since the loop breaks and the other shares are not summed). Then, in distribution, the code sends the entire creatorFee to the first recipient. So if a share is invalid (over 100%), the entire royalty goes to the first recipient. This could be a vulnerability if the creator accidentally sets a share over 100%, causing the royalty to be sent to the first recipient. But it's more of a data validation issue. The contract should validate that all shares are <= BASIS_POINTS and that the total is <= BASIS_POINTS, but it doesn't. So this could be a vulnerability where invalid shares cause incorrect distribution. 

So possible vulnerabilities:

3. Lack of validation that creatorShares sum up to <= BASIS_POINTS, leading to incorrect royalty distribution if the total exceeds 100% or individual shares exceed 100%.

But in the code, if any share is over BASIS_POINTS, it sets maxCreatorIndex to 0, causing the entire creatorFee to go to the first recipient. This handles individual shares exceeding 100% but doesn't check the total. For example, if shares are [5000, 5000], each is valid, but total is 10000 (100%). That's okay. But if shares are [5000, 6000], total is 11000, but individual shares are <=10000. The code doesn't check the total, so it would distribute as 5000/11000 and 6000/11000 of creatorFee. But if BASIS_POINTS is 10000, having a total over 100% would mean that the sum of shares is over 100%, leading to the royalty being more than 100% of the creatorRev. Wait, no. creatorRev is a fixed amount (price - foundationFee for primary, or 10% for secondary). The shares are used to split the creatorRev. If the shares sum to more than 10000 (100%), the code doesn't check that. So for example, if creatorRev is 100, and shares are [5000, 6000], total 11000, then each recipient gets 5000/11000 *100 ≈45.45 and 6000/11000 *100≈54.55, totaling 100. So the code allows shares summing to over 100%, which is okay because it's proportional. However, this could be a vulnerability if the shares are intended to sum to 100% but the contract allows otherwise. But according to EIP2981, royalties are a single value, so perhaps this contract's approach is different. So maybe this isn't a vulnerability but a design choice.

Another possible issue: in the case where creatorRecipients has more than one recipient, but due to truncation or other issues, the distribution could leave dust amounts. For example, when splitting among multiple recipients, due to integer division, small amounts may be left undistributed. However, the code sends the remainder to the first recipient, which should account for any rounding errors. For example, if creatorRev is 100 wei, and two recipients with shares [1,1], total 2. Each would get 50 wei, but 100/2 =50. So remainder is 0. If creatorRev is 101 wei, then 50 and 50, remainder 1 to the first recipient. So total is 51 +50 =101. That's handled correctly. So this part is okay.

To recap, the vulnerabilities I've identified so far:

1. Truncation of royalty recipients beyond MAX_ROYALTY_RECIPIENTS_INDEX, leading to loss of funds for excluded recipients.
2. Hardcoded 10% creator royalty for secondary sales, not respecting the NFT's own royalty standard (like EIP2981).
3. No validation that creatorShares sum up to <= BASIS_POINTS, allowing shares that exceed 100% in total, which could be a misconfiguration leading to unintended distribution.

Additionally, another possible issue:

4. If the `_getCreatorPaymentInfo` function in `NFTMarketCreators` allows the creator to set their own royalty recipients and shares, but this contract doesn't properly validate those inputs (like ensuring the arrays are of equal length, or that they are non-zero), it could lead to failed transactions or incorrect distributions. However, since this contract isn't shown, it's hard to say, but the code here does handle empty creatorRecipients by skipping creatorRev.

Another thing: the code uses the same BASIS_POINTS (10000) for both foundation fees and creator royalty. But if the NFT uses a different basis (like per mille), there could be a mismatch. However, this is a design choice.

Also, the code allows the foundation fee to be 15% on the primary sale and 5% on secondary. If the total fees (foundation + creator) exceed 100%, that would cause underflow in ownerRev. But the code ensures that in primary sale (creator is seller), creatorRev is price - foundationFee. Since foundationFee is 15%, price - 15% is 85%, so ownerRev (seller's revenue) is 85% minus creatorRev (which is 85% here). Wait, no: in primary sale, creatorRev is price - foundationFee. So if the primary sale is by the creator, then creatorRev is price - 15% fee. The foundationFee is 15%, and the creator gets 85%. So ownerRev is zero in this case, because the seller is the creator. Wait, no. Let me check _getFees:

If isCreator is true and first sale not completed:

fee = PRIMARY (15%)
foundationFee = price * 15% 
creatorRev = price - foundationFee (85%)
ownerRevTo is not set (since ownerRev is price - foundationFee - creatorRev = 0)
ownerRev is zero.

But then, in the code, ownerRevTo is set to seller only if not isCreator. Wait, in the code:

if (isCreator) {
  creatorRev = price - foundationFee;
} else {
  creatorRev = (price * 10%) 
  ownerRevTo = seller;
  ownerRev = price - foundationFee - creatorRev;
}

So if isCreator, then ownerRev is zero, and ownerRevTo is not set. But in the _distributeFunds function, the code sends ownerRev to ownerRevTo. So in the case of isCreator (primary sale), ownerRev is zero, so nothing is sent to ownerRevTo. 

But in the primary sale, the seller is the creator, and the entire revenue (price - foundationFee) is sent to the creator as creatorRev. So that's correct.

Now, the potential vulnerabilities are:

1. Truncation of royalty recipients beyond MAX_ROYALTY_RECIPIENTS_INDEX, leading to loss of funds for those recipients.
2. Hardcoded 10% creator royalty on secondary sales, not respecting the NFT's own royalty implementation (EIP2981).
3. No validation that the sum of creatorShares is <= BASIS_POINTS (10000), leading to unintended distribution if the sum exceeds 100% (though the code handles it proportionally, which might be correct but unexpected).

Other notes:

- The use of `_sendValueWithFallbackWithdraw` suggests that if a recipient cannot receive ETH (like a contract without a receive function), the ETH is stored for later withdrawal, which prevents failed transactions. This is a safe approach.
- The code uses `Initializable` and storage gaps, which is correct for upgradeable contracts.","```
1. Truncation of Royalty Recipients Beyond Maximum Limit
```","**Average Precision (AP):** 1.0

### Explanation:
- The true positive ""Truncation of Royalty Recipients Beyond Maximum Limit"" appears at rank 1 in the ranked list of predictions.
- Precision at rank 1 (\( P@1 \)) is calculated as \( \frac{1}{1} = 1.0 \).
- Since there is only one true positive, the Average Precision (AP) is simply the precision at that rank, which is **1.0**.",1
,,,,,,,,3,12,,,2,3,10,43,,,,2