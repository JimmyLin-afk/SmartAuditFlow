nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content
LendingPool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';

/**
 * @title Contract that deals with pooling of capital from lenders
 * @notice Implements the functions related to lender pooling
 * @author Sublime
 **/

contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of savings account
     */
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    /**
     * @notice address of pooled credit line
     */
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    /**
     * @notice address of verification module
     */
    IVerification public immutable VERIFICATION;
    /*
     * @notice Factor with which certain variables/constants are multiplied to maintain precision
     */
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- State variables start --------------------------------//

    /**
     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line
     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender
     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender
     */
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    /**
     * @notice Struct that stores the constants of a pooled credit line
     * @param startTime Timestamp at which pooled credit line starts
     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param collateralAsset address of token that is used as collateral deposited by the borrower
     * @param borrowLimit max tokens that was requested by borrower
     * @param minBorrowAmount min tokens that was requested by borrower
     * @param lenderVerifier address of verifier with which lenders should be verified to lend
     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account
     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable
     */
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    /**
     * @notice Struct that stores the variables of a pooled credit line
     * @param lenders mapping that stores lender specific info for the pooled credit line
     * @param sharesHeld total shares of borrow token held by the pooled credit line
              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit
              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced
              when any amount is repaid sharedHeld is increased.
              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is
              not changed.
     * @param borrowerInterestShares total interest in shares repaid by borrower
     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares
     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together
     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation
     */
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    /**
     * @notice Mapping that stores constants for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    /**
     * @notice Mapping that stores variables for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    /**
     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId
     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here
     */
    mapping(uint256 => uint256) public totalSupply;

    //-------------------------------- State variables end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice Modifier that allows only pooled credit line to call a function
     */
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- LenderPool events start ---------------------------//

    /**
     * @notice Emitted when lender deposits tokens for pooled credit line
     * @param id identifier for the pooled credit line
     * @param user address of the user
     * @param amount amount of tokens lent by user
     */
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares amount of shares of liquidity provided initially by lender withdrawn
     */
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation
     */
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when interest by yield or/and borrower is withdrawn
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower
     */
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when a lender withdraws their share of liquidation
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param collateralShare share of collateral withdrawn by lender from liquidation
     */
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    /**
     * @notice Emitted when a pooled credit line is liquidated by a lender
     * @param id identifier for the pooled credit line
     * @param collateralLiquidated amount of collateral that is received after liquidation
     */
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    //--------------------------- LenderPool events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Init start --------------------------------//

    /**
     * @notice constructor to initialize immutable global variables
     * @param _pooledCreditLine address of pooled credit line contract
     * @param _savingsAccount address of savings account contract
     * @param _verification address of verification contract
     */
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    /**
     * @notice initializes the contract in context of proxy
     */
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    //-------------------------------- Init end --------------------------------//

    //-------------------------------- PCL creation start --------------------------------//

    /**
     * @notice function invoked when creating pooled credit line
     * @dev only pooled credit line can call the create function
     * @param _id identifier for the pooled credit line
     * @param _lenderVerifier address of verifier with which lenders should be verified to lend
     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account
     * @param _borrowLimit max tokens that was requested by borrower
     * @param _minBorrowAmount min tokens that was requested by borrower
     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines
     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable
     */
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    //-------------------------------- PCL creation end --------------------------------//

    //-------------------------------- Lend & accept start --------------------------------//

    /**
     * @notice Function used by lenders to lend to pooled credit line
     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called
     * @param _id identifier for the pooled credit line
     * @param _amount amount of borrow tokens to lend
     */
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    /**
     * @notice function used to start the pooled credit line once the start time is reached
     * @dev this function needs to be called by the borrower
     * @param _id identifier for the pooled credit line
     */
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        // PCL can be started once the collection period is over
        require(block.timestamp >= _startTime, 'LP:S2');
        // PCL cannot be started once it has ended
        // PCL remains in the REQUESTED stage if it is not started
        // check _withdrawLiquidity method to see how these cases are handled
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        // If msg.sender is not borrower, then tx is rejected
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    //-------------------------------- Lend & accept end --------------------------------//

    //-------------------------------- callbacks start --------------------------------//

    /**
     * @notice Function invoked on borrow from the pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesBorrowed amount of shares borrowed
     */
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    /**
     * @notice Function invoked when repayment is done to pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesRepaid shares repaid
     * @param _interestShares interest in shares repaid
     */
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    /**
     * @notice Function invoked when pooled credit line is cancelled
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     */
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.
        delete pooledCLConstants[_id].startTime;

        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'
        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _to address to which all the borrow tokens are transferred
     */
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this is the maximum amount which can be borrowed from the PCL
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        // the borrower has not borrowed this much amount yet
        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI
        // also _notBorrowed == _borrowedLimit when the PCL has not started
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]
            // when the PCL is active totalSupply[_id] == _borrowedLimit
            // but _borrowLimit is some cases can be different than totalSupply[_id]
            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI
            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI
            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds
            // in this case too _borrowedLimit is greater than the totalSupply[_id]
            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit
            // this is done to get the _actualNotBorrowedInShares which might be less than the
            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares
            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because
            // no withdrawal of the principal fund deposited in the PCL can happen when it is active
            // interest withdrawn from the PCL has already been deducted from sharesHeld
            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime
            // borrowInterest is accrued only when PCL is active
            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares
            // any change in the totalSupply[_id] on does affect the interest shares in the PCL
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    //-------------------------------- callbacks end --------------------------------//

    //-------------------------------- Interest start --------------------------------//

    /**
     * @notice Function used to withdraw interest repaid by the borrower and
               the yield interest generated by the borrow assets deposited in the strategy
     * @dev Tokens lent are locked till end of Pooled Credit line. 
            Any interest paid by borrower can be withdrawn by lenders proportional to
            their token balances for that pooled credit line. Partial withdrawal of
            interest is not allowed. Whenever they call the `withdrawInterest` function
            they will get the entire amount of interest that is owed to them by that time
     * @param _id identifier for the pooled credit line
     */
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this checks if the constants are not deleted
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    /*
     * @dev this function updates the interest shares withdrawn by the lender.
            interest shares are of 2 types
            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender
            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender
     */
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    /**
     * @notice Function used to get interest withdrawable by a lender in pooled credit line.
               the interest this function returns is a sum of borrowerInterest + yieldInterest
               borrower interest is the interest paid by the borrower
               yield interest is the interest generated by the yield strategy
     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't 
            make any state changes except for getSharesForTokens and getTokensForShares in yield
     * @param _lender address of lender for whom interest is withdrawn
     */
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // get borrower repayments and yield interest shares
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        // convert total interest shares into tokens and return
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            // _sharesHeld is set in the _accept method
            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate
            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)
            // is the _totalYieldInterest
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    //-------------------------------- Interest end --------------------------------//

    //-------------------------------- Liquidity withdraw start --------------------------------//

    /**
     * @notice Function to withdraw liquidity by lender
     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios
            - pcl is cancelled by the borrower
            - pcl gets cancelled because because desired amount wasn't reached
            - pcl gets cancelled because it was never started by the borrower and endTime has reached
            - pcl is liquidated before the endTime has reached
            - pcl is liquidated after the endTime has reached
            - pcl is closed after all repayments
           in the other cases this function reverts
     * @param _id identifier for the pooled credit line
     */

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            // Case 0:
            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)
            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met
            // &&
            // Case 1: Pooled credit line never started because desired amount wasn't reached
            // _maxToLend is 0 if credit line is accepted so this case is never run

            //transfer liquidity provided
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within
                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL
                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            // all other cases distribute the sharesHeld proportional to their poolToken balances
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    /**
     * @notice Function that can be used to calculate principal withdrawable
     * @param _id identifier for the pooled credit line
     * @param _lender lender whose share of principal is to be withdrawn
     * @return Principal withdrawable
     */
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            // this else if block covers the conditions when PCL was cancelled OR
            // the PCL was in requested stage but never started
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    /*
    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed
           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount
    */
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    //-------------------------------- Liquidity withdraw end --------------------------------//

    //-------------------------------- Liquidation start --------------------------------//

    /**
     * @notice Function used to liquidate a pooled credit line
     * @dev only one of the lenders can liquidate their pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _withdraw flag used to identify if lender's share of
              liquidated collateral and liquidity (amount lent + interest) is also withdrawn
     */
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        // This line would call the liquidate function in the pooledCreditLine contract.
        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            // This function would give the share of the lender who called this function from the total liquidated amount
            // this will withdraw both the _collateralAsset and the borrowAsset
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    /**
     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset
     * @param _id identifier for the pooled credit line
     */
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        // this will withdraw the lender's share of liquidity (amount lent + interest)
        _withdrawLiquidity(_id, true);
    }

    //-------------------------------- Liquidation end --------------------------------//

    //-------------------------------- Pre token transfer start --------------------------------//

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                // cannot transfer to the borrower
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                // cannot transfer to a non verified user
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                // this is the case for minting tokens
                // increase the total supply of lp tokens
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                // this is the case for burn
                // reduce the total supply of lp tokens
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                // case for user to user transfer
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                // we need to transfer the lender info from to the receiving address
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            // if the transfer is from user to user, we will withdraw all the interest for the user
            // this is done because we need to transfer the lender info
            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    //-------------------------------- Pre token transfer end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _lender address of the lender for which query is made
     * @return returns lender info
     */
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    //-------------------------------- getters end --------------------------------//
}",9069,858,"[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee
The `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.
  [H-02] PooledCreditLine: termination likely fails because `_principleWithdrawable` is treated as shares
`_principalWithdrawable` is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.
  [M-01] Pool Credit Line May Not Able to Start When `_borrowAsset` is Non ERC20 Compliant Tokens
`IERC20(_borrowAsset).transfer(_to, _fee);`
If the USDT token is supported as `_borrowAsset`, the unsafe version of `.transfer(_to, _fee)` may revert as there is no return value in the USDT token contract’s transfer() implementation (but the IERC20 interface expects a return value).
Function `start()` will break when `_borrowAsset` is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.
  [M-02] Lack of access control allow anyone to `withdrawInterest()` for any lender
`withdrawInterest()` at a certain time may not be in the best interest of the specific `lender`.
It's unconventional and can potentially cause leak of value for the `lender`. For example, the lender may still want to accrued more interest from the strategy.
  [M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time
An attacker could keep track of the `totalSupply` of each LenderPool to see if it is more than the `minBorrowAmount`. If so, at startTime, which is pre-announced, the attacker could call `start`, which will trigger `SAVINGS_ACCOUNT.deposit()` of the entire pool assets to mint LP tokens from external strategy, for example, in CompoundYield.
There is potentially a big sum depositing into a known Compound `cToken` contract at a known fixed time. Thus, the attacker could prepare the pool by depositing a fair sum first to lower the exchange rate before calling start in lenderPool. Hence, the deposit of the entire pool could be at a less favourable rate. This also applies to other potential strategies that are yet to be integrated. For example, in Curve pool, the attacker could prime the pool to be very imbalanced first and trigger the deposit and then harvest the arbitrage bonus by bringing the pool back to balance.
This attack can happen once only when the pooledCreditLine becomes active for each new lenderPool.",5,"pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';



contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    

    
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    
    IVerification public immutable VERIFICATION;
    
    uint256 constant SCALING_FACTOR = 1e18;

    

    

    
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    
    mapping(uint256 => uint256) public totalSupply;

    

    

    
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    

    

    

    
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    

    

    

    
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    

    

    
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    

    

    
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        
        require(block.timestamp >= _startTime, 'LP:S2');
        
        
        
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    

    

    
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        
        delete pooledCLConstants[_id].startTime;

        
        
    }

    
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        
        
        
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            
            
            
            
            
            
            
            
            
            
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            
            
            
            
            
            
            
            
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    

    

    
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            
            
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            
            
            
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    

    

    

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            
            
            
            
            
            

            
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                
                
                
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            
            
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    

    

    
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        
        
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            
            
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        
        _withdrawLiquidity(_id, true);
    }

    

    

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                
                
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                
                
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            
            
            
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    

    

    
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    
}",5453,2,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Insufficient ERC20 Approval Handling in `_accept` Function**  
   The `_accept` function uses `safeApprove` for the strategy without resetting the allowance to zero first. If the strategy already has a non-zero allowance from a previous transaction, `safeApprove` will revert, preventing the deposit. This can occur when the same strategy is reused across multiple credit lines.

2. **Precision Loss Due to Integer Division Truncation**  
   Multiple calculations (e.g., in `_calculateLenderInterest`, `_rebalanceInterestWithdrawn`, and `_calculatePrincipalWithdrawable`) use integer division, leading to truncation of fractional values. This results in dust amounts accumulating in the contract, which could lock small portions of funds or misallocate interest.

3. **Reused Credit Line ID Leading to Data Corruption**  
   The contract does not enforce uniqueness of `_id` values. If the PooledCreditLine contract reuses an `_id`, it could overwrite or access stale data in `pooledCLConstants` and `pooledCLVariables`, leading to incorrect calculations or unauthorized access to residual data.

4. **Incorrect Collateral Handling During Multiple Liquidations**  
   The `liquidate` function sets `collateralAsset` and `collateralHeld` without checking if liquidation has already occurred. If called multiple times, this could overwrite collateral data, potentially allowing improper distribution of collateral if the PooledCreditLine allows repeated liquidations.

5. **Potential Division by Zero in `_calculateLenderInterest`**  
   If `_borrowLimit` is zero (e.g., due to incorrect initialization), divisions like `_lenderBalance.div(_borrowLimit)` would fail. While other checks prevent this, improper external updates could bypass safeguards.

6. **Unhandled Strategy Share Decay in `terminate` Function**  
   When withdrawing shares during termination, truncation in `_notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens)` might leave residual shares unaccounted for, causing funds to remain locked in the strategy.

7. **Inconsistent Interest Accounting During Token Transfers**  
   The `_rebalanceInterestWithdrawn` function proportionally adjusts withdrawn interest during transfers, but truncation may allow senders to retain slightly more withdrawn interest than entitled, enabling interest over-withdrawal over multiple transfers.

8. **Lack of Strategy Reinitialization Checks**  
   If a strategy is compromised or becomes invalid, the contract lacks mechanisms to update or revoke it, risking fund loss if strategies behave maliciously or return incorrect share values.

9. **Front-Runnable `start` Function**  
   The `start` function can be called by anyone once the `startTime` is reached, potentially allowing manipulation of the credit line's activation timing, though mitigated by system-level constraints.

10. **Insufficient Validation for `collateralAsset` in Liquidation**  
    The `liquidate` function assumes the collateral asset returned by `POOLED_CREDIT_LINE.liquidate` is valid. If the external call returns an unexpected asset (e.g., address(0)), subsequent transfers could fail or lock funds.

These vulnerabilities stem from arithmetic precision issues, unsafe external interactions, improper state handling, and insufficient validation of external contract return values.","### **Output**

---

#### **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**

**Report Description**:  
The `_principalWithdrawable` calculation in `LenderPool` is incorrect when `_start()` is invoked with a non-zero start fee. The borrow limit is reduced by the fee, causing `totalSupply[id]` to no longer be 1:1 with the borrow limit. This discrepancy can lead to incorrect principal withdrawal amounts.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem involves incorrect arithmetic calculations due to fee adjustments, which is not covered in the provided responses.

---

#### **[H-02] PooledCreditLine: termination likely fails because `_principleWithdrawable` is treated as shares**

**Report Description**:  
The `_principalWithdrawable` value is denominated in the borrow asset but is incorrectly treated as shares during termination. This mismatch can cause termination to fail or result in incorrect fund withdrawals.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves incorrect handling of asset denominations, which is not covered in the provided responses.

---

#### **[M-01] Pool Credit Line May Not Able to Start When `_borrowAsset` is Non ERC20 Compliant Tokens**

**Report Description**:  
The `start()` function uses `IERC20(_borrowAsset).transfer(_to, _fee)`, which may revert if `_borrowAsset` is a non-ERC20 compliant token like USDT (which lacks a return value in its `transfer()` implementation). This could prevent the credit line from starting, especially for widely used tokens like USDT.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves unsafe external calls to non-ERC20 compliant tokens, which is not covered in the provided responses.

---

#### **[M-02] Lack of access control allow anyone to `withdrawInterest()` for any lender**

**Report Description**:  
The `withdrawInterest()` function lacks access control, allowing anyone to withdraw interest on behalf of any lender. This could lead to value leakage, as lenders may prefer to accrue more interest rather than withdraw it prematurely.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves improper access control, which is not covered in the provided responses.

---

#### **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**

**Report Description**:  
An attacker could monitor the `totalSupply` of each `LenderPool` and call `start()` at the pre-announced `startTime` to deposit the entire pool into a known strategy (e.g., Compound or Curve). This could result in depositing at an unfavorable rate, especially if the attacker primes the strategy beforehand to manipulate the exchange rate.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Front-Runnable `start` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the front-runnable nature of the `start` function but does not address the specific risk of depositing at unfavorable rates due to strategy manipulation. The response focuses on timing manipulation rather than the broader economic impact.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**

**Missed Issues from Issue Report**:  
- **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**  
- **[H-02] PooledCreditLine: termination likely fails because `_principleWithdrawable` is treated as shares**  
- **[M-01] Pool Credit Line May Not Able to Start When `_borrowAsset` is Non ERC20 Compliant Tokens**  
- **[M-02] Lack of access control allow anyone to `withdrawInterest()` for any lender**

--- 

The response list fails to address most of the issues in the `issue` report, particularly those related to arithmetic precision, improper access control, and unsafe external calls. The only partial match focuses on the front-runnable nature of the `start` function but misses the broader economic implications.",0,1,4,10,"Okay, let's try to analyze this smart contract for vulnerabilities. The contract is called LenderPool and it's using Solidity 0.7.6. It imports several OpenZeppelin contracts, which is common, but sometimes even those can be misused. Let's go through the code step by step.

First, the constructor initializes some immutable addresses. Then there's an initialize function which sets up ReentrancyGuard and ERC1155. That's standard for upgradeable contracts. But since they're using initializer, I need to check if someone else can call initialize again. But the initializer modifier should prevent that, right? Unless there's a missing modifier here. Let me check the initialize function—yes, it's marked as external and uses initializer, so that should be okay.

Looking at the create function, it's called by onlyPooledCreditLine. So access control here is enforced. But when creating a new pooledCLConstants entry, are there any checks on the _id? Maybe if the same _id is reused, it could overwrite previous data. But since it's called by the PooledCreditLine contract, maybe that's handled there. Still, possible issue if the PooledCreditLine allows duplicate IDs.

In the lend function, the user provides _amount and it's checked against the borrowLimit. The code uses SafeMath, so no overflow here. The code transfers the tokens from the user to the contract and mints ERC1155 tokens. But since it's using safeTransferFrom, that's safe. However, the function is nonReentrant, which is good.

The start function calls _accept, which deposits the tokens into the savings account. It uses safeApprove, but in older versions of OpenZeppelin, safeApprove might have issues if the previous allowance isn't zero. Wait, the code does IERC20(_borrowAsset).safeApprove(_strategy, _amount); So if the strategy was already approved before, this might fail because safeApprove checks that the current allowance is zero. But in create, they set the allowance to max for POOLED_CREDIT_LINE. Wait, no. In create, after creating the pooledCLConstants, they check the allowance from this contract to POOLED_CREDIT_LINE. If it's not max, they approve max. But in _accept, they are approving the _strategy for _amount. But if there was a previous approval for the strategy, this could reset it. Suppose the strategy is the same as POOLED_CREDIT_LINE, but that's unlikely. Maybe not a vulnerability, but possible issue if the strategy was already approved.

In the terminate function, there's a lot of math. Let's see. They calculate _notBorrowed as borrowLimit minus principal. Then convert to shares. Then calculate _actualNotBorrowedInShares. Then sum with _totalInterestInShares. But if there's a division here, maybe there's a rounding error. For example, _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens) could truncate, leading to loss of precision. That might cause some tokens to be left in the contract unaccounted for. Similarly, when calculating shares for withdrawal, if there's any miscalculation, funds could be locked.

Looking at the withdrawLiquidity function, when the status is CANCELLED, they transfer the _liquidityProvided back. But _liquidityProvided is the balanceOf, which is in terms of ERC1155 tokens. However, the ERC1155 tokens are supposed to represent shares. But in the code, when you lend, you get 1:1 tokens. But when the funds are deposited into the savings account, they're converted to shares. However, during cancellation, the code just transfers the same amount of tokens as the ERC1155 balance. But if the tokens were deposited into a strategy that has interest, maybe the actual balance is higher. Wait, but during the start function, the code deposits into the savings account, so the ERC1155 tokens represent the initial amount, but the savings account shares could have increased. But in CANCELLED status, maybe the deposit never happened. Let me check: When the status is REQUESTED and then CANCELLED, the startTime is deleted, and in terminate, perhaps the funds are still in the contract. Wait, no. The terminate function is called when the pooled credit line is terminated. But during cancellation (status CANCELLED), the code in withdrawLiquidity transfers the _liquidityProvided (balance) directly from the contract. But if the contract hasn't deposited into the savings account yet (because the start function was not called), then the funds are in the contract's balance, so transferring them is okay. So in that case, the 1:1 transfer is correct.

But if the start function was called, and then somehow the status is CANCELLED, then the code may not handle it. Wait, no. Once the start function is called, the status transitions to ACTIVE, I think. Because start is supposed to accept the pooled credit line. So if the status is CANCELLED, the funds were never deposited into the savings account. So transferring the original amount is okay.

But let's check the _accept function: when _accept is called, it deposits the _amount into the savings account. So during the start function, the code transfers the tokens into the savings account. So the ERC1155 tokens represent the initial deposit, but once deposited into the savings account, the actual value in shares could be different. Wait, but in the code, they calculate sharesHeld as the result of SAVINGS_ACCOUNT.deposit. So if the tokens are deposited into the savings account, the contract holds shares. So during normal operation, when a lender withdraws, they should get their share of the principal and interest. But in the CANCELLED status, if the code didn't deposit into the savings account, then the tokens are still in the contract, and transferring 1:1 is okay.

Another possible issue: in the liquidate function, when collateral is transferred, the code uses safeTransfer. But if the collateral is a token with callbacks, like ERC777, there could be reentrancy. But the function is marked nonReentrant, so that's probably okay.

Looking at the _beforeTokenTransfer function. This is an override of the ERC115Upgradeable's _beforeTokenTransfer. The code checks that from and to are not the same. Then, for each id, if the recipient is not zero, they check that the recipient is not the borrower and that they are verified. Also, if transferring to a non-zero address, the token must be transferable. However, when minting (from is zero), these checks are bypassed. So when minting, the to address is the lender, which should have been checked in the lend function. But in the _beforeTokenTransfer, when minting (from == address(0)), they don't check if the to address is a valid lender. Wait, no. In the lend function, they check VERIFICATION.isUser(msg.sender, ...), but when tokens are transferred to another address, in _beforeTokenTransfer, for non-mint transfers, the to address must be a verified user. So when someone transfers their tokens to another address, the recipient must be verified. That's good. But when minting, the code doesn't check the to address. But in the lend function, the msg.sender is the one receiving the tokens, which was checked. So when minting, the to address is the lender, which was already verified. So that's okay.

Another thing: the _rebalanceInterestWithdrawn function is called during token transfers. When transferring tokens, the interest is recalculated. But there's a possibility of division errors here. For example, when calculating yieldInterestOnTransferAmount, they divide by fromBalance. If fromBalance is zero, this would fail, but the function requires fromBalance != 0. Also, using .div could truncate, leading to small amounts of interest being lost. For example, if a lender transfers a portion of their tokens, the division could leave some dust in the original lender's shares. Over time, this dust could accumulate. But that's a minor issue, though it could be considered a vulnerability if the amounts are significant.

Reentrancy: most functions have nonReentrant modifiers, which is good. But in the _withdrawLiquidity function, during the CANCELLED status, the code transfers the tokens to the user before burning them. Since it's using safeTransfer, which could call back into the contract. But since the function is nonReentrant, that should prevent reentrancy attacks. However, the _burn happens after the transfer. Wait, no: in the code for CANCELLED status, they transfer, then emit an event, and then the _burn is outside the if statements. Wait, looking at the code:

In withdrawLiquidity, after handling the status (CANCELLED, CLOSED, etc.), the code does _burn(msg.sender, _id, _liquidityProvided). So the burn happens after the transfer. But the nonReentrant modifier should prevent reentrancy. So even if the ERC20 token calls back into the contract, the reentrancy guard would block it. So that's safe.

Another possible issue: in the terminate function, when they delete pooledCLConstants[_id] and pooledCLVariables[_id], but mappings in Solidity can't be deleted entirely. So if the same _id is reused later, the old data might still exist. But since the code uses external calls to create with _id, it's up to the PooledCreditLine contract to ensure that _id is unique and not reused. If the PooledCreditLine allows reusing IDs, then this could lead to data corruption. So that's a possible vulnerability if the PooledCreditLine doesn't properly manage the _id uniqueness.

Also, in the _calculateLenderInterest function, the code uses multiple external calls to getSharesForTokens and getPrincipal. If any of these functions (like getPrincipal) can be manipulated, it could affect the calculations. But assuming that POOLED_CREDIT_LINE is a trusted contract, this might not be an issue. But if it's not, then it's a problem. But since the LenderPool is part of the same system, probably trusted.

Another thing: the code uses SafeMath, which is good for preventing overflows, but in Solidity 0.7.6, the compiler itself has built-in overflow checks for uint256. Wait, no—Solidity 0.8.x introduced default overflow checks. Since this is 0.7.6, SafeMath is necessary. The code uses SafeMath for uint256, which is correct.

In the _accept function, after depositing into the savings account, they set borrowLimit to _amount and delete startTime and minBorrowAmount. But if the borrowLimit was previously higher, this could affect other parts of the code that rely on the original borrowLimit. But since the function is called only once when starting, this might be intentional.

In the liquidate function, when calculating the lender's collateral share, they use _balance.mul(_collateralLiquidated).div(_currentSupply). If _currentSupply is zero, this would cause a division by zero. But the code requires that the user has a balance (checked in withdrawTokensAfterLiquidation), so _balance is non-zero. But if _currentSupply is zero, but the user's balance is non-zero, that would be a problem. However, totalSupply is tracked in the contract. When a user has a balance, totalSupply should be non-zero. So maybe this is safe.

Another possible issue is that the code allows transferring tokens even when the credit line is active, as long as the tokens are marked as transferable. But during an active credit line, transferring liquidity might affect interest calculations. However, the code tries to rebalance the interest when tokens are transferred. But there's a possibility that if a user transfers tokens after earning interest but before withdrawing, the new owner could claim that interest. But the code's _rebalanceInterestWithdrawn function is supposed to handle that by updating the withdrawn amounts for both parties. However, the precision loss due to division could lead to minor discrepancies.

In the withdrawLiquidity function, when the status is CLOSED or LIQUIDATED, they calculate the principal and interest to withdraw. The principal is based on the borrowed tokens. If the calculation of _principalWithdrawable is incorrect, users might not get the right amount. For example, _totalLiquidityWithdrawable is borrowLimit minus principal. If the principal is more than borrowLimit, this could underflow. But since borrowLimit is set to the total lent when the credit line is accepted, and the principal can't exceed that. Wait, the borrowLimit is set to _amount in _accept, which is the totalSupply[_id]. So when the credit line is accepted, the borrowLimit is equal to the total lent. Then, the principal (amount borrowed) can't exceed that. So _totalLiquidityWithdrawable would be borrowLimit - principal, which is non-negative. So no underflow here.

Another thing: when a credit line is LIQUIDATED, the code transfers collateral to the lender. But the collateral is held in the LenderPool contract. If the collateral is a different asset, but the code allows for that. However, when the liquidate function is called, the collateralAsset is set. But if the collateral is not properly tracked, there could be issues. For example, if multiple liquidations occur, but the code assumes that collateralHeld is only set once. But the code in liquidate sets pooledCLConstants[_id].collateralAsset and pooledCLVariables[_id].collateralHeld. If someone calls liquidate again, would it overwrite the collateral? The code has a check in liquidate that requires the user's lending share to be non-zero, but after the first liquidation, when the user withdraws, their balance is burned. So maybe only one liquidation can occur. But if multiple users call liquidate, they each get their share. The code in liquidate calls POOLED_CREDIT_LINE.liquidate, which presumably can only be called once. So maybe the first caller triggers the liquidation, and subsequent calls would fail. But that's up to the POOLED_CREDIT_LINE's implementation. If the LenderPool's liquidate function can be called multiple times, then collateralHeld could be overwritten. But the code in the liquidate function does not check if the credit line is already liquidated. For example, after the first liquidation, if someone else calls liquidate again, POOLED_CREDIT_LINE.liquidate might revert, but if not, this could cause collateralHeld to be overwritten. However, since POOLED_CREDIT_LINE is a separate contract, it's possible that once it's liquidated, further calls to liquidate would fail. So the LenderPool's code might be safe here.

In the terminate function, when the code deletes pooledCLConstants[_id], this sets all the struct's fields to their default values. However, mappings in the struct (like LenderPoolVariables.lenders) can't be deleted. So if terminate is called and then the same _id is reused, the old lender info might still exist. But again, this depends on the PooledCreditLine contract not reusing IDs.

Another possible issue is in the _calculateLenderInterest function. The code uses IYield(_strategy).getSharesForTokens and getTokensForShares. If the strategy's conversion between tokens and shares is manipulated or has rounding down, this could lead to incorrect interest calculations. But this depends on the implementation of the IYield strategy. If the strategy is trusted and correctly implemented, this isn't an issue. Otherwise, it could be a problem.

In the _rebalanceInterestWithdrawn function, when tokens are transferred, the code moves the withdrawn shares proportionally from the sender to the receiver. However, if the sender's withdrawn shares are not correctly adjusted, the sender could withdraw more than they should. For example, if a user transfers part of their tokens, the code subtracts a proportional amount of their withdrawn shares. But due to division truncation, the transferred amount might be less than the exact proportion, leading to a small discrepancy. This could allow the original sender to claim slightly more interest than they should. But since the code uses SafeMath's mul and div, which truncate, the error is minimal. However, over multiple transfers, this could accumulate. This is a potential precision loss vulnerability, but it's minor.

Another thing to check is the use of the onlyPooledCreditLine modifier. Functions like create, borrowed, repaid, etc., are only callable by the PooledCreditLine contract. If that contract is compromised, the LenderPool could be manipulated. But that's outside the scope of this contract's vulnerabilities.

Looking for front-running possibilities: For example, in the lend function, if the collection period is about to end, a lender could front-run the start transaction to get their funds in, but the code checks block.timestamp < startTime. However, since startTime is set as block.timestamp + collectionPeriod in create, and the collectionPeriod is presumably set when creating the credit line, this should be okay. But if the collection period is too short, there might be a race condition. But that's more of a parameter issue, not a code vulnerability.

In the terminate function, when the code withdraws the shares, it calculates _totalBorrowAsset as _actualNotBorrowedInShares.add(_totalInterestInShares). Then withdraws that amount. But if there's a miscalculation here, some shares might remain in the savings account. However, the code attempts to withdraw all possible shares. But due to possible truncations in previous calculations, there might be leftover shares, leading to locked funds. For example, if _notBorrowedInShares is calculated using getSharesForTokens which truncates, then _actualNotBorrowedInShares could be less than expected, leading to some shares not being withdrawn. This would leave dust in the contract, which is a minor issue.

In the withdrawLiquidity function, when status is CLOSED or LIQUIDATED, the code calls _calculatePrincipalWithdrawable. This function uses the current totalSupply[_id], which is the sum of all ERC1155 tokens. However, during withdrawals, the totalSupply is updated after the transfer. But since the function is nonReentrant and the burn happens after the transfer, the totalSupply is accurate at the time of calculation. Wait, no: the _burn happens at the end of the function. So during the calculation, the totalSupply is still the original value. Let's see: when a user withdraws, their balance is _liquidityProvided. The code calculates the principal and interest, then burns the tokens. So during the calculation, totalSupply is the original value, and the user's share is based on that. But if multiple users withdraw at the same time, the totalSupply could decrease between their transactions, leading to a larger share for later users. This could be a problem if the contract's funds are not sufficient to cover all withdrawals. For example, if the totalSupply is 100, and two users each have 50. The first user withdraws, gets 50/100 of the principal and interest. Then the second user withdraws, but the totalSupply is now 50, so 50/50 = 100%, which might not have enough funds. Wait, no: in the code, when a user withdraws, the code burns their tokens after processing the withdrawal. So the totalSupply is only updated after the funds are transferred. Therefore, if multiple users withdraw, each calculation uses the original totalSupply. So the first user gets 50/100, and the second also 50/100, which could sum to more than the available funds. Wait, but in reality, the code uses the current totalSupply when calculating. Let's see:

In _calculatePrincipalWithdrawable, it uses balanceOf(_lender, _id) which is the user's balance, and _borrowedTokens is the borrowLimit. So for each user, their share is (balance / totalSupply) * _totalLiquidityWithdrawable. But if the totalSupply is 100, and user A has 50, user B has 50. Both withdraw. User A's withdrawal calculates 50/100 * X, and user B's also 50/100 * X. But if the total X is 100, each gets 50, which is correct. But if the total X is less than 100, say 90, then each would get 45, totaling 90. However, if the code allows both to withdraw 45 each, but the contract only has 90, that's okay. So the code should handle this correctly as long as the math is accurate. But if the code is using totalSupply as the initial value, but during multiple withdrawals, the actual available funds decrease, there could be a problem. However, since the code is transferring the exact amount based on the shares at the time of withdrawal, even if subsequent withdrawals overdraw, the contract might not have enough funds. Wait, but in the code, when status is CLOSED or LIQUIDATED, the code is calculating based on the totalSupply, which is the sum of all ERC1155 tokens. When a user withdraws, their tokens are burned, so totalSupply decreases. However, the calculation for each user is based on their balance divided by the original totalSupply (since totalSupply hasn't been updated yet). So if two users withdraw, each with 50 out of 100 totalSupply, they each get 50% of the available funds, which is correct. The contract should have enough funds because the total available is based on the initial totalSupply. So even after burning, the calculations are based on the original shares.

But wait, in the code for CLOSED/LIQUIDATED status:

The user's _liquidityProvided is their balance. Then _principalWithdrawable is calculated as _totalLiquidityWithdrawable * (balance / _borrowedTokens). Wait, no: _calculatePrincipalWithdrawable does _totalLiquidityWithdrawable.mul(balanceOf).div(_borrowedTokens). Wait, but _borrowedTokens is pooledCLConstants[_id].borrowLimit, which was set to the totalSupply when the credit line was accepted. So _borrowedTokens is the same as the initial totalSupply. So for each user, their share is (balance / _borrowedTokens) * _totalLiquidityWithdrawable. So even if the totalSupply decreases due to burns, the calculation is based on the original borrowLimit (which was the initial totalSupply). Therefore, all users can withdraw their proportional share based on their original contribution. This ensures that even if the totalSupply decreases, the calculation remains accurate. So this part is handled correctly.

Another thing: in the _beforeTokenTransfer function, when transferring tokens, they call _rebalanceInterestWithdrawn. This function calculates the interest to be withdrawn by the sender and receiver. However, if the transfer is part of a larger batch transfer (since ERC1155 supports batch transfers), the code loops through each id and amount. But the current code's logic might not handle batch transfers correctly, but the code seems to loop through each id and process them individually. So that's okay.

Potential vulnerabilities identified so far:

1. Precision loss in interest calculations during token transfers due to division truncation. This could lead to dust amounts being locked or incorrect interest distribution.

2. If the PooledCreditLine contract reuses _id values, old data in LenderPool could be overwritten or interfere with new entries. But this depends on the external contract.

3. In the terminate function, when deleting pooledCLVariables and pooledCLConstants, mappings within LenderPoolVariables (like lenders) are not cleared. If the same _id is reused, previous lender info could still exist. This could lead to incorrect interest calculations if the same _id is reused.

4. During token transfers, if the token is not transferable (areTokensTransferable is false), transfers should be blocked. The code checks this in _beforeTokenTransfer, but only for non-mint and non-burn transfers. So users can't transfer if the tokens are not transferable. That's correct.

5. In the liquidate function, if the collateralAsset is set incorrectly or multiple times, it could lead to incorrect collateral distribution. But the code sets it once when liquidate is first called.

6. If the savings account strategy allows for negative interest (unlikely), the shares could decrease, leading to underflow in calculations. But the code uses SafeMath, so this would revert. However, in practice, strategies shouldn't lose value, but that's an assumption.

7. The start function can be called even after the credit line has started if certain conditions are met. The code checks block.timestamp >= _startTime and block.timestamp < endsAt. But if the endsAt is in the past, the start function would fail. However, the code requires block.timestamp < endsAt. But if the credit line's endsAt is set incorrectly, this could cause issues.

Possible vulnerabilities:

- Reentrancy in ERC20 transfers: But the nonReentrant modifier should block that.

- Division truncation in interest calculations leading to loss of funds.

- Incorrect handling of token transfers leading to interest miscalculations.

- Missing access controls: The code uses modifiers like onlyPooledCreditLine, which seems correct.

- Front-running in lending before the startTime: Users could add liquidity last minute, but the code allows that as long as it's before startTime.

Another thing to check is the handling of fees. If the contract takes a fee, but there's no code for that, but the given code doesn't mention fees, so maybe not applicable.

Another possible issue is that in the _accept function, the code approves the strategy for the _amount. But if the strategy was previously approved for a different amount, this could reset the allowance. For example, if the contract had already approved some amount to the strategy, this approval could be insufficient. But in this context, the _accept function is called once when starting, so it's supposed to approve the exact amount needed for the deposit. Since the code transfers the entire _amount into the strategy, the approval is for exactly that amount. However, some tokens (like USDT) require allowance to be set to zero before setting a new allowance. The safeApprove function from OpenZeppelin's SafeERC20 handles this by checking if the current allowance is zero. But in this code, they use safeApprove(_strategy, _amount). If there's an existing non-zero allowance, this would revert. So in the case where the strategy is the same as a previous one and has an existing allowance, the _accept function would fail. But the create function sets the allowance for POOLED_CREDIT_LINE to max, which is a different address. So if the _strategy is a new address each time, this isn't a problem. But if the same strategy is reused, the code could have issues. For example, if the strategy is used for multiple credit lines, each time _accept is called, it would try to approve _amount. But if there was a previous approval, safeApprove would check if the current allowance is zero. If not, it would revert. This would prevent the deposit. Therefore, the code assumes that each strategy is only used once per credit line, or that the previous allowance is zero. But if the same strategy is used for multiple credit lines, this could cause the approval to fail. This is a possible vulnerability if strategies are reused and previous allowances are not zero.

For example, suppose a strategy is used for _id 1, and then again for _id 2. When creating _id 2, during the create function, the code approves the POOLED_CREDIT_LINE to max. But during _accept for _id 2, it would approve the strategy for _amount. If there's a previous allowance left from another credit line, the safeApprove would fail. Therefore, this could prevent deposits into the strategy for subsequent credit lines using the same strategy.

This is a vulnerability because the code doesn't reset the allowance before approving. The correct approach would be to set the allowance to zero first, then approve the new amount. However, the safeApprove function does this check, but only if the current allowance is not zero. So if the current allowance is non-zero and not enough, safeApprove would revert. So in cases where the strategy has a previous allowance, the code would fail to deposit.

For example, suppose a previous deposit approved 100 tokens, and now trying to approve another 200. The safeApprove would see that the current allowance is 100 (non-zero), and thus revert. Therefore, the code would be unable to deposit into the strategy. This is a problem.

Therefore, this is a vulnerability: the code doesn't handle the case where a strategy has a previous non-zero allowance. The fix would be to first call safeApprove with 0, then with the new amount. But the code currently only calls safeApprove once. This is a potential issue.

Another thing: the code uses the same savings account for all deposits. If the savings account has a strategy that can be changed, but the code assumes it's fixed. But this is part of the system's design, so maybe not a vulnerability.

Possible list of vulnerabilities:

1. **Insufficient ERC20 Approval Handling in _accept Function**: The _accept function uses safeApprove for the strategy, which may fail if there's an existing non-zero allowance. This can prevent the deposit into the strategy if the same strategy is used in multiple credit lines.

2. **Precision Loss in Interest Calculations**: Due to integer division truncation in multiple places (e.g., _calculateLenderInterest, _rebalanceInterestWithdrawn), small amounts of interest might be lost, leading to dust amounts stuck in the contract.

3. **Incorrect Collateral Handling on Liquidation**: If the liquidate function is called multiple times, it may overwrite the collateralAsset and collateralHeld, but this depends on the PooledCreditLine's implementation. If it's allowed, this could lead to incorrect collateral distribution.

4. **Reused ID Leading to Data Corruption**: If the PooledCreditLine contract reuses the same _id for multiple credit lines, the LenderPool's data for that _id could be overwritten, leading to incorrect calculations or access to previous data.

5. **Token Transfer Restrictions Bypass**: If tokens are marked as non-transferable, the _beforeTokenTransfer function should prevent transfers. However, during minting (from address(0)), the recipient is not checked against the lender verifier. But in the lend function, the msg.sender is checked. However, if tokens are minted to an address that later loses verification, they can still hold the tokens but not transfer them unless the flag allows it. Not sure if this is a vulnerability.

6. **Potential Division by Zero in _calculateLenderInterest**: If _borrowLimit is zero (unlikely since minBorrowAmount is required), some divisions could fail. But checks in create and start functions prevent this.

7. **Improper Handling of Dust in terminate Function**: When terminating, the code may leave dust shares in the savings account due to truncation in calculations, leading to locked funds.

8. **Incorrect Withdrawal of Principal and Interest**: In the withdrawLiquidity function, when the status is CLOSED or LIQUIDATED, the code may miscalculate the withdrawable amounts due to incorrect use of shares vs. tokens, leading to users not receiving the correct amounts.

9. **Lack of Event Emission on Critical Operations**: Some functions may not emit events, making it hard to track off-chain. But the code includes events for key actions.

10. **Uninitialized Variables**: The LenderPoolVariables struct includes a mapping, which is automatically initialized. However, when a new credit line is created, the variables are initialized properly. But if an _id is reused, previous mappings could still exist.

After considering all these points, the main vulnerabilities are:

- The ERC20 approval issue in _accept (vulnerability 1).

- Precision loss leading to dust (vulnerability 2).

- Reused IDs leading to data issues (vulnerability 4).

- Potential division truncation in various calculations.

The others are either minor or depend on external factors."