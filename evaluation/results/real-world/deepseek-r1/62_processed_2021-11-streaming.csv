nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
Locke.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6655,856,"[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users “uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.
As a result:
- When the protocol governance calls `claimFees()` and `claim` accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken.
- Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.
  [H-02] Tokens can be stolen when `depositToken == rewardToken`
The `Streaming` contract allows the deposit and reward tokens to be the same token.
The reward and deposit balances are also correctly tracked independently in depositTokenAmount and rewardTokenAmount. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:
“function recoverTokens(address token, address recipient) public lock {}”
  [H-03] Reward token not correctly recovered
The Streaming contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.
However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:
“function recoverTokens(address token, address recipient) public lock {“
 
[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets
Function `arbitraryCall`
“function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {“
When an incentiveToken is claimed after `endStream`, `incentives[who]` will be 0 for that `incentiveToken`.
If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as who and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.
  [H-05] Possible incentive theft through the arbitraryCall() function
The `Locke.arbitraryCall()` function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).
However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().
  [H-06] Creating rewardTokens without streaming depositTokens function `updateStreamInternal`
`stake` and `withdraws` can generate rewardTokens without streaming depositTokens. It does not matter whether the stream is a sale or not.
The following lines can increase the reward balance on a `withdraw` some time after `stake`:   [H-07] Business logic bug in `_abdicate()` function - 2 Bugs
The `_abdicate()` function at  is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the ""gov"" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.
 
[H-08] ts.tokens sometimes calculated incorrectly
Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.
Now after some time he stakes some tokens again. At the second stake `updateStream()` is called and the following if condition is false because `ts.tokens==0`
“if (acctTimeDelta > 0 && ts.tokens > 0) {“
Thus `ts.lastUpdate` is not updated and stays at the value from the first withdraw. Now he does a second withdraw. `updateStream()` is called an calculates the updated value of `ts.tokens`. However it uses `ts.lastUpdate`, which is the time from the first withdraw and not from the second stake. So the value of `ts.token` is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.
  [H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max
reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.
 
[H-10] recoverTokens doesn't work when isSale is true
In `recoverTokens` function, the logic to calculate the excess number of deposit tokens in the contract is:
""uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.
  [M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens
Any airdrop gathered with arbitraryCall will be immediately lost as an attacker can track arbitraryCall transactions and back run them with calls to recoverTokens, which doesn't track any tokens besides reward, deposit and incentive tokens, and will give the airdrop away.
 
[M-04] arbitraryCall() can get blocked by an attacker
`arbitraryCall()` use case is to claim airdrops by ""gov"". If the address ""who"" is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable, because on L735 there is a `require(incentives[who] == 0, ""inc"");` that reverts if a ""who"" token was received as an incentive.
In this case the the `incentives[who]` can be set to 0 by the stream creator by calling claimIncentive() but only after the stream has ended according to require(block.timestamp >= endStream, ""stream""); (L520)
If the airdrop is only claimable before the end of the stream, then the airdrop can never be claimed.
If ""gov"" is not the stream creator then the stream creator must become also the ""gov"" because claimIncentive() only can be called by the stream creator and the arbitraryCall() only by ""gov"". If resetting incentives\[who] to 0 by calling claimIncentive() and arbitraryCall() for the ""who"" address doesn't happen atomic, an attacker can send between those two calls again a ""who"" token.",12,"pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";


contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    
    
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    
    
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}


contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    
    
    
    uint32 private immutable startTime;
    
    uint32 private immutable streamDuration;
    
    uint32 private immutable depositLockDuration;
    
    uint32 private immutable rewardLockDuration;

    
    uint32 private immutable endStream;
    
    uint32 private immutable endDepositLock;
    
    uint32 private immutable endRewardLock;

    
    address public immutable rewardToken;
    
    address public immutable depositToken;

    
    uint64 public immutable streamId;

    
    uint16 private immutable feePercent;
    
    bool private immutable feeEnabled;

    
    bool public immutable isSale;

    
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    

    
    
    uint112 private rewardTokenAmount;
    
    uint112 private depositTokenAmount;
    

    
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    

    
    uint256 private cumulativeRewardPerToken;
    

    
    uint256 private totalVirtualBalance;
    

    
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    

    
    mapping (address => TokenStream) public tokensNotYetStreamed;

    
    mapping (address => uint112) public incentives;

    
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    
    modifier updateStream(address who) {
        
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            
            cumulativeRewardPerToken = rewardPerToken();

            
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                
                
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) 
        public 
    {
        
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        
        require(feePercent < 10000, ""fee"");
    
        
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        
        streamId = _streamId;

        
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        
        if (feeEnabled) {
            
            
            
            
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

     
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        

        
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

     
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

     
    function exit() public updateStream(msg.sender) {
        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

     
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

     
    function claimIncentive(address token) public lock {
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

     
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        
        
        require(amount > 0, ""amt"");

        
        require(block.timestamp > endDepositLock, ""lock"");

        
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

     
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        
        cumulativeRewardPerToken = rewardPerToken();

        
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

     
    function creatorClaimSoldTokens(address destination) public lock {
        
        require(isSale, ""!sale"");

        
        require(!claimedDepositTokens, ""claimed"");
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

     
    function claimFees(address destination) public lock externallyGoverned {
        
        require(block.timestamp >= endStream, ""stream"");

        
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    

     
    function recoverTokens(address token, address recipient) public lock {
        
        
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            
            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            
            
            
            
            
            

            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        
        
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; 

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        
        require(incentives[who] == 0, ""inc"");
        
        require(who != depositToken && who != rewardToken, ""erc"");

        
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; 

    
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        
        
        
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",4772,10,2,"Here is a list of vulnerabilities identified in the provided smart contract code:

1. **Incorrect Accounting for Flashloan Fees (Critical)**  
   - **Description**: The `depositTokenFlashloanFeeAmount` is not included in the `depositTokenAmount` accounting. This allows the stream creator to recover these fees via `recoverTokens` before the governed address can claim them via `claimFees`, leading to loss of protocol fees.  
   - **Location**: `recoverTokens` function for `depositToken` calculations.

2. **Arbitrary External Call Vulnerability (High Risk)**  
   - **Description**: The `arbitraryCall` function allows the governed address to execute arbitrary calls to external contracts. If the governance is compromised, this can result in unauthorized fund transfers or contract manipulations.  
   - **Location**: `arbitraryCall` function in the Stream contract.

3. **Potential Fee Calculation Rounding Error (Medium Risk)**  
   - **Description**: For very small flashloan amounts, the fee calculation (`amount * 10 / 10000`) may round down to zero, enabling free flashloans and potential drain of fee reserves.  
   - **Location**: `flashloan` function fee computation.

4. **Incentive Token Recovery Race Condition (Medium Risk)**  
   - **Description**: The stream creator can recover incentive tokens via `recoverTokens` even if they were intended to be claimed via `claimIncentive`, creating a conflict in token ownership.  
   - **Location**: `recoverTokens` function and `claimIncentive` function.

5. **Lack of Reward Auto-Claim in `exit` (Low Risk)**  
   - **Description**: The `exit` function withdraws staked tokens but does not automatically claim accrued rewards, potentially causing users to lose unclaimed rewards.  
   - **Location**: `exit` function in the Stream contract.

6. **Centralized Risk in Governance Functions (Informational)**  
   - **Description**: Critical functions (e.g., `arbitraryCall`, `setEmergencyGov`) rely on trusted governance addresses, posing risks if the governance keys are compromised.  
   - **Location**: Governed and ExternallyGoverned modifiers.

7. **Insufficient Event Logging (Informational)**  
   - **Description**: Key state changes (e.g., fee parameter updates in the factory) lack event emissions, reducing transparency and auditability.  
   - **Location**: Functions modifying `streamParams` and `feeParams` in StreamFactory.

These vulnerabilities range from critical accounting errors to informational risks related to centralization and event logging. The most severe issues involve incorrect fee accounting and arbitrary external calls, which could directly lead to fund loss or protocol exploitation.","### **Comparison and Evaluation**

---

#### **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users**

**Report Description**:  
The `excess` calculation in `recoverTokens` does not exclude `depositTokenFlashloanFeeAmount`, allowing the stream creator to retrieve these fees. This can lead to insufficient balances when the protocol governance attempts to claim fees, or users may lose part of their deposits as fees are incorrectly transferred.

**Match in Response List**:  
Matches with **""Incorrect Accounting for Flashloan Fees (Critical)""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect accounting of `depositTokenFlashloanFeeAmount` in the `recoverTokens` function. It correctly highlights the risk of fund loss due to the stream creator recovering fees before the protocol governance can claim them.

---

#### **[H-02] Tokens can be stolen when `depositToken == rewardToken`**

**Report Description**:  
When the deposit and reward tokens are the same, the `recoverTokens` function allows the token to be recovered twice—once for deposits and once for rewards—leading to token theft.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `recoverTokens` function when deposit and reward tokens are identical.

---

#### **[H-03] Reward token not correctly recovered**

**Report Description**:  
The `recoverTokens` function incorrectly calculates the excess reward token amount as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`, leading to incorrect recovery of reward tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `recoverTokens` function for reward tokens.

---

#### **[H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets**

**Report Description**:  
The `arbitraryCall` function allows the protocol governance to execute arbitrary calls, including `transferFrom`, which can be used to steal funds from users' wallets if the governance is compromised.

**Match in Response List**:  
Matches with **""Arbitrary External Call Vulnerability (High Risk)""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of unauthorized fund transfers or contract manipulations due to the `arbitraryCall` function. It correctly highlights the potential for exploitation if the governance is compromised.

---

#### **[H-05] Possible incentive theft through the `arbitraryCall()` function**

**Report Description**:  
The `arbitraryCall` function can be used to set an allowance on an incentive token before the contract has received any of the token through `createIncentive`, enabling potential theft of incentives.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `arbitraryCall` function for incentive tokens.

---

#### **[H-06] Creating rewardTokens without streaming depositTokens**

**Report Description**:  
The `updateStreamInternal` function allows reward tokens to be generated without streaming deposit tokens, which can lead to incorrect reward balances.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `updateStreamInternal` function.

---

#### **[H-07] Business logic bug in `_abdicate()` function - 2 Bugs**

**Report Description**:  
The `_abdicate()` function does not consider the emergency governor and pending governor, allowing a pending governor to reclaim governance after abdication.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `_abdicate()` function.

---

#### **[H-08] ts.tokens sometimes calculated incorrectly**

**Report Description**:  
The `ts.tokens` calculation in `updateStream` can be incorrect due to an outdated `ts.lastUpdate` value, leading to incorrect token withdrawals.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `updateStream` function.

---

#### **[H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max**

**Report Description**:  
The `exit` and `withdraw` functions can revert due to overflow for high values, causing permanent loss of funds for users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `exit` and `withdraw` functions.

---

#### **[H-10] recoverTokens doesn't work when isSale is true**

**Report Description**:  
The `recoverTokens` function fails to correctly calculate excess deposit tokens when `isSale` is true, breaking the function's functionality.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical vulnerability in the `recoverTokens` function.

---

#### **[M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens**

**Report Description**:  
Airdrops gathered via `arbitraryCall` can be stolen by attackers using `recoverTokens`, as the function does not track these tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a medium-risk vulnerability in the `recoverTokens` function.

---

#### **[M-04] arbitraryCall() can get blocked by an attacker**

**Report Description**:  
An attacker can block `arbitraryCall` by sending an incentive token, preventing the governance from claiming airdrops.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a medium-risk vulnerability in the `arbitraryCall` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users**
- **[H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-02] Tokens can be stolen when `depositToken == rewardToken`**
- **[H-03] Reward token not correctly recovered**
- **[H-05] Possible incentive theft through the `arbitraryCall()` function**
- **[H-06] Creating rewardTokens without streaming depositTokens**
- **[H-07] Business logic bug in `_abdicate()` function - 2 Bugs**
- **[H-08] ts.tokens sometimes calculated incorrectly**
- **[H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max**
- **[H-10] recoverTokens doesn't work when isSale is true**
- **[M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens**
- **[M-04] arbitraryCall() can get blocked by an attacker**

---

The response list covers some critical issues but misses many others, particularly those related to token recovery, governance, and incorrect calculations. A more comprehensive review is needed to address all identified vulnerabilities.",2,0,12,7,"Okay, let's take a look at this smart contract code and try to find all the vulnerabilities. I'm going to start by reading through the code carefully and checking for common issues like reentrancy, access control problems, arithmetic overflows, and other security pitfalls.

First, looking at the Stream contract, which inherits from LockeERC20 and ExternallyGoverned. There's a modifier called 'lock' which uses a reentrancy guard with the 'unlocked' variable. That's a common pattern to prevent reentrancy attacks, so that's good. But let's check if all the functions that should be protected by this modifier are indeed using it. For example, the stake, withdraw, exit, fundStream, etc., have the lock modifier. But I need to check if any functions that change state don't have this, which could be a problem.

Looking at the updateStreamInternal function. It's called via the updateStream modifier. The function has several operations that update the state, like adjusting cumulativeRewardPerToken and the user's TokenStream. However, since the modifier is applied to functions like stake and withdraw, which are protected by the lock, maybe that's okay. But what about other functions that might call updateStreamInternal without the lock? Let me check. The exit function uses the updateStream modifier, which triggers updateStreamInternal. The exit function also calls withdraw, which has the lock. Hmm, maybe the exit function is covered. Not sure yet, but moving on.

Next, looking at the flashloan function. It transfers tokens to 'to' and then calls lockeCall on that address. This could be a reentrancy risk if the 'to' contract calls back into the Stream contract. However, the flashloan function is protected by the 'lock' modifier, so even if there's a reentrancy attempt, the unlocked variable would be set to 2, preventing reentrancy. So that's probably safe.

Another thing to check is the use of SafeTransferLib. The code uses safeTransfer and safeTransferFrom, which should handle tokens that don't return a boolean. But since Solidity 0.8, maybe some of those functions are compatible. Not sure, but using SafeTransferLib is generally a good practice.

Now, looking at the ERC20 balance updates. For example, in the fundStream function, they check the balance before and after transferring to calculate the actual amount received. That's important for handling fee-on-transfer tokens, but since the code uses this method, it should handle those tokens correctly. However, this might lead to unexpected behavior if the token's balance doesn't exactly match the transferred amount. For example, if a token takes a fee on transfer, the actual amount added to the contract is less than 'amount', but the code uses the difference in balances, which is correct. So maybe that's okay, but could be a consideration if not intended.

Now, looking for arithmetic issues. The code uses Solidity 0.8, which has built-in overflow checks, so unless there's some unchecked block, overflows shouldn't be a problem. Let me check. For example, in the dilutedBalance function, they multiply streamDuration by amount and then divide. Since all variables are uint256, but the parameters are uint32 and uint112, but with Solidity 0.8, multiplication could overflow if the numbers are too big. Wait, streamDuration is a uint32, so when cast to uint256, multiplied by amount (uint112), which is up to 2^112-1. 2^32 * 2^112 = 2^144, which is less than 2^256, so that's safe. Then divided by timeRemaining (uint32). The result should fit into a uint256. So arithmetic here is probably safe.

In the updateStreamInternal function, when updating ts.tokens, they subtract (acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)). Since acctTimeDelta is the time since last update, and endStream - ts.lastUpdate is the remaining time in the stream. However, if endStream - ts.lastUpdate is zero, this division could cause a division by zero. But endStream is startTime + streamDuration. The modifier updateStream is applied when block.timestamp < endStream. So in updateStreamInternal, the first check is if block.timestamp >= startTime. Then, if block.timestamp < endStream, we proceed. So when calculating endStream - ts.lastUpdate, ts.lastUpdate is set to startTime initially. If ts.lastUpdate is startTime and block.timestamp is after startTime but before endStream, then endStream - ts.lastUpdate is streamDuration. Which is a positive number. So division by zero should not happen here. But if somehow ts.lastUpdate is >= endStream, then (endStream - ts.lastUpdate) could be zero, leading to division by zero. How could that happen? Let's see. The updateStreamInternal is called when block.timestamp < endStream. So during the stream period. If ts.lastUpdate is set to startTime, and the stream is active, then endStream - ts.lastUpdate is streamDuration. If the user's lastUpdate is somehow set to a time after startTime but before endStream, then endStream - lastUpdate would be positive. So maybe division by zero is not possible here. But need to confirm.

Another potential issue is in the 'dilutedBalance' function. If timeRemaining is zero, then dividing by zero. But the function is called only when block.timestamp >= startTime, and during the stream period. Because in updateStreamInternal, the code checks if block.timestamp < endStream. Wait, no: the dilutedBalance function is called when staking, which is possible before the stream starts. Let me check the dilutedBalance function: if block.timestamp < startTime, returns amount. Otherwise, computes timeRemaining as endStream - block.timestamp. But if block.timestamp is >= endStream, then timeRemaining would be zero, leading to division by zero. However, the stake function is called with the updateStream modifier, which first calls updateStreamInternal. In updateStreamInternal, the first check is if block.timestamp >= startTime. Then, if block.timestamp < endStream. So during staking, if block.timestamp >= endStream, the updateStreamInternal would not update anything. But if the stake function is called after the stream has ended (block.timestamp >= endStream), then the modifier updateStream would check that block.timestamp < endStream and revert because the require statement in updateStreamInternal's first line says require(block.timestamp < endStream, ""!stream""). Wait, looking at the code:

In the modifier updateStream, the function updateStreamInternal is called. In updateStreamInternal, the first line is:

require(block.timestamp < endStream , ""!stream"");

So if someone tries to call stake after the stream has ended, the updateStreamInternal will revert. Therefore, dilutedBalance is only called when block.timestamp < endStream. Therefore, timeRemaining = endStream - block.timestamp, which is positive. So division by zero is not possible here.

Next, looking for access control issues. The Stream contract is ExternallyGoverned, which means that certain functions are restricted to the gov contract's gov() address. For example, the claimFees function has the externallyGoverned modifier, which checks that msg.sender is gov.gov(). Similarly, the arbitraryCall function is externallyGoverned. The StreamFactory is Governed, which has a governed modifier requiring msg.sender == gov. So the access controls seem properly set, but let's check if any functions are missing access control.

For example, the recoverTokens function in Stream requires that msg.sender == streamCreator. That's okay, but if the stream creator is compromised, they could recover tokens. But that's a trust assumption. The createIncentive and claimIncentive functions are accessible to anyone, but claimIncentive requires msg.sender == streamCreator. So that's okay.

Another issue could be in the emergencyGov functions. The Governed contract has an emergency_gov, which can perform certain actions. For example, the setEmergencyGov function can be called by the governed (gov) to change the emergency_gov. The emergency_governed modifier allows either gov or emergency_gov to call functions. But looking at the Stream contract, I don't see any functions using the emergency_governed modifier. The ExternallyGoverned contract's modifier externallyEmergencyGoverned allows either gov.gov() or gov.emergency_gov(). But the Stream contract doesn't use this modifier in any functions. So maybe the emergency gov functionality isn't used here, which could be a missed access control, but not a vulnerability unless there's a function that should have it and doesn't.

Looking at the StreamFactory's createStream function. It's public, so anyone can create a stream. But the parameters are validated, like startTime must be >= block.timestamp, stream duration must be within the configured min and max. The factory's parameters are set by the governed address. So that seems okay.

Another potential issue is in the arbitraryCall function. It allows the externally governed address to call any contract with arbitrary data. This could be dangerous if the governed account is compromised, as it could lead to arbitrary code execution. However, this is a privileged function intended for the governor, so it's a feature rather than a vulnerability, but it's a risk if the governor is malicious or compromised. Since the question is about vulnerabilities in the code, this could be considered a potential backdoor, but if the governance is trusted, it's acceptable. However, from a code perspective, this function allows for arbitrary external calls, which is risky.

In the flashloan function, after transferring the tokens, it calls LockeCallee(to).lockeCall(msg.sender, token, amount, data). The fee is 0.1% (amount * 10 / 10000), which is 0.1%. But if the fee calculation is incorrect, it could lead to undercharging or overcharging. For example, 10 / 10000 is 0.1%, which seems correct. But if the amount is very small, the fee might be zero due to integer division. However, the function requires amount > 0, and the feeAmt is calculated as amount * 10 / 10000. If amount is less than 1000, then feeAmt would be zero. For example, amount=999, 999*10=9990, divided by 10000 is 0. So in that case, the fee would be zero. Is that a problem? Maybe not, but it's a possible issue if the protocol expects a minimum fee. However, the code allows it, so that's a possible oversight.

Another thing to check is the tokenAmounts function, which returns rewardTokenAmount, depositTokenAmount, etc. These variables are updated when staking or funding. But if there's a way for these variables to become out of sync with the actual balances, that could be a problem. For example, if someone sends tokens directly to the contract without going through the stake or fund functions, the contract's internal accounting wouldn't reflect that. However, the recoverTokens function allows the stream creator to recover excess tokens, which would handle such cases. So that's a possible issue but mitigated by the recover function.

In the claimReward function, after transferring the reward tokens, it's possible that the rewardTokenFeeAmount could be included in the balance. But the code subtracts the rewardTokenAmount and rewardTokenFeeAmount when recovering. Wait, looking at the recoverTokens function for rewardToken: it checks if block.timestamp > endRewardLock, then calculates excess as balance - (rewardTokenAmount + rewardTokenFeeAmount). So if the rewardTokenAmount is the amount allocated for rewards, and rewardTokenFeeAmount is the fees, then the excess would be any tokens that are not part of those. But if someone sends extra reward tokens to the contract, they could be recovered by the stream creator after the lock period. So that's handled.

Another possible issue is in the stake function. When staking, the code mints LockeERC20 tokens if it's not a sale. However, in a sale scenario (isSale = true), the _mint is skipped. But the withdraw function burns the tokens only if it's not a sale. So in a sale, users stake deposit tokens but don't receive any ERC20 tokens. When they withdraw, the depositTokenAmount is decreased, but since there's no burn, the total supply of LockeERC20 tokens would not match the depositTokenAmount. Wait, the LockeERC20 is initialized with the depositToken and streamId. In the constructor of Stream, which inherits LockeERC20, the constructor is called with LockeERC20(_depositToken, _streamId, _startTime + _streamDuration). So the LockeERC20 is a token that represents the staked deposit tokens. However, in the stake function, when isSale is true, the _mint is skipped. So users who stake in a sale do not receive any LockeERC20 tokens, meaning they can't later burn them to withdraw. But the withdraw function checks if it's a sale and skips the burn. Wait, in the withdraw function:

if (!isSale) {
    _burn(msg.sender, amount);
} else {
}

But when a user stakes in a sale, they don't get minted tokens, so when they try to withdraw, the _burn would fail because their balance is zero. However, in the stake function when isSale is true, the code does not mint, so the user's balance is zero. But the withdraw function attempts to burn tokens only if it's not a sale. So in the case of a sale, the code skips the burn. That seems okay. Wait, let me check:

In the withdraw function:

ts.tokens -= amount;

...

if (!isSale) {
    _burn(msg.sender, amount);
} else {
}

So when isSale is true, the burn is skipped. But the user's ts.tokens (their staked amount) is being reduced, and the depositToken is transferred back. However, since in a sale, the staker doesn't have LockeERC20 tokens, but the code allows them to withdraw their deposit tokens by reducing their ts.tokens. But how is the ts.tokens tracked? Because in a sale, the user's balance in the LockeERC20 token is zero, so trying to burn would fail. But the code doesn't burn in a sale. So this seems okay. The ts.tokens is part of the TokenStream struct and is separate from the ERC20 balance. So in a sale, the ERC20 tokens are not used, and the TokenStream's tokens field is used to track the staked amount. So that's okay.

Wait, but in the stake function:

if (!isSale) {
    _mint(msg.sender, trueDepositAmt);
} else {
}

So in a sale, no tokens are minted. The user's TokenStream.tokens is incremented by trueDepositAmt. Then, when they withdraw, TokenStream.tokens is checked, and if they have enough, it's reduced. So even without the ERC20 tokens, the withdraw function can be called as long as the user has a TokenStream.tokens balance. But how is authorization handled? Because in the withdraw function, the code uses the updateStream modifier, which is msg.sender-based. So the TokenStream is per address, so each user's own TokenStream is modified when they call withdraw. So even without ERC20 tokens, the code tracks the staked amount via the TokenStream struct. That seems okay, but this could be a design choice. However, this could lead to a situation where a user's TokenStream.tokens is positive, but they can't withdraw because the ERC20 balance is zero. Wait, no: in the withdraw function, when isSale is true, the code doesn't check the ERC20 balance. So in a sale, users can stake and withdraw without needing ERC20 tokens. The ERC20 is only used for non-sale streams. So this is intentional and not a vulnerability, but a feature.

Another possible issue is in the exit function. It calls withdraw(amount), which is the user's entire staked amount. But if the user has some rewards, those are not automatically claimed. The exit function only withdraws the staked tokens, not the rewards. The user would need to call claimReward separately. That's a UX consideration but not a vulnerability.

Looking at the ERC20 integrations. For example, the depositToken and rewardToken are immutable addresses set in the constructor. So no risk of them being changed later. The SafeTransferLib is used for transfers, which is good.

Now, considering the fee calculations. In fundStream, if feeEnabled is true, the fee is calculated as feePercent * amount / 10000. Then, the amt is amount - feeAmt. But if feePercent is 10000, then feeAmt would be amount, leading to amt = 0. However, the constructor of Stream checks that feePercent < 10000. So in the Stream's constructor, there's a require(feePercent < 10000, ""fee""). So that's prevented. However, the feePercent is set by the StreamFactory's feeParams, which is governed. So if the governed address sets a feePercent >= 10000, creating a Stream would revert. But the StreamFactory's updateFeeParams function has a require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee""), where MAX_FEE_PERCENT is 500 (5%). So this check ensures that feePercent can't be set to 10000 or more. Wait, looking at the StreamFactory code:

MAX_FEE_PERCENT is 500, which is 5% (since 500 / 10000 = 5%). So when creating a Stream, the feePercent is taken from the factory's feeParams, which is limited to <=500. Therefore, in the Stream's constructor, the require(feePercent < 10000) is redundant but safe.

Another thing to check is the initializer for the LockeERC20. The Stream inherits from LockeERC20, which is presumably an ERC20 implementation. If LockeERC20 doesn't initialize the ERC20 correctly (like not calling __ERC20_init in an upgradeable contract), that could be an issue. But since the code isn't provided, it's hard to say. Assuming LockeERC20 is properly implemented, this is not a vulnerability here.

In the arbitraryCall function, the code checks that the 'who' address is not the depositToken or rewardToken, and that incentives[who] == 0. But after the call, it checks that the deposit and reward token balances haven't changed. However, if the arbitrary call manipulates the balances of other tokens (like incentive tokens), that's allowed. But the 'incentives' mapping is for other tokens, so if the 'who' is an incentive token, the check incentives[who] == 0 would prevent calling it. But the arbitraryCall could still interact with other tokens not in the incentives mapping. However, the recoverTokens function allows the stream creator to recover any tokens, including those manipulated via arbitraryCall. So this could be a way to drain other tokens if the governed address is malicious. But again, this is a governance risk, not a code vulnerability per se.

Potential vulnerabilities found so far:

1. Division by zero in certain edge cases. But after checking, seems mitigated by requires.

2. Reentrancy in flashloan. But protected by the lock modifier.

3. Incorrect fee calculation leading to zero fees for small amounts. Possible but depends on design.

4. The arbitraryCall function allows governed address to perform arbitrary external calls, which is a risk if the governor is compromised.

Wait, the arbitraryCall function has the externallyGoverned modifier, meaning only the gov.gov() can call it. If the governance is malicious, they can use this to do anything, including stealing funds. But this is an admin privilege, so it's a centralization risk rather than a code vulnerability. However, in the context of a vulnerability list, this could be mentioned as a potential issue.

Another possible vulnerability is in the recoverTokens function. When recovering depositToken, it calculates excess as ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens). However, depositTokenAmount is the total staked, and redeemedDepositTokens is the amount claimed via claimDepositTokens. So the remaining deposit tokens should be depositTokenAmount - redeemedDepositTokens. But if there's a flashloan fee (depositTokenFlashloanFeeAmount), which is part of the contract's balance but not accounted for in depositTokenAmount. So when calculating excess, depositTokenFlashloanFeeAmount is part of the balance but not subtracted. For example, if the contract has depositTokenAmount = 100, redeemedDepositTokens = 50, and depositTokenFlashloanFeeAmount = 10, the actual balance would be 100 -50 +10 = 60. The excess would be 60 - (100 -50) = 10. But the code calculates excess as balance - (depositTokenAmount - redeemedDepositTokens). However, depositTokenFlashloanFeeAmount is part of the balance. So the excess would correctly include the flashloan fees. But the code allows the streamCreator to recover that excess, which is correct because the fees are supposed to be claimable via claimFees by the governed address. However, in the recoverTokens function, if the token is depositToken, after endDepositLock, the streamCreator can recover the excess, which includes the flashloan fees. But the flashloan fees should be claimable by the governed via claimFees. This creates a conflict where both the streamCreator and the governed could claim the fees. For example, if the streamCreator recovers the depositTokenFlashloanFeeAmount via recoverTokens, then when the governed calls claimFees, there would be nothing left. So this is a potential issue of double-claiming or incorrect accounting.

Looking at the recoverTokens function for depositToken:

excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens)

But depositTokenFlashloanFeeAmount is part of the contract's balance. However, depositTokenAmount is the total staked, redeemedDepositTokens is the amount withdrawn. The depositTokenFlashloanFeeAmount is stored separately. So when calculating excess, the code subtracts (depositTokenAmount - redeemedDepositTokens), which is the remaining staked tokens. The flashloan fees are in addition to that. Therefore, the excess would include the flashloan fees, allowing the streamCreator to recover them via recoverTokens. However, the flashloan fees should be claimable by the governed address via claimFees. This is a vulnerability because the streamCreator could take the flashloan fees before the governed does, leading to loss of fees for the protocol.

Similarly, for rewardToken, the recoverTokens function calculates excess as balance - (rewardTokenAmount + rewardTokenFeeAmount). But if there are flashloan fees in rewardToken (from flashloans of rewardToken), those fees are stored in rewardTokenFeeAmount. However, when the code calculates excess, it subtracts (rewardTokenAmount + rewardTokenFeeAmount), so any additional tokens (like someone sending tokens directly) would be considered excess. But flashloan fees in rewardToken are part of rewardTokenFeeAmount, so they wouldn't be considered excess. Wait, no: when a flashloan is done with rewardToken, the fee is added to rewardTokenFeeAmount. So the code in flashloan does:

rewardTokenFeeAmount += feeAmt;

Therefore, when recoverTokens is called for rewardToken, the excess is balance - (rewardTokenAmount + rewardTokenFeeAmount). The rewardTokenFeeAmount is part of the contract's allocated fees, so they are not considered excess. Therefore, the flashloan fees for rewardToken cannot be recovered by the streamCreator via recoverTokens, only via claimFees by governed. However, for depositTokenFlashloanFeeAmount, those fees are part of the contract's balance but not accounted for in depositTokenAmount. Therefore, when recoverTokens is called for depositToken, the excess would include depositTokenFlashloanFeeAmount, allowing the streamCreator to withdraw them, even though they should be claimable by governed via claimFees. This is a problem because the depositTokenFlashloanFeeAmount is supposed to be fees for the protocol, but the streamCreator can recover them, stealing the fees.

So this is a vulnerability: the depositTokenFlashloanFeeAmount is not included in the depositTokenAmount, so when calculating excess deposit tokens, the flashloan fees are considered excess and can be recovered by the streamCreator, bypassing the governed's ability to claim them via claimFees.

Similarly, the rewardTokenFlashloan fees are added to rewardTokenFeeAmount, which is included in the recoverTokens calculation, so they can't be recovered by the streamCreator. But depositTokenFlashloan fees are stored in depositTokenFlashloanFeeAmount, which is not part of depositTokenAmount, so when recoverTokens is called for depositToken, the excess includes those fees.

Another example: suppose the contract has depositTokenAmount = 100, redeemedDepositTokens = 50, and depositTokenFlashloanFeeAmount = 10. The total depositToken balance would be 100 - 50 + 10 = 60. When recoverTokens is called for depositToken, the excess is 60 - (100 -50) = 60 -50 =10, which is the depositTokenFlashloanFeeAmount. The streamCreator can then recover those 10 tokens, but those were supposed to be claimable via claimFees by the governed. Therefore, this is an accounting error allowing the streamCreator to steal flashloan fees meant for the protocol.

This is a critical vulnerability because it allows the stream creator to drain the flashloan fees that should be reserved for the governed.

Another issue is in the claimFees function: it transfers both rewardTokenFeeAmount and depositTokenFlashloanFeeAmount. But if the depositTokenFlashloanFeeAmount has been taken by the streamCreator via recoverTokens, then when claimFees is called, it would transfer zero or a reduced amount. Therefore, the fees are not safely accounted for.

So the root cause is that depositTokenFlashloanFeeAmount is not included in the depositTokenAmount, so when calculating the excess in recoverTokens, it's considered excess and can be stolen by the streamCreator.

Similarly, if the streamCreator calls recoverTokens before the governed claims the fees, the governed would get nothing.

This is definitely a vulnerability.

Another potential issue: when creating an incentive with createIncentive, the token is added to incentives[token]. However, if the same token is used as depositToken or rewardToken, the createIncentive function will revert because of the require(token != rewardToken && token != depositToken, ""inc""). So that's okay.

In the claimIncentive function, after the stream has ended, the streamCreator can claim the incentive tokens. But if someone else sends tokens to the contract address, those could be recovered via recoverTokens, as long as they are not part of incentives. But incentives are only for tokens that were explicitly incentivized via createIncentive.

Another possible issue is that the incentives mapping doesn't track the actual token balance. For example, if someone sends tokens to the contract without calling createIncentive, those can be recovered by the streamCreator as long as the token is not depositToken or rewardToken and block.timestamp >= endStream. But that's intended.

Another vulnerability could be in the arbitraryCall function. Even though it checks that the token balances of depositToken and rewardToken haven't changed, it doesn't check the balances of other tokens, like incentive tokens. So the governed could call arbitraryCall on an incentive token's contract and manipulate its balance. However, the incentives mapping for that token would still track the original amount, and the excess could be recovered by the streamCreator. So this might allow the governed to steal incentive tokens by transferring them out via arbitraryCall, but the incentives[token] would still show the original amount, leading to discrepancies.

But the arbitraryCall function requires that incentives[who] == 0, meaning that the called contract address cannot be an incentive token. Wait, the code has:

require(incentives[who] == 0, ""inc"");

So if 'who' is an incentive token, incentives[who] would be the amount, which is >0, so the require would fail. Therefore, the arbitraryCall cannot be used on incentive tokens. So that's okay.

In summary, the key vulnerabilities I've identified are:

1. **Incorrect Accounting for Flashloan Fees in depositToken**  
   The `depositTokenFlashloanFeeAmount` is not included in the `depositTokenAmount`, allowing the stream creator to recover these fees via `recoverTokens` before the governed can claim them via `claimFees`. This results in a loss of protocol fees.

2. **Arbitrary External Call in `arbitraryCall` Function**  
   The `arbitraryCall` function allows the governed address to perform arbitrary calls to any contract (except incentive tokens and the deposit/reward tokens). If the governed account is compromised, this can lead to unauthorized actions, including fund theft.

3. **Potential Division by Zero in `dilutedBalance`**  
   Although checks are in place to prevent division by zero, if the `timeRemaining` calculation in `dilutedBalance` ever results in zero (due to incorrect timing logic), it could cause a revert. However, the require statements in `updateStreamInternal` mitigate this risk.

4. **Incorrect Fee Calculation for Small Amounts in Flashloan**  
   For very small flashloan amounts, the fee calculation may round down to zero, allowing users to take flashloans without paying fees. This could be exploited to drain funds if not properly managed.

5. **Incentivized Token Recovery Conflict**  
   The `recoverTokens` function allows the stream creator to recover any excess tokens, including those sent accidentally. However, if another function (like `claimIncentive`) is supposed to handle these tokens, there might be a race condition where the stream creator can claim them first.

6. **Unprotected `exit` Function**  
   The `exit` function allows users to withdraw their staked tokens but does not automatically claim their rewards. Users might forget to claim rewards separately, leading to potential loss of funds if rewards are time-sensitive.

7. **Lack of Event Emission for Critical Functions**  
   Some functions (like state variable changes in `updateStreamParams` and `updateFeeParams` in the factory) emit events, but others might not, leading to poor traceability.

After reviewing, the most critical issues are the first two: the flashloan fee accounting error allowing the stream creator to steal fees, and the arbitrary call function posing a governance risk.","```
1. Incorrect Accounting for Flashloan Fees (Critical)
2. Arbitrary External Call Vulnerability (High Risk)
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect Accounting for Flashloan Fees (Critical)"" appears at rank 1.
   - ""Arbitrary External Call Vulnerability (High Risk)"" appears at rank 2.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 2: \( P@2 = \frac{2}{2} = 1.0 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 1.0}{2} = 1.0 \)

**Output**:
```
1.0
```",1