nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5808.0,615.0,"[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets
In the NFTXMarketplaceZap.sol contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
“require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance”);""
A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAndSwap721WETH() should return unused weth/eth back to `msg.sender` instead of `to`
function `buyAndSwap721WETH`   [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address
`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] `buyAndSwap1155WETH` Does Not Work As Intended
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873.0,2,4,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect NFT Transfer Leading to Failed Mint/Swap**  
   - **Severity**: Critical  
   - **Description**: In `_mint721` and `_swap721`, NFTs are transferred directly to the vault instead of the contract itself. The vault's `mint` and `swap` functions require the caller (contract) to hold the NFTs, which they no longer do after direct transfer to the vault. This results in failed transactions.

2. **Out-of-Bounds Array Access in `mintAndSell1155` Functions**  
   - **Severity**: High  
   - **Description**: The `mintAndSell1155` and `mintAndSell1155WETH` functions loop over the `ids` array to sum `amounts[i]`, but `amounts` (from swap results) has a fixed length (e.g., 2 elements). This mismatch causes out-of-bounds errors for `ids.length > 2`, reverting transactions.

3. **Hardcoded INIT_CODE_HASH in Pair Calculation**  
   - **Severity**: High  
   - **Description**: The `pairFor` function uses a hardcoded `INIT_CODE_HASH` for SushiSwap. If deployed on a chain with a different hash (e.g., a fork), pair addresses will be miscalculated, leading to failed swaps or unintended token interactions.

4. **Underflow in Redeem Fee Calculation**  
   - **Severity**: Medium  
   - **Description**: In `buyAndRedeem` and similar functions, `specificIds.length` could exceed `amount`, causing underflow in `(amount - specificIds.length)`. This reverts transactions due to arithmetic errors.

5. **CryptoPunk Handling Without ETH**  
   - **Severity**: Medium  
   - **Description**: When transferring CryptoPunks, `transferFromERC721` calls `buyPunk` without sending ETH. This fails because buying a Punk requires payment, locking transactions involving Punk transfers.

6. **Payable Functions with Unused `msg.value`**  
   - **Severity**: Low  
   - **Description**: Functions like `buyAndSwap721WETH` are marked `payable` but do not use `msg.value`, allowing ETH to be sent accidentally and trapped in the contract.

7. **Insufficient ERC20 Approval Handling**  
   - **Severity**: Low  
   - **Description**: Using `approve` in `_sellVaultTokenWETH` may fail for tokens requiring reset-to-zero allowances (e.g., USDT), though mitigated by per-transaction approval.

8. **Incorrect Fee Balance Check in `_mint721`**  
   - **Severity**: Low  
   - **Description**: Assumes the vault's `mintFee` is per NFT, which may not hold true for alternative fee structures, risking incorrect balance checks and transaction failures.","### **Output**

---

**[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**

**Report Description**:  
In the `NFTXMarketplaceZap.sol` contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken. However, when executing the `_buyVaultToken` method, `msg.value` is used instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, potentially causing a loss of user assets.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The failure to use `maxWethIn` instead of `msg.value` is a critical oversight that could lead to transaction failures and asset loss, but it is not covered in the response list.

---

**[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user owning a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is because every operation involving vToken minting checks:  
`require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");`  
A malicious user could transfer any amount > 0 of a vault’s vToken to the marketplace or staking zap contracts, making the vault functionality unavailable for all users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability for a malicious user to lock vault functionality by transferring vTokens is a significant security concern, but it is not mentioned in the response list.

---

**[M-01] Missing non-reentrancy modifier**

**Report Description**:  
Several functions are missing the `nonReentrant` modifier, although other public/external functions use it. While no exploit was identified, the absence of the modifier in these functions could pose a reentrancy risk, especially since other functions in the contract are protected.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The absence of the `nonReentrant` modifier in certain functions is a potential security risk, but it is not covered in the response list.

---

**[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**

**Report Description**:  
The `buyAndSwap721WETH` function should return unused WETH/ETH back to `msg.sender` instead of `to`. This is a logical error that could lead to unintended asset transfers.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect handling of unused WETH/ETH is a logical error that could lead to unintended consequences, but it is not mentioned in the response list.

---

**[M-04] NFTXStakingZap and NFTXMarketplaceZap's `transferFromERC721` transfers CryptoKitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function should transfer NFTs from `msg.sender` to `to`. However, when the ERC721 is a CryptoKitty, it transfers to `address(this)` instead. This is likely a mistake that leads to incorrect NFT accounting, as the NFT will be missed in the vault (which is `to`).

**Match in Response List**:  
Matches with the issue titled **""CryptoPunk Handling Without ETH""**.

**Validation**:  
**Partially Correct**. The response identifies a similar issue with CryptoPunk handling but does not address the specific problem of CryptoKitties being transferred to the wrong address. The core issue of incorrect NFT accounting is partially covered but not fully addressed.

---

**[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. However, the `_buyVaultToken` call uses `msg.value` instead of `maxWethIn`. As a result, the function will not work unless the user supplies both WETH and native ETH amounts equivalent to `maxWethIn`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect use of `msg.value` instead of `maxWethIn` is a critical flaw that prevents the function from working as intended, but it is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] NFTXStakingZap and NFTXMarketplaceZap's `transferFromERC721` transfers CryptoKitties to the wrong address**

**Missed Issues from Issue Report**:  
- **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**  
- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**  
- **[M-01] Missing non-reentrancy modifier**  
- **[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**  
- **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

--- 

**Conclusion**:  
The response list fails to address the majority of the issues reported in the issue list. Only one issue is partially covered, while the rest are either incorrectly addressed or completely missed. This indicates significant gaps in the response list's coverage and accuracy.",0,1,5,8,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called NFTXMarketplaceZap, and it seems to handle interactions with NFT vaults and swaps on SushiSwap. 

First, I'll start by checking for common issues like reentrancy. The contract uses the nonReentrant modifier from ReentrancyGuard, so that's good. But wait, maybe there are places where the modifier is missing? Let me check the functions. 

Looking at the functions, most of them have the nonReentrant modifier. For example, mintAndSell721, buyAndSwap721, etc. But what about the functions that are internal? Like _swap721 or _mint721. They don't have the modifier, but they are called by functions that do. So that's probably okay.

Next, let's look at ERC721 and ERC1155 transfers. The transferFromERC721 function has some logic for CryptoKitties and CryptoPunks. For CryptoPunks, it calls buyPunk, which might transfer ownership. But if the contract is not the owner, this could fail. Wait, the code checks if the owner is msg.sender before calling buyPunk. But in the transferFromERC721 function, when the asset is punks, they check the owner via a staticcall. So if the owner is msg.sender, then they proceed to buyPunk. But wait, buying a punk requires paying ETH, right? Because buyPunk is called here. But where is the ETH coming from? The function is called during a transferFrom, which might not include ETH. That could be a problem. Because when they call buyPunk, the contract would need to send the punk's price, but in this code, they're not providing any ETH. That would cause the call to fail, leading to a revert. So this is a vulnerability. The code assumes that the contract can buy the punk without sending ETH, which isn't the case. So transferring CryptoPunks might not work correctly here.

Another thing is the approveERC721 function. For CryptoPunks, they call offerPunkForSaleToAddress. But is this the correct way to approve? Maybe not. The standard approve function isn't available for punks, so they use offerPunkForSale, but setting the price to zero. However, I'm not sure if this is the right approach. Also, if someone else buys the punk before the contract does, it could cause issues. But maybe that's a known limitation, but from a security standpoint, this could be a problem if the approval isn't handled correctly, leading to failed transactions or unintended transfers.

Looking at the _buyVaultToken function, it uses swapTokensForExactTokens. The parameters are minTokenOut and maxWethIn. Wait, the function is swapping WETH for vault tokens. The maxWethIn is the maximum amount the user is willing to spend. But in the parameters for sushiRouter.swapTokensForExactTokens, the first parameter is the exact amountOut, and the second is the max amountIn. So this seems correct. But maybe there's a slippage issue here if the minTokenOut is not calculated properly. But that's more of a user input issue.

In the mintAndSell1155 function, there's a line that says 'uint256[] memory amounts = _sellVaultTokenETH(...);' but then the code uses 'amounts[i]' in a loop. Wait, 'amounts' here refers to the amounts from the swap, which is an array of the path's token amounts. Then they loop over 'ids.length' which might not match the 'amounts' array. Wait, no. Let me check. The function is trying to calculate 'count' by summing 'amounts[i]', but 'amounts' here is from the swapExactTokensForETH call, which returns an array where the last element is the amount of ETH received. So, using amounts[1] (as in the emit line) might be correct, but in mintAndSell1155, after getting 'amounts' from _sellVaultTokenETH, they loop through 'ids' and sum 'amounts[i]'. But if 'amounts' is the result of a swap, which is a 2-element array (since swapping from vault token to WETH to ETH?), then accessing amounts[i] where i is beyond 1 would cause an out-of-bounds error. Wait, no. The function 'mintAndSell1155' has a line:

uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

Then:

uint256 count;
for (uint256 i = 0; i < ids.length; i++) {
    count += amounts[i];
}

But the 'amounts' array here is the result of swapping vault tokens to ETH via the given path. The length of 'amounts' depends on the path length. For example, if the path is [vault, WETH], then amounts would have 2 elements: [vaultTokenBalance, WETHAmount]. But in the loop, it's iterating over ids.length, which could be longer than the amounts array. This would cause an index out of bounds error when i exceeds the length of 'amounts'. For example, if the user provides 3 ids, the loop runs 3 times, but 'amounts' has only 2 elements. This is a critical issue because it would revert the transaction, leading to a DoS. This seems like a mistake; the code should be summing the amounts from the swap, but instead, it's using the loop over the 'ids' array. That's definitely a bug. Similarly, in mintAndSell1155WETH, the same issue occurs. The count is being calculated by looping over 'ids' and adding 'amounts[i]', but 'amounts' here is from the swap, which is not related to the number of IDs. This will cause a runtime error.

Another thing: the functions that handle ERC1155 transfers, like _swap1155, use safeBatchTransferFrom. The contract inherits from ERC1155HolderUpgradeable, which should handle the safe transfers. But when the contract receives the ERC1155 tokens, it's approved the vault to spend them. That's probably okay.

Looking at the buyAndSwap721WETH function, it's payable but doesn't use msg.value. Instead, it transfers WETH from the user. However, the function is marked as payable. This is a potential issue because someone could send ETH along with the transaction, which would be locked in the contract since the function doesn't use msg.value. The same applies to other WETH functions that are marked payable but don't use the sent ETH. This could lead to accidental loss of funds.

In the buyAndSwap1155WETH function, the parameters include 'uint256 maxWethIn', which is transferred from the user. However, the function is marked as payable. If someone sends ETH along with this function call, it would be stuck in the contract. Since the function uses WETH transfers, the ETH sent via msg.value is not handled here. This is a vulnerability because users might mistakenly send ETH, thinking it's required, but it's not used, leading to lost funds.

Another issue could be related to fee calculations. For example, in buyAndRedeem, the code calculates totalFee as (targetRedeemFee * specificIds.length) + (randomRedeemFee * (amount - specificIds.length)). However, if the user provides more specificIds than the amount, this could underflow. For example, if amount is 5 and specificIds.length is 6, then (5 - 6) would underflow. The code does not check that specificIds.length <= amount. This could lead to a revert due to underflow, which would cause the transaction to fail. So in functions like buyAndRedeem and buyAndRedeemWETH, there's a missing check that specificIds.length <= amount. If that's not enforced, an underflow occurs.

Looking at the _mint721 function: after transferring the NFTs and minting, it calculates balance as (count * BASE) - (count * mintFee). But if the mint fee is a percentage, maybe it's not just multiplied by count. Wait, the mintFee is a per-NFT fee. So for each NFT minted, the fee is subtracted. So for count NFTs, total fee is count * mintFee. The balance is then count * BASE (assuming 1 NFT = 1e18 vault tokens) minus the fees. But then they check if balance equals the contract's vault token balance. However, if the vault's mint fee is variable or if there are other fees, this could be incorrect. But maybe the vault's mintFee() returns the fee per NFT in BASE units. Assuming that's correct, then the calculation is okay. But if the vault's mint fee is not per NFT, this could be wrong. However, that's dependent on the vault's implementation, which is external. So maybe not a vulnerability here, but a potential assumption.

Another thing: the contract uses IERC20Upgradeable(address(WETH)).approve(_sushiRouter, type(uint256).max); in the constructor. That's good for WETH approval. But for other ERC20 tokens (vault tokens), approvals are done in functions like _sellVaultTokenWETH, where they approve the router for maxTokenIn. However, if the router isn't resetting the allowance, there could be residual allowances. But since the approval is done per-transaction with the exact amount needed, that's better. Wait, in _sellVaultTokenWETH, they do IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn); before swapping. So each time, it's setting the approval to maxTokenIn, which should be sufficient. But if there was a previous approval, this could be less than the remaining allowance, leading to a failed transaction. But since they set it to maxTokenIn each time, that's okay. However, if the swap requires more than maxTokenIn, then the approval would be insufficient. But since the function is called with maxTokenIn, the approval is correct. So maybe not an issue here.

Reentrancy is guarded by the nonReentrant modifier, but are there any external calls that could be used to reenter? For example, when transferring NFTs, if the NFT contract has a callback that could reenter. But the contract uses nonReentrant on the external functions, so even if a callback occurs, the reentrancy guard would block it. However, the ERC721HolderUpgradeable and ERC1155HolderUpgradeable might have onERC721Received and onERC1155Received functions. These callbacks could be a vector for reentrancy. But since the functions that handle transfers are internal and called from nonReentrant functions, the reentrancy guard should protect against that. So maybe not an issue here.

In the transferFromERC721 function, for CryptoKitties, they call transferFrom(msg.sender, address(this), tokenId). Then approve the vault. But for other ERC721s, they use safeTransferFrom. However, the safeTransferFrom would call onERC721Received on the recipient (which is 'to', but in this case, 'to' is the vault address). If the vault is malicious or has a callback that fails, this could cause the transfer to revert. But the vault is part of the NFTX system, so it's a trusted contract. However, if the vault is not properly implemented, this could be a problem, but that's outside the scope of this contract's security.

Another thing: the pairFor function computes the Uniswap pair address using a hardcoded INIT_CODE_HASH. However, if the SushiSwap factory's INIT_CODE_HASH changes (which it can't unless they deploy a new factory), this would break. But the contract is using sushiRouter.factory(), so it's getting the factory address from the router. However, the INIT_CODE_HASH in pairFor is hardcoded to the SushiSwap's one. If the contract is deployed on a chain where SushiSwap has a different INIT_CODE_HASH, this would compute the wrong pair address. This could lead to incorrect pair addresses and failed swaps or even fund loss. This is a vulnerability because the INIT_CODE_HASH is hardcoded but should be derived from the factory. The pairFor function is using a fixed hash, which may not match the actual hash used by the factory. This is incorrect and would cause the contract to interact with the wrong pair or a non-existent one, leading to failed transactions or incorrect token swaps.

Additionally, the sortTokens function is used in pairFor, which is correct as it sorts the tokens to get the correct pair address. But the hardcoded INIT_CODE_HASH is a problem. For example, SushiSwap on different chains might have different INIT_CODE_HASH values. So this contract would not be portable across chains without modifying the INIT_CODE_HASH, which is hardcoded as 'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'. If this isn't the correct hash for the chain where the contract is deployed, the pairFor function will return incorrect addresses.

In the buyAndSwap721 and similar functions, when the swap is done, the remaining WETH is withdrawn and sent to 'to'. However, if the WETH balance is zero, the withdraw would fail. But since they check remaining = WETH.balanceOf(address(this)), if it's zero, the withdraw is skipped. Wait, no: even if remaining is zero, WETH.withdraw(0) is called, which would attempt to withdraw zero WETH, which is allowed. Then sending zero ETH to 'to' is okay. So that's not an issue.

Another possible issue is front-running. Since the contract uses minWethOut and other parameters, users are responsible for setting these correctly to avoid slippage. But that's a general DeFi issue, not a contract vulnerability per se.

Looking at the _sellVaultTokenETH function, they approve the sushiRouter for maxTokenIn. Suppose the vault token has an approve function that doesn't allow changing the approval unless it's set to zero first. Then, if the current allowance is higher than maxTokenIn, some tokens (like USDT) require resetting the allowance to zero before setting a new one. If the vault token is such a token, the approve call would fail. This is a potential vulnerability if the vault token's approve function doesn't allow decreasing the allowance. However, since the contract is designed to work with their own vault tokens, which are presumably standard ERC20, this might not be an issue. But if a vault token is USDT, this could cause problems.

Also, in the _mint721 function, after minting, they check if the balance is equal to (count * BASE) - (count * mintFee). But if the vault's mintFee is not subtracted properly, or if there are other fees (like a flat fee), this check could fail. For example, if the vault takes a flat fee regardless of the number of NFTs minted, the calculation here would be wrong. However, this depends on the implementation of the INFTXVault's mintFee() function. If the vault's mint fee is per NFT, then it's correct. But if it's a flat fee, then the calculation would be wrong, leading to a revert. The code assumes that the fee is per NFT, which may not hold true if the vault is configured differently. This is a potential issue if the vault's fee structure changes.

Another thing: in the _swap721 function, after transferring the NFTs, they call swapTo with emptyIds for the specificIds. But if the user intended to swap for specific IDs, maybe that's handled elsewhere. Not sure, but this is part of the swap logic which might be correct.

In the approveERC721 function, for non-Kitties and non-Punks assets, they do nothing. So the code assumes that the safeTransferFrom has already approved the vault. But in the transferFromERC721 function, after transferring the NFT to the contract, they call approveERC721, which for standard ERC721 does nothing. Wait, no: the code transfers the NFT to 'to' (which is the vault) using safeTransferFrom(msg.sender, to, tokenId). Wait, in transferFromERC721, for non-Kitties/Punks, data is abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId). So the NFT is sent from msg.sender to 'to' (the vault). Then approveERC721 is called, which for non-special cases does nothing. So the vault is the new owner, but does the vault need approval to transfer the NFT? Probably not, because the vault is the owner. But in the case of the swap, maybe the vault needs to burn the NFT, which requires approval. Wait, no: if the NFT is already in the vault's possession, the vault can manage it without needing approval. So maybe the approve step is redundant for standard ERC721s. However, in the code, after transferring the NFT to the vault (to), they call approveERC721, which for non-Kitties/Punks does nothing. So that's correct. But maybe the transfer should be to the contract first, then approved, then deposited into the vault. Let me check the flow. For _mint721, the code transfers the NFT from msg.sender to the contract (using transferFromERC721 with to as address(this)), then approves the vault, then mints. Wait, no. Let me check the parameters of transferFromERC721 in _mint721:

transferFromERC721(assetAddress, ids[i], vault);

So the 'to' parameter is the vault address. So the NFT is transferred from msg.sender to the vault directly. Then approveERC721 is called, which for non-Kitties/Punks does nothing. Then they call INFTXVault(vault).mint. So the vault must have the NFT already. But how can the vault mint an NFT that it already holds? Wait, maybe the mint function in the vault requires the NFTs to be held by the caller (this contract), but if they were transferred to the vault directly, then the vault owns them, and the contract can't mint them. This seems like a mistake. Because when you mint, you need to transfer the NFTs to the vault, but perhaps the vault expects the NFTs to be held by the minter (this contract) and then transferred during the minting process. But in the current code, the NFTs are transferred directly to the vault, bypassing the contract. So when the contract calls INFTXVault(vault).mint(ids, emptyIds), the vault checks if the contract owns the NFTs. But since they were transferred to the vault, the contract no longer owns them. This is a critical issue. Because the code transfers the NFTs to the vault before minting, which would mean the contract doesn't own them anymore, leading the mint function to fail. 

Wait, let's think again. The process for minting in NFTX typically requires the user to send the NFTs to the vault, and then call mint. But the way this contract is doing it may be incorrect. For example, in the _mint721 function:

- Transfer the NFT from msg.sender to the vault (using transferFromERC721 with 'to' as the vault address)
- Approve the vault to transfer the NFT (but since the vault already has it, this is unnecessary)
- Call INFTXVault(vault).mint(ids, emptyIds)

But if the mint function requires the caller (this contract) to own the NFTs, then transferring them to the vault first would make the contract not own them, causing the mint to fail. This is a critical flaw. The correct approach would be to transfer the NFTs to the contract first, then approve the vault to take them, then call mint. 

For example, in the code:

transferFromERC721(assetAddress, ids[i], vault);

This sends the NFT from msg.sender to the vault. Then approveERC721(assetAddress, vault, ids[i]); which for standard ERC721 does nothing. Then call mint. But if the vault's mint function requires the contract to hold the NFTs, then this won't work, because they are in the vault's possession. The contract no longer holds them, so the mint call would fail. Therefore, this is a vulnerability. The code should instead transfer the NFTs to the contract itself first, then approve the vault to take them, and then call mint, which would transfer them to the vault. 

So in _mint721, the code is transferring the NFTs directly to the vault, which may be incorrect. The correct flow is:

1. Transfer NFT from msg.sender to this contract.
2. Approve the vault to take the NFT from this contract.
3. Call mint on the vault, which transfers the NFT from this contract to the vault and mints the vault tokens.

But in the current code, step 1 transfers directly to the vault, so step 3's mint would find that this contract doesn't own the NFT, leading to failure. This is a critical vulnerability because the mint function will fail, causing the entire transaction to revert. 

This mistake is present in both _mint721 and _swap721 functions. For example, in _mint721, they transfer to the vault, then call mint. If the vault's mint function requires the caller to have the NFTs, this will fail. Similarly, in _swap721, the NFTs are transferred to the vault, then swapTo is called. But the swapTo function might require the caller to hold the NFTs, leading to failure.

This is a major issue. The contract is not following the correct flow for interacting with the vault. The NFTs should be transferred to the contract first, then approved, and then the vault's functions should be called to transfer them into the vault. Otherwise, the vault's functions will not find the NFTs in the caller's possession, leading to failed transactions.

Another example is in the transferFromERC721 function for punks. They call buyPunk, which would transfer the punk to the contract. Then, in approveERC721 for punks, they call offerPunkForSaleToAddress. So the contract owns the punk, and offers it for sale to the vault. But when the vault's mint function is called, it would attempt to transfer the punk from the contract to the vault. But if the contract has not approved the vault, this would fail. However, for punks, there is no approve function. So the vault would need to call buyPunk, but the contract has to offer it for sale. The code does call offerPunkForSaleToAddress in approveERC721, which for punks is correct. But if the contract owns the punk and offers it to the vault for zero ETH, then the vault can call buyPunk to acquire it. But when the vault's mint function is called, does it handle punks correctly? That's up to the vault's implementation, but this code's logic for punks is complex and may have edge cases.

In summary, the key vulnerabilities I can see are:

1. **Incorrect NFT Transfer in Minting and Swapping**: Transferring NFTs directly to the vault instead of to the contract itself, leading to failed mint and swap calls because the contract doesn't own the NFTs anymore.

2. **Out-of-Bounds Array Access in mintAndSell1155 Functions**: Using the length of the IDs array to loop over the 'amounts' array, which may be shorter, causing a runtime error.

3. **Incorrect Pair Address Calculation**: Hardcoding the INIT_CODE_HASH for SushiSwap pair creation, leading to incorrect pair addresses if the hash differs on the deployment chain.

4. **Underflow in Fee Calculation**: Not checking that the number of specific IDs does not exceed the amount in redeem functions, leading to underflow and transaction reverts.

5. **CryptoPunk Handling Without ETH**: Attempting to buy CryptoPunks without sending ETH, causing transfers to fail.

6. **Payable Functions with Unused msg.value**: Marking WETH functions as payable, allowing ETH to be sent but not handled, leading to stuck funds.

7. **Incorrect Use of safeTransferFrom for ERC721**: Possibly transferring directly to the vault instead of the contract, leading to ownership issues.

Now, let's list these vulnerabilities in order of severity and explain each."
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672.0,172.0,"[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the `_sendForReceiver` function.
In the `_sendForReceiver` function, when `_receiver` is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
 
[M-02] `addReceiver()`: Failure to check for existing receiver
The `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
  [M-10] `_sendForReceiver` doesn't return success if receiver is not a contract
Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in `_sendForReceiver`
The `_sendForReceiver()` function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
  [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the `_sendForReceiver` function to distribute the fee In the `_sendForReceiver` function, when the `_receiver` is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605.0,1,5,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Fee Distribution Logic**  
   The `distribute` function calculates each receiver's share using the **initial token balance** but uses the **current balance** during iterations. This can lead to incorrect allocations if prior transfers reduce the balance. Additionally, leftover amounts from failed sends are carried over, potentially causing over-allocation to subsequent receivers.

2. **Unsafe ERC20 Allowance Handling**  
   In `_sendForReceiver`, after approving tokens for a contract receiver, the allowance is not revoked if the call succeeds but doesn’t use the full amount. This leaves residual allowances, allowing receivers to drain tokens later via `transferFrom`.

3. **RescueTokens Function Allows Fund Draining**  
   The `rescueTokens` function permits the owner to withdraw **any ERC20 token**, including vault tokens meant for distribution. This creates a backdoor for the owner to drain funds.

4. **Missing Zero Address Validation**  
   - `setInventoryStakingAddress` does not check for `address(0)`, risking invalid configurations.  
   - `addReceiver` allows adding a receiver with `address(0)`, potentially causing lost funds or failed calls.

5. **Residual Allowances After Failed Contract Calls**  
   If a contract receiver’s call fails but consumes the allowance (e.g., via a separate transaction), the distribution logic may mishandle leftovers, leading to incorrect token distribution.

6. **Potential Denial-of-Service (DoS) via Gas Limits**  
   Looping over a large `feeReceivers` array in `distribute` could exceed gas limits, causing transaction failures.

7. **Lack of Event Emission for Critical Operations**  
   The `rescueTokens` function does not emit events, reducing transparency into fund recovery actions.

8. **Incorrect Receiver Order After Removal**  
   Removing a receiver via `removeReceiver` reorders the array, which may disrupt distribution logic if order-dependent.","### **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**

**Report Description**:  
In the `NFTXSimpleFeeDistributor.sol` contract, the `distribute` function relies on the return value of the `_sendForReceiver` function to determine if the fee was sent successfully. However, when `_receiver` is not a contract, the `_sendForReceiver` function does not return a value, defaulting to `false`. This causes the `distribute` function to incorrectly assume the fee sending failed, leading to duplicate fee distributions and potential overpayment to receivers.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of the `_sendForReceiver` function failing to return a value when the receiver is not a contract. This oversight is critical and leads to incorrect fee distribution logic.

---

### **[M-01] Missing non reentrancy modifier**

**Report Description**:  
Certain functions in the contract lack the `nonReentrant` modifier, even though other public/external functions use it. While no exploit was identified, the absence of this modifier in functions that could potentially be vulnerable to reentrancy attacks poses a security risk.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not mention the absence of the `nonReentrant` modifier in certain functions, which is a significant oversight in ensuring contract security.

---

### **[M-02] `addReceiver()`: Failure to check for existing receiver**

**Report Description**:  
The `addReceiver()` function does not verify if the `_receiver` already exists in the list. This can lead to duplicate entries, causing erroneous fee distributions and overpayment to the same receiver.

**Match in Response List**:  
Matches with the issue titled **""Missing Zero Address Validation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of missing validation in `addReceiver` but focuses on zero address validation rather than checking for duplicate receivers. The core issue of duplicate entries is not addressed.

---

### **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**

**Report Description**:  
The `_sendForReceiver` function does not return `true` when the receiver is not a contract, leading to double spending of fees. This results in overpayment to earlier receivers in the list and missed payments for those at the end.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of `_sendForReceiver` failing to return `true` for non-contract receivers, which is a critical flaw in the fee distribution logic.

---

### **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Report Description**:  
The `_sendForReceiver` function only sets a return value in the `if` block but not in the `else` block. If the `else` block is executed, no value is returned, defaulting to `false`. This causes the `distribute` function to incorrectly handle leftover amounts, potentially sending funds to the treasury unnecessarily.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unassigned return values in `_sendForReceiver`, which is a critical oversight in the contract's logic.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:  
If a malicious receiver is a contract, it can execute `revert()` in its `receiveRewards` function, causing the `distribute` function to fail and resulting in a denial-of-service (DoS) attack.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial-of-Service (DoS) via Gas Limits""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of DoS but focuses on gas limits rather than malicious behavior by receivers. The specific issue of malicious receivers causing reverts is not addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] `addReceiver()`: Failure to check for existing receiver**  
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**Missed Issues from Issue Report**:  
- **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**  
- **[M-01] Missing non reentrancy modifier**  
- **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**  
- **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

---

The response list fails to address several critical issues, particularly those related to the `_sendForReceiver` function's return value handling and the absence of the `nonReentrant` modifier. While some issues are partially covered, the overall coverage is insufficient, leaving significant vulnerabilities unaddressed.",0,2,4,8,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. I'm not an expert, but I'll go through each part step by step.

First, the contract is called NFTXSimpleFeeDistributor. It imports several interfaces and uses some Safe libraries, ReentrancyGuard, and Pausable. That's good because those are common practices to prevent reentrancy and handle math safely. But let's check for issues.

Starting with the state variables. There's a distributionPaused flag, addresses for vault factory, lpStaking, treasury, inventoryStaking, and allocTotal which tracks total allocation points. The feeReceivers array holds FeeReceiver structs with allocPoint, receiver address, and isContract flag. The functions include distributing fees, adding/updating receivers, and administrative functions.

Looking at the __SimpleFeeDistributor__init__ function. It initializes the contract and adds a receiver with 0.8 ether allocPoint. Wait, 0.8 ether here probably means 0.8 * 1e18, which is a common way to represent decimals. But if that's supposed to be 80%, maybe the initial setup is correct. But if allocTotal is 0.8 ether and other receivers are added, the total could be more than expected. But maybe the initializer is setting up correctly. Not sure yet.

Next, the distribute function. It checks if distribution is paused or allocTotal is zero, sends funds to treasury. Otherwise, it loops through feeReceivers, calculates their share, and sends. But there's a leftover mechanism. Let's see.

In the loop, for each receiver, amountToSend is (leftover + (tokenBalance * allocPoint)/allocTotal). Then checks currentTokenBalance and caps amountToSend. Then calls _sendForReceiver. If the send fails (complete is false), leftover is set to amountToSend. Otherwise, leftover is zero.

Wait, but the code uses the current token balance each time. Suppose the first receiver takes their share, then the next receiver's calculation uses the updated balance. But in the code, tokenBalance is fixed at the start. Wait, no. The code first gets tokenBalance as the initial balance. But inside the loop, when they calculate amountToSend, it's based on the original tokenBalance plus any leftover. However, when sending, they check the current balance again. So there's a mix of initial and current balances here. That might lead to incorrect distribution if other transfers happen during the loop.

Wait, for example: suppose tokenBalance is 100. AllocTotal is 100. Receiver A has 50, Receiver B has 50. So each should get 50. But during the first iteration, amountToSend would be 50 (0 + (100 *50)/100). But if after sending 50, the balance is 50. Then for the next receiver, the code uses (leftover + (100 *50)/100) = 0 +50 =50. But current balance is 50, so amountToSend is 50. But if during sending, some other operation affects the balance, but maybe not. Wait, the code uses leftover from previous iterations. So the leftover is carried over if a send fails.

But if a send fails (like a contract call that fails), then the leftover is added to the next iteration's amount. However, the code for the loop runs for all feeReceivers, but if one fails, the leftover accumulates. Then, after the loop, any leftover is sent to treasury. But there's a problem here: suppose a receiver's _sendForReceiver fails, then the leftover is added to the next receiver's amount. However, the next receiver's calculation is based on the original tokenBalance, not the remaining balance. That could lead to over-spending.

Wait, let me walk through an example. Suppose tokenBalance is 100, allocTotal is 100. Two receivers, each with 50 allocPoints. First receiver's amountToSend is (0 + (100 *50)/100) =50. Suppose the send fails (complete=false). Then leftover becomes 50. Next iteration, i=1. amountToSend is 50 + (100 *50)/100 =50 +50=100. But the currentTokenBalance is now 100 (since previous send failed and didn't transfer). So amountToSend is 100. If that send succeeds, then 100 is sent, which is more than the original tokenBalance. Wait, but the original tokenBalance was 100. So that would drain the contract's balance entirely. That's a problem because the contract's balance after the first failed send is still 100. So in the second iteration, it's allowed to send 100, which would take all tokens. But that's incorrect because the total allocation points sum to 100, so each should get 50. But because the first failed, the second gets 100. But the leftover is carried over. But in the code, the leftover is from previous iterations, and added to the new allocation. This could lead to over-allocation.

This seems like a vulnerability. The distribution logic is flawed because it uses the initial tokenBalance multiplied by the receiver's allocPoint, but if a receiver's transfer fails and leaves leftover, the next receiver could end up taking more than their share. Also, since the leftover is added to the next receiver's amount, which is based on the initial tokenBalance, this could result in more tokens being distributed than intended, potentially draining the contract's balance. For example, if all sends except the last one fail, the last receiver could get all the tokens plus leftovers from each prior failed send.

Another thing: the code uses a loop that runs for each feeReceiver. If there are many feeReceivers, this could hit the block gas limit, causing the distribute function to fail. That's a potential DOS vulnerability. However, the owner controls adding receivers, so if they add too many, it's their fault. Still, it's a risk if not managed.

Looking at _sendForReceiver. If the receiver is a contract, it approves the amount and then calls receiveRewards. But after the call, it checks if the allowance is back to zero. But there's a possible race condition here. Suppose the receiver's contract doesn't use all the allowance; the remaining allowance could be used in a future call. However, since the approval is done each time, but the code checks that the allowance is zero after the call. Wait, the code does:

IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
Then calls the receiver via a low-level call.
Then checks if the allowance is now zero.

If the receiver's contract doesn't use the entire allowance (e.g., only uses part of it), then the allowance remains, and the function returns false. Therefore, the leftover would be added. But if the receiver is a contract that doesn't use the full allowance, the transaction would fail, leading to leftover. However, if the receiver is malicious, they could front-run and use the allowance in another transaction. For example, after approve is called, but before the receiveRewards is called, a malicious receiver could transfer the tokens using the allowance. This would cause the receiveRewards call to fail, but the allowance is already used. Then, after the call, the code checks allowance is zero. If the receiver used the allowance, the check would pass (since allowance is zero), but the receiveRewards might have failed. Wait, the code returns (success && allowance ==0). So if the call was unsuccessful, but the allowance is zero, then it would return false (since success is false). However, if the call was unsuccessful but the allowance was used (e.g., via a separate transferFrom), then the code would return (false && true), which is false. Therefore, the leftover would be set to the amountToSend. But if the allowance was used, then the contract's balance would have decreased, leading to possible discrepancies.

This seems like an approval issue. The contract approves a specific amount, but if the receiver doesn't use it all, the allowance remains. However, the code tries to check that the allowance is zero after the call. But if the receiver only uses part of the allowance, the check would fail, and the function returns false. Then, the leftover would be added. But the actual token balance might have decreased by some amount, leading to leftover in the next iteration. However, the code in the distribute function uses the currentTokenBalance each time. For example, if the receiver used part of the allowance, the balance would have decreased, so currentTokenBalance would reflect that. So when the next receiver's amountToSend is calculated, it would use the updated balance. But in the code, the amountToSend is computed as leftover + (tokenBalance * allocPoint / allocTotal), where tokenBalance is the initial value. Wait no: in the code, tokenBalance is the initial balance, but the loop uses the current balance each time. Wait, no:

In distribute:

uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

Then, inside the loop:

uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;

So even though the initial tokenBalance is captured, the code checks the current balance each time. So if a prior transfer reduced the balance, the currentTokenBalance would be lower. However, the amountToSend is calculated based on the initial tokenBalance multiplied by the receiver's allocPoint divided by allocTotal, plus any leftover. But this approach may not correctly account for the actual remaining balance. For example, if the first receiver's transfer reduces the balance, but the second receiver's amount is calculated based on the initial balance, leading to an incorrect distribution.

Wait, this is a problem. The code calculates the amountToSend for each receiver as (leftover + (initialTokenBalance * allocPoint) / allocTotal). But the actual remaining balance could be less than initialTokenBalance, leading to a situation where the sum of (allocPoint / allocTotal) for all receivers would be 1 (if all allocPoints sum to allocTotal), but due to leftover and decreasing balances, the total distributed could exceed the initial balance. For example:

Initial tokenBalance = 100, allocTotal = 100. Two receivers with 50 each.

First receiver: amountToSend = 0 + (100*50)/100 =50. currentTokenBalance is 100. So sends 50. Succeeds. Now balance is 50. Leftover is 0.

Second receiver: amountToSend =0 + (100*50)/100=50. currentTokenBalance is 50. So amountToSend is min(50,50) =50. Sends 50. Now balance is 0.

That's correct. But suppose first receiver fails. Then leftover becomes 50. Second receiver: amountToSend =50 + (100*50)/100=100. currentTokenBalance is 100 (since first send failed). So sends 100, which is the entire balance. Now, total sent is 100, which is correct. But that's only if the initial balance was 100 and both receivers have 50. However, if the allocTotal is not 100, but say, 200, and the initial tokenBalance is 100, then each receiver's share is 50% of 100. But that's another scenario.

Wait, allocTotal is the sum of all allocPoints. So in this case, the initial example works. But the problem arises when after some transfers, the balance is less than the initial tokenBalance. For example:

Suppose initial tokenBalance is 100, allocTotal is 100. Receiver A (alloc 60), Receiver B (alloc 40).

First iteration: amountToSend =0 + (100*60)/100=60. currentTokenBalance is 100. Send 60, succeeds. Balance is 40. Leftover 0.

Second iteration: amountToSend =0 + (100*40)/100=40. currentTokenBalance is 40. Send 40. All good.

But if during the first send, some tokens were transferred out (unlikely, but possible if the receiver is a contract that does something else), then currentTokenBalance would be lower. But the code uses the current balance each time when determining how much to send. However, the amountToSend is based on the initial tokenBalance. So the calculation is (leftover + (initialTokenBalance * allocPoint)/allocTotal). But if the initial tokenBalance is 100, and after some transfers the balance is 50, the amountToSend could be higher than the current balance, so it's capped. But this could lead to the sum of the sent amounts being less than the initial balance, with the remaining going to treasury. However, maybe the intention is to distribute based on the initial balance. But the code may have a flaw here because it uses the initial tokenBalance multiplied by the receiver's allocation, but after some sends, the balance may have changed. For example, if a receiver is a contract that calls distribute again during the send, causing reentrancy. But the function is marked nonReentrant, so that's prevented.

Another potential issue: in the distribute function, the leftover is added to the next receiver's amount. This could lead to receivers getting more than their allocation if prior sends fail. For example, if the first receiver's send fails, their allocated amount is added to the next receiver's share, which could result in the next receiver getting both their own allocation and the failed one. If the total allocations are supposed to sum to 100%, this would mean some receivers get more than intended.

The rescueTokens function allows the owner to transfer any ERC20 token out of the contract. This is a privileged function and could be a backdoor if the owner is malicious. However, since it's marked onlyOwner, it's a centralization risk. But if the contract is supposed to be decentralized, this is a vulnerability. But maybe it's intended for emergencies. Still, it's a potential issue if the owner's account is compromised.

Looking at the _addReceiver function, it adds a new receiver and increases allocTotal. But if the sum of allocPoints exceeds the maximum (e.g., if using 1e18 as 100%), then adding receivers could cause an overflow. However, the contract uses SafeMathUpgradeable, so that should prevent overflows. But the code doesn't show SafeMath being used in all arithmetic operations. For example, allocTotal += _allocPoint; is in _addReceiver. If SafeMath is not used here, it could overflow. Wait, the contract imports SafeMathUpgradeable but does the code use it? Looking at the code, there's ""using SafeERC20Upgradeable for IERC20Upgradeable;"" but no using SafeMath for uint256. So in the code, when they do allocTotal += _allocPoint, it's possible that without SafeMath, an overflow could occur. However, the pragma is ^0.8.0, which has built-in overflow checks. So in Solidity 0.8.0, arithmetic operations automatically revert on overflow. So that's safe. Therefore, no overflow vulnerability here.

Another thing: in the changeReceiverAlloc function, the owner can change the allocation points. However, if they set a receiver's allocation to a very high value, it could take a large portion of the fees. But that's an admin privilege, so depends on trust in the owner.

The initializeVaultReceivers function is called by the vault factory, but it's protected by a require(msg.sender == nftxVaultFactory). So if the factory is set incorrectly, this could be a problem. But the owner can set the factory address. If the owner is malicious, they could set a malicious factory. But that's a centralization risk.

The removeReceiver function replaces the receiver with the last element in the array and pops. This is a common pattern to avoid gaps, but if the order of receivers matters (e.g., for distribution order), then changing the order could affect behavior. However, the function correctly updates the array. The vulnerability here could be if during the removal, the index is incorrect, but the require ensures it's within bounds.

In _sendForReceiver, when the receiver is a contract, the code uses a low-level call to invoke receiveRewards. If the receiver contract doesn't have this function, the call will fail. But the code catches the success variable. However, there's a possible issue if the receiver is an EOA (externally owned account) but marked as a contract. The code would attempt to call receiveRewards, which would fail, but since it's an EOA, the call would return success false, and the function would return false. Then, the leftover would be added. But if the receiver is incorrectly marked as a contract (isContract = true), but is actually an EOA, the call would fail, leading to leftover.

Another thing: the code uses abi.encodeWithSelector to call receiveRewards. If the receiver's contract has a function with the same selector but different parameters, this could lead to unexpected behavior. For example, if the receiver has a function that matches the selector but expects different arguments, the call could succeed but with unintended consequences.

Also, in the _sendForReceiver function, after approving the amount, the code makes the call and then checks if the allowance is back to zero. But if the call is successful but the receiver didn't use the allowance, the allowance remains, which could allow the receiver to transfer the tokens later. However, the code checks if the allowance is zero and returns false if not, leading to leftover. But in that case, the receiver could have an allowance, which is a security risk. For example, if the receiver is compromised later, they could drain the tokens using the old allowance. To prevent this, after the call, the code should revoke the allowance whether the call succeeded or not. However, the current code doesn't do that. So if the call succeeds but the allowance wasn't used, the allowance remains, which is a vulnerability. The receiver could call transferFrom later to take the tokens.

So that's a problem. The code approves the receiver to spend amountToSend, then calls receiveRewards. If the receiver doesn't use the allowance, the approval remains. The code checks if the allowance is zero, and if not, returns false (which adds the amount to the leftover). However, the approval is not reset, so the receiver can still use the allowance in the future. This is a security risk. For example, a malicious receiver could call transferFrom in a separate transaction after the distribute call, taking the tokens that were approved but not used.

This is a vulnerability. The contract should revoke the approval after the call, regardless of success. Otherwise, leftover allowances can be exploited.

Another possible issue: when adding a receiver, the _addReceiver function doesn't check if the receiver's address is valid (non-zero). So the owner could accidentally add a zero address, leading to tokens being sent to address(0) if it's not a contract (burning tokens) or causing failed calls if it's marked as a contract.

Also, in the setTreasuryAddress and setLPStakingAddress functions, the code checks that the new address is not zero. But in setInventoryStakingAddress, there's no check. So the owner could set inventoryStaking to address(0), which might cause issues if other functions rely on it being a valid address.

In the rescueTokens function, the owner can transfer any ERC20 token, including the vault tokens. This could be used to withdraw funds that were meant to be distributed. For example, if fees are accumulated and the owner calls rescueTokens with the vault address, they can take all the funds. But this function is supposed to be for rescuing non-fee tokens. However, there's no check to prevent rescuing the vault tokens, which are the ones being distributed. This is a vulnerability as the owner can drain the contract's funds.

Another thing: the rescueTokens function uses safeTransfer to send the tokens to the owner. However, if the token is a contract that returns false on transfer (like some non-compliant tokens), the safeTransfer would revert. But for compliant tokens, it works. However, the function allows the owner to take any tokens, which could include tokens sent accidentally to the contract. But if the owner is trusted, this is a feature, but if not, it's a backdoor.

Looking at the event emissions: when a receiver is added, updated, or removed, events are emitted. But in the removeReceiver function, the event is emitted before the receiver is removed from the array. The event emits feeReceivers[_receiverIdx].receiver, which is correct. So no issue there.

In the distribute function, if the distribution is paused or allocTotal is zero, all funds go to treasury. But if allocTotal is zero, adding receivers would have to be done to start distributions again. However, if there's a situation where allocTotal is zero but feeReceivers are present (though unlikely, since each receiver contributes to allocTotal), the code would send to treasury. But the code properly checks allocTotal.

Another possible issue: if the feeReceivers array is empty, the distribute function will send all funds to treasury. But that's intended behavior.

In the __SimpleFeeDistributor__init__ function, the _addReceiver is called with 0.8 ether (0.8e18) allocPoint. Assuming that 'ether' here represents 100%, but allocTotal is a sum of allocPoints. So if the total is 0.8e18, and other receivers are added, the sum could be more than 1e18, but since allocTotal is a sum of arbitrary points, maybe that's acceptable. But if the intention is for allocPoints to sum to 1e18 (representing 100%), then adding more receivers could exceed that. However, the code doesn't enforce that, so the owner must manage the allocPoints correctly. If the sum exceeds 1e18, distributions would be based on the ratio relative to allocTotal. So no inherent issue, but depends on proper configuration.

Reentrancy: the distribute function is marked nonReentrant, so that's safe. The other functions that transfer tokens are within nonReentrant or use SafeERC20, which should prevent reentrancy.

Possible front-running: when changing receiver addresses or allocations, there's no timelock or commit-reveal mechanism, so the owner could be front-run, but since the owner is a privileged address, that's a centralization risk, not a code vulnerability.

Access control: all critical functions (adding receivers, changing addresses) are protected by onlyOwner. If the owner is compromised, the contract can be taken over. But that's a centralization risk, not a code vulnerability.

So summarizing the vulnerabilities found:

1. **Incorrect Distribution Logic Leading to Over/Under Distribution**: The distribute function calculates each receiver's share based on the initial token balance, but uses the current balance during each iteration. If prior transfers reduce the balance, subsequent receivers may receive incorrect amounts. Additionally, leftover from failed sends is added to the next receiver's amount, which could lead to over-allocation.

2. **Unsafe Allowance Handling in _sendForReceiver**: When sending to a contract receiver, the code approves the amount but doesn't reset the allowance if the call succeeds but the allowance isn't fully used. This leaves residual allowances that could be exploited by the receiver in the future.

3. **Residual Allowances After Failed Calls**: If a contract receiver's call fails but the allowance is used (e.g., via a separate transaction), the code may not properly handle the leftover, leading to incorrect token distribution.

4. **RescueTokens Function Allows Draining Funds**: The rescueTokens function allows the owner to withdraw any ERC20 token, including the vault tokens meant for distribution. This could be used maliciously or accidentally to drain funds.

5. **Inventory Staking Address Can Be Set to Zero**: The setInventoryStakingAddress function doesn't check if the new address is non-zero, potentially leading to errors if other functions rely on a valid address.

6. **Possible Front-Running of Receiver Address Changes**: Changing receiver addresses could be front-run, but this is more of a governance issue than a code flaw.

7. **Adding Receivers with Zero Address**: The addReceiver function doesn't check if the receiver address is non-zero, which could lead to tokens being lost or calls failing.

8. **Lack of Event Emission on Critical Operations**: While most functions emit events, some operations (like rescueTokens) don't emit events, reducing transparency.

9. **Potential DoS Due to Gas Limits**: If there are too many feeReceivers, the distribute function could run out of gas, causing the transaction to fail.

Now, considering the severity of each:

1. **Incorrect Distribution Logic** is a high-severity issue because it can lead to incorrect distribution of funds, potentially allowing a receiver to get more than their share.

2. **Unsafe Allowance Handling** is a medium-severity issue as it leaves residual allowances which can be exploited, especially if the receiver is compromised.

3. **RescueTokens Function** is a high-severity issue if the owner is malicious or compromised.

4. **Zero Address for Inventory Staking** is a low-severity issue unless the contract relies on that address being valid.

5. **Adding Zero Address Receivers** is a medium-severity issue as it could lead to loss of funds.

6. **Residual Allowances After Failed Calls** is a medium-severity issue.

So the main vulnerabilities are:

- Incorrect fee distribution logic leading to improper token allocation.
- Unsafe ERC20 allowance handling leaving residual approvals.
- RescueTokens allows owner to drain contract funds.
- Zero address checks missing in setInventoryStakingAddress and addReceiver.
- Residual allowances after failed contract calls.

These are the key points."
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750.0,561.0,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock
The default value of `inventoryLockTime` in NFTXStakingZap is 7 days while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in XTokenUpgradeable.
The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in NFTXInventoryStaking`",2.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033.0,0,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Insecure Randomness in NFT Selection**  
   The `getRandomTokenIdFromVault` function uses block variables (`blockhash`, `block.timestamp`, etc.) and a predictable `randNonce` to select NFTs during redemptions. This allows miners or attackers to manipulate the outcome, potentially leading to the theft of valuable NFTs.

2. **Minting Shares Without Valid NFT Transfers (ERC721)**  
   The `transferFromERC721` function allows users to mint shares for ERC721 tokens already held by the vault but not tracked in `holdings`. Attackers can exploit this by front-running transactions to deposit NFTs into the vault, enabling minting without transferring ownership, resulting in illegitimate share creation.

3. **Hardcoded Privileged Address**  
   The `assignDefaultFeatures` function restricts execution to a hardcoded address (`0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a`). This centralizes control, posing a risk if the address is compromised and limiting protocol flexibility.

4. **Missing Storage Gap for Upgradeability**  
   The contract inherits upgradeable patterns but lacks a storage gap variable. This omission risks storage layout collisions during future upgrades, potentially corrupting state variables.

5. **Incorrect ERC721 Ownership Check**  
   During ERC721 minting, the contract checks ownership using `IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)`. If the vault holds an NFT not recorded in `holdings`, it allows unauthorized minting of shares for that NFT.

6. **Centralized Fee Distribution Control**  
   Fee distribution relies on `vaultFactory.feeDistributor()`, which, if compromised or misconfigured, could lead to loss of funds. However, this depends on external contract trust.

7. **Potential Reentrancy in Flash Loans**  
   The `flashLoan` function permits reentrancy via the callback. While other functions use `nonReentrant`, unprotected functions could be exploited if combined with flash loans. However, most critical functions are guarded.

8. **Lack of Input Validation in ERC1155 Handling**  
   In `withdrawNFTsTo`, ERC1155 quantities are decremented without explicit checks for underflow (though Solidity 0.8+ defaults to reverting on underflow).

These vulnerabilities include critical risks (e.g., NFT theft, share minting exploits) and administrative concerns (e.g., upgradeability, centralization).","### **Output**

---

**[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:  
The Pool Manager can front-run the entry fee setting to 100% (uint(1 ether) = 10**18), which is a per-token fee. This allows the manager to steal all user deposits by setting the fee to the maximum value just before a large deposit is made. This vulnerability arises because anyone can create a pool, and the admin can manipulate the fee structure to exploit users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of front-running fee manipulation by the Pool Manager. This is a critical oversight, as the vulnerability allows for the theft of user funds and is not covered in the provided responses.

---

**[M-09] Bypass zap timelock**

**Report Description**:  
The `inventoryLockTime` in `NFTXStakingZap` defaults to 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. The timelock is calculated as `block.timestamp + timelockLength`, even if an existing timelock is further in the future. This allows an attacker to reduce a long timelock (e.g., 7 days) to 2 ms by calling `deposit` in `NFTXInventoryStaking`, bypassing the intended security mechanism.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of timelock bypass in `NFTXStakingZap` and `NFTXInventoryStaking`. This is a significant vulnerability, as it undermines the security of the timelock mechanism, and its absence in the response list is a critical gap.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**  
- **[M-09] Bypass zap timelock**

---

### **Analysis**  
The `response_list` fails to address two critical issues from the `issue` report:  
1. The **front-running fee manipulation** vulnerability ([M-05]) is a high-risk issue that allows the Pool Manager to steal user funds. This is a significant oversight, as it directly impacts user security and trust.  
2. The **timelock bypass** vulnerability ([M-09]) is another critical issue that undermines the security of the protocol. The absence of this issue in the response list indicates a gap in the vulnerability assessment.  

Both issues are high-priority and should be addressed in the response list to ensure comprehensive coverage of the vulnerabilities in the smart contract.",0,0,2,8,"Okay, let's take a look at this smart contract and try to figure out any vulnerabilities. I'm a bit new to this, so I'll go step by step.

First, the contract is called NFTXVaultUpgradeable. It imports a bunch of interfaces and other contracts, which might be using upgradeable patterns. That makes me think about potential proxy issues or storage collisions. Oh right, since it's using OpenZeppelin upgradeable contracts, they should use the @openzeppelin/contracts-upgradeable versions. But maybe there's a storage layout problem if they added variables in the wrong order. Let me check the state variables.

The contract inherits from OwnableUpgradeable, ERC20FlashMintUpgradeable, ReentrancyGuardUpgradeable, and some SafeHolder contracts. The state variables start with vaultId, manager, assetAddress, etc. Then there's some UNUSED_FEE1, UNUSED_FEE2, UNUSED_FEE3. Wait, those are declared but not used. Maybe they were supposed to hold fee values but are left as placeholders. But since they're private and not used, maybe that's just leftover code. Not a vulnerability per se, but code clutter.

Next, looking at the functions. The __NFTXVault_init function is the initializer. It sets up the vault, and then calls setVaultFeatures with all features enabled. The initializer is public override virtual, but since it's using the initializer modifier, it should only be called once. But since anyone can call it if it's not properly initialized? Wait, no—the initializer modifier should prevent that. But if another contract inherits from this and doesn't properly call the initializer, that could be a problem. But maybe that's outside the scope here.

The assignDefaultFeatures function has a require that the sender is a specific address (0xDEA9...). That's a hardcoded address, which is a centralization risk. If that address's private key is compromised, someone could call this function. Also, if the protocol wants to change that address, they can't. So that's a potential issue.

Looking at the setManager function, it's protected by onlyPrivileged. The onlyPrivileged function checks if the manager is address(0), then requires the sender is the owner. Otherwise, the sender must be the manager. So if the manager is set, the owner can't call functions that use onlyPrivileged unless they are the manager. That might be intended, but could lead to privilege confusion if not handled properly.

Now, looking at the mint, redeem, swap functions. The mintTo function calls receiveNFTs, which checks if the tokenIds are valid via allValidNFTs. If allowAllItems is true, then any NFT is accepted. Otherwise, it checks the eligibilityStorage. But if eligibilityStorage is not set, allowAllItems is false, then allValidNFTs returns false, so minting would fail. So maybe if the eligibility module isn't deployed, the vault can't mint, which could be a problem if the deployer forgets to set it. But the deployEligibilityStorage function allows the privileged account to deploy it. So maybe not a vulnerability, but a possible misconfiguration risk.

In the receiveNFTs function, for ERC721, they call transferFromERC721. Let's check that function. For CryptoKitties and CryptoPunks, they use specific transfer functions. For others, they use safeTransferFrom. But there's a check in the else clause: if the owner of the token is already the vault, and the token isn't in holdings, they just proceed. Wait, but when receiving NFTs during mint, the user is transferring the token to the vault. But if the vault already owns the token, and it's not in holdings, they bypass the transfer. That might be a way to bypass fees or checks, because the user could have transferred the NFT to the vault beforehand. For example, if the vault already holds an NFT not in holdings (maybe from a previous redemption), the user could mint without actually transferring, leading to incorrect accounting. That's a potential issue.

In the transferFromERC721 function, for non-CryptoKitties and non-Punks, there's a check: if the owner is the vault and the token is not in holdings, it just returns without transferring. But if someone sends an NFT directly to the vault (not through mint), it could be in the vault's balance but not in holdings. Then, when someone tries to mint using that tokenId, the transferFromERC721 would see that the vault already owns it and skip the transfer. This would allow the minter to mint shares without actually sending an NFT, because the vault already holds it. That's a critical vulnerability because users could mint tokens without providing the required NFTs.

Another thing: the receiveNFTs function adds the tokenId to holdings for ERC721. So if the vault already owns the token (but it's not in holdings), then when minting, the code would add it to holdings, effectively allowing the minter to ""claim"" that NFT into the vault's holdings without actually transferring it. The user could front-run a transaction that sends the NFT to the vault, then call mint with that tokenId, and the vault would accept it without the user actually transferring it. This could be exploited to steal NFTs from the vault.

Looking at the withdrawNFTsTo function: when redeeming, for ERC721, it removes the tokenId from holdings and transfers it out. But if the vault has an NFT in its balance that's not in holdings (due to the above issue), then during redemption, when getRandomTokenIdFromVault is called, it might pick a tokenId that's not actually in the holdings. But getRandomTokenIdFromVault uses the holdings set, so it can't. Wait, getRandomTokenIdFromVault uses holdings.at(randomIndex), so it's only selecting from the holdings. So even if the vault has other NFTs not in holdings, they can't be redeemed. But the problem is during minting: if the vault already owns an NFT not in holdings, a user can mint shares by including that tokenId in their mint, and the code would add it to holdings without the user transferring it. So the user gets shares for an NFT that wasn't theirs to deposit. That's a big issue.

Another thing: the getRandomTokenIdFromVault function uses a pseudo-random number based on block variables. This is predictable and can be manipulated by miners or attackers. For example, when redeeming random tokens, an attacker could predict or influence which tokenId is selected, leading to front-running attacks or stealing valuable NFTs. The randNonce is incremented each time, but the randomIndex is generated using blockhash, nonce, coinbase, difficulty, timestamp—all of which are not secure sources of randomness. This makes the random selection vulnerable to manipulation.

Looking at the flashLoan function, it's using the ERC20FlashMintUpgradeable's flashLoan. The function overrides it and adds an onlyOwnerIfPaused(4) modifier. That means if the vaultFactory has lockId 4 set to locked, only the owner can execute flash loans. But the check is whether the sender is the owner if it's paused. However, flash loans typically should be permissionless, so this might restrict functionality, but maybe that's intentional. However, the main issue with flash loans is usually not access control but reentrancy. But they have a nonReentrant modifier on functions like mintTo, redeemTo, etc. However, the flashLoan function itself doesn't have a nonReentrant modifier. The parent ERC20FlashMint's flashLoan function calls the receiver's callback, which could reenter the vault. But the flashLoan function here is overridden and includes onlyOwnerIfPaused(4), which is a modifier that checks if the vaultFactory is locked. Wait, the onlyOwnerIfPaused is a modifier that does require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused""). So if the lockId 4 is not locked, anyone can call flashLoan. Otherwise, only the owner. The flash mint itself could be a vector for reentrancy into other functions. But since the other functions have nonReentrant, maybe it's mitigated. However, if the callback reenters into another function that's not protected, that could be an issue. Need to check.

The transferERC721 function has a (bool success,) = ... call and then require(success). But for some assets, like punks, the transferPunk function is used. However, some ERC721 contracts may not implement safeTransferFrom, but the code here handles specific cases. However, using low-level calls without handling return data could be an issue. Wait, in the code, after the call, they do require(success), which checks if the call was successful. But in the transferFromERC721 function, there's (bool success, bytes memory resultData) = ... call(data), and require(success, string(resultData)). That's better because it includes the revert reason. But in transferERC721, for non-punks and non-kitties, they use safeTransferFrom, which should revert on failure. But the code here does a low-level call and checks success. However, safeTransferFrom would revert if the transfer fails, but since it's a low-level call, it might not. For example, if the receiving contract doesn't implement the ERC721Receiver, safeTransferFrom would fail, but the low-level call would catch that as a success=false. So that's handled. So maybe that part is okay.

Another thing: the vault uses EnumerableSetUpgradeable for holdings. For ERC721, each tokenId is added once, and for ERC1155, quantity is tracked. But when minting ERC1155, if the same tokenId is sent multiple times in the tokenIds array, the quantity is incremented. But the code checks if quantity1155[tokenId] is 0 before adding to holdings. That's correct. So for ERC1155, each tokenId is in holdings once, regardless of quantity.

In the withdrawNFTsTo function, when redeeming, for ERC1155, they subtract 1 from quantity1155 and remove from holdings if it reaches zero. That's correct. But for ERC721, they remove the tokenId from holdings and transfer it out. However, if the vault has an ERC721 token that's not in holdings (due to the earlier mentioned issue), that token could be stuck in the contract, because the code only transfers out tokens that are in holdings. But during redemption, only tokens in holdings are selected, so those stuck tokens wouldn't be accessible. However, during mint, if someone can add a tokenId to holdings without transferring, that's the problem.

Another point: the afterRedeemHook calls eligibilityStorage.afterRedeemHook(tokenIds). If the eligibilityStorage is malicious or has a vulnerability, this could be a reentrancy vector. But the redeemTo function has a nonReentrant modifier, so that should prevent reentrancy. However, if the eligibilityStorage's afterRedeemHook is called after the tokens are transferred out, maybe there's a reentrancy there. Let me check the flow: in withdrawNFTsTo, after transferring the tokens, they call afterRedeemHook(redeemedIds). So the hook is called after the tokens have been sent. If the hook makes an external call to a contract that reenters the vault, but the redeemTo function is nonReentrant, so reentrancy would be blocked. So that's probably safe.

The _chargeAndDistributeFees function transfers the fee to the feeDistributor. If the feeDistributor is a malicious contract, the transfer could fail, but since it's set by the vaultFactory, which is presumably trusted, this is a trust issue rather than a vulnerability.

Now, the use of ERC20FlashMintUpgradeable: flash mints allow anyone to borrow tokens as long as they pay them back within the same transaction. The flashLoan function here is protected by onlyOwnerIfPaused(4), which if not paused, allows anyone to use it. But this is standard for flash loans. The risk is if the vault's other functions don't properly account for the temporary balance changes during a flash loan. For example, if someone takes a flash loan and then interacts with another function that uses the vault's balance, but since ERC20 is being used, the totalSupply would include the flash minted tokens. However, since the flash loan must be repaid, this is generally safe. But maybe there's an interaction I'm missing.

Looking at the setVaultFeatures function: it allows the privileged account to enable/disable various features. If these are set incorrectly, it could affect the vault's functionality, but that's an admin risk, not a code vulnerability.

The assignDefaultFeatures function has a hardcoded address check. If that address is ever compromised, or if the protocol wants to change it, they can't. So this is an admin key risk.

Another thing: the vaultId is set to vaultFactory.numVaults() during initialization. Since the vault is created via the factory, this should be correct. But if the factory's numVaults() is not properly incremented before this call, vaultId could be wrong. However, since the factory is presumably the one deploying this contract, it's likely handled correctly.

In the mintTo function, the count for ERC721 is tokenIds.length, and for ERC1155, it's the sum of amounts. Then, the user is minted base * count tokens. So for ERC1155, each ""amount"" is a token count. That's correct.

Now, let's list potential vulnerabilities:

1. **Insecure Randomness in getRandomTokenIdFromVault**: The function uses block variables and a nonce to generate a random index, which can be manipulated by miners or attackers. This allows attackers to predict or influence which NFTs are redeemed, potentially leading to theft of high-value NFTs.

2. **ERC721 Minting Without Transfer**: If the vault already holds an ERC721 token (not in holdings), a user can mint shares by including that tokenId, causing the vault to add it to holdings without the user transferring the token. This allows users to mint shares for NFTs they don't own, leading to loss of funds.

3. **Hardcoded Address in assignDefaultFeatures**: The function assignDefaultFeatures can only be called by a specific address (0xDEA9...). This centralizes control and poses a risk if the private key for that address is compromised.

4. **Reentrancy in Flash Loan**: The flashLoan function doesn't have a nonReentrant modifier, but other functions do. However, if the callback during flash loan reenters a function that isn't protected, it could cause issues. But given that functions like mintTo, redeemTo, etc., have nonReentrant, maybe this is mitigated. Need to check which functions are callable. For example, if a flash loan is taken and the callback calls redeemTo, which is nonReentrant, it would be blocked. So maybe not a vulnerability here.

5. **Lack of Access Control in assignDefaultFeatures**: Only the hardcoded address can call this function, which might be intended, but it's a centralization risk.

6. **Unchecked Return Value in transferERC721**: In transferERC721, the code uses a low-level call and checks success, but for some ERC721 implementations, the function might return false instead of reverting. However, the code does require(success), so that's okay.

7. **Possible Front-Running in Minting**: If a user sends an NFT to the vault and then quickly mints using that tokenId, they can claim shares without actually transferring. But the vulnerability here is the same as point 2.

8. **Eligibility Storage Not Set**: If allowAllItems is false and eligibilityStorage is not set, all mints would fail. This is a configuration issue but could be a denial-of-service if not properly initialized.

So the main critical issues are points 1, 2, and 3. 

Another thing to note: the code uses upgradeable contracts but doesn't have a storage gap. OpenZeppelin recommends adding a storage gap in upgradeable contracts to allow for future upgrades. The absence of a __gap variable could prevent future upgrades if new state variables are added. However, the current contract may have inherited the gap from the parent contracts. Checking the imports: the OwnableUpgradeable, ERC20FlashMintUpgradeable, etc., might include the gaps. But if this contract adds new state variables without a gap, that's a problem. Let me check the state variables in the contract:

The contract defines several state variables after the inheritance, including vaultId, manager, assetAddress, vaultFactory, eligibilityStorage, randNonce, UNUSED_FEEs, booleans, and mappings. Since all upgradeable contracts from OZ have a __gap at the end, but this contract does not. So if they add more variables in an upgrade, it could overwrite existing storage slots. This is a vulnerability in terms of upgradeability but might not affect the current version. However, since the question is about vulnerabilities in the given code, and the code doesn't include a storage gap, that's a potential issue.

But the user asked not to provide mitigations, just list vulnerabilities.

So summarizing the vulnerabilities:

- Insecure randomness in the selection of NFTs during redemption, allowing manipulation.
- Minting of vault shares without transferring ERC721 tokens if the vault already holds them, leading to theft.
- Use of a hardcoded address for privileged function access, creating centralization risk.
- Missing storage gap for upgradeable contracts, risking future upgrades."
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4828.0,479.0,"[M-08] Low-level call return value not checked
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect CryptoPunks Handling**  
   - The `transferFromERC721` function incorrectly uses `buyPunk` to transfer CryptoPunks, which requires the punk to be listed for sale. This fails for non-listed punks, preventing legitimate transfers.  
   - The `approveERC721` function uses `offerPunkForSaleToAddress` instead of proper approval mechanisms, leading to failed approvals.

2. **Reentrancy Risks in `provideInventory` Functions**  
   - `provideInventory721` and `provideInventory1155` lack the `nonReentrant` modifier. Malicious ERC721/ERC1155 contracts could re-enter these functions during token transfers, potentially manipulating contract state.

3. **Ownable Initialization Conflict**  
   - The contract imports `OwnableUpgradeable` but inherits from `Ownable`, causing a mismatch. If `OwnableUpgradeable` was intended, the constructor incorrectly initializes ownership (upgradeable contracts require `initialize` functions, not constructors).

4. **Unrestricted ERC20 Rescue Function**  
   - The `rescue` function allows the owner to withdraw arbitrary ERC20 tokens, posing a centralization risk if funds are accidentally trapped or misused.

5. **Redundant Code in Liquidity Addition**  
   - The check `if (amountToken < minTokenIn)` in `_addLiquidityAndLock` is redundant because `addLiquidity` enforces `amountToken >= minTokenIn`, making this code unreachable.

6. **Unchecked External Call Return Values**  
   - Return values of `inventoryStaking.timelockMintFor` and `lpStaking.timelockDepositFor` are not checked, risking silent failures if these functions do not revert on errors.

7. **ERC1155 Reentrancy During Transfers**  
   - `provideInventory1155` uses `safeBatchTransferFrom` without reentrancy guards, potentially allowing reentrant calls during token receipt callbacks.

8. **Front-Running Exposure**  
   - The use of `block.timestamp` as a deadline in `addLiquidity` functions offers minimal protection against delayed transactions, exposing users to front-running risks (design-level concern).

9. **Incompatible ERC721 Logic for CryptoKitties**  
   - The `transferFrom` method for CryptoKitties assumes prior approval, which may not exist, leading to failed transfers if the contract isn’t approved by the user.

10. **Unsafe Low-Level ETH Transfer**  
    - ETH refunds use `payable(to).call{value: ...}`, which could expose to reentrancy if the `nonReentrant` modifier is improperly applied. However, the modifier is present in enclosing functions, mitigating this risk.","---

**[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded. This could lead to silent failures if the call fails, potentially resulting in loss of funds or unexpected behavior.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Low-Level ETH Transfer""**.

**Validation**:  
**Partially Correct**. The response identifies the use of low-level `.call` for ETH transfers, which is relevant to the issue. However, it focuses on the potential reentrancy risk rather than the specific problem of unchecked return values. While the response mentions the presence of the `nonReentrant` modifier, it does not address the core issue of failing to validate the success of the low-level call. This oversight is critical, as unchecked return values can lead to silent failures and financial losses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-08] Low-level call return value not checked**

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation highlights that while the response partially addresses the issue, it misses the critical aspect of validating return values, which is central to the reported vulnerability.",0,1,0,10,"Okay, let's try to figure out the vulnerabilities in this smart contract. I'm a bit new to this, so I'll take it step by step.

First, I'll look at the code structure. The contract is called NFTXStakingZap, and it imports several interfaces and inherits from Ownable, ReentrancyGuard, ERC721HolderUpgradeable, and ERC1155HolderUpgradeable. The main functions involve staking NFTs and providing liquidity, handling both ERC721 and ERC1155 tokens. There are functions like provideInventory721, addLiquidity721ETHTo, and others that interact with external contracts.

Now, potential vulnerabilities. The first thing that comes to mind is reentrancy. The contract uses ReentrancyGuard with a nonReentrant modifier. But I should check where the modifier is applied. For example, the addLiquidity721ETHTo function has the nonReentrant modifier, which is good. But other functions like provideInventory721 don't have it. Wait, but maybe those functions don't call external contracts in a way that's vulnerable. Hmm.

Looking at the transferFromERC721 function. It uses low-level calls to transfer ERC721 tokens. There's a check for success, but some ERC721 implementations might not follow the standard, leading to issues. Also, the code has special cases for CryptoKitties and CryptoPunks, which are non-standard. For example, when dealing with punks, it calls buyPunk, which might have different behavior. Are there any reentrancy possibilities here? Since these are specific to those contracts, maybe there's a risk if those contracts have unexpected behavior.

Another point is the use of safeTransferFrom in transferFromERC721. For standard ERC721, safeTransferFrom can call back into the contract, leading to reentrancy. But the nonReentrant modifier is on the functions that call transferFromERC721, right? Let me check. For example, provideInventory721 is called by users. If that function is called and during the transferFromERC721, a malicious contract's onERC721Received is triggered, could that re-enter? Since provideInventory721 doesn't have a nonReentrant modifier, that's a possible issue. But maybe the functions that call provideInventory721 are not protected. Wait, provideInventory721 is a public function. If someone calls it directly, and during the transfer, a reentrant call is made, maybe that could cause issues. So that's a possible reentrancy vulnerability.

Another area is the use of ERC20 approvals. For example, in the constructor, WETH is approved with type(uint256).max. If the sushiRouter is compromised, that could lead to draining WETH. But that's probably a trust issue on the router, which is an external dependency.

Looking at the addLiquidityAndLock function. It uses sushiRouter.addLiquidity. The parameters minTokenIn and minWethIn are user-provided. Wait, no, in _addLiquidity721WETH, minTokenIn is the balance calculated after minting. But in the call to addLiquidity, the minTokenIn is passed as both the amount of tokens to add and the min. That's okay because the code checks that the balance after minting is correct. However, if the vault's mint function doesn't mint the expected tokens, there could be a discrepancy. But the code does have a require statement checking the balance after minting. So maybe that's handled.

Another thing is the use of block.timestamp in the addLiquidity call. The sushiRouter.addLiquidity uses block.timestamp as the deadline, which is acceptable, but in the _addLiquidityAndLock function, it's using block.timestamp for the deadline. Wait, no, the deadline is set to block.timestamp, which might not give enough time for the transaction to be mined. However, the code uses the sushiRouter's addLiquidity function with block.timestamp, which is common practice but could be a minor issue if the transaction is delayed. But maybe that's considered acceptable.

Looking at the rescue function. It allows the owner to rescue any ERC20 token, which is a common feature. But if the contract holds tokens that are supposed to be locked or belong to users, this could be a privilege escalation. However, since the contract is supposed to not hold funds after operations (as it transfers excess back), maybe it's acceptable. But if there's a mistake in the code where tokens are left behind, the owner can take them, which is a centralization risk.

In the _addLiquidityAndLock function, after adding liquidity, the LP tokens are sent to lpStaking. But what if the liquidity is zero? The code doesn't check if liquidity is positive. If the addLiquidity call fails to provide liquidity but doesn't revert, it could deposit zero, which might be an issue. But the addLiquidity function in Uniswap should revert if the liquidity is zero, assuming correct min values.

Another thing: in the functions that handle ETH, like addLiquidity721ETHTo, after depositing WETH, any excess ETH is sent back using a call. The code does payable(to).call{value: ...} which is a low-level call. This could potentially allow for reentrancy if 'to' is a malicious contract. However, since the nonReentrant modifier is applied to the function, the reentrancy guard should prevent that. But wait, the nonReentrant modifier is on the outer function. If during the WETH.withdraw, which is a call to WETH contract, and then sending ETH via call, could that be a problem? Let's see: the nonReentrant modifier is active during the entire function execution. So any reentrant call during the payable(to).call would be blocked by the reentrancy guard. So that's probably safe.

In the transferFromERC721 function, when handling CryptoPunks, it checks if the owner is the msg.sender, then calls buyPunk. But CryptoPunks have a different ownership model. The buyPunk function is called by the contract, which might not have the punk. Wait, the code first checks if the owner is msg.sender. Then, it calls buyPunk(tokenId), which would require that the contract has enough ETH to buy the punk. But in this context, the msg.sender is the user, and the code is trying to transfer the punk from the user to the contract. However, the buyPunk function is used to purchase a punk that's for sale. But here, the code is trying to transfer a punk that the user already owns. That doesn't make sense. The correct way to transfer a punk is to call transferPunk, not buyPunk. So this seems like a flaw. If the user owns the punk and wants to transfer it, the code would instead try to buy it, which would fail unless the punk is for sale. This would cause the transfer to fail, leading to a revert. So this is a vulnerability in handling CryptoPunks transfers.

Similarly, in the approveERC721 function for punks, it calls offerPunkForSaleToAddress with price 0. But that might not be the correct way to approve the vault to take the punk. The correct method for allowing another address to transfer a punk is to use offerPunkForSaleToAddress, but if the contract doesn't actually own the punk, this could fail. So the approval step for punks is flawed.

Another issue: in the provideInventory721 function, after transferring the NFTs to the vault, it mints the xTokens. But if the vault's mint function doesn't correctly handle the NFTs, the xToken balance might not increase as expected. However, the code checks that the new balance is oldBal + count*BASE, which should catch that. So maybe that's okay.

In the addLiquidity functions, there's a call to pairFor to get the LP token address. This uses a hardcoded SushiSwap factory and init code hash. If the SushiSwap factory's implementation changes, this could return the wrong address. But since the sushiRouter is set in the constructor and the pairFor uses the router's factory, maybe this is correct. Wait, no. The pairFor function in the contract uses the sushiRouter's factory, which is correct. So if the router is correctly set, the pairFor should compute the correct address. But if the router's factory is upgraded, this could break. But the contract's code uses the router's factory at the time of deployment, so it's static. Wait, the code for pairFor uses the factory address from the sushiRouter, which is a state variable. So if the sushiRouter's factory changes over time (unlikely, since Uniswap/Sushiswap factories are usually immutable), then the pairFor would compute incorrect addresses. But assuming the sushiRouter is a correct and unchanging router, this should be okay.

Looking at the rescue function again: it allows the owner to transfer any ERC20 token from the contract. If users accidentally send tokens to the contract, the owner can rescue them, which is a centralization risk but not a vulnerability per se. However, if the contract is supposed to hold user funds temporarily, this could allow the owner to steal them. But in normal operation, the contract should not hold funds after transactions. Still, the presence of a rescue function could be considered a backdoor.

Another possible issue is front-running. For example, when adding liquidity, the minWethIn and minTokenIn are parameters. If the transaction is front-run, the actual amounts could be worse than expected, but the user sets the minimums. So that's handled by the user setting appropriate slippage. So not a vulnerability in the contract code itself.

In the transferFromERC721 function, the code uses a low-level call and then checks success. However, some ERC721 implementations might not revert on failure but return false. The code uses require(success, ...), which would catch that. So that's okay.

There's also the use of ERC721HolderUpgradeable and ERC1155HolderUpgradeable, which handle the safe transfer callbacks. Those should be okay, as they implement the necessary functions to receive tokens.

Wait, in the provideInventory1155 function, the code calls nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """"). Then approves the vault and mints. Since the contract is holding the ERC1155 tokens temporarily, but then transfers them to the vault, that's okay. But during the time between transferFrom and mintTo, the contract holds the tokens. If there's a reentrancy here, but since provideInventory1155 doesn't have a nonReentrant modifier, maybe that's a risk. However, ERC1155's safeBatchTransferFrom would call onERC1155BatchReceived on the recipient (this contract), which is handled by ERC1155HolderUpgradeable. The implementation of that function should prevent reentrancy during the transfer. Wait, the ERC1155HolderUpgradeable's onERC1155Received and onERC1155BatchReceived functions are called during the transfer. Since the provideInventory1155 function is called by the user, and during the safeBatchTransferFrom, the contract's onERC1155BatchReceived is triggered. The ERC1155HolderUpgradeable's implementation returns the function selector, indicating that it can receive the tokens. But during this callback, could a malicious contract re-enter provideInventory1155? If the user is a contract, and during the transfer, it calls back into provideInventory1155, but since provideInventory1155 is a public function and not protected by nonReentrant, this could be a problem. However, since the code first transfers the tokens to itself, then approves the vault, then mints, maybe the state changes would prevent reentrancy attacks. But without a reentrancy guard, it's possible. For example, during the safeBatchTransferFrom, the attacker's onERC1155BatchReceived could call back into provideInventory1155 again, before the first call has completed. Since the contract's state hasn't been updated yet (the mint hasn't happened), this could lead to double-minting or other issues. But the code checks the balance before and after minting, so maybe that's okay. But this is a possible reentrancy vector.

Another thing: the provideInventory721 and provideInventory1155 functions do not have any access control. Anyone can call them. Is that intended? The functions are supposed to allow users to stake their NFTs, so that's correct. But maybe there's a lack of validation on the tokenIds or amounts, leading to possible errors. For example, in provideInventory721, if the user passes tokenIds that they don't own, the transferFrom would fail, so that's handled by the require(success) in transferFromERC721. So that's okay.

In the addLiquidityAndLock function, after adding liquidity, the code transfers any excess tokens back to the user. However, there's a line: if (amountToken < minTokenIn) { ... transfer minTokenIn - amountToken }. Wait, minTokenIn is the amount the user intended to add. But amountToken is the actual tokens used. If the actual is less than minTokenIn, the contract transfers the difference back. That's correct. Because the user specified a minimum amount of tokens they want to use, but the actual could be higher. Wait, no, in addLiquidity, the parameters are (amountTokenDesired, amountEthDesired, amountTokenMin, amountEthMin, ...). So the code here uses minTokenIn as amountTokenDesired, and minTokenIn as amountTokenMin. So if the actual amountToken used is less than minTokenIn (due to slippage), the require would fail. Wait, in the addLiquidity call:

sushiRouter.addLiquidity(
  address(vault), 
  sushiRouter.WETH(),
  minTokenIn, // amountTokenDesired
  wethIn, // amountEthDesired
  minTokenIn, // amountTokenMin
  minWethIn, // amountEthMin
  address(this), 
  block.timestamp
);

So the minTokenIn is both the desired and the min. So if the actual token amount is less than minTokenIn, the addLiquidity would revert. Therefore, the code after the addLiquidity that checks if (amountToken < minTokenIn) would never execute, because the addLiquidity would have already reverted. So that code is redundant. But since the code uses the returned amountToken, which is the actual used, perhaps in some cases, even with the min parameters, the amountToken could be less. Wait, no: the addLiquidity function will ensure that amountToken >= amountTokenMin. Since amountTokenMin is set to minTokenIn, which is the same as the desired, the addLiquidity should use exactly minTokenIn or more. But in reality, due to the way liquidity is calculated, the actual amount used might be less than desired but not less than the min. But the code sets amountTokenMin to minTokenIn, which is the same as the desired. Therefore, if the actual amountToken is less than desired, but not less than the min (which is equal to desired), then it would revert. Therefore, the check after addLiquidity for (amountToken < minTokenIn) is unnecessary and can never be true. So that code is dead code. But that's not a vulnerability, just an inefficiency.

Another possible issue is the use of timelockMintFor in inventoryStaking. The code does not check the return value xTokensMinted. If the inventoryStaking.timelockMintFor fails to mint the xTokens, the function would proceed regardless. However, the function is likely designed to revert on failure, as it's an external call. But if the function doesn't revert, this could be an issue. For example, if timelockMintFor returns 0 but doesn't revert, the code would proceed. However, the inventoryStaking contract's function is expected to revert on failure, so maybe this is safe. But the code doesn't check the returned xTokensMinted, which could be a problem if the function doesn't revert.

In the same vein, lpStaking.timelockDepositFor is called, but there's no check on the return value. If the deposit fails but doesn't revert, the code would proceed. But again, assuming those functions revert on failure, this is okay.

In the transferFromERC721 function, when dealing with CryptoKitties, it uses transferFrom, which for CryptoKitties requires that the sender is the owner or approved. But the code is using msg.sender as the from address. So if the user is transferring their own CryptoKitty, this should work. However, the code uses ""transferFrom(msg.sender, address(this), tokenId)"", which would require that the contract is approved to transfer the Kitty. But in the code's transferFromERC721, it's the user calling provideInventory721, so msg.sender should be the owner of the Kitty. Therefore, the transferFrom should work. But if the user hasn't approved the contract, the transfer would fail, which is correct. However, the code doesn't handle that scenario; it just assumes the user has approved the contract. Wait, no. The code's transferFromERC721 is called when the user is providing their NFT. So the user must have approved the contract to transfer their NFTs. Otherwise, the transferFrom would fail. But the code's functions (like provideInventory721) require that the user has done that. So this is a user responsibility, not a contract vulnerability.

Another thing: the code uses IERC20Upgradeable(vault).balanceOf(address(xToken)) before and after minting. If the vault's balance is manipulated during the minting process (e.g., someone else mints or burns tokens), the require statement might fail incorrectly. But since the code is in a nonReentrant function (if applicable) and the calls are atomic, this is unlikely. However, provideInventory721 is not protected by nonReentrant, so if the vault's balance changes during the mint, the require could fail. But the function is designed to mint exactly the number of tokens based on the transferred NFTs, so that should hold.

In the _addLiquidity721WETH function, after transferring the NFTs to the vault, it calls mint(ids, emptyIds), which mints the vTokens. The emptyIds is an empty array. The INFTXVault's mint function is supposed to take the ids and amounts, but for ERC721, amounts are zero. Wait, the code passes emptyIds as the second parameter, which is for ERC1155 amounts. But for ERC721, the function may expect that the amounts array is empty or not. The INFTXVault's mint function for ERC721 might require that the amounts array is empty, but if not, this could lead to incorrect minting. But according to the code, the emptyIds is an array of length zero, which should be acceptable for ERC721. So that's okay.

Finally, the contract uses OwnableUpgradeable from the util directory. Wait, but the contract NFTXStakingZap inherits from Ownable, which is a standard Ownable implementation, not the upgradeable one. Looking at the code, the contract NFTXStakingZap is using Ownable and ReentrancyGuard. However, OwnableUpgradeable is a different contract meant for upgradeable contracts. But in the given code, the NFTXStakingZap inherits from Ownable, not OwnableUpgradeable. However, the import is ""util/OwnableUpgradeable.sol"". Wait, this might be a mistake. If the contract is supposed to use OwnableUpgradeable (for upgradeability) but instead inherits from Ownable (which is not upgradeable), there could be issues. But looking at the code:

The contract declaration is:

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {

But the import is ""./util/OwnableUpgradeable.sol"". If the Ownable being used here is actually OwnableUpgradeable, then there's a problem because OwnableUpgradeable has different initializer functions (like __Ownable_init()) instead of a constructor. However, in the contract's constructor, it calls Ownable() and ReentrancyGuard(). If Ownable is the upgradeable version, the constructor would fail because upgradeable contracts can't use constructors; they use initialize functions. So this is a possible issue. The contract might be using the wrong Ownable implementation, leading to initialization conflicts. This could prevent the contract from being deployed correctly or cause ownership functions to malfunction. For example, the OwnableUpgradeable requires that the initialize function is called, but if the contract uses the constructor from the non-upgradeable Ownable, there could be inconsistencies. This is a critical issue because it could mean that the owner is not set correctly, or the contract is not initializing properly, leading to ownership being set to the zero address or another incorrect address.

So summarizing the potential vulnerabilities:

1. **Incorrect handling of CryptoPunks in transferFromERC721 and approveERC721 functions**: Using buyPunk instead of transferPunk for CryptoPunks, leading to failed transfers when the user owns the punk but hasn't listed it for sale. Similarly, using offerPunkForSaleToAddress for approval may not correctly approve the vault to transfer the punk.

2. **Reentrancy in provideInventory721 and provideInventory1155 functions**: These functions do not have the nonReentrant modifier, and during the ERC721 or ERC1155 transfers, a malicious contract could re-enter the function, potentially leading to unexpected behavior.

3. **Use of Ownable instead of OwnableUpgradeable leading to initialization issues**: If the contract was intended to be upgradeable but uses the non-upgradeable Ownable, the owner might not be initialized correctly, causing ownership functions to fail.

4. **Incorrect ERC20 approval in the rescue function**: The rescue function allows the owner to withdraw any ERC20 token, which could be a backdoor if not properly documented or if users mistakenly deposit tokens into the contract.

5. **Possible front-running vulnerabilities**: While not a code flaw, the lack of protection against MEV (Miner Extractable Value) attacks, such as using deadlines in addLiquidity, could allow miners to sandwich transactions, but this is more of a design consideration.

6. **Dead code in _addLiquidityAndLock**: The check for (amountToken < minTokenIn) is redundant since the addLiquidity call should revert if the minimum isn't met, leading to unnecessary code that could be confusing or a maintenance issue.

7. **Incorrect use of ERC1155 safeBatchTransferFrom without reentrancy guards**: The provideInventory1155 function could be vulnerable to reentrancy during the safeBatchTransferFrom callback, though mitigated if the called contract doesn't perform malicious actions.

8. **Missing checks on return values from external calls**: Functions like inventoryStaking.timelockMintFor and lpStaking.timelockDepositFor do not check return values, assuming they revert on failure. If these functions don't revert on failure, it could lead to incorrect state changes.

Each of these points should be evaluated for their severity and likelihood. The most critical ones are the CryptoPunk handling, reentrancy in provideInventory functions, and the Ownable initialization issue."
,,,,,,,,3,12,,,0,4,11,34,