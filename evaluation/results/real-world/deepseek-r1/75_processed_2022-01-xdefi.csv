nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP
XDEFIDistribution.sol,"// SPDX-License-Identifier: MIT

pragma solidity =0.8.10;

import { ERC721, ERC721Enumerable, Strings } from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import { IERC20, SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import { IEIP2612 } from ""./interfaces/IEIP2612.sol"";
import { IXDEFIDistribution } from ""./interfaces/IXDEFIDistribution.sol"";

/// @dev Handles distributing XDEFI to NFTs that have locked up XDEFI for various durations of time.
contract XDEFIDistribution is IXDEFIDistribution, ERC721Enumerable {

    uint88 internal MAX_TOTAL_XDEFI_SUPPLY = uint88(240_000_000_000_000_000_000_000_000);

    // See https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728
    uint256 internal constant _pointsMultiplier = uint256(2**128);
    uint256 internal _pointsPerUnit;

    address public immutable XDEFI;

    uint256 public distributableXDEFI;
    uint256 public totalDepositedXDEFI;
    uint256 public totalUnits;

    mapping(uint256 => Position) public positionOf;

    mapping(uint256 => uint8) public bonusMultiplierOf;  // Scaled by 100 (i.e. 1.1x is 110, 2.55x is 255).

    uint256 internal immutable _zeroDurationPointBase;

    string public baseURI;

    address public owner;
    address public pendingOwner;

    uint256 internal _locked;

    constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(""Locked XDEFI"", ""lXDEFI"") {
        require((XDEFI = XDEFI_) != address(0), ""INVALID_TOKEN"");
        owner = msg.sender;
        baseURI = baseURI_;
        _zeroDurationPointBase = zeroDurationPointBase_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""NOT_OWNER"");
        _;
    }

    modifier noReenter() {
        require(_locked == 0, ""LOCKED"");
        _locked = uint256(1);
        _;
        _locked = uint256(0);
    }

    /*******************/
    /* Admin Functions */
    /*******************/

    function acceptOwnership() external {
        require(pendingOwner == msg.sender, ""NOT_PENDING_OWNER"");
        emit OwnershipAccepted(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }

    function proposeOwnership(address newOwner_) external onlyOwner {
        emit OwnershipProposed(owner, pendingOwner = newOwner_);
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {
        uint256 count = durations_.length;

        for (uint256 i; i < count; ++i) {
            uint256 duration = durations_[i];
            require(duration <= uint256(18250 days), ""INVALID_DURATION"");
            emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);
        }
    }

    /**********************/
    /* Position Functions */
    /**********************/

    function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {
        // Lock the XDEFI in the contract.
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        // Handle the lock position creation and get the tokenId of the locked position.
        return _lock(amount_, duration_, destination_);
    }

    function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {
        // Approve this contract for the amount, using the provided signature.
        IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);

        // Lock the XDEFI in the contract.
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        // Handle the lock position creation and get the tokenId of the locked position.
        return _lock(amount_, duration_, destination_);
    }

    function relock(uint256 tokenId_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        // Handle the unlock and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        // Handle the lock position creation and get the tokenId of the locked position.
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            // Send the excess XDEFI to the destination, if needed.
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.
        _updateXDEFIBalance();
    }

    function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        // Handle the unlock and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        // Send the the unlocked XDEFI to the destination.
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.
        _updateXDEFIBalance();
    }

    function updateDistribution() external {
        uint256 totalUnitsCached = totalUnits;

        require(totalUnitsCached > uint256(0), ""NO_UNIT_SUPPLY"");

        uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());

        if (newXDEFI == uint256(0)) return;

        _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);

        emit DistributionUpdated(msg.sender, newXDEFI);
    }

    function withdrawableOf(uint256 tokenId_) public view returns (uint256 withdrawableXDEFI_) {
        Position storage position = positionOf[tokenId_];
        return _withdrawableGiven(position.units, position.depositedXDEFI, position.pointsCorrection);
    }

    /****************************/
    /* Batch Position Functions */
    /****************************/

    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        // Handle the lock position creation and get the tokenId of the locked position.
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            // Send the excess XDEFI to the destination, if needed.
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.
        _updateXDEFIBalance();
    }

    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        // Send the the unlocked XDEFI to the destination.
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.
        _updateXDEFIBalance();
    }

    /*****************/
    /* NFT Functions */
    /*****************/

    function getPoints(uint256 amount_, uint256 duration_) external view returns (uint256 points_) {
        return _getPoints(amount_, duration_);
    }

    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""MIN_2_TO_MERGE"");

        uint256 points;

        // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.
        for (uint256 i; i < count; ++i) {
            uint256 tokenId = tokenIds_[i];
            require(ownerOf(tokenId) == msg.sender, ""NOT_OWNER"");
            require(positionOf[tokenId].expiry == uint32(0), ""POSITION_NOT_UNLOCKED"");

            _burn(tokenId);

            points += _getPointsFromTokenId(tokenId);
        }

        // Mine a new NFT to the destinations, based on the accumulated points.
        _safeMint(destination_, tokenId_ = _generateNewTokenId(points));
    }

    function pointsOf(uint256 tokenId_) external view returns (uint256 points_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return _getPointsFromTokenId(tokenId_);
    }

    function tokenURI(uint256 tokenId_) public view override(IXDEFIDistribution, ERC721) returns (string memory tokenURI_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return string(abi.encodePacked(baseURI, Strings.toString(tokenId_)));
    }

    /**********************/
    /* Internal Functions */
    /**********************/

    function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {
        // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.
        return (points_ << uint256(128)) + uint128(totalSupply() + 1);
    }

    function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {
        return amount_ * (duration_ + _zeroDurationPointBase);
    }

    function _getPointsFromTokenId(uint256 tokenId_) internal pure returns (uint256 points_) {
        return tokenId_ >> uint256(128);
    }

    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {
        // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.
        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, ""INVALID_AMOUNT"");

        // Get bonus multiplier and check that it is not zero (which validates the duration).
        uint8 bonusMultiplier = bonusMultiplierOf[duration_];
        require(bonusMultiplier != uint8(0), ""INVALID_DURATION"");

        // Mint a locked staked position NFT to the destination.
        _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));

        // Track deposits.
        totalDepositedXDEFI += amount_;

        // Create Position.
        uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));
        totalUnits += units;
        positionOf[tokenId_] =
            Position({
                units: units,
                depositedXDEFI: uint88(amount_),
                expiry: uint32(block.timestamp + duration_),
                created: uint32(block.timestamp),
                bonusMultiplier: bonusMultiplier,
                pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)
            });

        emit LockPositionCreated(tokenId_, destination_, amount_, duration_);
    }

    function _toInt256Safe(uint256 x_) internal pure returns (int256 y_) {
        y_ = int256(x_);
        assert(y_ >= int256(0));
    }

    function _toUint256Safe(int256 x_) internal pure returns (uint256 y_) {
        assert(x_ >= int256(0));
        return uint256(x_);
    }

    function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {
        // Check that the account is the position NFT owner.
        require(ownerOf(tokenId_) == account_, ""NOT_OWNER"");

        // Fetch position.
        Position storage position = positionOf[tokenId_];
        uint96 units = position.units;
        uint88 depositedXDEFI = position.depositedXDEFI;
        uint32 expiry = position.expiry;

        // Check that enough time has elapsed in order to unlock.
        require(expiry != uint32(0), ""NO_LOCKED_POSITION"");
        require(block.timestamp >= uint256(expiry), ""CANNOT_UNLOCK"");

        // Get the withdrawable amount of XDEFI for the position.
        amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);

        // Track deposits.
        totalDepositedXDEFI -= uint256(depositedXDEFI);

        // Burn FDT Position.
        totalUnits -= units;
        delete positionOf[tokenId_];

        emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);
    }

    function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""USE_UNLOCK"");

        // Handle the unlock for each position and accumulate the unlocked amount.
        for (uint256 i; i < count; ++i) {
            amountUnlocked_ += _unlock(account_, tokenIds_[i]);
        }
    }

    function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {
        uint256 previousDistributableXDEFI = distributableXDEFI;
        uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;

        return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);
    }

    function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {
        return
            (
                _toUint256Safe(
                    _toInt256Safe(_pointsPerUnit * uint256(units_)) +
                    pointsCorrection_
                ) / _pointsMultiplier
            ) + uint256(depositedXDEFI_);
    }

}",3289,347,"[H-01] Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases
“_pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);”
In the current implementation, `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.
A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.
As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.
  [H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards
There is a reentrancy vulnerability in the `_safeMint` function
  [M-01] `_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function
NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.
When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The merge() function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, _generateNewTokenId() may end up using the same totalSupply() value, causing _safeMint() to fail if the same amount_ and duration_ values are used.
This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate tokenId. As a result, this may impact a user's overall experience while interacting with the XDEFI protocol, as some transactions may fail unexpectedly.",3,"pragma solidity =0.8.10;

import { ERC721, ERC721Enumerable, Strings } from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import { IERC20, SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import { IEIP2612 } from ""./interfaces/IEIP2612.sol"";
import { IXDEFIDistribution } from ""./interfaces/IXDEFIDistribution.sol"";


contract XDEFIDistribution is IXDEFIDistribution, ERC721Enumerable {

    uint88 internal MAX_TOTAL_XDEFI_SUPPLY = uint88(240_000_000_000_000_000_000_000_000);

    
    uint256 internal constant _pointsMultiplier = uint256(2**128);
    uint256 internal _pointsPerUnit;

    address public immutable XDEFI;

    uint256 public distributableXDEFI;
    uint256 public totalDepositedXDEFI;
    uint256 public totalUnits;

    mapping(uint256 => Position) public positionOf;

    mapping(uint256 => uint8) public bonusMultiplierOf;  

    uint256 internal immutable _zeroDurationPointBase;

    string public baseURI;

    address public owner;
    address public pendingOwner;

    uint256 internal _locked;

    constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(""Locked XDEFI"", ""lXDEFI"") {
        require((XDEFI = XDEFI_) != address(0), ""INVALID_TOKEN"");
        owner = msg.sender;
        baseURI = baseURI_;
        _zeroDurationPointBase = zeroDurationPointBase_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""NOT_OWNER"");
        _;
    }

    modifier noReenter() {
        require(_locked == 0, ""LOCKED"");
        _locked = uint256(1);
        _;
        _locked = uint256(0);
    }

    
    
    

    function acceptOwnership() external {
        require(pendingOwner == msg.sender, ""NOT_PENDING_OWNER"");
        emit OwnershipAccepted(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }

    function proposeOwnership(address newOwner_) external onlyOwner {
        emit OwnershipProposed(owner, pendingOwner = newOwner_);
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {
        uint256 count = durations_.length;

        for (uint256 i; i < count; ++i) {
            uint256 duration = durations_[i];
            require(duration <= uint256(18250 days), ""INVALID_DURATION"");
            emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);
        }
    }

    
    
    

    function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {
        
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        
        return _lock(amount_, duration_, destination_);
    }

    function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {
        
        IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);

        
        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);

        
        return _lock(amount_, duration_, destination_);
    }

    function relock(uint256 tokenId_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        
        _updateXDEFIBalance();
    }

    function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        
        amountUnlocked_ = _unlock(msg.sender, tokenId_);

        
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        
        _updateXDEFIBalance();
    }

    function updateDistribution() external {
        uint256 totalUnitsCached = totalUnits;

        require(totalUnitsCached > uint256(0), ""NO_UNIT_SUPPLY"");

        uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());

        if (newXDEFI == uint256(0)) return;

        _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);

        emit DistributionUpdated(msg.sender, newXDEFI);
    }

    function withdrawableOf(uint256 tokenId_) public view returns (uint256 withdrawableXDEFI_) {
        Position storage position = positionOf[tokenId_];
        return _withdrawableGiven(position.units, position.depositedXDEFI, position.pointsCorrection);
    }

    
    
    

    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {
        
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        
        require(lockAmount_ <= amountUnlocked_, ""INSUFFICIENT_AMOUNT_UNLOCKED"");

        
        newTokenId_ = _lock(lockAmount_, duration_, destination_);

        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;

        if (withdrawAmount != uint256(0)) {
            
            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);
        }

        
        _updateXDEFIBalance();
    }

    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) {
        
        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);

        
        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);

        
        _updateXDEFIBalance();
    }

    
    
    

    function getPoints(uint256 amount_, uint256 duration_) external view returns (uint256 points_) {
        return _getPoints(amount_, duration_);
    }

    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""MIN_2_TO_MERGE"");

        uint256 points;

        
        for (uint256 i; i < count; ++i) {
            uint256 tokenId = tokenIds_[i];
            require(ownerOf(tokenId) == msg.sender, ""NOT_OWNER"");
            require(positionOf[tokenId].expiry == uint32(0), ""POSITION_NOT_UNLOCKED"");

            _burn(tokenId);

            points += _getPointsFromTokenId(tokenId);
        }

        
        _safeMint(destination_, tokenId_ = _generateNewTokenId(points));
    }

    function pointsOf(uint256 tokenId_) external view returns (uint256 points_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return _getPointsFromTokenId(tokenId_);
    }

    function tokenURI(uint256 tokenId_) public view override(IXDEFIDistribution, ERC721) returns (string memory tokenURI_) {
        require(_exists(tokenId_), ""NO_TOKEN"");
        return string(abi.encodePacked(baseURI, Strings.toString(tokenId_)));
    }

    
    
    

    function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {
        
        return (points_ << uint256(128)) + uint128(totalSupply() + 1);
    }

    function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {
        return amount_ * (duration_ + _zeroDurationPointBase);
    }

    function _getPointsFromTokenId(uint256 tokenId_) internal pure returns (uint256 points_) {
        return tokenId_ >> uint256(128);
    }

    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {
        
        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, ""INVALID_AMOUNT"");

        
        uint8 bonusMultiplier = bonusMultiplierOf[duration_];
        require(bonusMultiplier != uint8(0), ""INVALID_DURATION"");

        
        _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));

        
        totalDepositedXDEFI += amount_;

        
        uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));
        totalUnits += units;
        positionOf[tokenId_] =
            Position({
                units: units,
                depositedXDEFI: uint88(amount_),
                expiry: uint32(block.timestamp + duration_),
                created: uint32(block.timestamp),
                bonusMultiplier: bonusMultiplier,
                pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)
            });

        emit LockPositionCreated(tokenId_, destination_, amount_, duration_);
    }

    function _toInt256Safe(uint256 x_) internal pure returns (int256 y_) {
        y_ = int256(x_);
        assert(y_ >= int256(0));
    }

    function _toUint256Safe(int256 x_) internal pure returns (uint256 y_) {
        assert(x_ >= int256(0));
        return uint256(x_);
    }

    function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {
        
        require(ownerOf(tokenId_) == account_, ""NOT_OWNER"");

        
        Position storage position = positionOf[tokenId_];
        uint96 units = position.units;
        uint88 depositedXDEFI = position.depositedXDEFI;
        uint32 expiry = position.expiry;

        
        require(expiry != uint32(0), ""NO_LOCKED_POSITION"");
        require(block.timestamp >= uint256(expiry), ""CANNOT_UNLOCK"");

        
        amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);

        
        totalDepositedXDEFI -= uint256(depositedXDEFI);

        
        totalUnits -= units;
        delete positionOf[tokenId_];

        emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);
    }

    function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {
        uint256 count = tokenIds_.length;
        require(count > uint256(1), ""USE_UNLOCK"");

        
        for (uint256 i; i < count; ++i) {
            amountUnlocked_ += _unlock(account_, tokenIds_[i]);
        }
    }

    function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {
        uint256 previousDistributableXDEFI = distributableXDEFI;
        uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;

        return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);
    }

    function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {
        return
            (
                _toUint256Safe(
                    _toInt256Safe(_pointsPerUnit * uint256(units_)) +
                    pointsCorrection_
                ) / _pointsMultiplier
            ) + uint256(depositedXDEFI_);
    }

}",2551,2,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Token ID Overflow in Merge Function**  
   - **Description**: Merging tokens with high `points_` can cause an overflow when generating the new `tokenId_` via `_generateNewTokenId()`, leading to a transaction revert. This occurs because `points_ << 128` may exceed `uint256` limits.  
   - **Impact**: Critical (prevents merging large positions, disrupting functionality).

2. **Incorrect Array Length Handling in `setLockPeriods`**  
   - **Description**: The `setLockPeriods` function does not validate that `durations_` and `multipliers` arrays have equal lengths. If they differ, accessing `multipliers[i]` may cause an out-of-bounds error.  
   - **Impact**: High (potential reverts, misconfiguration of multipliers).

3. **Merging Unlocked/Expired Tokens**  
   - **Description**: The `merge` function allows merging tokens whose positions have already been unlocked (and deleted). This creates new tokens with points derived from expired positions, enabling users to illegitimately accrue rewards without locked collateral.  
   - **Impact**: Critical (funds theft via fake points).

4. **Timestamp Truncation to `uint32`**  
   - **Description**: `block.timestamp + duration_` is stored as `uint32`, which will overflow after the year 2106, causing reverts for valid transactions.  
   - **Impact**: Medium (long-term usability issue).

5. **Incompatibility with Fee-on-Transfer Tokens**  
   - **Description**: If the XDEFI token applies fees on transfers, `distributableXDEFI` calculations will underflow (due to `balanceOf` being less than `totalDepositedXDEFI`), breaking core functionality.  
   - **Impact**: High (contract reverts on critical functions).

6. **Integer Overflow in Points Correction**  
   - **Description**: When creating positions, `_pointsPerUnit * units` could exceed `2^255-1`, causing `pointsCorrection` (an `int256`) to overflow and revert.  
   - **Impact**: Low (theoretical, requires extreme values).

7. **Missing Access Control on `updateDistribution`**  
   - **Description**: Although not a direct vulnerability, allowing anyone to trigger `updateDistribution` could lead to front-running or unnecessary gas costs.  
   - **Note**: Design choice, but could be exploited for spam.

8. **Stale Position Data in Merge**  
   - **Description**: Merging tokens with deleted positions (post-unlock) allows creating invalid tokens, as their `points` are based on historical data, not active locks.  
   - **Impact**: Critical (rewards manipulation via ghost points).","### **Output**

---

**[H-01] Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases**

**Report Description**:  
The issue arises from the manipulation of `_pointsPerUnit` in the `updateDistribution()` function, which can be called by anyone. A malicious early user can lock a minimal amount (e.g., `1 wei`) of XDEFI, causing `_pointsPerUnit` to become excessively large. This can lead to arithmetic overflow in operations involving `_pointsMultiplier`, preventing future users from locking or unlocking their funds. As a result, the contract may malfunction, and users' funds could be frozen in edge cases.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it mentions missing access control on `updateDistribution`, it does not identify the critical risk of arithmetic overflow or the potential freezing of funds. This is a significant gap in the response list.

---

**[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards**

**Report Description**:  
The `_safeMint` function contains a reentrancy vulnerability. An attacker could exploit this to repeatedly call the function during the minting process, potentially stealing all rewards.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not mention or address the reentrancy vulnerability in `_safeMint`. This is a critical security issue that is entirely missed in the response list.

---

**[M-01] `_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function**

**Report Description**:  
The `_generateNewTokenId` function may generate duplicate `tokenId` values when merging unlocked NFTs. This occurs because the `totalSupply()` value can overlap with the `points_` value used in the calculation. As a result, `_safeMint` may fail unexpectedly, impacting user experience and transaction success.

**Match in Response List**:  
Matches with the issue titled **""Token ID Overflow in Merge Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of `tokenId` overflow in the merge function, which is related to the edge case described in the issue. However, it does not explicitly mention the failure of `_safeMint` or the impact on user experience. The response focuses on the overflow risk but misses the broader implications of the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] `_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function**

**Missed Issues from Issue Report**:  
- **[H-01] Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases**  
- **[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards**

---

### **Analysis of Gaps**  
The response list fails to address two critical high-severity issues:  
1. The manipulation of `_pointsPerUnit` leading to arithmetic overflow and potential fund freezing.  
2. The reentrancy vulnerability in `_safeMint` that could allow an attacker to steal rewards.  

Additionally, the response to the `_safeMint` edge case is incomplete, as it does not fully capture the impact on user experience or the failure of the `_safeMint` function.  

These gaps highlight the need for a more comprehensive review of the contract's vulnerabilities, particularly focusing on arithmetic operations, access control, and reentrancy risks.",0,1,2,8,"Okay, let's take a look at this smart contract. I need to find all the vulnerabilities here. Let's start by going through the code step by step.

First, the contract is an ERC721Enumerable, which means it's an NFT contract. The name is ""Locked XDEFI"", so maybe it's for locking tokens and earning rewards. Let's check the state variables and modifiers.

The constructor initializes the XDEFI token address, base URI, and some zero duration base. The owner is set to msg.sender. There's a modifier onlyOwner and noReenter. The noReenter uses a _locked variable to prevent reentrancy. But wait, the _locked is set to 1 when entering and 0 after. Since it's using Solidity 0.8.10, maybe that's okay, but reentrancy protection is there.

Looking at functions like lock, lockWithPermit, relock, unlock. These functions handle transferring XDEFI tokens, creating positions, etc. There's a Position struct stored in positionOf mapping. The lock function checks the duration's bonusMultiplier exists. 

One thing to check is the ERC721Enumerable extension. Since it's using Enumerable, maybe there are issues with the _safeMint function? Also, the merge function allows merging multiple tokens. Wait, in merge, they burn the old tokens and mint a new one. But when burning, are they properly handling the positions? Let's see. When merging, they loop through tokenIds_, check the owner, that the position is not locked (expiry is 0?), then burn each token. But the positionOf data might not be deleted here. Because when you burn the token, the position data is still in the mapping. But in the _unlock function, they delete positionOf[tokenId_]. So in merge, after burning, the position data is still there. That could be an issue. But since the token is burned, maybe it's not accessible. However, if there's another function that references positionOf for burned tokens, that could cause problems. For example, if someone tried to call unlock on a burned token, it would fail because ownerOf would revert, but maybe there's a way to have stale data.

Another point: the merge function generates a new tokenId based on the sum of points from merged tokens. The points are calculated as _getPointsFromTokenId, which is tokenId_ >> 128. Wait, tokenId_ is generated by shifting points_ << 128 and adding the supply count. So when merging, the points are summed, and the new tokenId is (sum_points << 128) + new_supply+1. But when merging, if the sum of points from merged tokens is very large, shifting left by 128 bits could cause an overflow. Since points are amount_ * (duration_ + base), if those values are big enough, the sum could be a very large number. However, the tokenId is a uint256, so even if points_ is very big, shifting left 128 bits might not overflow, but it's possible. For example, if points_ is 2^128, then shifting left 128 bits would be 2^256, which overflows. But Solidity 0.8.x checks for overflows, so that would revert. So if the sum of points in merge is too big, it would cause an overflow in tokenId generation, leading to a revert. That's a possible vulnerability. So merging multiple tokens with high points could result in an overflow, making the merge transaction revert. But how likely is that? If points can be up to (amount_ * (max_duration + base)), and amount_ is up to MAX_TOTAL_XDEFI_SUPPLY (which is 240e24), then points could be very large. For example, 240e24 * (18250 days + base). Let's compute 18250 days in seconds: 18250 * 86400 = around 1.577e9 seconds. If base is similar, points_ could be 240e24 * 3e9 = 7.2e35. Then, 7.2e35 << 128 would be way beyond 2^256 (which is ~1e77). So this would definitely overflow. Therefore, merging tokens with high points would cause an overflow in tokenId generation. That's a critical vulnerability.

Another issue: in the setLockPeriods function, the owner can set durations and multipliers. The loop uses durations_[i] as the key, but what if two entries have the same duration? The latter would overwrite the previous one. Also, there's no check that durations_ and multipliers arrays are of the same length. Wait, the function parameters are durations_ and multipliers. The code loops for i in 0 to count, where count is durations_.length. So if multipliers has a different length, this could cause an out-of-bounds error. Wait, the code has:

function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {
    uint256 count = durations_.length;

    for (uint256 i; i < count; ++i) {
        uint256 duration = durations_[i];
        require(duration <= 18250 days, ""INVALID_DURATION"");
        emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);
    }
}

But the multipliers array is passed as a parameter. If durations_.length is not equal to multipliers.length, then when i exceeds multipliers.length, accessing multipliers[i] would revert. For example, if durations_ has 3 elements and multipliers has 2, then i=2 would cause an out-of-bounds error. Therefore, the function needs a require(durations_.length == multipliers.length), but it's missing. So the owner could accidentally pass arrays of different lengths, leading to a revert, or if they intentionally pass a longer multipliers array, it would be ignored. But if multipliers is shorter, it would revert. This is a potential vulnerability as it can cause the function to fail or set incorrect multipliers.

Another point: in the relock function, after unlocking, they check lockAmount_ <= amountUnlocked_. Then, they call _lock(lockAmount_, ...). But in _lock, there's a check that amount_ <= MAX_TOTAL_XDEFI_SUPPLY. However, when relocking, the lockAmount_ comes from the unlocked amount, which was previously deposited. But MAX_TOTAL_XDEFI_SUPPLY is a fixed value. However, if the sum of totalDepositedXDEFI plus new lockAmount_ exceeds MAX_TOTAL_XDEFI_SUPPLY, the check in _lock would fail. Wait, no: when you unlock, totalDepositedXDEFI is decreased by the depositedXDEFI of the token. Then, when you relock, the lockAmount_ is added back. So as long as lockAmount_ is <= MAX_TOTAL_XDEFI_SUPPLY, and the totalDepositedXDEFI after subtracting the unlocked amount plus lockAmount_ doesn't exceed MAX_TOTAL_XDEFI_SUPPLY. Wait, the MAX_TOTAL_XDEFI_SUPPLY is checked in _lock function: require(amount_ != 0 && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, ""INVALID_AMOUNT""). So if someone tries to lock more than MAX_TOTAL_XDEFI_SUPPLY in a single lock, it's prevented. But if multiple locks sum up beyond that, the check isn't there. For example, if totalDepositedXDEFI is already at MAX, and someone tries to relock, the _lock function would check the new amount. Since totalDepositedXDEFI is updated before calling _lock (since in relock, first they call _unlock which subtracts from totalDepositedXDEFI, then they add lockAmount_ via _lock, which adds to totalDepositedXDEFI). Wait, in _unlock, totalDepositedXDEFI -= depositedXDEFI. Then, in _lock, totalDepositedXDEFI += amount_. So if you have totalDepositedXDEFI at MAX, then unlock some, say 100, then relock 100, then totalDepositedXDEFI would be back to MAX. But the check in _lock is amount_ <= MAX, which would pass. However, if someone tries to lock more than MAX in a single transaction, that's prevented. But if the total across multiple positions exceeds MAX, that's allowed. So maybe the MAX check is per-lock, not total. So that's not a vulnerability, but perhaps a design choice.

Another possible issue: in the _lock function, units are calculated as (amount_ * bonusMultiplier) / 100. The bonusMultiplier is a uint8. So if the bonusMultiplier is 200 (as a percentage), then (amount_ * 200) / 100 = 2 * amount_. So units can be up to 2 * amount_, assuming the multiplier is 200. However, units are stored as uint96. If amount_ is large (e.g., MAX_TOTAL_XDEFI_SUPPLY is 240e24), multiplying by 255 (max uint8 is 255) would give 240e24 * 255 = 6.12e26. Then divided by 100 is 6.12e24. But uint96 can hold up to 2^96-1, which is ~7.9e28. So that's okay. So units shouldn't overflow.

But the calculation uses uint256 arithmetic, then cast to uint96. So if the result is larger than uint96.max, it would silently truncate. Wait, no. Because in Solidity 0.8.x, explicit conversions between integers truncate, but if the value is too large, it would wrap. For example, if (amount_ * bonusMultiplier) / 100 is larger than 2^96 -1, then casting to uint96 would truncate, leading to incorrect units. That's a problem. Because units are used to calculate points and distribute rewards. So if the actual units are larger than uint96 can hold, they get truncated, leading to loss of units for the user. For example, if a user locks a huge amount, the units could overflow uint96, causing their position to have much lower units than intended. This is a vulnerability. Let's check:

In _lock:

uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));

If (amount_ * bonusMultiplier) / 100 exceeds 2^96 -1, then uint96() would truncate the value, leading to an incorrect units value. Since amount_ can be up to MAX_TOTAL_XDEFI_SUPPLY (240e24), and bonusMultiplier up to 255, then (240e24 * 255) / 100 = 6.12e26. 2^96 is ~7.9e28, so 6.12e26 is less than that. Wait, 6.12e26 is 612 followed by 24 zeros. 2^96 is about 79,228,162,514,264,337,593,543,950,336 which is ~7.9e28. So 6.12e26 is smaller. So for this contract, with the current MAX_TOTAL, units won't overflow uint96. But if MAX_TOTAL_XDEFI_SUPPLY is increased in the future (but it's internal and set to a fixed value), then this could be a problem. However, as per the current code, the max units would be (240e24 * 255)/100 = 6.12e26, which is 6.12e26 < 7.9e28 (2^96). So uint96 is sufficient. Therefore, no overflow here. So maybe this is okay.

Another thing: in the merge function, after burning the old tokens, the new token is minted with _safeMint. The _safeMint function checks if the destination is a contract and implements onERC721Received. But in the code, merge calls _safeMint(destination_, tokenId_). If destination_ is a contract that doesn't handle ERC721 tokens, the mint could fail. But that's standard for _safeMint. However, the merge function is external, so the caller could pass any destination. If the destination is a contract that can't receive ERC721, the transaction would revert. That's intended behavior, not a vulnerability.

Reentrancy: the functions lock, relock, unlock, etc., have the noReenter modifier. So they should be protected against reentrancy. However, the updateDistribution function does not have a noReenter modifier. But updateDistribution doesn't seem to call external contracts, except for IERC20(XDEFI).balanceOf. If the XDEFI token is malicious and calls back into the contract during balanceOf, but balanceOf is a view function, so it shouldn't execute code. So maybe no reentrancy risk here.

Another possible issue: the _updateXDEFIBalance function calculates distributableXDEFI as balanceOf(this) - totalDepositedXDEFI. However, if someone sends XDEFI tokens directly to the contract (not through deposit functions), the distributableXDEFI would increase. Then, when updateDistribution is called, these extra tokens are distributed. But the contract might not expect this. For example, someone could send XDEFI tokens directly to the contract, which would be considered distributable, leading to rewards for current unit holders. This could be a desired behavior, but if the contract is intended to only distribute tokens deposited via the lock functions, then this is a vulnerability. Since anyone can send XDEFI to the contract and affect the distribution. So this is a potential issue if the distribution is supposed to be only from specific sources.

Another thing: the _pointsPerUnit is updated in updateDistribution. The calculation is _pointsPerUnit += (newXDEFI * _pointsMultiplier) / totalUnitsCached. However, if totalUnitsCached is zero, the function reverts. But updateDistribution has a require(totalUnitsCached > 0, ""NO_UNIT_SUPPLY""). So that's handled. 

Now, looking at the ERC721Enumerable extension. The contract inherits from ERC721Enumerable and overrides _safeMint and other functions. However, ERC721Enumerable requires that any minting or burning properly updates the enumerable data structures. The contract uses _safeMint, which should call the ERC721Enumerable's _beforeTokenTransfer hook. Since the contract inherits ERC721Enumerable and doesn't override _beforeTokenTransfer, it should be handled correctly. So no issues here.

Another possible issue: the Position struct includes expiry and created as uint32. The block.timestamp is a uint256, but when stored as uint32, it could overflow. For example, if block.timestamp is larger than 2^32 -1 (which is around 2106-02-07), the stored value would be truncated. However, since Solidity 0.8.x, this would cause an error. Let's check the code:

In _lock:
expiry: uint32(block.timestamp + duration_),
created: uint32(block.timestamp),

But block.timestamp is a uint256. If block.timestamp + duration_ exceeds 2^32 -1 (which is ~4294967295 seconds, about 136 years from 1970, so around 2106), then the conversion to uint32 would cause an overflow. Since Solidity 0.8.x checks for overflows, this would revert. Therefore, if the duration_ is set such that block.timestamp + duration_ exceeds 2^32 -1, the transaction would revert. However, in setLockPeriods, durations are required to be <= 18250 days (about 50 years). So block.timestamp + 50 years is around current time (say 2023) + 50 years = 2073. The timestamp for 2073 is ~3.3e9, which is less than 2^32 (4.29e9). So until the year 2106, the uint32 can hold the timestamp. Therefore, durations set via setLockPeriods that are up to 18250 days (50 years) would not overflow until after 2106. So this is a potential issue if the contract is used beyond 2106, but that's a long time from now. However, if someone tries to create a lock with a duration that pushes the expiry beyond 2^32 -1, the transaction would revert. Since setLockPeriods restricts durations to <= 18250 days, which when added to current timestamp would stay below 2^32 until around 2106, this may not be an immediate issue, but it's a time bomb.

Another issue: the merge function requires that the positions being merged are not locked (expiry == 0). Wait, in merge, the code checks positionOf[tokenId].expiry == 0. But when you create a position via _lock, the expiry is set to block.timestamp + duration_. So expiry is non-zero. So how can a position have expiry == 0? The only time expiry is set to 0 is when the position is unlocked (because in _unlock, the position is deleted, but in the merge function, the code checks expiry == 0. Wait, in the merge function:

require(positionOf[tokenId].expiry == uint32(0), ""POSITION_NOT_UNLOCKED"");

But when you unlock a position via unlock, the _unlock function deletes the positionOf entry. However, in the merge function, after burning the token, the position data is still in the mapping. Wait, when a token is burned via _burn(tokenId), the ERC721's ownerOf function will revert for that tokenId. However, the positionOf mapping still has the data unless it's deleted. So in the merge function, after burning the token, the position data remains. However, in the unlock function, when you unlock, the position is deleted. So merging can only be done on tokens that have been unlocked (expiry passed and unlocked), which would have their positions deleted. Wait, no. Let's see:

The unlock function calls _unlock, which deletes positionOf[tokenId_]. So after unlocking, the position data is deleted. However, the merge function requires that the position's expiry == 0, but if the position has been unlocked (and thus deleted), then positionOf[tokenId_] would have default values. The Position struct's expiry is a uint32, so the default is 0. Therefore, after unlocking, the positionOf[tokenId_] is deleted, so when you check positionOf[tokenId_].expiry, it would be 0. Therefore, merge can be called on tokens that have been unlocked. But in that case, the token would have been burned already. Wait, no. When you unlock, the unlock function calls _unlock, which deletes the position data, but the token is still owned by the user. Wait, no: when you call unlock, the process is:

1. Call unlock(tokenId_, destination_)
2. _unlock is called, which checks ownerOf(tokenId_) is the account
3. It deletes positionOf[tokenId_]
4. Then, it transfers the XDEFI to destination_
5. The token is not burned. Wait, wait, looking at the code:

In unlock function:

amountUnlocked_ = _unlock(msg.sender, tokenId_);

Then, in _unlock:

They delete positionOf[tokenId_], but the token itself is not burned. So the NFT remains in the user's wallet, but the position data is deleted. Then, when the user tries to merge such a token, the merge function checks if positionOf[tokenId_].expiry == 0. Since the position was deleted, the expiry is 0. So merge can be called on these tokens. However, the merge function also checks that the owner is msg.sender. So after unlocking, the token is still owned by the user, but has no position data. Then, merging such tokens would sum their points (from the tokenId), which is based on the points stored in the tokenId. But when merging, the points are obtained via _getPointsFromTokenId(tokenId_), which is tokenId_ >> 128. However, when the token was created, the tokenId was generated based on points from the position. But after the position is deleted, merging the token would still use the points from the tokenId, even though the position no longer exists. This could allow users to merge tokens that have already been unlocked, effectively allowing them to combine points from expired positions, but since the underlying XDEFI has already been withdrawn, this would create a new token with points but no actual locked XDEFI. This is a critical issue.

Wait, let's think through this scenario:

1. User locks 100 XDEFI for 1 year, gets a tokenId with points based on 100 * (duration + base).
2. After 1 year, user unlocks the token, receives 100 XDEFI, position data is deleted.
3. The token is still in the user's wallet, but has no associated position.
4. User then merges this token with another similar token. The merge function checks that the user owns the tokens and that the position's expiry is 0 (which it is, because the position was deleted).
5. The merge burns the old tokens and creates a new token with summed points. However, this new token's points are based on the old points, which no longer have any XDEFI locked. So the new token would have points but no XDEFI backing it, allowing the user to possibly withdraw more XDEFI than they have locked.

This is a major vulnerability. Because when you merge tokens that have been unlocked (and their positions deleted), the merge creates a new token with combined points. When the user then tries to unlock this new token, since there's no position data (because the merge process doesn't create a new position; it just creates a new token with points in the tokenId), the _unlock function would look for positionOf[newTokenId], which doesn't exist, leading to a default Position with units 0, depositedXDEFI 0, etc. Then, the withdrawableXDEFI would be 0 + something based on pointsCorrection. But pointsCorrection is part of the position data, which is not present. So merging unlocked tokens creates new NFTs that have no backing XDEFI, but may still allow the user to withdraw funds through some other means, or at least disrupt the accounting.

Alternatively, the merge function is supposed to merge tokens that are not in a locked state. But if the tokens have already been unlocked and their XDEFI withdrawn, merging them would create a new token with points that do not correspond to any actual locked XDEFI. This would allow users to accumulate points from tokens that have already been used, leading to incorrect distribution of rewards.

This is a critical vulnerability because it allows users to create new tokens with points from expired positions, which could be used to claim rewards without actually locking XDEFI.

Another thing to check is the tokenURI function. It uses baseURI concatenated with the tokenId. If the baseURI is set to a malicious contract, it could return incorrect metadata, but that's up to the owner. Not a vulnerability unless the owner is compromised.

Another issue: the _lock function mints a token with _safeMint(destination_, tokenId). The tokenId is generated via _generateNewTokenId, which uses totalSupply() + 1. However, totalSupply() is the number of tokens minted, but when merging tokens, multiple tokens are burned and one is minted. So the tokenId generation uses totalSupply() + 1. But tokenId is generated as (points_ << 128) + uint128(totalSupply() +1). Since totalSupply() can be reduced when tokens are burned (like in merge), this could lead to tokenId collisions. For example:

1. Suppose totalSupply() is 5. Mint a new token: tokenId = (points << 128) + 6.
2. Then, merge two tokens, burning them. Now totalSupply() is 5 - 2 + 1 = 4.
3. Mint another token: tokenId = (points << 128) + 5.

But the previous token with id ending with 6 is still there. So the tokenId's lower 128 bits are based on totalSupply() at mint time, not the current totalSupply(). Since tokenIds are unique (as per ERC721), the way tokenIds are generated here ensures uniqueness because each new token increments the counter. However, if the totalSupply() is allowed to wrap around (which is impossible in practice, since it's a uint256), but given that the tokenId's lower 128 bits are used as a counter, even if the counter wraps around after 2^128, it could cause collisions. However, 2^128 is a huge number, so this is not a practical concern. Therefore, tokenId generation is safe from collisions.

Another potential issue: the _updateXDEFIBalance function is called in relock, unlock, relockBatch, unlockBatch. It updates distributableXDEFI as the current balance minus totalDepositedXDEFI. However, if the XDEFI token has a fee-on-transfer mechanism, the actual received amount could be less than the transferred amount, causing the balance to not match the expected value. For example, when someone calls lock, they transfer amount_, but if the token takes a fee, the contract's balance increases by less than amount_. Then, totalDepositedXDEFI is increased by amount_, which would make distributableXDEFI = balance - totalDepositedXDEFI negative. However, in _updateXDEFIBalance, it's calculated as IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI. If the XDEFI token has fees, this could lead to distributableXDEFI being negative, but since it's a uint256, it would underflow. But in Solidity 0.8.x, this would revert. Therefore, the contract is incompatible with fee-on-transfer tokens, which could be a problem if XDEFI is such a token.

The contract uses SafeERC20 for transfers, which is good. But if XDEFI is a fee-on-transfer token, the lock function would transfer amount_, but the actual received amount is less. So totalDepositedXDEFI is increased by amount_, but the balance is less, leading to underflow in distributableXDEFI. However, in the code, when you lock, the totalDepositedXDEFI is increased by the amount_, but if the received amount is less, then distributableXDEFI would be (balance - totalDepositedXDEFI), which could be negative. But in Solidity 0.8.x, subtracting two uints can't be negative, so IERC20(XDEFI).balanceOf(address(this)) is a uint, and totalDepositedXDEFI is a uint, so if balance < totalDepositedXDEFI, then distributableXDEFI would be 0 (since it's a uint). Wait, no: the code says distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI. If balance is less than totalDepositedXDEFI, this would underflow, causing a revert. However, in Solidity 0.8.x, this subtraction would revert if balance < totalDepositedXDEFI. Therefore, if the XDEFI token has fee-on-transfer, the lock function would cause the contract's balance to be less than the amount_ transferred, leading to totalDepositedXDEFI exceeding the balance, causing subsequent calls to _updateXDEFIBalance to revert. This would break the contract's functionality. Therefore, the contract is not compatible with fee-on-transfer tokens. If XDEFI is such a token, this is a critical issue.

Additionally, the lockWithPermit function uses permit to approve the contract to spend XDEFI. If the permit function is implemented incorrectly (e.g., not following EIP-2612), this could fail. But that's dependent on the XDEFI token's implementation.

Another potential issue: the bonusMultiplier is stored as a uint8. The maximum multiplier is 255. So if the owner wants to set a multiplier higher than 255, they can't. But this is a design choice, not a vulnerability.

In the setLockPeriods function, the owner can overwrite existing durations' multipliers. This could be used to reduce the bonus for existing positions, but since existing positions' bonusMultiplier is stored in their Position struct, changing the global bonusMultiplierOf[duration] wouldn't affect existing positions. So existing positions are safe, but new positions with the same duration would get the new multiplier. That's intended.

In the Position struct, pointsCorrection is an int256. When a position is created, pointsCorrection is set to -_toInt256Safe(_pointsPerUnit * units). This is to account for the current pointsPerUnit when calculating rewards. However, if _pointsPerUnit * units is very large, converting to int256 could overflow. Since _pointsPerUnit is a uint256 and units is uint96, their product is a uint256. If that exceeds 2^255-1, converting to int256 would overflow, causing a revert. But given that _pointsPerUnit increases over time as distributions are updated, this could eventually overflow. For example, if _pointsPerUnit is 2^200, and units is 2^40, their product is 2^240, which is larger than 2^255-1. Converting to int256 would cause an overflow. This would prevent new positions from being created once _pointsPerUnit becomes too large. This is a potential denial-of-service issue for future positions if the contract runs for a very long time and accumulates many distributions.

Another issue: the unlock function transfers the XDEFI to destination_, but if the contract's XDEFI balance is less than the amountUnlocked_, the transfer would fail. However, amountUnlocked_ is calculated as depositedXDEFI_ plus the reward from points. The depositedXDEFI is subtracted from totalDepositedXDEFI in _unlock, but if the contract doesn't have enough XDEFI (e.g., due to a bug or an exploit), the transfer would revert. However, the code should ensure that the contract's balance is sufficient. If the contract's balance is less than totalDepositedXDEFI, then _updateXDEFIBalance would return a negative value, which is converted to a uint256 via _toUint256Safe, which would revert. But that's handled in _updateXDEFIBalance.

Wait, the _updateXDEFIBalance function returns int256, but the code in updateDistribution calls _toUint256Safe on the result. However, if the new balance is less than the previous distributableXDEFI, newFundsTokenBalance_ would be negative, causing _toUint256Safe to revert. Therefore, if the contract's XDEFI balance is less than totalDepositedXDEFI, any call to updateDistribution would revert. This could happen if someone steals XDEFI from the contract, leading to an inconsistent state. This would effectively freeze the contract's distribution mechanism. However, this is more of a result of an exploit rather than a vulnerability in the code.

Another issue: the merge function allows merging tokens with different durations and multipliers, which could lead to combining points in unintended ways. However, this is a design choice, not a vulnerability.

In summary, the main vulnerabilities found are:

1. **Token ID Overflow in Merge Function**: Merging tokens with high points could cause an overflow in tokenId generation, leading to a revert. This is critical.

2. **Incorrect Array Length Handling in setLockPeriods**: The function does not check that durations_ and multipliers arrays have the same length, leading to potential out-of-bounds errors. High severity.

3. **Merging Unlocked Tokens**: Users can merge tokens that have already been unlocked, creating new tokens with points that don't correspond to locked XDEFI, allowing them to claim rewards illegitimately. Critical severity.

4. **Timestamp Truncation to uint32**: Storing block.timestamp + duration_ as uint32 could overflow post-2106, causing reverts. Medium severity.

5. **Incompatibility with Fee-on-Transfer Tokens**: If XDEFI is a fee-on-transfer token, the contract's accounting breaks, leading to reverts. High severity.

6. **Potential Integer Overflow in Points Correction**: When creating new positions, if _pointsPerUnit * units exceeds 2^255-1, converting to int256 would revert. Low severity as it's a future concern.

7. **Missing Access Control on updateDistribution**: The updateDistribution function can be called by anyone, but it's necessary for distributing rewards. Not a vulnerability but a note. However, if it's supposed to be called automatically, maybe not.

8. **Stale Position Data in Merge Function**: Merging tokens after their positions have been unlocked could lead to incorrect points calculation. As discussed in point 3.","```
None.
```",0.0