nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
NFTXStakingZap.sol,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,428.0,"[H-01] ERC20 transferFrom return values not checked
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Handling of CryptoPunks Transfers**:
   - The `transferFromERC721` function attempts to buy CryptoPunks by calling `buyPunk` without verifying if the contract is the approved buyer. The `approveERC721` function sets the sale to the vault address, not the contract itself, causing the `buyPunk` call to fail when initiated by the contract.

2. **Unsafe ETH Transfer**:
   - The use of `payable(to).call{value: ...}` in functions like `addLiquidity721ETHTo` does not check the success of the ETH transfer. If the recipient is a contract without a payable fallback, funds may be irrecoverably lost.

3. **Hardcoded SushiSwap Pair Hash**:
   - The `pairFor` function relies on a hardcoded `INIT_CODE_HASH` for SushiSwap pair creation. Changes to the SushiSwap factory's implementation (e.g., updated hash) will result in incorrect LP pair addresses, leading to liquidity being sent to invalid or malicious contracts.

4. **Reentrancy in `provideInventory` Functions**:
   - The `provideInventory721` and `provideInventory1155` functions lack reentrancy guards (`nonReentrant`). External calls to `vault.mintTo` could allow reentrant attacks if the vault behaves maliciously, potentially manipulating balance checks.

5. **Centralized Risk via `rescue` Function**:
   - The `rescue` function allows the owner to withdraw arbitrary ERC20 tokens, posing a risk if the owner's account is compromised. While intentional, this centralization introduces trust assumptions.

6. **Improper ERC721 Handling for CryptoKitties**:
   - The `transferFromERC721` function uses `transferFrom` instead of `safeTransferFrom` for CryptoKitties, risking token loss if the recipient (vault) does not support ERC721.

7. **Missing Balance Check in ETH Liquidity Functions**:
   - Functions like `addLiquidity721ETHTo` do not validate if the contract's WETH balance increases after `WETH.deposit`, potentially leading to incorrect liquidity calculations.

8. **Inconsistent Use of `nonReentrant` Modifier**:
   - Critical functions (e.g., `provideInventory`) lack the `nonReentrant` modifier, increasing exposure to reentrancy despite its use in other functions.

9. **Front-Runnable Operations**:
   - Transactions involving token approvals and transfers (e.g., `provideInventory`) are susceptible to front-running, though mitigated by user-specified parameters.","### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to ensure the transfer has been successful. While the `transfer()` function calls were checked, the `transferFrom()` function calls were not. This oversight could lead to silent failures in token transfers, especially when dealing with untrusted tokens, potentially causing discrepancies in token balances and security vulnerabilities.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked `transferFrom()` return values. This is a critical security concern in Solidity smart contracts, as failing to validate the return value of `transferFrom()` can lead to silent failures and potential vulnerabilities. The response list covers other vulnerabilities but misses this specific issue entirely.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] ERC20 transferFrom return values not checked**

---

### **Analysis of Gaps**
The response list covers a variety of vulnerabilities, including reentrancy, unsafe ETH transfers, and improper handling of ERC721 tokens. However, it fails to address the critical issue of unchecked `transferFrom()` return values, which is a common and significant security concern in Solidity smart contracts. This gap highlights the need for a more comprehensive review of ERC20 token handling in the contract.",0,0,1,9,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called NFTXStakingZap, and it's designed to interact with various NFTX components like vaults, LP staking, and inventory staking. I'll start by going through each function and the code structure to spot possible issues.

First, the contract imports several interfaces and uses Ownable and ReentrancyGuard. It also has ERC721 and ERC1155 holder contracts. The constructor initializes some addresses like the NFTX factory, LP staking, inventory staking, SushiSwap router, and WETH.

Looking at the functions:

1. **provideInventory721** and **provideInventory1155**: These functions handle transferring NFTs to the vault and minting xTokens. They use loops to transfer and approve each token. One thing that comes to mind is that loops could be gas-intensive if there are many tokens, but that's more of an efficiency issue than a vulnerability. However, in the 721 function, after transferring and approving each token, they call vault.mintTo with empty amounts. Wait, the mintTo function for 721 might expect an array of amounts, but since they are ERC721s, maybe that's handled. But if the vault expects ERC1155, passing empty amounts might be an issue. But looking at the code, the vault's mint function for 721s might not require amounts. But maybe there's a mismatch here. Let me check the parameters again.

Wait, in provideInventory721, they pass tokenIds and a new uint256[](0) for amounts. If the vault's mint function is designed for 721, maybe it ignores the amounts. But if it's a 1155 vault, passing empty amounts could be a problem. But the code here seems to be specific for 721s, so maybe the vault's mint function can handle that. Not sure if that's a vulnerability here.

2. **addLiquidity721ETHTo** and similar functions: These handle adding liquidity by wrapping ETH into WETH, then interacting with the vault. The code uses nonReentrant modifier, which is good to prevent reentrancy. But let's check for any possible reentrancy points. The functions call into external contracts like the vault and the router. Since they're using nonReentrant, maybe that's covered. But need to check if any external calls could call back into the contract.

3. **transferFromERC721** and **approveERC721**: These functions have special handling for CryptoKitties and CryptoPunks. For example, in transferFromERC721, if the asset is CryptoPunks, it checks the owner via a staticcall and then calls buyPunk. Wait, but the code is transferring from the user to the contract. The code here is trying to handle the transfer of punks by having the contract buy the punk from the user. However, the way this is done could be problematic. For example, if the user is the owner of the punk, the contract calls buyPunk, but does it send ETH? Because buying a punk usually requires paying. Wait, the buyPunk function requires the caller to send the amount of wei in the sale. But here, the code is calling buyPunk(tokenId), but there's no value sent. So if the punk is not for sale, or the price is not zero, this would fail. But in the code, the user is supposed to be the owner (checked via punkIndexToAddress), and the code is using offerPunkForSaleToAddress in approveERC721. Wait, in the approve function for punks, they call offerPunkForSaleToAddress with price 0. So maybe the contract first offers the punk for sale at 0, then buys it. But if the user is the owner, the contract (acting on behalf of the user) offers it for sale to itself at 0, then calls buyPunk. However, when the contract calls buyPunk, does it need to send ETH? Since the price is 0, maybe not. But this seems like a potential issue if the punk's sale isn't properly set up. Also, in the transferFromERC721 function, after checking the owner is the msg.sender, the contract calls buyPunk(tokenId). But the contract is the one calling buyPunk, which would require that the punk is for sale to the contract. But the code first offers it for sale to the contract via approveERC721. Wait, the approveERC721 function is called before the transfer. So in the case of punks:

- In transferFromERC721, first, they check that the owner is msg.sender.
- Then, data is encoded as buyPunk(tokenId), and the contract calls this on the punks contract.
- But to buy a punk, the punk must be for sale. So the approveERC721 function is supposed to set that up. Let's see: in approveERC721, if assetAddr is punks, they call offerPunkForSaleToAddress(tokenId, 0, to). So the owner (msg.sender) is offering the punk for sale at price 0 to the 'to' address (which would be the vault, perhaps). Wait, no: in the transferFromERC721 function, during the transfer, they call buyPunk. But the approveERC721 is called with 'to' as the vault address. Wait, the code for transferFromERC721 is:

for ERC721s, they call safeTransferFrom. For punks, after checking the owner is msg.sender, the contract calls buyPunk. But how does the contract get the punk from the user? Because normally, the user has to transfer the punk, but punks are handled differently. The code here is trying to make the contract buy the punk from the user. But for that, the user must have offered the punk for sale. The code seems to have a step where in approveERC721 (which is called for punks), they call offerPunkForSaleToAddress with price 0 to the 'to' address. But in the transferFromERC721 function, 'to' is the vault address. Wait, no: in the transferFromERC721 function, 'to' is the argument passed in. For example, in _addLiquidity721WETH, the code calls transferFromERC721(assetAddress, ids[i], vault). So 'to' is the vault address. Then, approveERC721 is called with assetAddress, vault, tokenId. So for punks, in approveERC721, they call offerPunkForSaleToAddress(tokenId, 0, to), which would be the vault. Then, the contract (NFTXStakingZap) calls buyPunk, which would purchase the punk from the current owner (the user) if it's offered for sale to the vault. But since the user is the owner, and they have offered the punk to the vault at price 0, the contract can buy it for 0. However, the problem is that the code does not handle the payment. The buyPunk function requires that the caller sends the sale amount in wei. In the code's transferFromERC721 function, when calling buyPunk, there's no value sent. So if the punk is offered for sale at 0, then it's okay. But the code here may not be sending the required ETH. Wait, in the case of ETH functions like addLiquidity721ETHTo, the user is sending ETH. But for punks, when the contract calls buyPunk, the contract would need to have enough ETH to pay for the punk. However, in the code's current setup, when handling punks in transferFromERC721, the contract is not sending any ETH. This would cause the buyPunk call to fail unless the punk is offered for sale at 0, and even then, maybe the contract needs to send 0 ETH. Wait, the buyPunk function in CryptoPunks requires that the caller sends the exact amount of wei specified in the sale. If the sale is for 0, then the contract needs to send 0 ETH. But in this code, when the contract calls buyPunk, there's no ETH attached. So if the sale is at 0, then it's okay, but otherwise, it would fail. However, in the approveERC721 step, they set the price to 0. So the code is offering the punk for sale at 0 to the vault, then the contract calls buyPunk with no ETH. That should work. But how does the user's punk get transferred to the contract? Because when the contract buys it, the punk is transferred from the user to the contract. But in the code, the 'to' address in transferFromERC721 is the vault. So after buying, the punk would be in the contract's possession, and then the code calls approveERC721, which for punks calls offerPunkForSaleToAddress. Then, the code proceeds to call vault.mint, which may require the punk to be in the vault's possession. Wait, maybe there's a misunderstanding here. Let me outline the steps for punks:

1. User calls provideInventory721 with a punk's tokenId.
2. transferFromERC721 is called with assetAddr as punks contract, tokenId, and to as the vault address.
3. The code checks if the owner of the punk is the msg.sender.
4. Then, it calls buyPunk(tokenId) on the punks contract. This requires that the punk is for sale and that the contract sends the required ETH. However, the code doesn't send ETH here. But prior to this, in approveERC721, which is called in the loop for each tokenId, the code called offerPunkForSaleToAddress(tokenId, 0, to) where to is the vault. Wait, no: approveERC721 is called with (assetAddress, address(vault), tokenIds[i]). So the 'to' in approveERC721 is the vault address. So the code is offering the punk for sale to the vault at 0 price. But then, in transferFromERC721, the code calls buyPunk, which would be buying from the current owner (the user) to the contract. Wait, no. The buyPunk function transfers the punk to the caller (the contract) if the sale is set up. So if the user has offered the punk for sale to the vault at 0, then the vault can buy it. But in this code, the contract (NFTXStakingZap) is trying to buy the punk. So the steps would be:

- User owns the punk.
- User calls provideInventory721, which calls transferFromERC721 for the punk.
- transferFromERC721 checks that user is the owner.
- Then, the contract (NFTXStakingZap) calls buyPunk(tokenId). But for that, the punk must be for sale to the contract. However, the approveERC721 function was called earlier, which for punks, calls offerPunkForSaleToAddress(tokenId, 0, to), where to is the vault. So the punk is offered for sale to the vault, not to the contract. Therefore, when the contract tries to buy the punk, it's not the intended buyer. Therefore, the buyPunk call would fail because the punk is not offered for sale to the contract. This is a flaw in the code. The contract is trying to buy the punk, but the sale is set up for the vault, not the contract. Therefore, the buyPunk call would fail because the contract isn't the address the punk is offered to. This would result in a failed transaction whenever trying to deposit a punk. This is a vulnerability because the code does not correctly handle the transfer of CryptoPunks, leading to failed transactions or unexpected behavior.

Another issue is the use of payable(to).call{value: ...} without checking the success. For example, in addLiquidity721ETHTo, after withdrawing WETH, it does:

payable(to).call{value: msg.value-amountEth}();

But this doesn't check if the transfer succeeded. If the 'to' address is a contract that can't receive ETH (like a contract without a receive function), this would fail silently, leading to loss of funds. So this is an unsafe ETH transfer.

Next, looking at the rescue function: it allows the owner to rescue any ERC20 token. However, if the token is part of the contract's operations (like WETH or vault tokens), the owner could potentially drain funds that are supposed to be locked or in use. But since it's an Ownable function, it's a centralization risk, but that's more of a design choice. However, if the owner is malicious or compromised, they could steal funds. But the question is about vulnerabilities, not trust issues.

Another potential issue is the use of the pairFor function to compute the LP token address. The code uses a hardcoded sushiRouter.factory() and a specific INIT_CODE_HASH. However, if the SushiSwap factory's INIT_CODE_HASH changes (due to a factory upgrade or a new pair implementation), the computed pair address would be incorrect. This could lead to liquidity being added to a wrong or non-existent pair, resulting in loss of funds. The contract should retrieve the pair address using the factory's getPair function instead of computing it with a hardcoded hash. This is a vulnerability because it assumes a static INIT_CODE_HASH which may change.

Also, in the _addLiquidityAndLock function, after adding liquidity, the code transfers any leftover tokens to 'to'. But the line:

IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);

But 'minTokenIn' is the parameter passed in, which is the minTokenIn variable. However, the code computes 'minTokenIn' as count*BASE (from the vault.mint call). But if the actual tokens minted are less than expected (due to some fee or calculation error), this could lead to underflow. Wait, in _addLiquidity721WETH, count is obtained from INFTXVault(vault).mint(ids, emptyIds), which returns the number of vTokens minted. Then balance is count * BASE. Then, in _addLiquidityAndLock, minTokenIn is the parameter, which is count * BASE. But during addLiquidity, amountToken could be less than minTokenIn (since the router's addLiquidity function uses the minTokenIn as a parameter for slippage). If the actual amountToken is less than minTokenIn, then the code sends the difference to 'to'. However, if for some reason the balance was not exactly count * BASE (due to a miscalculation or a bug), this could result in sending more tokens than available, leading to a revert. But the code has a require statement checking that balance == IERC20Upgradeable(vault).balanceOf(address(this)) after minting. So that should prevent underflow. So that's probably safe.

Another point: in provideInventory721 and provideInventory1155, the code mints xTokens via inventoryStaking.timelockMintFor. Then, it mints the vault tokens to the xToken address. However, the code checks the old and new balances to ensure that the correct amount was minted. That seems okay. However, if the vault's mint function has a reentrancy guard, but since the contract uses nonReentrant modifiers in other functions, but not here. However, provideInventory functions don't have a nonReentrant modifier, so if the vault's mint function is malicious and calls back into the contract, there could be reentrancy. But considering that the vault is part of the NFTX system, which is presumably trusted, this may not be an issue. But in general, external calls without reentrancy protection could be a risk. However, the code does not use any state changes after the external calls, except for the balance checks, which are done after the call. So even if reentered, the state changes after the call (balance checks) may prevent some attacks, but it's not certain. This could be a potential reentrancy vulnerability, but since the code doesn't have a reentrancy guard here, it's a possible issue.

Another thing: the ERC721HolderUpgradeable and ERC1155HolderUpgradeable are used, which implement the onERC721Received and onERC1155Received functions. So the contract can safely receive these tokens. That part seems okay.

In the transferFromERC721 function, for CryptoKitties, it uses transferFrom instead of safeTransferFrom. However, since the contract is handling the transfer, maybe that's okay. But using transferFrom for ERC721 could potentially lead to tokens being stuck if the recipient doesn't support them. However, in this case, the recipient is the vault, which should handle the tokens correctly.

Also, the code uses a custom ReentrancyGuard implementation, but the ReentrancyGuard contract's nonReentrant modifier is applied to functions like addLiquidity721ETHTo. However, other functions like provideInventory721 do not have this modifier. If those functions make external calls that could re-enter, there might be a risk. For example, provideInventory721 calls vault.mintTo, which could be a point of reentrancy. But the code's state changes (like updating balances) occur after the external call, which is a CEI (Checks-Effects-Interactions) violation. Wait, in provideInventory721:

for each tokenId, transfers and approves, then calls vault.mintTo. Then checks the balance. The code first does all the transfers and approvals, then mints, then checks the balance. If the vault's mintTo function is malicious and calls back into the contract, the contract could be in an inconsistent state. For example, during the mintTo call, if the attacker re-enters provideInventory721, the oldBal and newBal checks might not hold. This is a possible reentrancy vulnerability.

Wait, during provideInventory721:

1. The code transfers the NFTs to the vault and approves them.
2. Then calls vault.mintTo, which mints vTokens to the xToken address.
3. Then checks that the xToken's balance increased by count*BASE.

If the vault's mintTo function is malicious and calls back into provideInventory721, the newBal could be incorrect. However, since the code uses oldBal and newBal after the external call, if during reentrancy the same xToken's balance is modified, the check could fail. However, the reentrant call would have to be providing the same vaultId and tokens, which may not be feasible. But in any case, the lack of a reentrancy guard here could be a vulnerability.

Moreover, the code's use of the nonReentrant modifier is only in certain functions (like the addLiquidity ones), but not in provideInventory. So if the provideInventory functions can be re-entered via the vault's mintTo function, that's a possible issue.

Another thing to check: in the addLiquidity functions, the code uses minWethIn and minTokenIn as parameters. If the actual amounts are lower than expected, the transaction would revert. But if the slippage is not properly handled, users could be front-run. However, the code uses the min parameters from the user, which is standard practice. So that's not a vulnerability per se.

Another point: the pairFor function uses a hardcoded INIT_CODE_HASH for SushiSwap. If the SushiSwap factory's INIT_CODE_HASH changes (due to a update to the factory), the computed pair address would be wrong, leading to adding liquidity to a non-existent pair or a wrong one. This is a vulnerability because the contract would interact with an incorrect LP token, potentially leading to loss of funds. The correct way is to use the factory's getPair function to determine the pair address, not compute it locally with a hardcoded hash.

Also, in the _addLiquidityAndLock function, after adding liquidity, the code approves the LP token for the lpStaking contract and deposits. However, if the LP token is not correctly computed (due to the pairFor issue), the approval and deposit would go to a wrong address, which is a critical vulnerability.

In summary, the key vulnerabilities I can identify are:

1. **Incorrect Handling of CryptoPunks Transfers**: The code attempts to buy CryptoPunks without ensuring the correct sale setup, leading to failed transfers. The approveERC721 function offers the punk for sale to the vault, but the transferFromERC721 function's buyPunk is called by the contract, which may not be the intended buyer. This would cause the buy to fail, as the punk is offered to the vault, not the contract.

2. **Unsafe ETH Transfer**: Using low-level call to send ETH without checking the return value. If the 'to' address is a contract that cannot receive ETH, the transfer fails silently, leading to stuck funds.

3. **Hardcoded SushiSwap Pair Hash**: The pairFor function uses a hardcoded INIT_CODE_HASH, which may become outdated if SushiSwap updates their contract, leading to incorrect LP pair addresses and potential loss of funds.

4. **Reentrancy in provideInventory Functions**: The provideInventory721 and provideInventory1155 functions do not use nonReentrant modifiers and make external calls (vault.mintTo) before updating state, which could allow reentrancy attacks if the vault is malicious.

5. **Centralized Risk with Rescue Function**: The rescue function allows the owner to withdraw any ERC20 token, which could be used maliciously if the owner's account is compromised. However, since the question says no need for mitigation, this might be considered a feature rather than a vulnerability, but it's still a risk.

6. **Possible Front-Running or Slippage**: While not a vulnerability in the code itself, the lack of proper slippage controls (though parameters are user-provided) could lead to MEV opportunities, but this is more of a user education issue.

So the main vulnerabilities are the first four points mentioned.","```
None.
```",0.0,0
Splitter.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162.0,293.0,"[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract
In general, the Splitter contract's `incrementWindow` function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the `incrementWindow` function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or `claimForAllWindows ` functions to steal the tokens in the contract.
  [H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker
When the value of currentWindow is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.
currentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.
Furthermore, an attacker can continually increment currentWindow by calling `incrementWindow()`. An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.
  [M-02] Fixed Amount of Gas Sent in Call May Be Insufficient
The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the receive() function. As a result the user would be unable to receive funds from this function.",3.0,"pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract Splitter is SplitStorage {
    
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    
    event TransferETH(
        
        address account,
        
        uint256 amount,
        
        bool success
    );

    
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    

    
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        
        return (amount * percent) / 100;
    }

    
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        
        
        
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    
    
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        
        return computedHash == root;
    }
}",1136.0,2,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Percentage Scaling Leading to Overpayment**  
   The `scaleAmountByPercentage` function divides by `10000` (1e4) instead of using the `PERCENTAGE_SCALE` constant (1e6). This inconsistency could result in miscalculations if the system expects percentages scaled to 1e6, allowing users to claim significantly more funds than intended.

2. **Insufficient Balance Checks in `incrementWindow`**  
   The `incrementWindow` function checks the current ERC20 balance against `royaltyAmount` but does not account for cumulative liabilities from previous windows. This can lead to insolvency if the total `balanceForWindow` entries exceed the contract's actual balance, causing failed transfers during claims.

3. **Gas Exhaustion in `claimForAllWindows`**  
   The loop iterating over all existing windows in `claimForAllWindows` may consume excessive gas as the number of windows grows, making the function impractical to execute and risking denial-of-service (DoS).

4. **Misleading `TransferETH` Event for ERC20 Transfers**  
   The `TransferETH` event is emitted during ERC20 token transfers, creating confusion between ETH and ERC20 transactions in off-chain monitoring systems.

5. **Lack of Percentage Validation in Claims**  
   The contract does not enforce that `percentageAllocation` values are within valid bounds (e.g., ≤10,000). Malicious or improperly constructed merkle nodes could allow claims exceeding 100% of available funds.

6. **Merkle Proof Dependency on Off-Chain Consistency**  
   The `verifyProof` function assumes the off-chain merkle tree is built with the same hashing order (computedHash ≤ proofElement). Inconsistent tree construction could lead to invalid proofs being accepted.

7. **Fixed Merkle Root for All Windows**  
   The contract uses a single `merkleRoot` for all windows. If user allocations are intended to change per window, the static root prevents updates, allowing outdated claims.","### **Output**

---

#### **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Report Description**:  
The `incrementWindow` function in the Splitter contract is intended to be called only when tokens are transferred to the contract, ensuring that `balanceForWindow` matches the contract balance. However, anyone can use a fake `RoyaltyVault` contract to call `incrementWindow`, causing `balanceForWindow` to exceed the actual contract balance. This allows verified users to exploit the `claim` or `claimForAllWindows` functions to steal tokens from the contract.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Balance Checks in `incrementWindow`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of insufficient balance checks in `incrementWindow` but misses the critical detail that anyone can call this function using a fake `RoyaltyVault` contract. This oversight is significant because it directly enables the theft of tokens. The response correctly highlights the risk of insolvency due to cumulative liabilities but does not fully address the exploitability of the vulnerability.

---

#### **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**

**Report Description**:  
The `claimForAllWindows` function in the Splitter contract can become unusable if the `currentWindow` value is raised sufficiently high, exceeding the block gas limit. Since `currentWindow` can only be incremented, it will naturally grow as royalties are paid into the contract. An attacker can exacerbate this issue by impersonating an `IRoyaltyVault` and sending 1 WEI of WETH to repeatedly call `incrementWindow`, rendering `claimForAllWindows` inoperable.

**Match in Response List**:  
Matches with the issue titled **""Gas Exhaustion in `claimForAllWindows`""**.

**Validation**:  
**Correct**. The response accurately identifies the gas exhaustion issue in `claimForAllWindows`, explaining that the loop iterating over all windows may consume excessive gas as the number of windows grows. This aligns with the reported issue, which highlights the risk of denial-of-service (DoS) due to the block gas limit being exceeded. The response fully captures the vulnerability and its impact.

---

#### **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Report Description**:  
The `attemptETHTransfer` function sends a fixed amount of gas (30,000) in its call. If the receiver is a contract, this may be insufficient to process the `receive()` function, resulting in the user being unable to receive funds. This issue could lead to failed transactions and user dissatisfaction.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of insufficient gas in `attemptETHTransfer`. This is a significant oversight, as it directly impacts the contract's ability to transfer funds reliably. The lack of a match indicates a gap in the response list's coverage of vulnerabilities.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**

**Partially Correct Matches**:

- **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Missed Issues from Issue Report**:

- **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

--- 

This evaluation highlights the strengths and weaknesses of the response list in addressing the reported issues. While some vulnerabilities are accurately identified, others are either partially addressed or missed entirely, indicating room for improvement in the response list's comprehensiveness and precision.",1,1,1,7,"Okay, let me take a look at this smart contract and try to find any vulnerabilities. So the contract is called Splitter and it's using SplitStorage. The first thing I notice is that it's using a merkle tree for proofs in the claim functions. Let's go through each function one by one.

Starting with the claimForAllWindows function. It takes a percentageAllocation and a merkleProof. It checks the proof using verifyProof, which seems to build the merkle tree. Then it loops through all the current windows and if the user hasn't claimed for that window, it adds the scaled amount. Then transfers the split asset.

Wait, the percentageAllocation is part of the merkle node. So each user has a specific percentage they can claim. But in this function, the percentageAllocation is passed as an argument. That could be a problem because a malicious user might pass a higher percentage than what's allowed in their merkle proof. Wait, no, because the merkle proof is generated with the node that includes the user's address and their percentageAllocation. So if the user tries to input a different percentage, the verifyProof would fail. So that part seems okay.

But what about the loop? If currentWindow is large, say hundreds or thousands, the loop could run out of gas. That's a possible DOS vulnerability. Because as the number of windows increases, the gas cost for claiming all previous windows would increase, potentially making it impossible to claim after a certain point. So that's a gas exhaustion issue in claimForAllWindows.

Moving on to the claim function. It checks that the window is not in the future, that the user hasn't claimed it yet, sets it as claimed, verifies the proof, and transfers the scaled amount. The same issue with scaledPercentageAllocation here. The user's node is generated with their specific percentage, so if they pass a different one, the proof would fail. So that's okay. But in this case, the user claims for a specific window. Not sure about the vulnerabilities here, but maybe reentrancy? The transferSplitAsset uses IERC20.transfer, which is a safe function and doesn't allow for reentrancy. So maybe not.

Looking at the incrementWindow function. It's called by the RoyaltyVault contract, checks that the msg.sender is a RoyaltyVault and that the splitter is this contract. Then it checks the WETH balance, requires that the royaltyAmount is greater than 0, pushes it into balanceForWindow, increments currentWindow. But wait, the royaltyAmount is passed as an argument. But the function checks that the WETH balance is >= royaltyAmount. However, the function doesn't actually transfer any funds. So where is the royaltyAmount coming from? It seems like this function is supposed to record a new window's balance, but how is the royaltyAmount determined? If the RoyaltyVault can pass any amount, even if it's not the actual amount received, that could be an issue. For example, if the vault passes a higher royaltyAmount than what's actually in the contract, then when users claim, they might get more than the contract holds. But the code here pushes royaltyAmount into balanceForWindow, and the transferSplitAsset uses that amount. Wait, but in the incrementWindow function, the code checks that the splitAsset's balance is >= royaltyAmount. But when the code pushes royaltyAmount into balanceForWindow, that's supposed to be the amount available for that window. However, after that, when users claim, the code scales that balance by their percentage. But if multiple windows are added, each with their own balance, but the total balance of the contract is only checked once when incrementing the window. So if there's not enough balance in the contract to cover all the windows, this could lead to insolvency. For example, if window 1 has 100 tokens, window 2 has another 100, but the contract only has 150 tokens in total. Then users from both windows could claim more than what's available. But when each window is incremented, the code checks that the current balance is >= royaltyAmount. So the problem is that each time you increment a window, you're adding to the total liability. But the check is only that the current balance is >= the current royaltyAmount, not the cumulative sum. So if you have multiple windows, each with their own royaltyAmount, the sum of all balanceForWindow entries could exceed the actual balance of the contract. Then, when users try to claim, the transfers would fail because the contract doesn't have enough funds. That's a vulnerability. For example, if first window is 100, balance is 100. Then increment window again with another 100, but the contract's balance is still 100. The code checks that the current balance (100) is >= 100, which it is, so it adds another 100 to balanceForWindow. Now total liability is 200, but actual balance is 100. So when users claim, the contract will try to transfer more than it has, leading to failed transfers. So this is a logical error in the incrementWindow function. The check on line 143 (wethBalance >= royaltyAmount) is incorrect, because it's checking the current balance against the new royaltyAmount, but not considering previous liabilities. So this could lead to an underfunded contract and failed transfers later on.

Another thing in the transferSplitAsset function: it uses IERC20.transfer, which returns a boolean. If the transfer fails, it will revert because of the require(didSucceed, ...). So that's okay. But the event TransferETH is emitted regardless. Wait, but splitAsset is an ERC20 token, not ETH. The event is named TransferETH, which is misleading. Also, the function is called transferSplitAsset, which is correct, but the event is named TransferETH. That's an inconsistency, but not a vulnerability. However, if someone is monitoring the events, they might misinterpret the transfers as ETH instead of ERC20.

Looking at the verifyProof function. It's a standard merkle tree verification. It builds the computedHash by iterating through the proof. However, the way it orders the hash (computedHash <= proofElement) might be vulnerable if the implementation doesn't match the way the merkle tree was constructed. For example, if the tree was built with a different ordering (like using proofElement <= computedHash), then the verification would fail. But this is dependent on how the merkle tree is generated off-chain. If the off-chain code uses the same ordering, then it's okay. Otherwise, it's a vulnerability. However, this is more of an integration issue rather than a contract vulnerability per se. So unless there's a mistake in the ordering here, but as per the code, it's using the standard approach.

Another thing: the claim functions allow the same user to claim multiple times if the merkle proof is valid. But the code uses a claimed mapping to prevent double claims. So once a user claims for a window, they can't again. That's correct.

In the incrementWindow function, the royaltyAmount is added to balanceForWindow, but where does the actual WETH come from? The function doesn't transfer any tokens into the contract. So the assumption is that the RoyaltyVault has already sent the tokens to the Splitter before calling incrementWindow. So the Splitter's balance is increased by some external mechanism. But the code here is responsible for tracking how much is allocated per window. The problem is that if the Splitter's balance is not properly managed, the sum of balanceForWindow entries could exceed the actual balance. Which as discussed earlier is a vulnerability.

Also, the incrementWindow function is called by the RoyaltyVault, which must support the IRoyaltyVault interface. But if a malicious contract pretends to be a RoyaltyVault and calls this function, it could manipulate the window. However, the code checks that IRoyaltyVault(msg.sender).getSplitter() == address(this). So the RoyaltyVault must return this contract's address as its splitter. That should prevent unauthorized calls. But if the RoyaltyVault is compromised or incorrectly configured, this could be a problem, but that's outside the contract's control.

Another point: the scaleAmountByPercentage function divides by 10000, which implies that the percentage is in basis points (since 10,000 = 100%). So scaledPercent is expected to be up to 10,000 (100%). But in the claimForAllWindows function, the percentageAllocation is passed as a parameter. If the merkle tree allows for a percentageAllocation greater than 10,000, then this would result in more than 100% being allocated, leading to scaling amounts that exceed the balance. However, the merkle proof would need to be valid for that percentage. So if the off-chain process ensures that the percentageAllocation doesn't exceed 10,000, then it's okay. Otherwise, this function would allow a user to claim more than the available amount. For example, if a user's node has a percentageAllocation of 12000, then scaleAmountByPercentage would compute (amount * 12000)/10000 = 120% of the amount, which is more than the total. So if the merkle tree includes such a node, the contract would allow over-claiming. So this is a potential vulnerability if the merkle tree isn't properly validated off-chain to ensure percentages don't exceed 10000. But the contract itself doesn't check that the percentageAllocation is within a valid range (e.g., <= 10,000). So that's a possible issue. For instance, in the claim function, if a user provides a scaledPercentageAllocation of 15000, the scaleAmountByPercentage would multiply by 15,000 and divide by 10,000, leading to 150% of the balance being allocated. So the contract doesn't enforce that the percentage is <= 10,000, which could lead to overflow in the allocation. So this is a vulnerability if the merkle tree isn't properly constructed.

Another thing: the PERCENTAGE_SCALE is defined as 10e5, which is 1,000,000. But in scaleAmountByPercentage, they divide by 10000 (10,000). So there's a discrepancy. Wait, 10e5 is 10^5 = 100,000. Wait, in Solidity, 10e5 is 10 * 10^5 = 1,000,000. Wait, no. 10e5 is 10^6 (since e5 is 10^5, so 10 * 10^5 = 1e6). So PERCENTAGE_SCALE is 1,000,000. But in the scaleAmountByPercentage function, they divide by 10000. That implies that the scaledPercent is in basis points (10000 = 100%). However, if PERCENTAGE_SCALE is 1e6, maybe the intention was to have percentages scaled to 1e6. But in the code, they're using 1e4. That's inconsistent. So for example, if the intended scale was 1e6 (like 100% = 1e6), but the code is dividing by 1e4, then the percentages are being treated as 100x larger than intended. This could be a mistake. For example, if the percentage was supposed to be 50% (500,000 in 1e6 scale), but the code is using 1e4, then passing 5000 (50%) would be scaled correctly. But the constant is named PERCENTAGE_SCALE but isn't used in the scaling function. So this is a possible error, leading to incorrect percentage calculations. For example, if the code intended to use PERCENTAGE_SCALE (1e6) but instead divides by 1e4, then the scaling is off by a factor of 100. So if the merkle tree's percentageAllocation is in 1e6 scale, the code would compute (amount * scaledPercent) / 1e4, leading to 100 times more than intended. For example, 50% (500,000) would be (amount * 500,000)/1e4 = 50 * amount. Which is 5000% instead of 50%. That's a critical vulnerability. However, this depends on how the percentageAllocation is being set off-chain. If the merkle tree's percentageAllocation is intended to be in 1e4 scale (like 5000 for 50%), then the code is correct, but the PERCENTAGE_SCALE constant is misleading. But if the intention was to use 1e6, then the code is wrong. Since the code isn't using the PERCENTAGE_SCALE constant in the scaling function, but is using 1e4, this could be a miscalculation. This would lead to incorrect scaling of amounts, allowing users to claim much more than intended. For example, a 1% allocation (100 in 1e4) would be scaled correctly, but if the code was supposed to use 1e6, then the division by 1e4 would lead to 100 * 1e4 / 1e4 = 100% (but 100 in 1e6 scale is 0.01%). So this is a critical vulnerability if the PERCENTAGE_SCALE is intended to be used but isn't. So this seems like a major issue. The function scaleAmountByPercentage is using 1e4 (10000) as the denominator, but the constant PERCENTAGE_SCALE is 1e6. So either the constant is wrong, or the division is wrong, leading to incorrect scaling.

Looking back at the code: the scaleAmountByPercentage function is public and pure. So it's used in multiple places. For example, when claiming, it's used to calculate how much a user gets based on their percentage. If the scaling is off by a factor of 100 (due to 1e4 vs 1e6), this could lead to massive overpayments. For instance, if a user is supposed to get 1% (10,000 in 1e6 scale), but the code is using 1e4, then 1% would be 100 in 1e4. So (amount * 100) / 10000 = 1% of the amount. That's correct. Wait, but 1% in basis points is 100 (since 1% is 100 basis points). Wait, no: 1% as a scaledPercent would be 100 (since 100 / 10000 = 0.01). So if the code uses 1e4 as the scale, then 100 is 1%, which is correct. The PERCENTAGE_SCALE is 1e6, which is 1000000. So if that's supposed to represent 100%, then the scaleAmountByPercentage function is using a different scale (1e4). That's a discrepancy. So the constant is not being used, which could indicate a bug. For example, if the code was supposed to use PERCENTAGE_SCALE (1e6) but uses 1e4 instead, this would be a problem. But perhaps the intention is that the percentage is in basis points (1e4), and the PERCENTAGE_SCALE is for something else. However, the variable is named PERCENTAGE_SCALE, which is confusing. But the code as written uses 1e4 as the scale in the calculation. If the merkle tree's nodes are generated with percentages in basis points (1e4), then it's correct. However, the presence of an unused PERCENTAGE_SCALE constant could indicate a mistake. For example, maybe the function was supposed to divide by PERCENTAGE_SCALE, but it's dividing by 10000. Let's see: PERCENTAGE_SCALE is 10e5, which is 1,000,000. If the scaling was supposed to be 1e6, then the code is wrong. So if the code was supposed to be scaled by 1e6 (for percentages with higher precision), but instead uses 1e4, that's an error. For example, a 1% allocation would be 10,000 in 1e6 scale. But the code would do (amount * 10000)/10000 = 100% of the amount. That's a critical error. So if the code intended to use PERCENTAGE_SCALE but uses 10000 instead, then this is a major vulnerability. Therefore, this is a vulnerability where the percentage scaling is incorrect due to using the wrong denominator, leading to incorrect allocation amounts.

Another possible issue: in the claimForAllWindows function, the loop runs from 0 to currentWindow - 1. But currentWindow is incremented in incrementWindow. Suppose currentWindow is N. Then the loop runs i from 0 to N-1. But balanceForWindow is an array that is 0-indexed. So if currentWindow is 3, balanceForWindow has 3 entries (indices 0, 1, 2). The loop will run i=0,1,2. That's correct. So no issue here.

In the incrementWindow function, when pushing royaltyAmount into balanceForWindow, the code is assuming that the splitAsset's balance is sufficient. But as discussed earlier, the check is only on the current balance, not the cumulative. So multiple increments could add up to more than the contract's balance, leading to insufficient funds later.

Another possible issue: reentrancy. The transferSplitAsset function calls IERC20.transfer, which is a standard function that doesn't execute external contracts, so it's safe. The attemptETHTransfer function is using a low-level call with 30,000 gas, which is enough for a transfer but not enough for reentrancy. But the code isn't using ETH transfers; the transferSplitAsset is for ERC20. However, the event is named TransferETH, which is confusing but not a vulnerability.

Another thing: the verifyProof function is private and pure. It's using the standard merkle tree verification. However, there's a potential vulnerability if the contract uses a different tree structure than what's expected. For example, if leaves are not hashed correctly. The getNode function hashes the address and percentageAllocation. But maybe it should include the window or other data. Wait, no: in the claim function, the node is generated with the user's address and the scaledPercentageAllocation. But in the merkle tree, if the node is just the address and the percentage, then the same node is used across all windows. But in the claim function, the user can claim for a specific window. However, the merkle proof is only based on their address and percentageAllocation. So if a user's percentageAllocation changes between windows, the merkle proof would need to be different. But in this setup, the merkle tree's leaf is based on the user's address and their percentageAllocation, which is fixed across all windows. So if a user is entitled to different percentages in different windows, this setup wouldn't handle that. But according to the code, the percentageAllocation is fixed for the user across all windows. So the merkle tree would need to have a different root if the percentage changes. However, if the percentageAllocation is the same for all windows, then the same node is used. But if the percentage is supposed to vary per window, this code wouldn't support it, leading to incorrect allocations. However, the contract's design seems to assume a fixed percentage per user across all windows. So unless the merkle root is updated for each window, this could be a problem. But if the merkle root is not updated, then users can claim any window with the same percentage, which may not be intended. However, this is a design decision rather than a vulnerability. Unless the merkle root is supposed to be updated per window and isn't, but the code doesn't show that.

Wait, in the SplitStorage contract (not shown here), there's a merkleRoot variable. If the merkleRoot is not updated per window, then the same root is used for all windows. So if a user's percentage changes in a new window, but the merkleRoot hasn't been updated, the user could claim with an outdated percentage. But again, this is dependent on how the merkle tree is managed off-chain. If the root is updated for each window, then the contract would need to have the merkleRoot updated, which it doesn't in the current code. The current code's incrementWindow function doesn't update the merkleRoot. So if the merkleRoot needs to change per window to reflect new allocations, the contract doesn't handle that, leading to possible incorrect claims. But without seeing how the merkleRoot is managed, it's hard to say. However, the contract as written doesn't include a way to update the merkleRoot, which could be an issue if allocations need to change. For example, if a user's percentage is reduced in a new window, but the merkleRoot isn't updated, the user can still claim the old percentage. So if the SplitStorage allows the merkleRoot to be changed, perhaps by an admin, then it's manageable. But if not, then it's a vulnerability if the allocations are supposed to be dynamic per window. But the code provided doesn't show any function to update the merkleRoot, so if the root is set once and never updated, users' percentages are fixed for all windows. Whether that's a vulnerability depends on the intended functionality. If the system expects dynamic percentages per window, then this is a flaw. Otherwise, it's by design.

Another possible issue: the incrementWindow function is public, so anyone can call it if they pass the checks. But the checks require that msg.sender is a RoyaltyVault that returns this contract as its splitter. So unless the RoyaltyVault is compromised, only the RoyaltyVault can call it. But if the RoyaltyVault is malicious or has a bug, then it could call incrementWindow with incorrect royaltyAmounts. However, that's outside the scope of this contract's security.

Putting this all together, the main vulnerabilities I can identify are:

1. **Incorrect Percentage Scaling Leading to Overpayment**: The scaleAmountByPercentage function uses a divisor of 10000 (1e4) instead of the PERCENTAGE_SCALE constant (1e6), potentially leading to incorrect scaling of percentages if the system expects the latter. This could allow users to claim significantly more funds than intended if the percentageAllocation is not properly validated off-chain.

2. **Insufficient Balance Checks in incrementWindow**: The incrementWindow function checks the current balance against royaltyAmount but does not account for previous liabilities. This can lead to a situation where the sum of all balanceForWindow entries exceeds the contract's actual balance, resulting in failed transfers when users attempt to claim.

3. **Gas Exhaustion in claimForAllWindows**: Looping through all previous windows could consume excessive gas if the number of windows is large, making the function uncallable and funds unrecoverable.

4. **Inconsistent Event Logging for ERC20 Transfers**: The TransferETH event is emitted when transferring ERC20 tokens, which is misleading and could cause confusion or errors in off-chain monitoring.

5. **Potential Merkle Tree Verification Issues**: If the merkle tree is constructed with a different node structure or ordering than what's implemented in verifyProof, it could lead to invalid proofs being accepted. However, this depends on external factors.

6. **Lack of Percentage Validation in Claims**: The contract does not enforce that the percentageAllocation is within valid bounds (e.g., <= 10000), which could lead to overflows or excessive claims if an invalid percentage is included in the merkle tree.

Out of these, the most critical are the scaling issue and the insufficient balance checks.","```
1. Gas Exhaustion in `claimForAllWindows`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Gas Exhaustion in `claimForAllWindows`"".
   - This appears at rank 3 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, \( k = 3 \), and there is 1 true positive up to rank 3.
   - \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.333 \).

**Output**:
```
0.333
```",0.333
CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331.0,310.0,"[H-04] CoreCollection can be reinitialized
Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.
Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.
However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.
  [H-07] Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it
The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the payableToken is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply check`. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.
  [H-08] Funds cannot be withdrawn in CoreCollection.withdraw
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the withdraw function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.",3.0,"pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    

    
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    

    
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    

    
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",1528.0,3,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect ERC20 Withdrawal (Critical):**  
   The `withdraw` function incorrectly uses `transferFrom` instead of `transfer` for ERC20 token withdrawals. This will cause withdrawals to fail, permanently locking funds in the contract.

2. **Unprotected Starting Index Initialization (High):**  
   The `setStartingIndex` function is publicly callable before the first mint, allowing anyone to trigger it and influence the starting token ID. This could lead to front-running or manipulation of token distribution.

3. **Inheritance and Override Conflicts (High):**  
   Multiple inheritance from `ERC721Enumerable`, `ERC721Payable`, and `ERC721Claimable` may result in improper execution of `_beforeTokenTransfer` due to Solidity's linearization. Critical functions like token enumeration tracking (via `ERC721Enumerable`) might be skipped, breaking core functionality.

4. **Gas Limit in Batch Minting (Medium):**  
   The `batchMint` function uses a loop without gas restrictions. Minting a large number of tokens in a single transaction could exceed the block gas limit, causing transaction failures.

5. **Reentrancy Risk in RoyaltyVault Call (Medium):**  
   The external call to `IRoyaltyVault(royaltyVault).sendToSplitter()` in `_beforeTokenTransfer` could introduce reentrancy if the vault is malicious, though the risk is mitigated by state updates occurring before the call.

6. **Lack of Access Control on `setStartingIndex` (High):**  
   The absence of access control on `setStartingIndex` allows anyone to determine the starting index, compromising fairness in token distribution.

7. **Inconsistent State from Override Misuse (Medium):**  
   If parent contract `_beforeTokenTransfer` functions are not properly invoked due to inheritance order, token metadata or enumeration data could become inconsistent.

8. **Potential ERC20 Fee-on-Transfer Incompatibility (Low):**  
   The `_handlePayment` logic assumes the ERC20 token does not have a fee-on-transfer mechanism, which could result in incorrect balance checks if such tokens are used.","### **Output**

---

**[H-04] CoreCollection can be reinitialized**

**Report Description**:  
The `initialize` function in `CoreCollection` sets the `initialized` flag but does not check if it has already been set, allowing the function to be rerun multiple times. This could reset critical variables like `payableToken`, potentially enabling the retrieval of all contract funds. Although the function is `onlyOwner`, the risk of accidental or malicious reinitialization by the owner remains, leading to system-breaking consequences.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of reinitialization in `CoreCollection`. This is a critical oversight, as reinitialization can lead to severe vulnerabilities, including fund loss or contract state corruption.

---

**[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

**Report Description**:  
The `mintToken()` function in the `ERC721` collection allows users to mint unique tokens by either providing a merkle proof or paying a fee in `payableToken`. However, if `payableToken` has a callback attached to it, a user can reenter the `mintToken()` function before `totalSupply()` is updated. This bypasses the `totalSupply() + amount <= maxSupply` check, enabling the minting of duplicate NFTs, especially if the user mints the last token.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the reentrancy risk in the `mintToken()` function. This is a significant vulnerability, as it allows for the minting of duplicate NFTs, undermining the integrity of the NFT collection.

---

**[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Report Description**:  
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens. However, `transferFrom` requires an allowance, and since `allowance[CoreCollection][CoreCollection] == 0`, the call will revert, permanently locking funds in the contract.

**Match in Response List**:  
Matches with the issue titled **""Incorrect ERC20 Withdrawal (Critical)""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with using `transferFrom` instead of `transfer` in the `withdraw` function. It correctly explains that this will cause withdrawals to fail, permanently locking funds in the contract, which aligns with the issue description.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-04] CoreCollection can be reinitialized**  
- **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

---

### **Conclusion**

The response list effectively addresses the issue of incorrect ERC20 withdrawal but fails to identify or mitigate the risks associated with reinitialization and reentrancy in the `mintToken()` function. These gaps highlight critical vulnerabilities that could lead to fund loss, contract state corruption, or the minting of duplicate NFTs. Addressing these issues is essential to ensure the security and integrity of the smart contract.",1,0,2,8,"Okay, let's take a look at this smart contract and try to find all the vulnerabilities. Hmm, starting with the code structure. The contract is called CoreCollection and it inherits from Ownable, ERC721Claimable, ERC721Enumerable, and ERC721Payable. Wait, multiple inheritance can sometimes cause issues with function overrides. Let me check the functions that might be conflicting.

Looking at the ERC721 extensions: ERC721Enumerable and ERC721Payable. Both of these might override the same functions from ERC721, like _beforeTokenTransfer. Let's check the _beforeTokenTransfer function in the contract. The contract has an override for _beforeTokenTransfer which calls super._beforeTokenTransfer. Since there are multiple parents, the order of inheritance matters here. Solidity uses linearization for inheritance, so the order in which the parent contracts are listed could affect which _beforeTokenTransfer is called first. If the parents don't properly call super, some functionality might be skipped. For example, ERC721Enumerable's _beforeTokenTransfer might not get called if the overrides aren't handled properly. That could lead to inconsistencies in the enumerable tracking of tokens.

Next, the constructor initializes the ERC721 with empty name and symbol. Then there's an initialize function that sets the name and symbol. But the ERC721 constructor already sets those, and the initialize function overwrites them. However, the ERC721's name and symbol functions are overridden to return _name and _symbol, which are set in initialize. But since the constructor passes empty strings to ERC721, maybe that's okay. Although, if someone calls name() before initialize, they'll get the empty string. But since the initialize function is only callable by the owner and sets initialized to true, maybe that's intended. But the contract is using the initializable pattern without using the initializer modifier from OpenZeppelin's Initializable contract. Wait, the initialize function has a modifier onlyUnInitialized, which checks that initialized is false. But since the owner could be a malicious actor, maybe there's a risk of reinitialization, but the modifier prevents that. So maybe not a vulnerability here.

Looking at the mintToken function. It has a parameter 'amount' which allows minting multiple tokens. The batchMint function loops from 0 to amount and mints each token. The problem here is that if the amount is large, this loop could consume too much gas, potentially causing an out-of-gas error. So a gas limit vulnerability. For example, if someone tries to mint a very large number of tokens in one transaction, it could fail. But since the maxSupply is checked, maybe the amount can't be too large. However, the maxSupply is set during initialize, and if it's set to a high value, like 10,000, then minting 10,000 in one go would be impossible due to gas limits. So the contract doesn't enforce a limit on the 'amount' parameter beyond the maxSupply. This could lead to failed transactions when users try to mint large amounts.

Another thing: the mint function calls setStartingIndex() if startingIndex is 0. But setStartingIndex is a public function. So anyone can call setStartingIndex at any time before it's set. Wait, setStartingIndex has a require that startingIndex == 0. Once it's set, it can't be called again. But before it's set, anyone can call it. The starting index is calculated based on block.number when it's called. If an attacker can call setStartingIndex before the owner does, they might manipulate the starting index. But the function can only be called once. So if the owner mints the first token, then setStartingIndex is called automatically. But if someone else calls it before any minting happens, they could influence the starting index. However, the startingIndex is set based on the block.number at the time it's called. So if an attacker calls it early, maybe during a time when the contract is not yet active, they could set the starting index to a value that's predictable. This might lead to a front-running attack where someone monitors the mempool and calls setStartingIndex right before a legitimate transaction, thereby affecting the token distribution. So the vulnerability here is that the starting index can be set by anyone before it's set, leading to potential manipulation.

Looking at the payment handling in mintToken: if the mintFee is greater than 0, it calls _handlePayment(mintFee * amount). The _handlePayment function (probably in ERC721Payable) should transfer the tokens from the user to the contract. But in the withdraw function, the contract transfers the accumulated fees to the owner. However, the withdraw function uses payableToken.transferFrom(address(this), msg.sender, amount). But for ERC20 transferFrom, the contract must have an allowance from the caller (the contract itself in this case). Wait, no, the contract is the one holding the tokens. To transfer out, the contract should call payableToken.transfer, not transferFrom. Because transferFrom is used when the msg.sender is allowed to spend tokens on behalf of another address. Here, the contract owns the tokens, so it should call payableToken.transfer(msg.sender, amount). Using transferFrom in this context is incorrect. For example, if the contract has 100 tokens, to send them to the owner, it should do payableToken.transfer(owner, 100). Using transferFrom would require that the contract has an allowance approved by itself, which is unnecessary. So this is a bug in the withdraw function. The transferFrom parameters are (from, to, amount), so here it's trying to transfer from address(this) to msg.sender. But transferFrom requires that the msg.sender has an allowance from address(this). However, the contract itself can't approve itself. So this line will fail, causing the withdraw function not to work. This is a critical vulnerability because the owner cannot withdraw the collected fees.

Another issue: the ERC721Payable contract may have a _handlePayment function that transfers the mintFee from the user. Let's assume that ERC721Payable's _handlePayment checks that the user has enough tokens and transfers them to the contract. But if the ERC20 token used for payment has a fee on transfer, the actual amount received by the contract could be less than mintFee * amount, leading to underflow or miscalculations. However, the contract may not account for such tokens. But since the contract uses a generic IERC20, it's possible that it's incompatible with fee-on-transfer tokens, leading to incorrect balance tracking. But maybe this is a known limitation rather than a vulnerability.

In the setRoyaltyVault function, it checks that msg.sender is splitFactory or owner. But splitFactory is set during initialize. However, there's no check that splitFactory is a valid contract address. If the splitFactory is set to a malicious address, that address could call setRoyaltyVault. But the owner is also allowed to call it. So maybe the owner can set it arbitrarily, which could be a centralization risk but not a vulnerability in the code.

The setHashedProof function can only be called once because it checks that HASHED_PROOF is empty. Once it's set, it can't be changed. That's okay, but if the hashed proof needs to be updated, the function doesn't allow it. Not a vulnerability, just a design choice.

Looking at the _beforeTokenTransfer hook: it calls super._beforeTokenTransfer, which should handle the hooks from ERC721, ERC721Enumerable, and ERC721Payable. However, because the contract inherits from multiple contracts that override _beforeTokenTransfer, the linearization order might cause some of the hooks not to execute. For example, ERC721Enumerable's _beforeTokenTransfer updates the enumeration data. If the CoreCollection's _beforeTokenTransfer doesn't properly call all the necessary parent functions, the enumeration might break. Let me check the override in the contract. The code shows:

function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal virtual override {
    super._beforeTokenTransfer(_from, _to, _tokenId);

    if (royaltyVault != address(0) && IRoyaltyVault(royaltyVault).getVaultBalance() > 0) {
        IRoyaltyVault(royaltyVault).sendToSplitter();
    }
}

The super call here would invoke the _beforeTokenTransfer of the parent contracts. But with multiple inheritance, the order in which parents are listed matters. The contract is defined as CoreCollection is Ownable, ERC721Claimable, ERC721Enumerable, ERC721Payable. The inheritance order is linearized from right to left? Wait, Solidity's inheritance is from the most base to derived. Let me recall: the order in the contract definition is Ownable, ERC721Claimable, ERC721Enumerable, ERC721Payable. So linearization is from the last parent to the first. So when super is called, it would go to the immediate parent. Let's see: the contract inherits from Ownable first? Wait, Solidity's linearization is from the most base to the most derived. The order in the 'is' list is from the most base to the most derived. Wait, no, in Solidity, the order is from the most base to the most derived. So for example, if you have contract A is B, C, then the linearization is C, B, A. Because C is considered more base than B. Wait, no, maybe I'm confused. The correct way is that the linearization is done in reverse order of the 'is' list. So for a contract that inherits Ownable, ERC721Claimable, ERC721Enumerable, ERC721Payable, the linearization order is ERC721Payable, ERC721Enumerable, ERC721Claimable, Ownable, and then the CoreCollection. So when the contract calls super._beforeTokenTransfer, it would call the function in ERC721Payable's parent, which might be another contract. Wait, ERC721Payable may itself inherit from ERC721 or have its own _beforeTokenTransfer. This can get complicated. If the various parent contracts (ERC721Enumerable, ERC721Payable, ERC721Claimable) all override _beforeTokenTransfer and don't call super properly, the CoreCollection's override might not correctly invoke all the necessary _beforeTokenTransfer functions. For example, ERC721Enumerable's _beforeTokenTransfer is required to update token ownership enumeration. If that's not called, the enumerable functions (like tokenOfOwnerByIndex) would break. So if the linearization causes some of the parent _beforeTokenTransfer functions not to be called, that's a problem.

The CoreCollection's _beforeTokenTransfer calls super, then does the royalty vault check. Let's check the parent contracts. ERC721Enumerable's _beforeTokenTransfer override calls super._beforeTokenTransfer (which would be ERC721's), and then updates the enumerable data. Similarly, ERC721Payable might have its own _beforeTokenTransfer. If the linearization leads to the CoreCollection's override only calling one of the parent's _beforeTokenTransfer, then others might be missed. For example, if the linearization order is such that when super is called in CoreCollection's _beforeTokenTransfer, it goes to ERC721Claimable's _beforeTokenTransfer, which in turn might not call further supers, then ERC721Enumerable's _beforeTokenTransfer might not be called. This could break the enumerable functionality, leading to incorrect tracking of tokens. The user could end up with tokens that aren't properly indexed, causing functions like tokenByIndex to fail or return incorrect data.

Another possible issue is reentrancy. In the _beforeTokenTransfer function, the code calls IRoyaltyVault(royaltyVault).sendToSplitter(). If sendToSplitter is a function that makes an external call to an untrusted contract, this could potentially re-enter the CoreCollection contract. For example, during a token transfer, if the royaltyVault is a malicious contract that calls back into the CoreCollection's functions, it could lead to reentrancy attacks. However, since the sendToSplitter is called after the super._beforeTokenTransfer, which includes the actual transfer logic, maybe the state changes have already been made, reducing the risk. But this depends on what sendToSplitter does. If the sendToSplitter transfers funds or calls another contract, it could be a reentrancy vector. The contract doesn't have a reentrancy guard, so this is a potential vulnerability.

Looking at the batchMint function, which loops and calls mint for each token. The mint function assigns the tokenId as ((startingIndex + totalSupply()) % maxSupply) + 1. However, totalSupply() increases with each mint, so the tokenId is calculated based on the current totalSupply. But if the startingIndex is not set yet, the first call to mint will set it. Wait, in mint(), the first thing checked is if startingIndex is 0, then call setStartingIndex(). Once set, the tokenId is computed. But totalSupply() is the number of tokens minted so far. When startingIndex is set, each subsequent mint uses the current totalSupply(). So for example, if startingIndex is 5 and totalSupply() is 0, tokenId would be (5 + 0) % maxSupply +1 = 5%maxSupply +1. Then totalSupply becomes 1. Next mint would be (5 +1) % maxSupply +1, etc. This should generate unique token IDs as long as maxSupply is fixed. But what if maxSupply is changed? Wait, maxSupply is set during initialize and cannot be changed afterward. So that's okay. However, if the startingIndex is set by a user, as mentioned earlier, it could lead to predictability or manipulation of token IDs.

Another thing: the ERC721 standard requires that each tokenId is unique and is assigned only once. The mint function's calculation of tokenId should ensure that no two tokens have the same ID. Since totalSupply() increments by 1 each time, and startingIndex is fixed once set, the formula ((startingIndex + totalSupply()) % maxSupply) +1 should cycle through all IDs from 1 to maxSupply without duplicates, assuming maxSupply is correct. But if the maxSupply is changed after deployment (which it can't be, as there's no function to change it), then duplicates could happen. But in the current code, maxSupply is set during initialize and is immutable. So that's safe.

In the initialize function, the contract sets splitFactory = _splitFactory. But there's no check that _splitFactory is a valid address (non-zero). If it's set to address(0), then calls to setRoyaltyVault that check msg.sender == splitFactory would fail, but the owner can still call it. So maybe not a vulnerability, just a potential misconfiguration.

The mintToken function uses canClaim, which is part of the ERC721Claimable contract. The canClaim function probably checks the merkle proof. But the parameters passed to canClaim include claimableAmount, amount, and merkleProof. The code requires that canClaim returns true, but if the merkle proof isn't properly validated, users might be able to claim more tokens than allowed. However, this depends on the implementation of ERC721Claimable's canClaim function. Since that's an imported contract, we can't see it here. Assuming that canClaim correctly verifies the merkle proof and the claimableAmount, then this is okay. But if there's a flaw in that contract, it could be a problem. But given the code here, we can't assess that.

Another thing: the event NewClaim is emitted in batchMint with msg.sender as the claimer and to as the recipient. But if the msg.sender is a contract that is calling mintToken on behalf of another user (to), then the event would log the contract's address as the claimant, which might not be intended. However, since the function uses msg.sender for the claim check, that's correct. So if a user calls mintToken with their own address as 'to', and they are the ones who have the valid merkle proof, then it's okay. But if someone else calls it on their behalf, the event would show the caller as the claimant, which might be misleading but not a vulnerability.

The withdraw function uses payableToken.transferFrom(address(this), msg.sender, amount). As mentioned earlier, this is incorrect. The correct method should be payableToken.transfer(msg.sender, amount), because the contract is the owner of the tokens. Using transferFrom here implies that the contract is allowed to spend the tokens of address(this), which it is, but the syntax is wrong. The transferFrom function requires that the msg.sender has an allowance from the 'from' address (which is the contract itself here). Since the contract can't approve itself, this would fail. For example, the contract has 1000 tokens. To transfer them, it should call transfer, not transferFrom. So the withdraw function is broken and will revert, preventing the owner from withdrawing funds. This is a critical issue.

In the mintToken function, when isClaim is true, it calls _claim(msg.sender, amount). The _claim function is part of ERC721Claimable and likely marks the claimed amount for the user. However, there's no check that the user hasn't already claimed their tokens. The canClaim function may enforce this via the merkle proof, but if the same proof can be reused, the user could claim multiple times. However, the ERC721Claimable's _claim function should mark the user as having claimed, preventing double claims. But again, since that's in an external contract, we can't be certain. Assuming it's correctly implemented, this isn't an issue here.

Another possible issue: the use of block.number in setStartingIndex. The startingIndex is calculated as (hash of ""CoreCollection"" and block.number) mod maxSupply +1. However, block.number is public and can be influenced by miners to some extent. If the contract's deployment and initial mints are in a block that the miner can manipulate, they might be able to bias the starting index. However, this is a common approach for randomization, though not truly secure. It's a low-severity issue since it's not a true random number, but it's a known limitation.

The HASHED_PROOF is set once and can't be changed. If the hashed proof is incorrect or needs updating, there's no way to fix it. But that's by design, so not a vulnerability.

In summary, the vulnerabilities I can identify are:

1. **Incorrect ERC20 Withdrawal (Critical):** The withdraw function uses transferFrom instead of transfer, which will fail, locking the funds in the contract.

2. **Unprotected Starting Index Setting (High):** The setStartingIndex function is public and can be called by anyone before it's set, allowing manipulation of the starting index.

3. **Inheritance and Function Override Issues (High):** Potential improper handling of _beforeTokenTransfer across multiple inherited contracts, leading to broken enumerable functionality or other side effects.

4. **Gas Limit in Batch Minting (Medium):** The batchMint function uses a loop which could hit gas limits with large amounts, causing failed transactions.

5. **Reentrancy in RoyaltyVault Call (Medium):** The _beforeTokenTransfer makes an external call to royaltyVault, which could be a reentrancy vector.

6. **Lack of Access Control on setStartingIndex (High):** Any user can trigger the starting index calculation before the first mint, potentially front-running legitimate transactions to influence the index.

7. **Potential Inconsistent State Due to Inheritance (Medium):** If parent contracts' _beforeTokenTransfer functions are not properly called, the contract's state could become inconsistent.

I think those are the main issues. Let me double-check each one.

Starting with the withdraw function: definitely a problem. Using transferFrom when the contract is the owner of the tokens. For example, if the contract has 100 tokens, to send them to the owner, the contract should call payableToken.transfer(owner, 100). Using transferFrom requires that the contract has approved itself to spend its own tokens, which is not needed and would fail because the contract cannot call approve on itself unless there's a function to do so. Since there's no such function, the transferFrom in withdraw will always revert.

Then, setStartingIndex is public and can be called by anyone. So if the contract is deployed and someone calls setStartingIndex before any mints, it sets the index based on their block.number. The starting index is critical for token distribution, so this allows manipulation. The function can only be called once, but if a malicious actor calls it at an advantageous time, they could influence the token IDs. This is a high-severity issue.

The inheritance issue with _beforeTokenTransfer: if the multiple inheritance causes some of the parent _beforeTokenTransfer functions not to be called, then features like enumerable tracking would break. For example, if ERC721Enumerable's _beforeTokenTransfer isn't called, the token ownership enumeration wouldn't update, leading to incorrect results in functions like tokenOfOwnerByIndex. Since the CoreCollection's _beforeTokenTransfer calls super, it's necessary that all parent implementations are properly called. However, Solidity's linearization might lead to only one parent's _beforeTokenTransfer being called. For instance, if the linearization results in ERC721Payable's _beforeTokenTransfer being the first parent, and that parent doesn't call super, then the ERC721Enumerable's _beforeTokenTransfer might not be invoked. This is a critical issue because it breaks core functionality.

The gas limit in batchMint: if the maxSupply is high (like 10,000), then minting 10,000 tokens in one transaction is impossible due to block gas limits. The function doesn't restrict the 'amount' parameter, leading to possible DoS on legitimate users trying to mint large amounts.

Reentrancy in _beforeTokenTransfer: when sending to the royaltyVault, if the vault is malicious, it could re-enter the contract during the transfer. However, the _beforeTokenTransfer is called after the super._beforeTokenTransfer, which includes the actual token transfer. So the state might have already been updated, but depending on what's done in sendToSplitter, there could still be reentrancy issues. For example, if sendToSplitter transfers tokens and the recipient is a contract that calls back into the CoreCollection, but since the token transfer has already happened, maybe the reentrancy would be limited. Still, it's a potential risk.

So these are the main vulnerabilities I can identify.","```
1. Incorrect ERC20 Withdrawal (Critical)
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect ERC20 Withdrawal (Critical)"".
   - This prediction appears at **rank 1** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is only one true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```",1
RoyaltyVault.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751.0,104.0,"[H-01] ERC20 transferFrom return values not checked
The transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
  [H-05] Centralisation RIsk: Owner Of RoyaltyVault Can Take All Funds
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.
As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.
  [H-09] ERC20 tokens with no return value will fail to transfer
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.",3.0,"pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",627.0,3,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Reentrancy in `sendToSplitter` Function**  
   - The function transfers tokens to `splitterProxy` and then calls `incrementWindow`, an external function on the splitter. A malicious splitter could re-enter `sendToSplitter` during this call, potentially draining funds if the vault's balance is manipulated during reentrancy.

2. **Unchecked Platform Fee Upper Bound**  
   - The `setPlatformFee` function lacks a check to ensure `_platformFee` does not exceed 10,000 basis points (100%). If set above this threshold, the calculation `balanceOfVault - platformShare` underflows, causing transactions to revert and locking funds.

3. **Missing Zero Address Check for Fee Recipient**  
   - The `setPlatformFeeRecipient` function does not validate that `_platformFeeRecipient` is non-zero. Setting it to `address(0)` causes transfers to fail, locking platform fees in the contract.

4. **Incompatibility with Non-Compliant ERC20 Tokens**  
   - Using `transfer` with `require` assumes the token returns a boolean. Tokens like USDT (pre-2018) do not return booleans, causing transfers to revert and making the contract incompatible with such tokens.

5. **Insufficient Validation of `splitterProxy`**  
   - While `splitterProxy` is checked against `address(0)`, there is no validation that it points to a valid `ISplitter` contract. A malformed address could cause `incrementWindow` to fail unexpectedly.

6. **Potential Trust in External Contract (`splitterProxy`)**  
   - The contract relies on `splitterProxy` behaving correctly. If compromised or malicious, it could disrupt fund distribution (e.g., reverting on `incrementWindow` or enabling reentrancy).

7. **Centralization Risks**  
   - The owner has unilateral control over critical parameters (e.g., fees, recipients). A compromised owner could steal funds or brick the contract by setting extreme values.","### **Output**

---

**[H-01] ERC20 transferFrom return values not checked**

**Report Description**:  
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked. Failing to validate the return value of `transferFrom` could lead to silent failures in token transfers, especially when dealing with non-compliant or malicious tokens.

**Match in Response List**:  
Matches with the issue titled **""Incompatibility with Non-Compliant ERC20 Tokens""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the issue of incompatibility with non-compliant ERC20 tokens, which aligns with the broader concern of unchecked return values. However, it does not explicitly address the specific issue of `transferFrom` return values being unchecked, which is a distinct vulnerability. The response focuses on `transfer` calls rather than `transferFrom`.

---

**[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Report Description**:  
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g., 100% = 10000), and that share of the contract's balance and future balances will be set to the `platformFeeRecipient` (which is in the owner's control) rather than the splitter contract. As a result, the owner can steal the entire contract balance and any future balances, bypassing the splitter.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Platform Fee Upper Bound""** and **""Centralization Risks""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk and the lack of validation on the `_platformFee` upper bound. It correctly explains how the owner can exploit this to steal funds, which aligns with the issue description. The response also highlights the broader centralization risks, which are relevant to this issue.

---

**[H-09] ERC20 tokens with no return value will fail to transfer**

**Report Description**:  
Although the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard (including high-profile tokens like USDT). In such cases, the `.transfer()` call will revert even if the transfer is successful because Solidity will check that the `RETURNDATASIZE` matches the ERC20 interface.

**Match in Response List**:  
Matches with the issue titled **""Incompatibility with Non-Compliant ERC20 Tokens""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of incompatibility with non-compliant ERC20 tokens, specifically mentioning tokens like USDT that do not return booleans. This directly aligns with the issue description and highlights the potential for transfers to revert unnecessarily.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**  
- **[H-09] ERC20 tokens with no return value will fail to transfer**

**Partially Correct Matches**:

- **[H-01] ERC20 transferFrom return values not checked**

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Assessment**

The `response_list` effectively covers most of the issues in the `issue` report, with accurate identification of centralization risks and incompatibility with non-compliant ERC20 tokens. However, the response for **[H-01]** is only partially correct, as it does not explicitly address the unchecked return value of `transferFrom`. This gap could be addressed by expanding the response to include the specific risks associated with unchecked `transferFrom` calls. Overall, the responses are well-aligned with Solidity best practices and security standards.",2,1,0,7,"Okay, let me try to figure out the vulnerabilities in this smart contract. I'm new to this, so I'll need to take it step by step.

First, looking at the code structure. The contract is called RoyaltyVault, and it imports several interfaces and OpenZeppelin contracts like ERC165 and Ownable. It also inherits from VaultStorage, IRoyaltyVault, ERC165, and Ownable. Ownable means it has an owner, which is good for access control, but maybe there's something there.

Looking at the functions. There's a sendToSplitter function which is external and overridden. Let me check what this does. It gets the vault balance using getVaultBalance, which checks the ERC20 balance of royaltyAsset. Then it checks that the balance is greater than 0 and that splitterProxy is not the zero address. Then it calculates platformShare as a percentage (platformFee) of the balance, and splitterShare as the remainder.

Then it transfers splitterShare to splitterProxy, calls incrementWindow on the splitter, and transfers platformShare to platformFeeRecipient. It emits events after each transfer.

Potential issues here:

1. Reentrancy: The function makes external calls (transfer and incrementWindow). Wait, ERC20 transfer is generally safe, but if the token is a malicious contract, maybe? But ERC20's transfer shouldn't allow reentrancy because it's a standard function. However, the order of operations here is transfer to splitterProxy, then call incrementWindow. Wait, after transferring, they call incrementWindow on the splitter. If the splitterProxy is a malicious contract, maybe when they call incrementWindow, it could re-enter the sendToSplitter function. But since the balance is checked at the beginning, maybe the reentrancy would fail the balance check. But maybe there's a way? Let's see. Suppose splitterProxy's incrementWindow calls back into sendToSplitter. The first time, balance is X. Then, after transferring X - platformShare to splitterProxy, the splitterProxy could send tokens back to the vault during incrementWindow. Then, during reentrancy, the balance would be platformShare plus whatever was sent back. So the balance would be more than zero again. Then, platformShare would be calculated again, but platformFee is a percentage of the new balance. This could lead to some funds being drained. But since platformFee is a percentage set by the owner, maybe if the fee is high, it could take more. Hmm. But is this possible? The sendToSplitter function is external, so someone could call it again, but in the same transaction. If the splitter's incrementWindow triggers a call back, then during the first sendToSplitter execution, they transfer, then call incrementWindow, which triggers another sendToSplitter. But the state variables haven't been updated yet. Wait, in the first call, after transferring splitterShare and platformShare, the vault's balance should be zero. Unless the splitter sends back tokens during incrementWindow. Then the balance would be positive again. So during reentrancy, the function would proceed again, calculate platformShare again based on the new balance. That could result in multiple transfers. However, the problem is that the transfers are done via ERC20's transfer, which is a standard function, but the splitterProxy's incrementWindow could be a contract that manipulates the vault's balance. So if the splitterProxy is malicious, this could be a reentrancy vulnerability. But since splitterProxy is set by the owner, maybe it's trusted? If the owner sets a malicious splitter, that's a different issue. But if the splitter is supposed to be a trusted contract, maybe not. But in the code, there's no check when setting the splitterProxy. Wait, looking at the code, where is splitterProxy set? The code has a function getSplitter which returns splitterProxy, but the setter function isn't visible here. The code imports VaultStorage, which probably contains the splitterProxy variable. So maybe splitterProxy is set in the VaultStorage contract, but since the code isn't shown, maybe there's a setter function that's missing access control? For example, if splitterProxy can be changed by anyone, that's a problem. But the current contract is Ownable, so if the setter for splitterProxy is onlyOwner, then that's okay. But since we don't have the code for VaultStorage, it's hard to say. So maybe splitterProxy is not properly controlled, leading to a vulnerability if it's changeable by unauthorized users. However, the current code doesn't show a setter for splitterProxy. Hmm. So perhaps that's an issue—if splitterProxy can be set arbitrarily by the owner, but if not properly validated, like not checking for zero address, but in sendToSplitter, there's a require that splitterProxy != address(0). So the owner could set a malicious splitterProxy, which is a centralization risk but not a vulnerability per se. So maybe splitterProxy is a trusted contract. But if it's a malicious contract, then during the call to incrementWindow, it could re-enter the sendToSplitter function. Let's simulate:

First call to sendToSplitter:

- balanceOfVault is 100 (for example)
- platformShare = 100 * platformFee / 10000. Suppose platformFee is 100 (1%), platformShare is 1, splitterShare is 99.
- Transfer 99 to splitterProxy. Now the vault's balance is 1 (platformShare). Then call incrementWindow(99) on splitterProxy.
- If splitterProxy's incrementWindow calls back into sendToSplitter, then in the second call:
- balanceOfVault is 1 (platformShare) but maybe the splitterProxy sent back 99 tokens to the vault during incrementWindow, so balance is 1 + 99 = 100 again?
- Then platformShare would be 1 again, splitterShare 99, but now splitterProxy is already set. So transferring 99 again, leading to draining the vault. But in the first transfer, the vault would have sent 99, then the splitter sends back 99, then in the reentrant call, sends 99 again. So total sent is 198, but the vault only had 100 initially. Wait, that's impossible unless the splitter has the tokens. But maybe the splitterProxy is a contract that holds tokens and when incrementWindow is called, it sends more tokens to the vault. Hmm, this might be a stretch. Alternatively, if the splitterProxy is a malicious contract that when incrementWindow is called, it calls sendToSplitter again, but the vault's balance is now 1 (platformShare not yet sent). Wait, in the first call, the splitterShare is transferred first, then incrementWindow is called, and then the platformShare is transferred. Wait, no. Let me check the code:

In sendToSplitter, after calculating splitterShare and platformShare, the code does:

- transfer splitterShare to splitterProxy.
- call incrementWindow(splitterShare) on splitterProxy.
- transfer platformShare to platformFeeRecipient.

Wait, so the order is: first transfer to splitter, then call incrementWindow, then transfer platform. So the platform transfer is the last step. So during the call to incrementWindow, the splitterProxy could call sendToSplitter again. But at that point, the vault's balance would be platformShare (since splitterShare was transferred out, and platformShare hasn't been transferred yet). But wait, no: the transfers to splitterProxy and platformFeeRecipient both happen in the same transaction. Wait, no, the splitterProxy transfer is done first. So let's say balance is 100. platformFee is 100 (1%), so platformShare is 1, splitterShare 99. Transfer 99 to splitterProxy. Now vault balance is 1. Then call incrementWindow(99). Suppose during that call, splitterProxy calls sendToSplitter again. Now, the vault balance is 1. So balanceOfVault is 1. The require(balanceOfVault > 0) passes. Then platformShare is 1 * 1% = 0.01 (if using 100 as denominator, but the code uses 10000, so platformFee is in basis points). Suppose platformFee is 100 (1%), then 1 * 100 / 10000 is 0. So platformShare would be zero if balance is 1. Wait, 1 * 100 is 100, divided by 10000 is 0.01, but since we're dealing with integers, 1 * 100 = 100, divided by 10000 is 0 (integer division). So platformShare would be 0, splitterShare would be 1 - 0 = 1. Then, transfer 1 to splitterProxy again, which is allowed. Then call incrementWindow(1). Then transfer 0 to platformFeeRecipient. So in this scenario, the splitterProxy could receive 99 + 1 = 100, and platformFeeRecipient gets 1. So total 101, but that's not possible. Wait, this depends on the actual token balances and how the splitterProxy behaves. But this is a possible reentrancy attack vector if the splitterProxy is malicious. Therefore, the sendToSplitter function is vulnerable to reentrancy via the incrementWindow call. The function transfers tokens to splitterProxy and then calls a function on it, which could re-enter. Since the state (balance) is not updated until after the external call, a reentrant call could manipulate the balance.

Another potential issue: the function uses transfer, which can fail if the recipient is a contract that doesn't handle ERC20 transfers properly. For example, if the platformFeeRecipient is a contract that doesn't implement ERC20 callbacks, the transfer could fail. However, the code uses require(transfer(...)), which would revert the entire transaction if the transfer fails. That's okay, but maybe there's a gas limit issue. Wait, using transfer might not be the best practice because some ERC20 tokens (like USDT) have transfer functions that don't return a boolean, leading to failures. But the code uses IERC20(royaltyAsset).transfer which requires that the function returns a boolean. So if the royaltyAsset is a token that doesn't return a boolean on transfer, this would revert. But since the contract uses OpenZeppelin's IERC20, which expects the return value, that's a problem for such non-compliant tokens. However, this contract would be incompatible with those tokens. But that's a known issue with certain ERC20 implementations. So if the royaltyAsset is a token that doesn't conform to the standard, this could cause the transfer to fail. So that's a vulnerability if the contract is intended to work with such tokens.

Another thing: the platformFee is set by the owner via setPlatformFee. If the owner sets a very high platformFee (like 10000, which is 100%), then all the funds would go to the platform, leaving nothing for the splitter. That's a centralization risk, but since the owner is trusted, maybe not a vulnerability. However, if the owner is malicious or compromised, that's a problem. But that's a trust issue rather than a code vulnerability.

Another thing: the sendToSplitter function is external, so anyone can call it. That might be intentional, but if there's a way to trigger it multiple times before the splitter's window is updated, it could lead to funds being sent multiple times. But the function checks the balance each time, so if the balance is zero, it won't proceed. But if the vault receives more tokens after the first send, subsequent calls would process the new balance. That's intended behavior, so maybe not a vulnerability.

There's also a possible front-running issue. For example, if someone sees a pending sendToSplitter transaction, they could front-run it by sending tokens to the vault, causing the splitter to receive more funds. But that's a general issue with how transactions are ordered and might not be a contract vulnerability.

Another thing: the code calculates splitterShare as balanceOfVault - platformShare. If platformFee is set such that platformShare is a large portion of the balance (e.g., balance is 100 and platformFee is 10000), then platformShare would be 100, and splitterShare would be 0. In that case, the transfer to splitterProxy would be 0, but the code still tries to transfer 0. ERC20's transfer of zero is allowed, but the require statement would pass as long as the transfer returns true. However, some tokens might not allow transferring zero, but the standard says that transferring zero should return true. However, if a token returns false on zero transfers, this would cause the require to fail. But that's unlikely. Still, the code proceeds to call incrementWindow(splitterShare), which could be zero. If the splitter's incrementWindow function doesn't handle zero correctly, that could be an issue. But the code requires that incrementWindow returns true, so if the splitter returns false when the amount is zero, the transaction would revert. So if splitterProxy's incrementWindow(0) returns false, then the transaction would revert. So if platformFee is set to 10000 (100%), then splitterShare is zero, leading to incrementWindow(0) call. If that's not allowed, the transaction reverts. So in that case, the sendToSplitter function would fail. So the platformFee needs to be set in a way that splitterShare is positive, or the splitter must accept zero. But the code doesn't check that platformFee is less than 10000. So if the owner sets platformFee to 10000, the sendToSplitter function would always revert, effectively freezing the funds. That's a possible denial of service. So the setPlatformFee function should have a maximum check. For example, require(_platformFee <= 10000), but in the current code, the owner can set any value. So if platformFee is set to 10001, then the calculation would overflow. Wait, (balanceOfVault * platformFee) when platformFee is 10001 would be (balance * 10001). For example, balance is 100, 100 * 10001 = 1,000,100, divided by 10000 is 100.01, but since it's integer division, 100.01 becomes 100. Then splitterShare is balanceOfVault (100) - 100 = 0. So platformShare is 100, splitterShare 0. The transfer to splitterProxy would be 0, which would work. Then incrementWindow(0) is called, which may or may not fail. But if the splitter expects a positive value, then the transaction would fail. However, the platformFee is set by the owner, so if they set it to a value that's over 10000, the calculation would be incorrect. Wait, 10000 is 100%, so if platformFee is more than 10000, the platformShare could exceed the balance. For example, if platformFee is 15000 (150%), then platformShare is (balance * 15000) / 10000 = 1.5 * balance. Which would be more than balance, so splitterShare would be negative. But since splitterShare is balanceOfVault - platformShare, which could underflow. But in Solidity 0.8.x, arithmetic operations are checked by default, so if platformShare exceeds balanceOfVault, this would cause an underflow and revert. Therefore, if platformFee is greater than 10000, the sendToSplitter function would revert. So the owner setting a platformFee over 10000 would make the sendToSplitter function fail. Therefore, the setPlatformFee function should have a require(_platformFee <= 10000) check to prevent this. The current code does not have such a check, so that's a vulnerability. An owner could accidentally or maliciously set a fee over 10000, causing sendToSplitter to revert, which would lock the funds in the vault because sending would be impossible.

Another thing: the contract inherits from VaultStorage, which likely holds state variables like splitterProxy, royaltyAsset, platformFee, platformFeeRecipient. Since the code isn't shown, maybe there are uninitialized variables. For example, if royaltyAsset is not set, then getVaultBalance would call IERC20 with a zero address, which would fail. But assuming that the VaultStorage is properly initialized with these variables, that's okay. But if not, that's a problem.

Also, the contract uses Ownable, which means the owner has a lot of power (setting platform fee and recipient). If the owner's account is compromised, the attacker can set the platform fee to 100% and recipient to their address, stealing all funds. But that's a centralization risk, not a code vulnerability.

Another potential issue: the sendToSplitter function transfers the platformShare to platformFeeRecipient. However, if platformFeeRecipient is a contract that cannot receive ERC20 tokens (like a contract without a function to handle ERC20 transfers), the transfer would fail and revert. But the code uses require(transfer(...)), so that's handled. However, if the platformFeeRecipient is set to address(0), the transfer would fail. But the setPlatformFeeRecipient function is onlyOwner, so the owner must set a valid address. The code does not check that the recipient is not zero in setPlatformFeeRecipient. So if the owner sets the recipient to address(0), then the transfer would fail, causing sendToSplitter to revert. So the setter function should have a require(_platformFeeRecipient != address(0)), but it's missing. That's a vulnerability because it allows the owner to set an invalid recipient, which would lock the platform fees.

Another thing: when transferring to splitterProxy and platformFeeRecipient, the code uses transfer, but the order of operations could be problematic. For example, if the splitterProxy transfer succeeds, but the platformFeeRecipient transfer fails, the entire transaction reverts. That's correct. However, the code does transfer to splitterProxy first, then calls incrementWindow, then transfers to platform. If the transfer to platform fails, the incrementWindow has already been called. But the code has a require after the transfer to splitterProxy and the incrementWindow. Let's look:

The code after calculating the shares:

1. Transfer splitterShare to splitterProxy. Require that transfer is true.
2. Call incrementWindow(splitterShare) on splitterProxy and require it returns true.
3. Transfer platformShare to platformFeeRecipient and require that's true.

So if the transfer to platformFeeRecipient fails, steps 1 and 2 have already been executed, but step 3 fails, so the entire transaction reverts. But wait, no: in Solidity, when a require fails, it reverts all state changes. So if step 3 fails, the previous transfers (steps 1 and 2) would be reverted. Wait, no. The ERC20 transfer is an external call, which modifies the token's state. Once the transfer is done, the token's state is updated. If a subsequent require fails, the entire transaction reverts, which would revert the token's state changes as well, only if the token's contract is using the standard revert mechanism. Wait, but ERC20 transfers are not reversible unless the entire transaction reverts. Wait, no. If during a transaction, you call transfer on an ERC20 token, and later the transaction reverts, the ERC20 transfer is also rolled back. Because all state changes in a transaction are reverted if the transaction reverts. So in the code's sendToSplitter function, if the transfer to splitterProxy is done (step 1), then incrementWindow is called (step 2), and then the transfer to platform fails (step 3), the entire transaction is reverted. Therefore, the splitterProxy would not have received the tokens, and the incrementWindow call would also be rolled back. So no problem here. So the code is safe in that regard. So even though steps 1 and 2 are done before step 3, if step 3 fails, everything is rolled back. So the order is okay.

Another thing: if the splitterProxy's incrementWindow function doesn't do anything with the splitterShare, but the code requires that it returns true. If the splitterProxy's incrementWindow returns false for any reason, the transaction would revert. So if the splitter's implementation has a condition where it returns false under certain circumstances, the sendToSplitter would fail. But that's expected behavior, and it's up to the splitter's implementation. However, the code's requirement is that incrementWindow returns true, so if the splitter doesn't return true, the transaction reverts, which is correct.

Another possible issue: the sendToSplitter function does not update any state variables after transferring. So multiple calls would process the same balance. Wait, no. The function's balance check is based on the current ERC20 balance. So if someone calls sendToSplitter, it sends the current balance, then if more tokens are deposited, another call would send those. That's intended. But if the vault is supposed to process all available funds each time, that's okay. However, if the vault is supposed to process funds only once, then this is a problem. But the code doesn't have such logic, so it's by design.

Potential vulnerabilities identified:

1. Reentrancy in sendToSplitter via the call to splitterProxy's incrementWindow. The external call is made after transferring tokens, which could allow a malicious splitter to re-enter the function.

2. No upper limit on platformFee in setPlatformFee, allowing the owner to set a fee over 10000, causing arithmetic underflow in sendToSplitter and reverting the transaction, leading to locked funds.

3. Missing zero address check in setPlatformFeeRecipient, which could allow the owner to set the recipient to address(0), causing transfers to fail and platform fees to be locked.

4. ERC20 transfer failures due to tokens that don't return a boolean (like USDT in older versions), causing the transfer to revert. The contract uses IERC20's transfer which expects a boolean return, leading to potential incompatibility.

5. The splitterProxy could be a contract with a malicious implementation, but that's a trust issue rather than a code vulnerability (assuming splitterProxy is set correctly by the owner).

6. If the royaltyAsset is not properly initialized in VaultStorage, calls to getVaultBalance would revert when interacting with a zero address. But that's dependent on VaultStorage's initialization.

Let me prioritize these:

1. Reentrancy is a critical issue if the splitterProxy is malicious. Since splitterProxy is set by the owner, but if compromised, it could lead to reentrancy attacks.

2. PlatformFee over 10000 causing underflow: since Solidity 0.8.x reverts on underflow, if platformFee is set over 10000, the calculation (balanceOfVault * platformFee) would be multiplied by a number over 10000, leading to a higher value than balanceOfVault * 10000. Then platformShare = (balance * platformFee) / 10000. If platformFee is 10001, then (balance * 10001)/10000 would be balance * 1.0001, which could be larger than balance. Then splitterShare = balance - platformShare would underflow. But in Solidity 0.8.x, this would revert. So setting platformFee over 10000 would cause sendToSplitter to revert. Therefore, the setPlatformFee function should have a require(_platformFee <= 10000). Without it, the owner can set a fee that bricks the contract.

3. Missing zero address check in setPlatformFeeRecipient: allows the platform fee recipient to be set to address(0), making the transfer to platformFeeRecipient fail, thus reverting sendToSplitter. This would lock all funds in the vault until the recipient is updated.

4. ERC20 compatibility: using transfer that requires a boolean return, which may not be supported by all ERC20 tokens. For example, USDT on Ethereum doesn't return a boolean, so the transfer call would revert. This would make the contract incompatible with such tokens.

Other possible issues:

- The sendToSplitter function can be called by anyone. If that's intended, maybe not a vulnerability. But if it's supposed to be restricted, that's a problem. However, the function is marked as external override, so it's designed to be called by anyone. For example, maybe it's intended that anyone can trigger the distribution.

- The contract's inheritance from VaultStorage may expose storage variables if not properly secured. Since VaultStorage is not shown, there might be variables that are public or not properly access-controlled.

- The contract uses Ownable but doesn't initialize it. If the VaultStorage or this contract's constructor doesn't properly initialize the owner, that's a problem. But assuming the constructor correctly initializes Ownable, that's okay.

So summarizing the vulnerabilities:

1. **Reentrancy in sendToSplitter**: The function makes an external call to splitterProxy after transferring tokens but before completing all state changes (transferring platform fees). A malicious splitter could re-enter the function, leading to multiple transfers.

2. **Unchecked Platform Fee**: The setPlatformFee function allows setting a fee over 10000 (100%), leading to underflow in sendToSplitter when calculating splitterShare, causing the transaction to revert and potentially locking funds.

3. **Unchecked Platform Fee Recipient**: The setPlatformFeeRecipient function does not check for address(0), allowing the owner to set an invalid recipient, causing transfers to fail and fees to be locked.

4. **ERC20 Compatibility Issues**: Using transfer that expects a boolean return value may not work with non-compliant ERC20 tokens (e.g., USDT), leading to failed transfers.

5. **Insufficient Validation of splitterProxy**: Although the function checks splitterProxy != address(0), there's no validation that splitterProxy is a valid contract implementing ISplitter, which could lead to errors when calling incrementWindow.

6. **Lack of Event Emission on Critical Changes**: While the setPlatformFee and setPlatformFeeRecipient functions emit events, other critical changes (like setting splitterProxy) may not emit events if handled in VaultStorage, reducing transparency.

But wait, the code provided doesn't show the splitterProxy setter. Since VaultStorage is imported, maybe the splitterProxy is set in VaultStorage with proper access control and events? Since it's not shown, we can't assume. But in the given code, there's no function to set splitterProxy. Therefore, if splitterProxy is set in VaultStorage without proper access control (e.g., public function), that's a vulnerability. However, since the current contract inherits Ownable, perhaps the splitterProxy is set via an onlyOwner function in VaultStorage. But since we don't have that code, we can't confirm. Therefore, the vulnerability analysis here must rely only on the provided code.

Another point: the sendToSplitter function uses the balance of the vault at the time of the call. If the vault receives tokens during the transaction (e.g., someone sends tokens after the initial balance check but before the transfers), those tokens would be processed. But that's not a vulnerability, just how the function works.

Another possible issue: the incrementWindow function is called with splitterShare, which is the amount sent to splitterProxy. However, if the splitter's incrementWindow expects the total amount that should be split among recipients, but splitterShare is already after deducting the platform fee, maybe that's correct. It depends on the ISplitter interface's requirements. If the splitter is supposed to handle the entire amount, but here only a portion is sent, that could be an integration issue. But since the code calls incrementWindow with splitterShare, that's probably correct if the splitter is designed to handle that.

So, considering all this, the main vulnerabilities in the provided code are:

1. Reentrancy in sendToSplitter via splitterProxy's incrementWindow.
2. Unchecked platform fee leading to possible underflow.
3. Missing zero address check for platform fee recipient.
4. ERC20 transfer compatibility issues.","1. Unchecked Platform Fee Upper Bound  
2. Centralization Risks  
3. Incompatibility with Non-Compliant ERC20 Tokens","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Unchecked Platform Fee Upper Bound** appears at rank 2.
   - **Centralization Risks** appears at rank 7.
   - **Incompatibility with Non-Compliant ERC20 Tokens** appears at rank 4.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - At rank 4: \( P@4 = \frac{2}{4} = 0.5 \)
   - At rank 7: \( P@7 = \frac{3}{7} \approx 0.4286 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.5 + 0.5 + 0.4286}{3} \approx \frac{1.4286}{3} \approx 0.4762
   \]

**Output**:
0.4762",0.4762
SplitFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197.0,175.0,"[M-01] DoS: Attacker May Front-Run `createSplit()` With A merkleRoot Causing Future Transactions With The Same merkleRoot to Revert
A merkleRoot may only be used once in `createSplit()` since it is used as salt to the deployment of a SplitProxy.
The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same merkleRoot but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this merkleRoot.",1.0,"pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  

  address public immutable splitter;
  address public immutable royaltyVault;

  
  

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; 
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  

  
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",893.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **MerkleRoot Collision Leading to Failed Deployments**  
   - The `CREATE2` salt for deploying `SplitProxy` is derived solely from `merkleRoot`. If two different `splitId`s use the same `merkleRoot`, the second deployment will fail due to a salt collision, even though the `splitId` is unique. This allows split IDs to be unique while causing deployment reverts due to deterministic address conflicts.

2. **Improper Initialization of Proxies**  
   - `SplitProxy` and `ProxyVault` are deployed without passing critical parameters (e.g., `merkleRoot`, `splitAsset`, `platformFee`) to their constructors. If these contracts require initialization with such data, they will be non-functional or misconfigured, as the factory does not provide them during deployment.

3. **Lack of Input Validation for `_splitAsset`**  
   - The `createSplit` functions do not validate that `_splitAsset` is a non-zero address. Passing an invalid address (e.g., `address(0)`) could lead to faulty proxy behavior.

4. **Insecure State Variable Handling**  
   - State variables (`merkleRoot`, `splitAsset`, `royaltyAsset`, etc.) are temporarily set and later deleted. While transactions are atomic, this design is error-prone and risks unintended interactions if future modifications misuse these variables.

5. **Reentrancy Risk in External Call**  
   - The call `ICoreCollection(_collectionContract).setRoyaltyVault(vault)` could expose reentrancy risks if the collection contract is malicious. However, state changes in `SplitFactory` are finalized before this call, limiting direct impact.

6. **Unrestricted Platform Fee Setting**  
   - The `setPlatformFee` function allows the owner to set arbitrary fees (e.g., 100%), posing centralization risks. This is an admin privilege concern but may be intentional.

7. **Missing Zero-Address Checks in `createSplit`**  
   - No validation ensures `_collectionContract` or `_splitAsset` are valid non-zero addresses, risking deployments to invalid contracts.

8. **Overloaded Function Ambiguity**  
   - The two overloaded `createSplit` functions have different parameters, which could lead to unexpected behavior if not carefully managed (e.g., missing access control in the version without `_collectionContract`).

9. **Dependency on External Contracts**  
   - The contract relies on external dependencies (e.g., `ICoreCollection`, `IRoyaltyVault`) without safeguards against malicious implementations or interface violations.","---

**[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Report Description**:  
The `createSplit()` function uses `merkleRoot` as a salt for deploying a `SplitProxy`. Since a `merkleRoot` can only be used once, an attacker can front-run a legitimate `createSplit()` transaction by submitting a similar transaction with a higher gas price and the same `merkleRoot`. This causes the original transaction to revert, preventing the user from using that `merkleRoot` in future transactions. This vulnerability could lead to denial-of-service (DoS) attacks, disrupting the intended functionality of the contract.

**Match in Response List**:  
Matches with the issue titled **""MerkleRoot Collision Leading to Failed Deployments""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the issue of `merkleRoot` collision causing deployment failures due to the deterministic nature of `CREATE2` salts. However, it does not explicitly address the front-running attack vector described in the issue report. While the response highlights the technical cause (salt collision), it misses the broader security implication of an attacker exploiting this behavior to cause DoS. Thus, the response is partially correct but lacks sufficient detail on the attack scenario.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation highlights that the response list partially addresses the issue but does not fully capture the security implications of the front-running attack. Additional details on the attack vector and its impact would improve the response's accuracy and sufficiency.",0,1,0,9,"Okay, let's take a look at this smart contract and try to find all the vulnerabilities. Hmm. The contract is called SplitFactory and it's using Ownable from OpenZeppelin. That means it has an owner, and some functions might be restricted to the owner. Let's go through the code step by step.

First, looking at the state variables. There's splitter and royaltyVault which are immutable. Then merkleRoot, splitAsset, royaltyAsset, splitterProxy, platformFee, platformFeeRecipient. And a mapping called splits that maps strings to addresses. So splits are tracked by splitId.

Now, the constructor initializes splitter, royaltyVault, platformFee as 500, and platformFeeRecipient to a specific address. Platform fee is set here, but maybe that's a fixed value, but maybe it should be configurable. But since the owner can set it via setPlatformFee, maybe that's okay.

Looking at the modifiers. The onlyAvailableSplit modifier checks that the splitId hasn't been used before. So each splitId must be unique. That's important to prevent reusing the same ID which could cause overwrites or other issues.

Now, the functions. There are two createSplit functions. One takes a _collectionContract and the other doesn't. Both have the same name but different parameters. That's function overloading. Let's check if that's handled correctly. The first one checks that the caller is the owner of the collection contract. The second one doesn't have that check. Maybe that's an issue. Because if the second createSplit is called by anyone, they can create a split without owning a collection. But maybe that's intended. Wait, but the modifier onlyAvailableSplit is applied, so the splitId must not be used. But perhaps there's a way to front-run or guess splitIds. Not sure yet.

Looking at createSplitProxy, it uses a salt with keccak256(abi.encode(merkleRoot)) to deploy a new SplitProxy via CREATE2. Wait, but merkleRoot is a state variable. If multiple people call createSplit, the merkleRoot could be overwritten between different transactions. Because in createSplit, they first set merkleRoot = _merkleRoot; then call createSplitProxy. But if two transactions are in the mempool at the same time, maybe the merkleRoot is set to one value, then another transaction comes in and changes it before the first one is mined. This could lead to the wrong merkleRoot being used in the salt. That's a race condition. For example, if two transactions call createSplit with different merkleRoots, but due to ordering, the second one's merkleRoot is set first, then the first one uses the second's merkleRoot in the salt. That would be a problem. So the merkleRoot state variable is not safe here. Same with splitAsset and royaltyAsset. Those state variables are being set before creating the proxies, but in a multi-transaction scenario, they can be overwritten.

So that's a vulnerability. The use of state variables to store parameters that are used in the salt for CREATE2 could lead to different proxies being deployed with unintended salts if multiple transactions are processed in the same block. Because the state variables are shared across all instances. So if two different users call createSplit, their parameters (merkleRoot, splitAsset, etc.) are stored in the same state variables, leading to possible collisions or unintended salts.

Another issue is that in createSplitProxy, after deploying the splitProxy, it deletes merkleRoot and splitAsset. Similarly, createVaultProxy deletes splitterProxy and royaltyAsset. But since these are state variables, if another transaction is processed in the same block before these variables are deleted, the variables would still have the previous values. Wait, but in the same transaction, the variables are set, then used, then deleted. So within the same transaction, the variables are correctly handled. But if another transaction comes in that calls createSplit before the first one's deletion, the state variables could be overwritten. For example, suppose Alice calls createSplit with merkleRoot A. Then Bob calls createSplit with merkleRoot B. If Alice's transaction is processed first, merkleRoot is set to A, then Bob's transaction sets it to B. Then when Alice's transaction proceeds to createSplitProxy, it uses merkleRoot B (since Bob's transaction overwrote it), which is incorrect. Wait, no, because transactions are processed one after another. So in a single-threaded blockchain, the transactions are processed in order. So if Alice's transaction is first, during her transaction execution, she sets merkleRoot to A, then creates the proxy with salt from merkleRoot (which is A), then deletes merkleRoot. Then Bob's transaction would set merkleRoot to B, create the proxy with salt from B, etc. But if in the same block, two transactions are interleaved, but since transactions are atomic, the state changes are applied sequentially. So Alice's transaction would run to completion, including the deletion of merkleRoot, then Bob's transaction would start. But if Alice's transaction deletes merkleRoot, then when Bob's transaction starts, merkleRoot is zero. Wait, no. Let me think again.

Wait, during Alice's transaction execution:

1. merkleRoot is set to A.
2. splitProxy is created using merkleRoot (A).
3. merkleRoot is deleted (set to bytes32(0)).

Then Bob's transaction:

1. merkleRoot is set to B.
2. splitProxy is created using merkleRoot (B).
3. merkleRoot is deleted.

So within each transaction, the merkleRoot is correctly set and used. So perhaps this is safe. But the problem arises if there are multiple createSplit calls in the same transaction, but that's not possible. Each transaction is processed separately. So maybe the state variables are not an issue because each transaction is processed atomically. Wait, but the variables are set in the function, then used. However, if two different functions share these state variables, there's a problem. For example, if there's another function that also uses merkleRoot, but in this case, the createSplit functions are the only ones that set them. So as long as within the same transaction, after setting the state variables, they are used immediately, and then deleted, it's okay. Because each transaction's execution is isolated. So maybe this is not a problem. Hmm. But this design is risky because it's using state variables as temporary storage. For example, in the first createSplit function, after setting merkleRoot, splitAsset, and royaltyAsset, it calls createSplitProxy and createVaultProxy. But during that call, the createSplitProxy uses the state variables. But if there are multiple createSplit functions, maybe they all use the same state variables. But since each transaction is processed one after another, maybe it's okay. But if someone calls the two different createSplit functions in some way that shares these variables, could that be a problem?

Wait, the two createSplit functions both set merkleRoot, splitAsset, and royaltyAsset. Then call createSplitProxy, which uses merkleRoot as part of the salt. But the problem is that in between setting the state variables and actually using them, another function call could modify them. But within the same transaction, the functions are called in sequence. So for example, in the first createSplit function, after setting the state variables, createSplitProxy is called, which uses the current merkleRoot. Then createVaultProxy is called. But in between, no other code is executed that could modify those variables. Then, after createSplitProxy is done, the variables are deleted. So within the same transaction, the variables are used and then deleted. Therefore, other transactions would not interfere. So perhaps this is safe. Maybe this is a false alarm. But the problem is that this approach is using state variables as temporary parameters, which is unconventional and can be error-prone, especially if future modifications to the code don't handle them properly. But as of now, maybe there's no vulnerability here. Maybe I should check for other issues.

Looking at the SplitProxy and ProxyVault deployment. They use CREATE2 with a salt. The salt for SplitProxy is keccak256(abi.encode(merkleRoot)), and for ProxyVault it's keccak256(abi.encode(splitProxy)). But CREATE2 allows deploying to a deterministic address based on the salt. So if two different merkleRoots are used, different addresses are generated. But if the same merkleRoot is used, the same SplitProxy address is deployed. But in the code, after creating a split, the splitId is mapped to the splitProxy address. So if someone tries to reuse a splitId, the modifier prevents it. But what if someone uses the same merkleRoot but different splitId? Then the same SplitProxy address would be generated, but different splitId would map to the same address. But the modifier only checks if the splitId is already used. So if two different splitIds are used with the same merkleRoot, the splits mapping would have two entries pointing to the same splitProxy address. That's possible, but maybe not a vulnerability unless the splitProxy is supposed to be unique per splitId. But according to the code, it's allowed. However, the splitProxy is a contract that may have its own state, so having multiple splitIds pointing to the same contract might cause conflicts. For example, if two splitIds are used with the same merkleRoot, then their splits would point to the same SplitProxy instance. That would be a problem because each SplitProxy is supposed to manage a different split. So the SplitProxy's address is determined by the merkleRoot, but the splitId is just a unique identifier. Therefore, if two different splitIds are used with the same merkleRoot, they would share the same SplitProxy address. But the splits mapping would have two entries (different splitIds) pointing to the same address. That's a problem because each splitId is supposed to have its own SplitProxy. This could lead to splitIds being associated with the same contract, which may not be intended. Therefore, the salt should include the splitId to ensure that each splitId results in a unique SplitProxy address. Otherwise, different splitIds with the same merkleRoot would deploy the same contract address, leading to splitId collisions in the splits mapping.

But according to the code, the salt for SplitProxy is keccak256(abi.encode(merkleRoot)), which depends only on merkleRoot. So if two different splitIds are used with the same merkleRoot, they will generate the same SplitProxy address. However, the modifier onlyAvailableSplit checks that the splitId hasn't been used before. So when the first splitId is used, splits[_splitId] is set to the SplitProxy address. Then, if another splitId is used with the same merkleRoot, the SplitProxy address would be the same, but since the splitId is different, the splits mapping will have a new entry. However, the SplitProxy contract is deployed once, and subsequent deployments with the same salt would fail because CREATE2 would revert if the contract already exists. Wait, no. CREATE2 allows deploying a contract only once per salt. If you try to deploy again with the same salt, it will revert. So when createSplitProxy is called, if a SplitProxy has already been deployed with the same merkleRoot (same salt), then the new SplitProxy{salt: ...} would fail because the contract already exists. So that's a problem. For example, if two splitIds use the same merkleRoot, the first one deploys the SplitProxy, but the second one would fail because the CREATE2 would try to deploy the same contract again. Therefore, the code would revert on the second deployment. But the modifier onlyAvailableSplit only checks if the splitId is already in use, not whether the SplitProxy can be deployed. So in this case, the second splitId would pass the modifier (since it's a different splitId), but the deployment would fail because the contract already exists. Therefore, this is a vulnerability because the code allows splitIds that share the same merkleRoot, which would cause the CREATE2 deployment to fail. The user would get a transaction revert when trying to create a split with a splitId that's unique but uses a merkleRoot that was already used with a different splitId.

Therefore, the SplitFactory's createSplit function allows splitIds to be unique but merkleRoots to collide, leading to failed deployments. This is a vulnerability because it doesn't check if the merkleRoot has been used before, only the splitId. The fix would be to include the splitId in the salt, or track used merkleRoots. Alternatively, the salt should be derived from both the splitId and merkleRoot to ensure uniqueness. But currently, it's only using merkleRoot, leading to possible deployment failures.

Another issue: the createSplit functions set royaltyAsset = _splitAsset. But royaltyAsset is a state variable. If two createSplit functions are called in separate transactions, but during their execution, royaltyAsset could be overwritten. But again, within each transaction, royaltyAsset is set to _splitAsset, then createVaultProxy is called which uses royaltyAsset, and then royaltyAsset is deleted. So each transaction handles it properly. So maybe not an issue here.

Looking at the setPlatformFee and setPlatformFeeRecipient functions. They are onlyOwner functions, and they call into the vault contract. But the parameters are not validated except for non-zero addresses. However, the platformFee is set by the owner, but there's no upper limit check. For example, if platformFee is set to 10000 (100%), that would take all the fees, which might be a problem. But since the owner is trusted, maybe that's acceptable. But if the owner is malicious, they can set a high fee. But that's more of a trust issue rather than a vulnerability in the code.

Another possible issue is that the SplitFactory is using delete on state variables after deploying the proxies. For example, after creating the split proxy, merkleRoot and splitAsset are deleted. Similarly, after creating the vault proxy, splitterProxy and royaltyAsset are deleted. However, if the function execution reverts after setting the state variables but before the delete statements, the state variables would retain their values. But in the createSplit functions, the state variables are set at the beginning, then the createSplitProxy and createVaultProxy are called. If any of those calls fail (e.g., if the SplitProxy deployment fails), the function would revert, and the state variables would be reset to their original values (since the entire transaction is atomic). So no, because if the transaction reverts, the state changes (like setting merkleRoot) would be rolled back. Therefore, this is handled correctly. So deleting the variables is safe because even if the function fails, the state variables are reverted.

Looking at the SplitProxy and ProxyVault contracts. Are they part of the code? The SplitFactory imports SplitProxy.sol, so perhaps that's another contract. But since we don't have the code for SplitProxy and ProxyVault, we can't check for vulnerabilities there. But the question is to list vulnerabilities in the given smart contract, which is SplitFactory. So maybe issues in the interactions with those contracts.

Another thing to note: the createSplit function that takes a _collectionContract calls ICoreCollection(_collectionContract).setRoyaltyVault(vault). This is an external call to another contract. If the _collectionContract is malicious, it could cause a reentrancy attack. But since setRoyaltyVault is called after creating the vault and splitProxy, and there are no further state changes after this call, a reentrancy here would not affect the SplitFactory's state. However, if the SplitFactory had state changes after this call, reentrancy could be a problem. But in this case, the only state changes before the call are setting the splits mapping and emitting events. So maybe not a reentrancy vulnerability here. But it's generally risky to make external calls to untrusted contracts. Since the function requires that the msg.sender is the owner of the collection contract (as per ICoreCollection(_collectionContract).owner() == msg.sender), the _collectionContract is supposed to be a legitimate contract. But if the collection contract's owner is malicious and the contract's setRoyaltyVault function is malicious, it could perform a reentrancy attack. However, the SplitFactory's state changes (setting splits[_splitId], deleting variables) have already been done before the external call. So even if reentered, the splits mapping is already updated, but the createSplit function is protected by the onlyAvailableSplit modifier, which would prevent reusing the same splitId. So maybe this is not exploitable. But it's still an external call that could fail, causing the entire transaction to revert. But that's a normal behavior.

Another potential issue is that the SplitFactory's createVaultProxy function uses splitProxy as the salt for deploying ProxyVault. The salt is keccak256(abi.encode(splitProxy)), which is the address of the SplitProxy. Since each SplitProxy is unique per merkleRoot (if no collision, which we already identified as an issue), the ProxyVault's address would be deterministic based on the SplitProxy's address. But since SplitProxy addresses can collide (as discussed earlier), the ProxyVault addresses would also collide if SplitProxy addresses are the same. But again, if the SplitProxy deployment is failing due to salt reuse, then the ProxyVault wouldn't be deployed either. So the problem cascades.

Another thing: the SplitFactory's createVaultProxy function sets splitterProxy = splitProxy (the address of the SplitProxy) before deploying the ProxyVault. Then, the salt for ProxyVault is keccak256(abi.encode(splitProxy)), which is the same as splitterProxy. Then, after deployment, splitterProxy is deleted. But since splitterProxy is a state variable, if another transaction is processed in the same block, after deletion, it's reset. But within the same transaction, splitterProxy is set, used, then deleted. So no problem here.

What about the platformFee being 500? Is that 5% (assuming basis points, so 500 = 5%)? The setPlatformFee function allows the owner to set it to any value. If the fee is too high, it could be a problem, but as mentioned before, it's an admin privilege.

Another issue: the createSplit functions do not check that _splitAsset is a valid ERC20 or ERC777 token. If it's a malicious contract, it could cause issues in the SplitProxy or ProxyVault. But that's an input validation issue. The function doesn't check if _splitAsset is a zero address, but in the createSplit functions, they set splitAsset = _splitAsset. Then, createSplitProxy uses splitAsset (but in the code shown, createSplitProxy doesn't use splitAsset except for creating the salt? Wait, no. Looking at the createSplitProxy function:

function createSplitProxy(string memory _splitId) private returns (address splitProxy) {
    splitProxy = address(
        new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );
    splits[_splitId] = splitProxy;
    emit SplitCreated(splitProxy, _splitId);
    delete merkleRoot;
    delete splitAsset;
}

So the SplitProxy is created with salt based on merkleRoot, but the SplitProxy's constructor parameters are not shown here. Wait, maybe the SplitProxy's constructor requires the splitAsset. If the SplitProxy's code is expecting to receive splitAsset as a parameter, but the code here is not passing it, that's a problem. Wait, the code for SplitProxy is not provided here, but in the code given, the SplitFactory creates a new SplitProxy with no arguments. But in the SplitFactory's createSplit functions, they set splitAsset to _splitAsset, which is passed as a parameter. But if the SplitProxy's constructor requires splitAsset, but here it's not provided, then the SplitProxy would not have the correct asset. But since we don't have the code for SplitProxy, it's hard to say. However, in the SplitFactory code, after creating the SplitProxy, they create a VaultProxy (ProxyVault), and then set the royalty vault for the collection contract.

Assuming that the SplitProxy is initialized with splitAsset and merkleRoot, but the code here doesn't pass those parameters, then that's a problem. Because when deploying the SplitProxy via new SplitProxy{salt: ...}(), there are no arguments passed. Therefore, the SplitProxy's constructor might not be properly initialized, leading to incorrect behavior. But since the SplitProxy code is not given, this is speculative. However, this could be a vulnerability if the SplitProxy relies on initializing with certain parameters that are not set here. The same applies to ProxyVault.

But according to the code in SplitFactory, the SplitProxy is created without any parameters. If the SplitProxy's constructor requires parameters (like merkleRoot, splitAsset, etc.), then this deployment would fail or initialize the proxy with incorrect data. Therefore, this is a critical vulnerability because the proxies are not initialized with the necessary data. The SplitFactory is supposed to set up these proxies with the correct parameters, but if the constructor doesn't receive them, then the proxies will not function correctly. For example, the SplitProxy may need to know the merkleRoot and splitAsset to distribute funds, but if they are not set during deployment, the proxy would be non-functional.

Therefore, the code as written may not properly initialize the SplitProxy and ProxyVault contracts with the required parameters. The SplitFactory sets state variables (merkleRoot, splitAsset) and then uses them in the salt, but the actual SplitProxy contract may not have access to these variables unless they are passed during deployment. Therefore, this is a major vulnerability where the SplitProxy and ProxyVault are not initialized with the necessary data, rendering them unable to perform their intended functions.

Another possible issue is that the SplitFactory's createVaultProxy function deploys a ProxyVault, but does not initialize it with any parameters. The ProxyVault may require parameters such as the splitter address, royaltyAsset, platformFee, etc. If these are not passed during deployment, the ProxyVault would not be set up correctly. For example, the code in createVaultProxy does not pass any parameters to the ProxyVault constructor. Therefore, the ProxyVault may not have the necessary information to function, leading to failed transactions when trying to interact with it.

In summary, the main vulnerabilities found are:

1. **MerkleRoot Collision Leading to Failed Deployments**: The CREATE2 salt for SplitProxy is based solely on merkleRoot, allowing different splitIds with the same merkleRoot to cause deployment failures due to existing contract addresses. This is because the salt is not unique across different splitIds, only based on merkleRoot.

2. **Improper Initialization of Proxies**: The SplitProxy and ProxyVault contracts are deployed without passing necessary constructor parameters (like merkleRoot, splitAsset, platformFee, etc.), leading to potential misconfiguration or non-functional proxies. This assumes that the proxies require these parameters to be initialized correctly.

3. **Lack of Input Validation**: The createSplit functions do not validate that _splitAsset is a valid non-zero address, potentially allowing deployments with invalid assets.

4. **Insecure State Variable Handling**: The use of state variables (merkleRoot, splitAsset, etc.) as temporary storage during deployment could lead to issues if multiple functions interact with them in unintended ways. However, within the current code's transaction flow, this may not be a vulnerability, but it's a risky design pattern.

5. **Reentrancy Risk in External Call**: The call to ICoreCollection(_collectionContract).setRoyaltyVault(vault) could be a reentrancy vector, but the state changes in SplitFactory are completed before this call, so reentrancy may not affect the SplitFactory. However, this depends on the implementation of the external contract.

6. **Unrestricted Platform Fee Setting**: The owner can set any platform fee, including 100%, which could be a centralization risk, but since it's an admin function, this may be by design.

7. **Splitter and Royalty Vault Immutability**: The splitter and royaltyVault addresses are immutable, which could be problematic if upgrades or changes are needed. But this is a design choice rather than a vulnerability.

The most critical vulnerabilities are the first two: MerkleRoot collision leading to failed deployments and improper initialization of proxies.","```
None.
```",0.0,0
,,,,,,,,9,2,,,4,3,4,40,,,,1.8092