nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
NameWrapper.sol,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",7024.0,963.0,"[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.
  [H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy
By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.
When a parent node tries to `setSubnodeOwner / setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.   [H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.
However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking the function `wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   [M-01] wrapETH2LD permissioning is over-extended
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token.   [M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry
There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.",5.0,"pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    

    

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        
        registrar.transferFrom(registrant, address(this), tokenId);

        
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        
        
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        
        
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",4828.0,3,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Fuse Validation Constraint**:
   - **Location**: `_canFusesBeBurned` function.
   - **Issue**: The function enforces that any fuses other than `PARENT_CANNOT_CONTROL` require both `PARENT_CANNOT_CONTROL` and `CANNOT_UNWRAP` to be set. This overly restrictive check prevents valid use cases where other fuses should be settable without these two flags, leading to incorrect fuse configurations.

2. **Reentrancy Risk in `renew` Function**:
   - **Location**: `renew` function.
   - **Issue**: The external call to `registrar.renew()` is made before updating the contract's state (expiry). If the `registrar` contract is malicious or compromised, a reentrancy attack could exploit inconsistent state during the callback, though risk is mitigated if the registrar is trusted.

3. **Incorrect Expiry Handling in `setChildFuses`**:
   - **Location**: `setChildFuses` function.
   - **Issue**: When updating a child node's expiry, the maximum allowable expiry is derived from the parent's expiry. However, if the parent's expiry is reduced after a child's expiry was previously set higher, the child's expiry isn't automatically adjusted, potentially allowing expiry beyond the parent's valid period until explicitly updated.

4. **Insufficient Event Emission for Critical Operations**:
   - **Location**: `setMetadataService` and `setUpgradeContract` functions.
   - **Issue**: Changes to critical contract parameters (metadata service, upgrade contract) do not emit events, reducing transparency and making off-chain tracking difficult.

5. **Potential Authorization Bypass via Parent-Controlled Fuses**:
   - **Location**: `setChildFuses` function.
   - **Issue**: If a parent node is compromised, an attacker could set fuses on child nodes before `PARENT_CANNOT_CONTROL` is applied, though the modifier checks prevent this once the fuse is set.

6. **Unchecked `registrar` and `ens` Trust Assumptions**:
   - **Issue**: The contract assumes `registrar` and `ens` are trusted immutable contracts. If these are compromised (e.g., via delegatecall or admin keys), the wrapper's security is inherently breached, though this is an external risk.

These vulnerabilities primarily revolve around incorrect access controls, reentrancy risks, and improper validation of fuse combinations.","### **Comparison and Evaluation**

---

#### **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Report Description**:  
Due to a reentrancy vulnerability in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), an attacker can exploit the `onERC1155Received` callback to perform actions between the token transfer and the setting of the new owner and fuses. This allows the creation of a fake ERC1155 NameWrapper token for a subdomain that is not owned by the NameWrapper, violating the intended ownership and fuse guarantees.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific reentrancy vulnerability in `_transferAndBurnFuses` or the creation of fake ERC1155 tokens. This issue is entirely missed in the response list.

---

#### **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Report Description**:  
By design, the child node's expiry should not exceed the parent's current expiry. However, the current implementation does not enforce this constraint when the parent's expiry is reduced after a child's expiry has been set higher. This violates the guarantee policy, as users may incorrectly assume that the child's expiry is valid based on the parent's expiry.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Expiry Handling in `setChildFuses`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with incorrect expiry handling in `setChildFuses`. It correctly explains the risk of a child's expiry exceeding the parent's expiry, which aligns with the reported issue.

---

#### **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Report Description**:  
If a parent node is maliciously unwrapped, an attacker can bypass the `PARENT_CANNOT_CONTROL` fuse by re-setting themselves as the ENS owner of the subdomain and re-invoking the `wrap` function. This allows the attacker to rewrite the fuses and wrapper owner of the subdomain, violating the intended access control.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific bypass of `PARENT_CANNOT_CONTROL` through malicious unwrapping of the parent node. This issue is entirely missed in the response list.

---

#### **[M-01] `wrapETH2LD` permissioning is over-extended**

**Report Description**:  
The `wrapETH2LD` function allows `msg.senders` who are not the owner to call it if they are either approved for all on the ERC721 registrar or approved on the wrapper. This over-extended permissioning could lead to unintended actions by non-owners, especially if the approval mechanism is misused.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the over-extended permissioning in `wrapETH2LD`. This issue is entirely missed in the response list.

---

#### **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Report Description**:  
If only the `PARENT_CANNOT_CONTROL` fuse is burnt (without `CANNOT_UNWRAP`), the subdomain can be unwrapped by its owner and then wrapped again. This clears the `PARENT_CANNOT_CONTROL` fuse, allowing the parent to bypass the control limitation before the expiry.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Fuse Validation Constraint""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with incorrect fuse validation but does not explicitly mention the specific bypass of `PARENT_CANNOT_CONTROL` through unwrapping and rewrapping. The core issue is partially addressed but lacks critical details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Partially Correct Matches**:

- **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Missed Issues from Issue Report**:

- **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**
- **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**
- **[M-01] `wrapETH2LD` permissioning is over-extended**

---

### **Conclusion**

The response list covers some issues but misses critical vulnerabilities, particularly those related to reentrancy, permissioning, and access control bypasses. Improvements are needed to ensure comprehensive coverage of all identified risks.",1,1,3,6,"Okay, let's take a look at this smart contract and try to identify any vulnerabilities. The contract is called NameWrapper and it's an ERC1155Fuse token, which I think is part of the ENS system. Let me go through the code step by step.

First, the contract imports several other contracts, including ERC1155Fuse, Controllable, and some interfaces. It also uses OpenZeppelin's Ownable and IERC721Receiver. The constructor initializes some nodes and sets up data for ETH_NODE and ROOT_NODE. There's a names mapping that stores bytes for each node.

Looking at the functions, there's a wrapETH2LD function that transfers a token from the registrar to this contract. It checks if the caller is authorized, then transfers the token. Wait, but when transferring, it uses transferFrom. If the contract is approved, that's okay. But I need to check for reentrancy here. The function calls _wrapETH2LD after transferring. Let me check if there's any external call in between that could allow reentrancy. The registrar.transferFrom is an external call, so maybe there's a reentrancy risk here. But since it's using OpenZeppelin's ERC721, which is supposed to be safe, maybe not. Hmm, but the transferFrom is called before the internal state changes. If the registrar's transferFrom calls back into this contract, maybe it could do something unexpected. But the state changes (like setting the name) happen after. So maybe a reentrancy vulnerability here? Not sure yet.

Next, the registerAndWrapETH2LD function is marked as onlyController. That seems okay, but the access control for controllers should be checked. Are there functions to add/remove controllers? The contract inherits Controllable, which I assume has functions to manage controllers. If there's a way for unauthorized users to become controllers, that's a problem, but I don't see that here.

Looking at the renew function, it calls registrar.renew, which might be external. Again, check for reentrancy. But the function updates the expiry after the external call. That's a possible issue. Since the external call is made before updating the state, an attacker could re-enter and manipulate the state. For example, if renew calls back into the contract, maybe they could exploit some state inconsistency. That's a possible vulnerability.

The wrap function allows wrapping a name by setting the ENS owner to the contract. It checks if the caller is the owner or approved. Then, if resolver is not zero, it sets the resolver. But after that, it calls _wrap. But during wrapping, the ENS owner is set to this contract. However, if the original owner was a contract that could react to the transfer, maybe that's an issue, but not sure.

Looking at the unwrap functions, they call _unwrap which does a burn and transfers ownership. If during the burn, there's an external call, that could be a problem. The _unwrap function calls ens.setOwner, which is an external call. So after burning the token, it changes the ENS owner. If the newOwner is a malicious contract, could that re-enter? But burning happens first, so the token is already burned. Maybe not a problem here.

The setFuses function allows setting fuses, but checks if the caller is the owner. However, the check for fuses & PARENT_CANNOT_CONTROL != 0 is done. Wait, the code says if (fuses & PARENT_CANNOT_CONTROL != 0) { revert Unauthorised... }. Wait, the comment says ""Cannot burn PARENT_CANNOT_CONTROL"" but the code checks if the new fuses include PARENT_CANNOT_CONTROL. But the function allows setting fuses, which can include this bit. Wait, maybe this is a logical error. The parent cannot control the fuses, so if the parent tries to set fuses that include PARENT_CANNOT_CONTROL, they shouldn't be allowed. But in the code, if the user tries to set fuses with PARENT_CANNOT_CONTROL, it reverts. But according to the comment, the parent can't control that. But the function is only callable by the token owner. So maybe this is an incorrect check. For example, the owner shouldn't be able to set PARENT_CANNOT_CONTROL. But the code here reverts if the fuses include PARENT_CANNOT_CONTROL. But when setting fuses, you can OR with existing fuses. So if the existing fuses already have PARENT_CANNOT_CONTROL, then adding more fuses would still include it. The check here might be incorrect. Let me see the code again: if (fuses & PARENT_CANNOT_CONTROL != 0) { revert... }, but the function is supposed to let the owner set fuses. If PARENT_CANNOT_CONTROL is set, then the parent can't control the subdomain. But the owner shouldn't be allowed to set that fuse. Wait, but in the code, when a parent sets fuses on a child, there's a check in setChildFuses. Maybe this check in setFuses is incorrect. For example, the owner of a node shouldn't be able to set the PARENT_CANNOT_CONTROL fuse because that's supposed to be controlled by the parent. So this is a possible vulnerability: allowing the token owner to set the PARENT_CANNOT_CONTROL fuse, which should only be set by the parent.

Another possible issue is in the _canFusesBeBurned function. It checks if the fuses have bits other than PARENT_CANNOT_CONTROL, and if so, it requires that both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP are set. Wait, the code says: if (fuses & ~PARENT_CANNOT_CONTROL != 0 && fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) != (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)), then revert. So if any fuses are set except PARENT_CANNOT_CONTROL, then both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP must be set. But why? Maybe this is a check to ensure that if any other fuses are set, the node can't be unwrapped and the parent can't control it. But if this check is incorrect, it could allow setting fuses that shouldn't be allowed.

Looking at the onERC721Received function, it decodes data from the calldata. If someone sends malformed data, could that cause issues? The function uses abi.decode, which will revert if the data doesn't match the expected types. So maybe not an issue here.

In the _wrap function, the names mapping is set with the name. If the name is too long or not properly validated, could that cause issues? The _addLabel function checks the length of the label. It reverts if the label is too short or too long. So that's handled.

Another thing to check is the use of the onlyTokenOwner modifier. For example, in setFuses, the modifier ensures the caller is the token owner or approved. But when setting fuses that affect parent control, maybe the parent should have some checks. But according to the code logic, the parent's permissions are handled elsewhere.

Looking at the upgrade functions (upgradeETH2LD and upgrade), they call _prepareUpgrade which burns the token and then calls the upgradeContract. But if the upgradeContract is malicious, it could perform unexpected actions. However, the upgradeContract is set by the owner, so if the owner sets a malicious contract, that's a problem. But that's an admin privilege issue, not a vulnerability in the code itself unless there's a way for an attacker to change the upgradeContract.

In the setChildFuses function, there's a check whether the parentNode is ETH_NODE. If so, it checks if the caller is the token owner or approved. Otherwise, it checks the parent's owner. But is there a way to set fuses on a child node without proper authorization? For example, if a user is the owner of a parent node, can they set fuses on a child even if the child's fuses should prevent that? The code checks if the parent's owner is the caller. But if the child has PARENT_CANNOT_CONTROL, then the parent shouldn't be able to set fuses. However, in setChildFuses, there's a check: if oldFuses & PARENT_CANNOT_CONTROL !=0 and the new fuses add more bits, then revert. So that's handled. So the parent can't change fuses if the child has PARENT_CANNOT_CONTROL set.

Another possible issue is in the _normaliseExpiry function. It takes the minimum of expiry and maxExpiry, but if maxExpiry is less than oldExpiry, it could lower the expiry. Wait, no: the code says if expiry > maxExpiry, set it to maxExpiry. Then, if expiry < oldExpiry, set it to oldExpiry. So it ensures expiry doesn't exceed maxExpiry and doesn't decrease below the oldExpiry. That seems correct.

What about the use of ERC1155Fuse? If the parent contract has any vulnerabilities. For example, in the _setData function, does it properly handle access control? The _setData in this contract calls super._setData, which is from ERC1155Fuse. But in this contract, _setData is overridden to include _canFusesBeBurned. So the checks are added here.

Reentrancy is a common issue. Let's check functions that make external calls. For example, in wrapETH2LD, after transferring the token, it calls _wrapETH2LD. But the transferFrom is done before any state changes in this contract. Wait, the token is transferred to this contract, then reclaim is called. Then _wrapETH2LD is called. The state changes (like setting names, minting tokens) happen after the external calls. So if the transferFrom or reclaim functions call back into the contract, could that cause issues? For example, during the transferFrom, if the registrar's ERC721 does a callback, like onERC721Received, which is handled by this contract's onERC721Received function. But in the case of wrapETH2LD, the token is being transferred to this contract, so the onERC721Received would be called. However, the onERC721Received function in this contract decodes data and performs actions. But when wrapETH2LD is called, the data is not passed through the onERC721Received. Wait, the wrapETH2LD is a normal function call, not an ERC721 transfer. So the onERC721Received would only be triggered if someone transfers a token to this contract via safeTransferFrom. So in the wrapETH2LD function, the transferFrom is initiated by this contract, so the onERC721Received is not called here. So maybe there's no reentrancy in this path.

However, in the onERC721Received function itself, when a token is received, it decodes data and calls _wrapETH2LD. But during that process, are there any external calls that could be re-entered? The function sets ens.owner, which is an external call. But ENS is a well-known contract, so maybe not an issue. But if the resolver is set to a malicious contract, that could be a problem elsewhere, but not here.

Another possible issue is in the setRecord function, which allows setting the resolver and TTL. If the owner has the CANNOT_SET_RESOLVER or CANNOT_SET_TTL fuse burned, then this function should revert. The modifiers operationAllowed check for these fuses. So if the fuses are set, the function can't be called. That seems correct.

What about front-running? For example, when setting the metadata service or upgrade contract, since these are onlyOwner functions, if the owner is compromised, that's a problem. But that's an admin risk, not a code vulnerability.

Check for integer overflows. The expiry is a uint64, and the code uses SafeMath or Solidity 0.8's built-in checks. Since the contract uses ^0.8.4, overflows are handled automatically.

Another possible issue is in the _wrapETH2LD function, which sets the resolver if it's not zero. But if the resolver is a malicious contract, that's a separate issue, but the contract allows the caller to set it. So that's a user responsibility.

What about the getFuses function? If the node doesn't exist, it reverts with NameNotFound. But the function is public, so if called with a non-existent node, it could revert. That's expected behavior.

In the setSubnodeOwner function, when creating a new subnode, it checks if the parent can create subdomains (CANNOT_CREATE_SUBDOMAIN fuse). But if the parent has that fuse burned, it reverts. That's correct.

Another thing to check is the use of abi.encodePacked in _makeNode. For example, _makeNode(parentNode, labelhash) uses keccak256(abi.encodePacked(parentNode, labelhash)). This is correct because ENS nodes are constructed by concatenating the parent node and the labelhash.

Wait, the ENS node for a subdomain is keccak256(parentNode || labelhash), right? So that's correct.

But in Solidity, abi.encodePacked can lead to hash collisions if there are dynamic types, but here both are bytes32, so it's safe.

Now, considering all the above points, the possible vulnerabilities I can think of are:

1. Reentrancy in renew function: The renew function makes an external call to registrar.renew before updating the expiry. If registrar.renew calls back into the contract, the state may not be updated yet, leading to inconsistencies. For example, during renew, if the expiry is updated after the external call, an attacker could manipulate the state during the callback.

2. Incorrect fuse permission in setFuses: The setFuses function reverts if the new fuses include PARENT_CANNOT_CONTROL. However, this fuse should only be set by the parent, not the token owner. The check here may be incorrect, allowing the token owner to set this fuse, which they shouldn't be allowed to do. For example, if a user is the owner of a node, they could set PARENT_CANNOT_CONTROL, which would prevent the parent from controlling it, but according to the logic, only the parent should be able to set that fuse.

3. Lack of event emission after critical operations: For example, when the metadata service or upgrade contract is changed, events should be emitted for transparency. However, the code does emit events like FusesSet, NameWrapped, etc. But for admin functions like setMetadataService or setUpgradeContract, there are no events. While not a vulnerability per se, it's a best practice to emit events for such changes. However, the question is about vulnerabilities, so this might not count.

4. Possible authorization bypass in canCallSetSubnodeOwner modifier: The modifier checks if the subnode exists. If it doesn't, it checks if the parent can create subdomains. If it does exist, it checks if the subnode has PARENT_CANNOT_CONTROL. But is there a scenario where a parent can still modify a subnode even if they shouldn't? For example, if the subnode's fuses allow the parent to set the subnode owner even when they shouldn't. But the code seems to handle that.

5. Use of tx.origin: Not in this contract, so that's not an issue.

6. Incorrect expiry handling: The _normaliseExpiry function could potentially allow extending beyond the maxExpiry, but the code caps it correctly. So no issue there.

The main vulnerabilities I can spot are the possible reentrancy in renew and the incorrect fuse permission in setFuses.

Another thing to check: In the _wrap function, when a node is wrapped, it mints a new token. If the node was previously wrapped and unwrapped, does it correctly handle re-wrapping? The _mint function checks if there's an existing owner and burns it before minting again. That seems okay.

Also, in the setSubnodeRecord function, when setting a subnode record, if the subnode already exists and is owned by the contract, it calls _transferAndBurnFuses. But if the caller is the parent owner, they can modify the subnode even if the subnode's fuses should prevent it. Wait, no: the canCallSetSubnodeOwner modifier checks if the subnode's fuses have PARENT_CANNOT_CONTROL. If they do, then the parent can't control it, and the modifier would revert. So that's handled.

So, the key vulnerabilities are:

- Reentrancy in renew due to external call before state update.
- Incorrect permission in setFuses allowing token owner to set PARENT_CANNOT_CONTROL.

Are there others?

Wait, the renew function calls registrar.renew, which returns the new expiry. Then, it computes the normalized expiry. Then sets the data. But during the call to registrar.renew, if that function is malicious (but the registrar is supposed to be a trusted contract), then maybe it's not an issue. However, if the registrar is upgradable, and someone changes it to a malicious contract, that could be a problem. But the registrar is set as immutable in the constructor, so it can't be changed. Therefore, if the registrar is a trusted contract, then the renew function is safe. Therefore, the reentrancy risk might be mitigated if the registrar is trusted.

So maybe the reentrancy is not a vulnerability here, assuming the registrar is a trusted contract.

Then, the main vulnerability is the setFuses function allowing the token owner to set PARENT_CANNOT_CONTROL, which should only be settable by the parent.

Looking at the code in setFuses:

function setFuses(bytes32 node, uint32 fuses)
    public
    onlyTokenOwner(node)
    operationAllowed(node, CANNOT_BURN_FUSES)
    returns (uint32)
{
    if (fuses & PARENT_CANNOT_CONTROL != 0) {
        revert Unauthorised(node, msg.sender);
    }

    (address owner, uint32 oldFuses, uint64 expiry) = getData(uint256(node));

    fuses |= oldFuses;
    _setFuses(node, owner, fuses, expiry);
    return fuses;
}

The check here is if the new fuses (not combined with old ones) include PARENT_CANNOT_CONTROL. However, the fuses parameter is OR'ed with oldFuses. So the user could pass fuses without PARENT_CANNOT_CONTROL, but since oldFuses might have it, the combined fuses could have it. However, the check is only on the new fuses parameter. Wait, the code checks if (fuses & PARENT_CANNOT_CONTROL != 0). But fuses here is the parameter passed in, not the combined fuses. So if the oldFuses already had PARENT_CANNOT_CONTROL set, then even if the user passes fuses that don't include it, the combined fuses would still have it. But the check here would not revert. However, the user is allowed to add more fuses, but cannot set PARENT_CANNOT_CONTROL if it wasn't already set.

Wait, the code is reverting if the new fuses (the parameter) include PARENT_CANNOT_CONTROL. But the old fuses might already have it. So if the old fuses have it, then the user can still call setFuses to add more fuses. But they can't set PARENT_CANNOT_CONTROL if the old fuses didn't have it. So the check is to prevent the user from adding PARENT_CANNOT_CONTROL. However, this fuse is supposed to be set by the parent, not the token owner. So this check is correct because it prevents the token owner from adding PARENT_CANNOT_CONTROL. If the old fuses already had it, then combining with new fuses is allowed. But the PARENT_CANNOT_CONTROL can only be set by the parent, not the token owner. So this check is correct. Therefore, maybe there's no vulnerability here.

Wait, but the PARENT_CANNOT_CONTROL is a fuse that once set, prevents the parent from controlling the node. Only the parent should be able to set this fuse. However, in the current code, if the old fuses already have PARENT_CANNOT_CONTROL (set by the parent), then the token owner can still add more fuses. But they can't add PARENT_CANNOT_CONTROL themselves. So the check here is correct.

Therefore, maybe the initial thought about this being a vulnerability is incorrect.

Another possible issue is in the _canFusesBeBurned function. Let's look at it again:

function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
    if (
        fuses & ~PARENT_CANNOT_CONTROL != 0 &&
        fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
        (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
    ) {
        revert OperationProhibited(node);
    }
}

This checks if any fuses other than PARENT_CANNOT_CONTROL are set, and if so, whether both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP are set. If not, it reverts. This seems to enforce that any fuse other than PARENT_CANNOT_CONTROL must have both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP set. But why? For example, if a user tries to set CANNOT_BURN_FUSES without those two, it would revert. But this might be a logical error. For example, if a parent sets a fuse on a child that is CANNOT_TRANSFER, the code would require that PARENT_CANNOT_CONTROL and CANNOT_UNWRAP are also set, which might not be intended.

Wait, the comment in the code says: ""// Cannot burn any fuses if the PARENT_CANNOT_CONTROL is not set and the CANNOT_UNWRAP is not set."" But the code actually checks that if any fuses other than PARENT_CANNOT_CONTROL are set, then both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP must be set. This seems to be a way to enforce that once any fuses are burned (other than PARENT_CANNOT_CONTROL), the node cannot be unwrapped and the parent can't control it. However, if this is not the intended behavior, this check could prevent legitimate fuse settings. For example, if a parent wants to set CANNOT_TRANSFER on a child without setting PARENT_CANNOT_CONTROL and CANNOT_UNWRAP, this check would prevent it. But according to the code's logic, this is enforced. So this might be a vulnerability if the check is incorrect and allows setting fuses that should not be allowed without the required flags. Or if it's too restrictive.

Wait, but the _canFusesBeBurned function is called when setting data. So whenever fuses are set, this check is performed. For example, when a parent sets fuses on a child via setChildFuses, this check would require that if any fuses other than PARENT_CANNOT_CONTROL are set, then both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP must be present. But this might not be intended. For instance, a parent might want to set CANNOT_CREATE_SUBDOMAIN on a child without setting PARENT_CANNOT_CONTROL. But this check would prevent that unless both fuses are set. This seems like a logic error. The intended behavior might be that certain fuses can be set without requiring PARENT_CANNOT_CONTROL and CANNOT_UNWRAP. Therefore, this check is overly restrictive and could prevent valid operations, leading to a vulnerability where valid fuse settings are impossible.

So this is a potential vulnerability where the _canFusesBeBurned function imposes incorrect constraints on fuse combinations.

Another possible issue: In the setChildFuses function, when setting fuses for a child, the expiry is normalized. However, if the parent's maxExpiry is less than the oldExpiry of the child, then the new expiry is set to the oldExpiry. But since maxExpiry is derived from the parent's expiry, if the parent's expiry is reduced, existing children's expiries are not automatically adjusted. However, when setting the child's fuses, the expiry cannot exceed the parent's maxExpiry. So that's handled during the fuse setting.

What about in the case where the parent's expiry is extended, does the child's expiry automatically extend? No, it would require the parent to update the child's expiry. But that's by design.

Another possible issue: The ETH_NODE and ROOT_NODE are initialized in the constructor with PARENT_CANNOT_CONTROL | CANNOT_UNWRAP. So these nodes cannot be unwrapped, which is correct. But what if someone tries to set fuses on them? The setFuses function would check if the caller is the owner. Since these nodes are owned by address(0), but the ERC1155 owner is set to address(0), but the ownerOf function might revert for them. Wait, in the constructor, the _setData is called for ETH_NODE and ROOT_NODE with address(0) as the owner. The ERC1155 ownerOf function would return address(0), but since the onlyTokenOwner modifier checks if the caller is the owner or approved, which is address(0), which can't call the function. Therefore, these nodes cannot have their fuses modified, which is correct.

So putting this all together, the main vulnerabilities are:

1. The _canFusesBeBurned function imposes an incorrect constraint that any non-PARENT_CANNOT_CONTROL fuses require both PARENT_CANNOT_CONTROL and CANNOT_UNWRAP to be set. This prevents valid use cases where a parent wants to set other fuses without those two, leading to a denial-of-service or incorrect fuse settings.

2. In the renew function, the external call to registrar.renew is made before updating the state (expiry). If the registrar is malicious (though it's supposed to be trusted), this could allow reentrancy attacks. However, since the registrar is set as immutable, this depends on whether the registrar is a trusted contract. If it's not, this is a vulnerability.

3. The setChildFuses function allows the parent to set fuses on a child node even if the child's fuses include PARENT_CANNOT_CONTROL. Wait, no: in setChildFuses, if oldFuses & PARENT_CANNOT_CONTROL != 0 and the new fuses add more bits, it reverts. So if the child has PARENT_CANNOT_CONTROL set, the parent can't modify the fuses. That's correct.

Therefore, the primary vulnerabilities are the incorrect fuse constraint in _canFusesBeBurned and potential reentrancy in renew (if the registrar is untrusted).

Another possible issue is that in the setSubnodeRecord and setSubnodeOwner functions, when a subnode is created, the resolver and TTL can be set by the parent, but if the parent is malicious, they could set a malicious resolver. However, this is a permission issue, not a code vulnerability. The parent is supposed to have control unless the child has PARENT_CANNOT_CONTROL.

Another thing: The onERC721Received function decodes data which is passed in by the caller. If the data is maliciously crafted, could it cause issues? For example, passing an incorrect label. The function checks that the labelhash from the data matches the tokenId. So if the label in the data doesn't hash to the tokenId, it reverts. Therefore, no issue there.

In conclusion, the main vulnerabilities are:

1. Incorrect fuse validation in _canFusesBeBurned leading to inability to set certain fuses unless PARENT_CANNOT_CONTROL and CANNOT_UNWRAP are also set.

2. Reentrancy in renew function if the registrar is untrusted and allows reentrant calls.

3. In the setFuses function, the check for PARENT_CANNOT_CONTROL is on the input fuses, not the combined fuses, which might allow setting other fuses when PARENT_CANNOT_CONTROL is already set. But since the check is for the input fuses, and if the old fuses already have PARENT_CANNOT_CONTROL, then the user can still add other fuses. However, the user shouldn't be allowed to modify fuses if PARENT_CANNOT_CONTROL is set unless they are the parent. But the onlyTokenOwner modifier allows the token owner to call setFuses. So if the token owner is not the parent, but the token has PARENT_CANNOT_CONTROL set, then the token owner can still modify other fuses. However, according to the code's logic, once PARENT_CANNOT_CONTROL is set, the parent cannot control the node, but the token owner can still set other fuses. That's by design. Therefore, maybe this is not a vulnerability.

So the confirmed vulnerabilities are:

- The _canFusesBeBurned function's incorrect fuse combination check.","```
1. Incorrect Expiry Handling in `setChildFuses`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Incorrect Expiry Handling in `setChildFuses`"".
   - This appears at rank 3 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Average the precision values for all true positives**:
   - There is only one true positive, so the AP is simply the precision at rank 3.

**Average Precision (AP)**: 0.333",0.333
ByteUtil.sol,"pragma solidity ^0.8.4;

library BytesUtils {
    /*
    * @dev Returns the keccak-256 hash of a byte range.
    * @param self The byte string to hash.
    * @param offset The position to start hashing at.
    * @param len The number of bytes to hash.
    * @return The hash of the byte range.
    */
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal.
    * @param self The first bytes to compare.
    * @param other The second bytes to compare.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal. Comparison is done per-rune,
    *      on unicode codepoints.
    * @param self The first bytes to compare.
    * @param offset The offset of self.
    * @param len    The length of self.
    * @param other The second bytes to compare.
    * @param otheroffset The offset of the other string.
    * @param otherlen    The length of the other string.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @param len The number of bytes to compare
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    /*
    * @dev Returns true if the two byte ranges are equal with offsets.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    /*
    * @dev Compares a range of 'self' to all of 'other' and returns True iff
    *      they are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    /*
    * @dev Returns the 8-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 8 bits of the string, interpreted as an integer.
    */
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    /*
    * @dev Returns the 16-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 16 bits of the string, interpreted as an integer.
    */
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    /*
    * @dev Returns the 32-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bits of the string, interpreted as an integer.
    */
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    /*
    * @dev Returns the n byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes.
    * @param len The number of bytes.
    * @return The specified 32 bytes of the string.
    */
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    /*
    * @dev Copies a substring into a new byte string.
    * @param self The byte string to copy from.
    * @param offset The offset to start copying at.
    * @param len The number of bytes to copy.
    */
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    // Maps characters from 0x30 to 0x7A to their base32 values.
    // 0xFF represents invalid characters in that range.
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    /**
     * @dev Decodes unpadded base32 data of up to one word in length.
     * @param self The data to decode.
     * @param off Offset into the string to start at.
     * @param len Number of characters to decode.
     * @return The decoded data, left aligned.
     */
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            // Multiple of 8 characters, no padding
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            // Two extra characters - 1 byte
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            // Four extra characters - 2 bytes
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            // Five extra characters - 3 bytes
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            // Seven extra characters - 4 bytes
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    /**
     * @dev Finds the first occurrence of the byte `needle` in `self`.
     * @param self The string to search
     * @param off The offset to start searching at 
     * @param len The number of bytes to search
     * @param needle The byte to search for
     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.
     */
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",2905.0,320.0,"[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters
Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than 32 characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than 32 characters where len or otherlen is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).
  [M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths
Compare will return false answer without reverting when the inputs are not valid.
  [M-08] Wrong Equals Logic
The function `equals` with offset might return true when equals without offset returns false.",3.0,"pragma solidity ^0.8.4;

library BytesUtils {
    
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    
    
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",1636.0,0,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Buffer Over-read in `compare` Function**  
   - The loop processes 32-byte chunks even when the remaining data is shorter than 32 bytes, leading to reading beyond the allocated memory of the input bytes arrays. This causes invalid memory access and incorrect comparison results.

2. **Incorrect Pointer Arithmetic in Read Functions (e.g., `readUint16`, `readUint32`, `readBytes20`)**  
   - These functions incorrectly calculate the data pointer by adding `2`, `4`, or `20` directly to the base pointer (`self`) instead of accounting for the 32-byte length prefix. This results in reading from the length field or invalid memory locations, returning corrupted data.

3. **Incorrect Masking in `memcpy` Function**  
   - The masking logic for handling remaining bytes (less than 32) copies the wrong portion of the source data. This corrupts the output in `substring` by combining the wrong bytes from the source and destination.

4. **Unchecked Bounds in `find` Function**  
   - The function does not validate that `off + len` is within the bounds of the bytes array. This allows out-of-bounds access, causing runtime errors (panic) when accessing invalid indices.

5. **Potential Base32Hex Decoding Issues in `base32HexDecodeWord`**  
   - While the function reverts on invalid characters, the handling of padding and bit-length adjustments for non-standard input lengths (e.g., `len % 8`) may not conform to Base32Hex specifications, risking incorrect decoding.

---

**Summary of Critical Issues:**  
- The `compare` function’s buffer over-read and the read functions’ incorrect pointer arithmetic are severe vulnerabilities, enabling data corruption or unexpected behavior.  
- The `memcpy` and `find` functions’ flaws can lead to runtime errors or corrupted outputs.  
- The Base32Hex decoding may produce incorrect results under specific edge cases due to improper bit-length adjustments.","### **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Report Description**:  
The `BytesUtil.compare` function incorrectly masks irrelevant characters only for strings shorter than 32 characters. For strings longer than 32 characters, the function fails to mask out irrelevant characters in the last pass of the loop (when the remainder of the string is 32 characters or less). This leads to incorrect comparisons of strings longer than 32 characters, especially when `len` or `otherlen` is smaller than the string length. Characters beyond the provided length are still accounted for in the comparison, which should not happen.

**Match in Response List**:  
Matches with the issue titled **""Buffer Over-read in `compare` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with buffer over-read in the `compare` function. It correctly explains the risks associated with processing 32-byte chunks even when the remaining data is shorter than 32 bytes, leading to invalid memory access and incorrect comparison results. This aligns with the issue described in the report.

---

### **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Report Description**:  
The `compare` function does not revert when the `offset` and `len` parameters exceed the length of the input bytes. Instead, it returns an incorrect result without reverting, which can lead to unexpected behavior and incorrect comparisons.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Bounds in `find` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unchecked bounds in the `find` function, which is similar to the problem in the `compare` function. However, the response does not explicitly address the `compare` function's failure to revert when `offset` and `len` exceed the bytes length. While the underlying issue of unchecked bounds is recognized, the specific context of the `compare` function is not fully covered.

---

### **[M-08] Wrong Equals Logic**

**Report Description**:  
The `equals` function with an offset might return `true` when the `equals` function without an offset returns `false`. This inconsistency in the logic of the `equals` function can lead to incorrect comparisons and unexpected behavior.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect logic in the `equals` function. This is a missed issue, as the response list does not cover the inconsistency in the `equals` function's behavior when an offset is applied.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Partially Correct Matches**:

- **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Missed Issues from Issue Report**:

- **[M-08] Wrong Equals Logic**",1,1,1,5,"Okay, I need to analyze this smart contract for vulnerabilities. Let me start by going through the code step by step.

First, the contract is a library called BytesUtils. It has various functions for handling byte operations, like keccak hashing, comparing bytes, reading integers from bytes, substring, base32 decoding, and finding a byte in a sequence.

Looking at the keccak function: It takes a bytes array, an offset, and a length. Then it uses assembly to compute the keccak256 hash. The require statement checks that offset + len is within the self.length. That seems okay, but maybe there's an overflow here? Wait, since Solidity 0.8, arithmetic operations are checked by default, so adding offset and len would revert on overflow. So the require statement is safe in that aspect. But maybe if someone passes very large values for offset and len that sum to a valid length but wrap around? No, because Solidity 0.8's SafeMath would prevent that. So that's probably fine.

Next, the compare function. Let's see. It compares two byte arrays. The assembly part loads the pointers by adding offset and 32. Wait, in the assembly, adding 32 to the bytes array's start because the first 32 bytes are the length. So selfptr is pointing to the data starting at offset. But when they loop, they process 32 bytes at a time. However, if the shortest length is less than 32, the mask calculation might have issues. Let's see the mask: when shortest > 32, mask is all ones. Otherwise, mask is ~(2 ** (8 * (32 - shortest + idx)) - 1). Wait, when shortest is the length of the shortest array. Wait, the loop is up to shortest, but in each iteration, they compare 32 bytes. But if the actual remaining bytes are less than 32, the mask is supposed to handle that. Hmm. Let's see an example. Suppose the shortest is 40 bytes, so two iterations (0 and 32), but 40 - 32 is 8 bytes left. Wait, no, if shortest is 40, the loop runs for idx from 0 to 32 (since idx increments by 32 each time). Wait, idx starts at 0, then 32, then 64. But since shortest is 40, the loop would run with idx=0 and idx=32. Wait, when shortest is 40, the loop condition is idx < 40. So first iteration idx=0, then 32. Next idx=64 which is >=40, so stops. So two iterations. But each iteration processes 32 bytes. Wait, but if the total bytes to compare are 40, then processing two 32-byte chunks would compare 64 bytes, which is more than the shortest. That's a problem. Because if the shortest is 40, but the code is comparing 64 bytes, which is beyond the actual data. Wait, no, the loop is for (uint idx = 0; idx < shortest; idx += 32). So when shortest is 40, the loop runs for idx=0 (0 <40) and idx=32 (32 <40), then idx=64, which is not less than 40. So total 32*2=64 bytes compared? But the actual data is only 40 bytes. Wait, that can't be right. Because each iteration compares 32 bytes, starting at selfptr + idx. Wait, no, the selfptr is initialized once as selfptr = add(self, add(offset, 32)). Then, in each iteration, after loading a and b, selfptr is increased by 32. So for the first iteration, the code is loading 32 bytes from selfptr (offset 0), then in the next iteration, from selfptr +32 (offset 32). If the shortest is 40 bytes, then the second iteration would compare the next 32 bytes, which is up to 64 bytes, but the actual data is only 40 bytes. So it's reading beyond the allocated memory for the bytes array, which is a buffer over-read. That's a critical vulnerability.

For example, if the shortest is 40, the loop will process two 32-byte chunks (total 64 bytes), but the actual data is only 40 bytes. The code would read past the end of the array, leading to incorrect comparisons and potential access to invalid memory regions, which could cause incorrect results or even crashes if the memory is unmapped. This is a buffer over-read vulnerability in the compare function.

Next, the equals function uses keccak to compare. Since keccak is properly checked with offset and len, maybe that's safe. But the compare function's over-read issue is a problem.

Looking at the read functions: readUint16, readUint32, etc. They check that idx + 2 or idx +4 is <= self.length. That's correct. For example, readUint16 at idx requires idx+2 <= length, so that's safe. But what about the assembly in readUint16: add(add(self, 2), idx). Wait, in Solidity, a bytes array is stored as a 32-byte length followed by the data. So when you do add(self, 2), you're moving the pointer 2 bytes ahead, but self is a memory pointer. Wait, no: self is a bytes memory, which is a pointer to the start of the bytes array in memory. The bytes array in memory is laid out as: 32 bytes for the length, followed by the actual bytes. So add(self, 2) would be adding 2*32 bytes to the pointer. Wait, because in Solidity, when you do pointer arithmetic, each increment is 32 bytes. Wait, no. Wait, in assembly, add(self, 2) would add 2 bytes to the pointer. But self is a memory pointer, which is a uint256 representing a memory address. So adding 2 to it would move 2 bytes. However, in the code for readUint16, the code is:

assembly {
    ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
}

Wait, add(self, 2) adds 2 to the self pointer (the start of the bytes array), then adds idx to that. Then mload that address. But the bytes data starts at self + 32 (since the first 32 bytes are the length). Wait, the code here is incorrect. Because self is the pointer to the bytes array, which points to the length. So the actual data starts at self + 32. So to access the data at position idx, you need to do add(self, 32) + idx. But the code here is add(add(self, 2), idx). So for example, if idx is 0, the code is adding self + 2 + 0, which is self +2. Then mloading that address. But self is the start of the bytes array, which has the length in the first 32 bytes. So this code is reading from self + 2 + idx, which is within the length field if idx is small. For example, if idx is 0, it's reading 32 bytes starting at self +2. But the length is stored at self. So mload(add(self, 2)) would read 32 bytes starting at self+2, which includes bytes 2-34 of the length (but the length is 32 bytes). Wait, this seems wrong. Because the data is at self +32, but this code is trying to read from self +2 + idx. That's incorrect. So the readUint16, readUint32, etc., functions are all flawed. They are reading from the wrong memory location.

For example, in readUint16, when you call readUint16(self, idx), the code is supposed to read the 2 bytes at position idx in the data. The data starts at self +32. So the correct address would be add(add(self, 32), idx). But the code has add(add(self, 2), idx), which adds 2 to the self pointer (the start of the bytes array), then adds idx. So if self is the pointer to the bytes array (which has the length at position 0), then add(self,2) points to 2 bytes into the length field. Adding idx, and then mloading that. But this is incorrect. The code should be adding 32 to self to get to the data, then adding idx. So this is a critical vulnerability where the read functions are reading from the wrong memory location, leading to incorrect data being returned.

Similarly, in readBytes32, the code is:

assembly {
    ret := mload(add(add(self, 32), idx))
}

Wait, here add(self,32) would be the start of the data (since the first 32 bytes are the length). Then add idx to that. Then mload 32 bytes from there. That's correct. So readBytes32 is correct. But readUint16, readUint32, readBytes20 are using add(add(self, 2), idx) which is wrong.

Wait, let me check:

For readUint16, the code is:

assembly {
    ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
}

So add(self, 2) moves the pointer 2 bytes forward from the start of the bytes array (which is the length). Then add idx. Then mload 32 bytes from that address, mask with 0xFFFF.

But the correct approach would be to get the data at idx, which is at self +32 (start of data) + idx. So the code should be add(add(self, 32), idx), but here it's add(add(self, 2), idx). So this is incorrect. Therefore, readUint16, readUint32, readBytes20, etc., are all reading from the wrong location. This is a major vulnerability because the functions will return incorrect values, potentially leading to security issues when these values are used in contract logic.

Next, the substring function: it creates a new bytes array of length len, then copies from the source. It uses memcpy, which has a loop for len >=32, copying 32 bytes at a time. Then handles the remaining bytes. But the memcpy function's mask calculation in the unchecked block may have an issue. Let's see:

mask = (256 ** (32 - len)) -1. Then it's using and/or operations to copy the remaining bytes. Wait, but when len is less than 32, the remaining part is len bytes. For example, if len is 10, then 32 - len is 22, so 256^22 is 2^(8*22), which is a huge number. mask is (256^(32 - len) -1). Wait, but 256^(32 - len) is equivalent to 2^(8*(32 - len)). So mask is 2^(8*(32 - len)) -1. Then not(mask) would be the mask to get the higher bits. Wait, the code says:

mask := not(sub(exp(256, sub(32, len)), 1))

Wait, no: in the memcpy function, during the unchecked block, mask is calculated as (256^(32 - len)) -1. Then:

srcpart := and(mload(src), not(mask)) // this would zero the lower bits
destpart := and(mload(dest), mask) // keep the lower bits
mstore(dest, or(destpart, srcpart)) // combine them

Wait, but when you have len remaining bytes (less than 32), the mask is (2^(8*(32 - len)) ) -1. For example, len=10, mask is (2^(8*(22)) -1), which is a mask for the lower 22 bytes. Then not(mask) would be a mask for the upper 10 bytes. So srcpart is the upper 10 bytes of the source, and destpart is the lower 22 bytes of the destination. Then combining them would write the upper 10 bytes from src to the dest, preserving the lower 22 bytes of dest. But the intention is to copy len bytes (10 in this case) from src to dest. However, the code here is taking the upper len bytes from the src (since when len=10, 32 - len=22, mask is lower 22 bytes, not(mask) is upper 10), and then combining with the lower 22 bytes of the destination. But that would copy the upper 10 bytes of the source's 32-byte word into the destination's upper 10 bytes. However, when memcpy is called for the remaining len bytes (less than 32), the src and dest pointers are pointing to the current positions. For example, if we have to copy 10 bytes, the code would read 32 bytes from src, take the upper 10 bytes (masked with not(mask)), and then write those upper 10 bytes into the destination's current 32-byte slot, but keeping the lower 22 bytes as they were. But this is incorrect. Because when you have to copy len=10 bytes, you want to copy the first 10 bytes from the src's current position, not the upper 10 bytes. Therefore, the mask is calculated incorrectly, leading to copying the wrong part of the source data into the destination. This would result in the substring function returning incorrect byte sequences. For example, if the source has bytes [0x00, 0x01, ..., 0x1F] (32 bytes), and you need to copy 10 bytes starting at position 0, the code would take the upper 10 bytes (positions 22-31) instead of the first 10. This is a vulnerability in the memcpy function's handling of the remaining bytes, leading to data corruption in the substring function.

Another issue: in the base32HexDecodeWord function, there's a loop that processes each character. The code checks that the char is between 0x30 and 0x7A. Then it uses the base32HexTable to decode the character. However, the table is a bytes constant of length 0x7B - 0x30 +1? Let's see: base32HexTable is initialized as hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F'.

Wait, the hex string starts with 00 01 02 03 04 05 06 07 08 09, then a bunch of FF (from 0x0A to 0x2F?), then 0A 0B ... up to 1F. Then more FFs, then 0A to 1F again? Not sure about the exact layout. But the code subtracts 0x30 from the char to index into the table. For example, if char is '0' (0x30), index 0. The value at index 0 is 0x00. If the char is 'A' (0x41), then index is 0x41 -0x30 = 0x11 (17 decimal). Looking at the hex string: the first 10 bytes (00-09) correspond to '0'-'9', then from 0x0A (10) to 0x2F (47), which are invalid and mapped to FF. Then starting at index 0x30 (48?), no, wait the hex string is in the code as a bytes constant. Let me parse it step by step.

The hex string starts with 00010203040506070809 which is 10 bytes (0x00 to 0x09). Then FFFFFFFFFFFFFF which is 7 bytes of 0xFF. Then 0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F: that's 32 bytes (from 0x0A to 0x1F, each byte increments). Then FFFFFFFFFFFFFFFFFFFFFF which is 12 bytes of 0xFF. Then 0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F again, 32 bytes. So the total length is 10 +7 +32 +12 +32 = 93 bytes. Wait, 10 +7 is 17, +32=49, +12=61, +32=93. So the table is 93 bytes long. The index is char -0x30. For example, '0' is 0x30, so index 0, which is 0x00. 'A' is 0x41 -0x30 = 0x11 (17), but in the table, after the first 10 bytes (indices 0-9) are 7 FFs (indices 10-16). Then at index 17 (0x11), the value is 0x0A. Then index 0x1F (31) is 0x1F. Then indices 32 (0x20) and above are more FFs. Wait, the code checks if decoded <=0x20. But the table has entries up to 0x1F (31) as valid, and others as 0xFF. But in the code, after getting decoded = table[char -0x30], it requires decoded <=0x20. Wait, 0x20 is 32. But the decoded values from the table for valid characters are 0x00-0x1F (0-31). So the check decoded <=0x20 is always true. But 0xFF is 255, which is greater than 0x20, so invalid characters (those that map to 0xFF) would fail the require. But wait, the code is:

decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
require(decoded <= 0x20);

But 0xFF is 255, so the require would fail, causing a revert. That's correct. So for invalid characters, the function reverts.

But the code allows len up to 52. Then, for each character, it does ret = (ret <<5) | decoded. Then, after processing all characters, it handles the padding based on len %8. For example, if len %8 ==0, which is a valid case. But for other remainders, like 2,4,5,7, the code adjusts the bitlen and ret. However, in the code, after the loop, the code checks len %8 and does shifting. But what if len is not a multiple that is allowed by the Base32Hex encoding? For example, Base32Hex requires that the input length be such that when multiplied by 5 bits per character, the total bits is a multiple of 8. So valid lengths are multiples of 8, 2, 4, 5, 7, etc.? Wait, no. Base32 encoding typically requires padding, but this function seems to handle different remainders. However, the code reverts if len %8 is not 0,2,4,5,7. So if someone passes len=3, the code would revert. That's correct. But does the code correctly handle the padding for different cases? For example, when len%8 ==2, the code subtracts 2 bits. But this function may not properly handle the padding, leading to incorrect decoding. However, without knowing the exact specification of the Base32Hex encoding, it's hard to say, but if the code follows the spec correctly, then it's okay. However, there's a possible vulnerability here: if the code allows invalid lengths that do not conform to the Base32Hex standard, leading to incorrect decoding. But since the code reverts on invalid remainders, maybe that's okay. Not sure if this is a vulnerability.

Another function is the find function, which searches for a byte in the given range. It loops from off to off + len. However, if off + len overflows, but since Solidity 0.8.x checks for overflows, the loop would revert if off + len exceeds uint256. But if off is larger than self.length, then the loop won't execute, and it returns max uint256. But the function's require is that the caller ensures the parameters are valid? The function doesn't check if off + len exceeds self.length. For example, if self.length is 10, and off is 8, len is 5, then off + len =13 >10. The loop would run from 8 to 13, accessing self[8] to self[12], which are out of bounds. But in Solidity, accessing self[idx] when idx >= self.length would revert. Therefore, the find function has a vulnerability where if off + len exceeds self.length, it will attempt to read beyond the array, causing a runtime error (panic). The function does not validate that off and len are within the bounds of self.length. This could lead to denial of service if the function is called with invalid parameters.

So summarizing the vulnerabilities:

1. **Buffer Over-read in Compare Function**: The loop in the compare function processes 32-byte chunks even when the remaining data is less than 32 bytes, leading to reading beyond the allocated memory for the bytes arrays. This can cause incorrect comparisons and access to invalid memory.

2. **Incorrect Pointer Arithmetic in Read Functions**: Functions like readUint16, readUint32, readBytes20 use incorrect pointer arithmetic, leading to reading data from the length field of the bytes array instead of the actual data. This results in returning incorrect values.

3. **Incorrect Masking in memcpy Function**: The memcpy function's handling of remaining bytes uses an incorrect mask, leading to copying the wrong part of the source data into the destination. This causes data corruption in the substring function.

4. **Unchecked Bounds in Find Function**: The find function does not validate that the off and len parameters are within the bounds of the bytes array, leading to out-of-bounds access and potential runtime errors.

5. **Potential Base32HexDecodeWord Padding Issues**: While not confirmed without the spec, there may be incorrect handling of padding or length checks in the base32HexDecodeWord function, possibly leading to incorrect decoding results.

These are the main vulnerabilities I can identify in the provided smart contract code.","```
1. Buffer Over-read in `compare` Function
```",1.0,1
,,,,,,,,3,5,,,2,2,4,11,,,,