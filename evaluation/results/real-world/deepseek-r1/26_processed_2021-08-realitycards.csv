nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
RCOrderbook.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    /*╔═════════════════════════════════╗
      ║          MODIFIERS              ║
      ╚═════════════════════════════════╝*/

    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    /*╔═════════════════════════════════╗
      ║         GOVERNANCE              ║
      ╚═════════════════════════════════╝*/

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    /*╔═════════════════════════════════════╗
      ║             INSERTIONS              ║
      ║ functions that add to the orderbook ║
      ╚═════════════════════════════════════╝*/

    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    /*╔═════════════════════════════════╗
      ║        HELPER FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7831.0,933.0,"[H-01] findNewOwner edgecase
In the function `findNewOwner()` of `RCOrderbook`, as loop is done which included the check `_loopCounter < maxDeletions` Afterwards, a check is done for ""(_loopCounter != maxDeletions)"" to determine if the processing is finished. If `_loopCounter == maxDeletions` then the conclusion is that it isn't finished yet.
However, there is the edgecase that the processing might just be finished at the same time as `_loopCounter == maxDeletions`.
You can see this the best if you assume `maxDeletions==1`, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.",1.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";


contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    
    
    mapping(address => Bid[]) public user;
    
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    
    mapping(address => Market) public market;
    
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    
    address[] public override closedMarkets;
    
    mapping(address => uint256) public override userClosedMarketIndex;

    
    
    IRCTreasury public override treasury;
    
    
    uint256 public override maxSearchIterations = 1000;
    
    uint256 public override maxDeletions = 70;
    
    uint256 public override cleaningLoops = 2;
    
    uint256 public override marketCloseLimit = 70;
    
    uint256 public override nonce;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    

    
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    

    
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    

    
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    
    
    
    
    
    
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        
        cleanWastePile();

        if (user[_user].length == 0) {
            
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    
    
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            
            
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            
            _price < _requiredPrice &&
            
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        
        
        
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _nextUser.prev = _user; 
        _prevUser.next = _user; 
        user[_user].push(_newBid);

        
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        
        
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; 
        _prevUser.next = _user; 

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    

    
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        
        treasury.decreaseBidRate(_user, _currUser.price);

        
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    
    
    
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    
    
    
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    
    
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; 
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        
                        uint256 _price = user[_user][_index].price;

                        
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        
                        if (_index != _lastRecord) {
                            
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        
                        _loopCounter++;
                    } else {
                        
                        
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                
                uint256 _lastRecord = user[_user].length - 1;
                
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    

    
    
    
    
    
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            
            if (index[_user][_market][_card] != 0) {
                
                return true;
            } else {
                
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    
    
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    
}",5819.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Use of `assert` for Validation**  
   - **Location**: `removeBidFromOrderbook` function  
   - **Issue**: The `assert(_user != ownerOf[_market][_card])` statement is used for input validation. `assert` is intended for internal invariants, not input checks, and will consume all gas on failure. This should be replaced with `require` to properly handle user errors and refund remaining gas.

2. **Reentrancy Risk via External Calls**  
   - **Location**: `transferCard` function (called in `_newBidInOrderbook` and `_updateBidInOrderbook`)  
   - **Issue**: External calls to `IRCMarket.transferCard` are made after updating the `ownerOf` mapping. While the linked list state is updated before the call, a malicious/malfunctioning market contract could re-enter the orderbook, potentially manipulating bids inconsistently. Though markets are ""trusted"" via `onlyMarkets`, this introduces risk if the market is compromised.

3. **Unbounded Loops with Gas Limit Risks**  
   - **Locations**:  
     - `_searchOrderbook` (bounded by `maxSearchIterations`)  
     - `findNewOwner` (bounded by `maxDeletions`)  
     - `closeMarket` (bounded by `marketCloseLimit`)  
   - **Issue**: These loops may exceed gas limits if their limits (`maxSearchIterations`, `maxDeletions`, etc.) are set too high by privileged roles (e.g., via `setSearchLimit`). This could lead to denial-of-service (DoS) scenarios.

4. **Incomplete Bid Cleanup During Foreclosures**  
   - **Location**: `removeUserFromOrderbook` function  
   - **Issue**: The loop stops after processing `maxDeletions` bids, potentially leaving residual bids in the orderbook if a user has more bids than the limit. This could leave the system in an inconsistent state.

5. **State Inconsistency During Market Closure**  
   - **Location**: `closeMarket` function  
   - **Issue**: When closing a market, bids are moved to `address(this)` (the contract itself) but not fully cleaned up. The `cleanWastePile` function may leave dangling references if interrupted, leading to potential state mismatches.

6. **Incorrect Index Handling in `bidExists`**  
   - **Location**: `bidExists` function  
   - **Issue**: The check `if (index[_user][_market][_card] != 0)` may incorrectly return `false` for valid bids stored at index `0`. The logic assumes index `0` is invalid, but it can legitimately hold a bid, causing false negatives.

7. **Lack of Input Validation in `setTimeHeldlimit`**  
   - **Location**: `setTimeHeldlimit` function  
   - **Issue**: The function does not validate `_timeHeldLimit` against reasonable bounds (e.g., maximum allowable time), potentially allowing unrealistic values if the market is compromised.

8. **Centralization Risks**  
   - **Locations**: Functions with `onlyUberOwner` (e.g., `setTreasuryAddress`, `setDeletionLimit`)  
   - **Issue**: Critical configuration parameters are controlled by a single privileged role (`UBER_OWNER`). Compromise of this role could disrupt the entire system (e.g., setting `maxDeletions` to 0 to prevent foreclosure processing).

9. **Outdated State References in `findNewOwner`**  
   - **Location**: `findNewOwner` function  
   - **Issue**: If the loop reaches `maxDeletions`, the old owner and price are stored, but the ownership transfer is not finalized. This could leave the system in an inconsistent state until another trigger resolves it.

10. **Unsafe Type Casting in Market Configuration**  
    - **Location**: `addMarket` function  
    - **Issue**: Uses `SafeCast.toUint64` for `_cardCount` and `_minIncrease` without validating if the input values fit into `uint64`. While `SafeCast` reverts on overflow, this could be a denial-of-service vector if inputs are unexpectedly large.","---

**[H-01] findNewOwner Edge Case**

**Report Description**:  
In the `findNewOwner()` function of `RCOrderbook`, a loop is executed with the condition `_loopCounter < maxDeletions`. After the loop, a check is performed to determine if processing is finished by comparing `_loopCounter` to `maxDeletions`. If `_loopCounter == maxDeletions`, the function concludes that processing is not yet finished. However, there is an edge case where processing might actually be finished at the same time as `_loopCounter == maxDeletions`. This is particularly evident if `maxDeletions == 1`, in which case the function will never conclude that processing is finished. While `maxDeletions == 1` is unlikely in practice, this edge case could lead to incorrect state handling.

**Match in Response List**:  
Matches with the issue titled **""Outdated State References in `findNewOwner`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `findNewOwner` and mentions that the loop reaching `maxDeletions` can leave the system in an inconsistent state. However, it does not explicitly address the edge case where processing might be finished at the same time as `_loopCounter == maxDeletions`. The response misses this critical detail, which is the core of the reported issue. Therefore, it is partially correct but incomplete.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-01] findNewOwner Edge Case**

**Missed Issues from Issue Report**:  
- *None*

---",0,1,0,10,"Okay, I need to find all the vulnerabilities in this smart contract. Let me start by reading through the code carefully.

First, looking at the imports. They're using SafeCast from OpenZeppelin, which is good for preventing overflow/underflow. But maybe there are other issues. The contract is called RCOrderbook and it's using NativeMetaTransaction, which relates to gasless transactions. Might want to check how that interacts with the other functions.

The struct Market has several uint64 variables. Since Solidity 0.8 is used, integer overflows are handled, but maybe there's something with the SafeCast usage. Let me check where SafeCast is used. In addMarket, they cast _cardCount and _minIncrease to uint64. If those values are larger than uint64 max, that would revert, which is safe.

There's a mapping called user which maps addresses to an array of Bid structs. Each Bid has prev and next addresses, forming a linked list. The index mapping tracks the position of a user's bid for a specific market and card. Hmm, possible issues here if the index isn't properly managed, leading to incorrect lookups.

In the addBidToOrderbook function, there's a call to cleanWastePile(). This function seems to handle some garbage collection. The modifier is onlyMarkets, which checks if the caller is authorized via the treasury. But maybe there's a reentrancy issue? Wait, the function doesn't have any external calls after cleanWastePile, so maybe not. But let me check other functions for external calls.

The _newBidInOrderbook function calls transferCard, which calls IRCMarket's transferCard. That's an external call. If the market contract is malicious or has a reentrancy vulnerability, it could call back into this contract. But since the function is protected by onlyMarkets, which should be trusted, maybe that's not a problem. But if a malicious market is added, that could be an issue.

Looking at the _searchOrderbook function, there's a loop that depends on maxSearchIterations. If the loop runs too many times, it might not find the position and revert, which could be a DoS vector. But the function checks i < maxSearchIterations and reverts if not. The max is set to 1000 by default, which could be expensive gas-wise but not a vulnerability per se.

In the _updateBidInOrderbook function, after adjusting the linked list pointers, there are calls to treasury functions. If the treasury contract's functions are state-changing and called after external transfers, there could be reentrancy. But since the transferCard is called after updating the state, maybe it's okay. Wait, transferCard is called before updating the treasury. Let me check: in _newBidInOrderbook, after adding the bid, they call transferCard, which does an external call. Then they call treasury.updateRentalRate. If the external call re-enters, the state might have been updated already. But since the linked list pointers are updated before the external call, maybe it's safe. Or maybe not. This could be a reentrancy vulnerability.

Another thing: in the removeBidFromOrderbook function, they use assert(_user != ownerOf[_market][_card]). But assert is meant for invariants and consumes all gas if failed, whereas require is for input validation. Using assert here is incorrect and could lead to gas exhaustion if triggered. That's a vulnerability.

In the closeMarket function, when moving bids to the waste pile (address(this)), there's a loop popping user[_market]. But if the market is closed and the user array is modified, maybe there's an issue with the indices. Also, they push a new Bid to user[address(this)], which is the contract itself. But address(this) is the orderbook contract. Could this lead to unintended behavior when interacting with the user mapping for the contract's own address? Maybe, but not sure yet.

The bidExists function checks if the index is non-zero or if the first element matches. But if the index is zero and the first element is a different market/card, this might incorrectly return false. Wait, the code says: if index is 0, check if the first element's market and card match. Otherwise, return true. But the index mapping is set when a bid is added. Suppose a user has a bid at index 0, which is valid, but the code would check if the first element is the same. But in that case, index would be 0, and the first element is the same. So maybe it's okay. Hmm, maybe not. Let me see: when a user adds a bid, index is set to user[_user].length -1. So the first bid would have index 0. Then, the bidExists function checks if index is non-zero. Wait, in the code: if (index[_user][_market][_card] !=0), return true. Otherwise, check if the first element matches. But if the index is 0, which is valid (like the first element), then the code checks the first element's market and card. If they don't match, returns false. But that's correct because index 0 would only be set if that's the correct position. Wait, maybe there's a problem here. For example, if a user has multiple bids, and one of them is at index 0, but for a different market and card. Then, when checking bidExists for that market and card, it would look for the index, which might be 0. Then check if the first element's market and card match. If not, returns false. That seems correct. So maybe the bidExists function is okay.

In the transferCard function, it calls IRCMarket(_market).transferCard. If the market contract is not properly implemented, this could fail, but since it's called via onlyMarkets, which are supposed to be valid, maybe not a vulnerability. But if a market contract is malicious, this could be a problem. But since markets are added via addMarket, which is called by addBidToOrderbook, which is onlyMarkets. So the markets are trusted? Or is there a way to add a malicious market? Only if the treasury allows it. So depends on the permissions in the treasury.

Another possible issue: in the removeOldBids function, there's a loop over closedMarkets. If the userClosedMarketIndex is not properly managed, it might skip some markets or process them multiple times. Also, the loop uses _loopCounter and _subLoopCounter to limit the iterations, but if the code is not handling underflows correctly, but since they're using Solidity 0.8, underflows would revert, so that's safe.

In the cleanWastePile function, they modify the user[address(this)] array. If this function is called externally, maybe someone could manipulate the waste pile. But it's an override function with only the contract itself calling it? Wait, the cleanWastePile is public and override, so anyone can call it. But it's part of the protocol's maintenance. However, an attacker could call it to trigger the cleaning, which might consume gas but not directly exploit anything. Not sure if that's a problem.

Looking at the use of SafeCast: when setting _newBid.timeHeldLimit to SafeCast.toUint64(_timeHeldLimit), if _timeHeldLimit is larger than uint64.max, it would revert. That's safe.

In the _newBidInOrderbook function, after adding the bid, if the prev is _market, it transfers the card to the new owner. But what if during this transfer, the market contract does something unexpected? Like reentrancy? For example, if transferCard calls back into the orderbook contract, modifying the bids. But since the linked list is already updated before the transfer, maybe the state is consistent. But if the reentrant call modifies the same data structures, it could cause inconsistencies. This is a potential reentrancy vulnerability.

Another point: in the setTreasuryAddress function, onlyUberOwner can change the treasury. If the uber owner is compromised, the entire contract is at risk. But that's a centralization risk, not a code vulnerability per se.

In the closeMarket function, when popping elements from user[_market], it's using a do-while loop. If the market has a large number of cards, this could exceed gas limits. But the loop is bounded by marketCloseLimit, which defaults to 70. So that's manageable, but if set to a high value by the owner, could cause DoS.

The findNewOwner function has a loop that removes bids until the new owner meets the time requirement. The loop is bounded by maxDeletions. If the loop reaches maxDeletions, it doesn't find a new owner and sets oldOwner and oldPrice. But if maxDeletions is set too low, the function might not find a valid new owner, leading to the card not being transferred. That's more of a design issue than a vulnerability.

In the removeUserFromOrderbook function, when removing a user's bids, it starts from the end and works backward. If the user has more bids than maxDeletions, it stops after maxDeletions. This could leave some bids in the orderbook, leading to inconsistencies. However, the function is called when a user is foreclosed, so perhaps it's acceptable. But if a user has many bids, this function might not remove them all, leaving stale bids.

In the transferCard function, ownerOf[_market][_card] is updated before calling the market's transferCard. If the external call fails, the state change (ownerOf) would have already happened. But since the market is supposed to be a trusted contract, maybe this is acceptable. However, if the market's transferCard can fail, this could result in an inconsistent state where ownerOf is updated but the transfer didn't happen. That's a vulnerability. For example, if transferCard reverts for some reason, the ownerOf would already be set to the new owner, but the actual transfer didn't occur. This could lead to discrepancies between the orderbook's state and the market's state.

Another issue: the use of the assert statement in removeBidFromOrderbook. As mentioned earlier, assert(_user != ownerOf[_market][_card]). If this condition fails, the transaction reverts and consumes all gas. This is different from require, which would refund remaining gas. Since ownerOf can be set by other functions, this condition could be violated, and using assert here is inappropriate. It should be a require statement.

In the addBidToOrderbook function, when adding a new bid, the code checks if the previous user's price is >= the new price. However, in the linked list structure, if the previous user's price is lower than the new price, it's possible that the new bid is inserted in the wrong position. Wait, no: the code requires that the previous user's price is >= new price. Otherwise, it reverts. But in the _newBidInOrderbook, after inserting, they call _searchOrderbook which might adjust the position. Wait, the _prevUser is passed to _searchOrderbook. Hmm, maybe there's a logic error here. Let me see:

In addBidToOrderbook, if _prevUserAddress is provided, it checks that its price is >= new price. Then, it calls _newBidInOrderbook or _updateBidInOrderbook. In _newBidInOrderbook, if the owner is not the market (i.e., there's an existing owner), it calls _searchOrderbook to find the correct position. So even if the provided _prevUserAddress has a lower price, the _searchOrderbook would find the correct position. Wait, no: in addBidToOrderbook, when the _prevUserAddress is given, the code requires that its price >= new price. Then, when adding, it uses that _prevUser. But maybe that's not the correct position. For example, if someone provides a _prevUserAddress that is not the immediate predecessor in price order, but the code allows it as long as the price is >=. Then, the _searchOrderbook function might move up the list until it finds the correct spot. Wait, no: the _searchOrderbook is called only if the current owner is not the market. Hmm, this part is a bit complex. Maybe there's a scenario where the provided _prevUserAddress is not the correct position, leading to an invalid linked list structure. For example, if the user provides a _prevUserAddress that is not in the correct order, but passes the initial check, the _searchOrderbook might correct it. But if the owner is the market, then the new bid is added as the new head. This might be okay, but could there be a way to insert a bid at an incorrect position, disrupting the order? Not sure. Maybe not a vulnerability, but a potential logic error.

Also, in the _newBidInOrderbook function, after inserting the new bid, if the new bid's prev is the market (i.e., it's the first bid), it transfers the card to the new owner. However, if the new bid's price is lower than the previous owner's price, that might not be intended. Wait, no: the _searchOrderbook ensures that the new bid's price is correctly placed. The _searchOrderbook finds the correct position by moving up until the price is sufficient. So if the new bid is placed as the first, its price must be higher than the required minimum based on the previous bid's price. So maybe that part is okay.

In the closeMarket function, when moving bids to address(this), the code pushes a new Bid with price 0. Then, when cleanWastePile is called, these bids are processed. However, if the market is closed, but there are still references to these bids in the user mapping, it could lead to inconsistencies. For example, if someone tries to interact with these old bids, but they're in the waste pile, maybe there's a way to exploit this. But since the closedMarkets are tracked and userClosedMarketIndex is used in removeOldBids, perhaps this is handled. However, if the market is reopened or something, there might be leftover state. Not sure.

Another thing: the userClosedMarketIndex mapping is used to track which closed markets a user has processed. But if a user has multiple bids in different markets, and some markets are closed, this index might not correctly track all of them. For example, if a user has bids in two closed markets, but userClosedMarketIndex[_user] is only incremented once per loop in removeOldBids, leading to some bids not being processed. This could leave old bids in the user's array, which might cause issues when accessing them later.

In the setTimeHeldlimit function, the code requires that the bid exists. However, there's no check that the _timeHeldLimit is valid. For example, setting it to a very high value. But that's up to the market's logic, so maybe not a vulnerability here.

The reduceTimeHeldLimit function subtracts _timeToReduce from the timeHeldLimit. If the timeHeldLimit is less than _timeToReduce, this will underflow. But since Solidity 0.8 is used, it will revert. So that's safe.

In the _removeBidFromOrderbookIgnoreOwner function, when deleting a bid, the code swaps the last element in the user's bid array with the one being deleted. However, if the index being deleted is not the last one, it moves the last element to the current index and updates the index mapping. This is a standard approach, but if the user's array is modified while iterating or accessing, there could be issues. However, the code properly updates the index mapping for the moved element. That should be safe.

Potential vulnerabilities identified so far:

1. Use of assert instead of require in removeBidFromOrderbook (specifically, the assert(_user != ownerOf[_market][_card])). This is a vulnerability because assert is for invariants and consumes all gas on failure, which is not appropriate here.

2. Reentrancy risk in transferCard function when making an external call. If the market contract's transferCard function re-enters the orderbook contract, it could manipulate the state in an unexpected way. However, since the market is supposed to be a trusted contract (onlyMarkets modifier), this might be considered a trusted call. But if a malicious market is added, it could exploit this. So if the market is not properly permissioned, this could be a problem.

3. In the closeMarket function, when moving bids to the waste pile (address(this)), the code sets user[_lastOwner][index[_lastOwner][_market][i]].prev to address(this). Then, when cleanWastePile processes these, it might incorrectly handle the references. However, I'm not sure if this leads to a specific exploit.

4. The transferCard function updates the ownerOf mapping before making the external call. If the external call fails or reverts, the ownerOf mapping would be incorrect. For example, if IRCMarket.transferCard throws an error, the ownerOf is already set to the new owner, but the transfer didn't happen. This is a classic external call after state change vulnerability. The state should be updated after the external call, or the external call should be made in a way that any failure rolls back the entire transaction.

5. Incorrect handling of closed markets in removeOldBids. If a user has bids in multiple closed markets, the userClosedMarketIndex might not properly track all of them, leading to leftover bids. However, the code uses a while loop to process until maxDeletions is reached. It could leave some bids unprocessed, but that's part of the design to limit gas usage.

6. In the findNewOwner function, if the loop reaches maxDeletions, the oldOwner and oldPrice are stored. But if the market is not properly handled afterward, the ownership might not be correctly transferred, leading to a stuck state.

7. The addMarket function initializes the linked list with _market as both prev and next. If the card count is zero, this could cause issues, but the code uses _cardCount from the market, which should be valid. Not sure.

8. In the closeMarket function, the loop pops user[_market].length elements, which could be expensive if the market has a large number of cards. However, it's limited by marketCloseLimit.

Prioritizing the most critical issues:

- The use of assert in removeBidFromOrderbook (issue 1) is a critical vulnerability because it can lead to gas exhaustion and is improper error handling.

- The external call in transferCard after updating state (issue 4) is a major vulnerability. If the external call fails, the state (ownerOf) is already updated, leading to inconsistencies.

- Reentrancy in transferCard (issue 2) if the market is malicious. Since the market is supposed to be authorized, but if compromised, this could allow reentrancy attacks.

Other issues may have lower severity or are design choices.

Let me check the transferCard function again. The code updates ownerOf[_market][_card] = _newOwner; then calls IRCMarket(_market).transferCard(...). If this call reverts, the entire transaction is rolled back, including the ownerOf change. Wait, no. Because in Solidity, if an external call throws an exception, the entire transaction is reverted. Unless it's using low-level calls (call, send, etc.), which here it's not. IRCMarket is an interface, so the function call is a regular external call which will propagate exceptions. So if transferCard reverts, the state changes (like ownerOf) made before the call will be reverted. Therefore, issue 4 is not a problem. Wait, in the code:

transferCard is called, which is:

IRCMarket(_market).transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);

If this call reverts, then the entire transaction reverts, so the ownerOf change (which happened before the call) is reverted as well. Therefore, the state is safe. So that's not a vulnerability. So issue 4 is invalid.

So the critical issues are:

1. Improper use of assert in removeBidFromOrderbook.

2. Potential reentrancy in functions that make external calls after state changes, but since the external calls are to trusted contracts (onlyMarkets), it's lower risk. However, if a malicious market is authorized, it could re-enter.

But the onlyMarkets modifier checks that the msgSender() is authorized by the treasury. If the treasury is compromised and allows a malicious market, then that's a problem. But that's outside the scope of this contract's vulnerabilities; it's a dependency on the treasury's permissions.

Another thing: the ownerOf mapping is updated in transferCard, but the actual transfer is done via the market contract. If the market contract doesn't correctly enforce the ownership, there could be a mismatch. But that's the market's responsibility.

Back to the assert in removeBidFromOrderbook. The line is:

assert(_user != ownerOf[_market][_card]);

But this is a require condition; using assert here is wrong. For example, if somehow the user is the owner, the transaction would consume all gas and revert. This should be a require statement with an appropriate error message.

Another potential issue: in _newBidInOrderbook, when adding a new bid, the code calls treasury.increaseBidRate(_user, _price). Then, if the new bid becomes the owner (i.e., prev is _market), it calls transferCard, which does an external call. If the treasury's increaseBidRate function is state-changing and affects the user's balance, and the external call re-enters, it could manipulate the treasury's state. For example, if the market's transferCard function calls back into the orderbook's addBidToOrderbook, modifying the user's bids and affecting the treasury's state. However, the treasury functions are called before the external call, so reentrancy after the state changes in the orderbook. But this depends on the order of operations. Since the external call is after the treasury calls, if the reentrant call modifies the same user's bids, it could interfere. This could be a reentrancy vulnerability.

Additionally, in _updateBidInOrderbook, the code adjusts the linked list pointers, then makes external calls to the treasury and transferCard. If the transferCard re-enters, it could modify the same linked list, leading to inconsistencies.

So reentrancy is a potential issue here. For example:

1. User adds a bid, which triggers a transferCard call to a malicious market.

2. The malicious market's transferCard function calls back into addBidToOrderbook.

3. During reentrancy, the linked list is modified again, leading to inconsistent state.

This is a possible reentrancy vulnerability. However, since the linked list is updated before the external call, any reentrant call would operate on the updated state. The impact depends on what the reentrant call does. For example, if it removes or adds bids, it could corrupt the linked list.

To mitigate this, the code should follow the checks-effects-interactions pattern. In this case, the code does:

- Updates the linked list (effects).

- Calls transferCard (interaction).

So the effects are done before the interaction, which is correct. However, during the interaction (external call), if reentrancy occurs, the state has already been modified. So any reentrant function would see the updated state. Whether this is a problem depends on the logic. For example, if during the transferCard call, the market calls removeBidFromOrderbook for the same user and card, it could cause issues. But since removeBidFromOrderbook is only callable by the market, which is the same as the current msgSender(), this would be allowed. However, this could lead to the removal of a bid that was just added, which might not be intended.

But this is more of a logical flaw than a vulnerability, as the market is trusted. If the market is malicious, it could manipulate the bids. But since the market is authorized by the treasury, this is a trust issue, not a code vulnerability in the orderbook itself.

Another issue: in the _newBidInOrderbook function, after adding the new bid, if it's the new owner (prev is market), it calls transferCard, which transfers ownership. Then, it calls treasury.updateRentalRate. But if the transferCard call fails, the updateRentalRate is not executed. However, since the entire transaction would revert, this isn't a problem.

In summary, the main vulnerabilities found are:

1. Use of assert instead of require in removeBidFromOrderbook, leading to gas exhaustion on failure.

2. Potential reentrancy if a malicious market contract is authorized, allowing re-entrant calls during transferCard.

3. Possible DoS in loops if limits are set too high, but since they are controlled by the owner, this is a configurable risk.

4. In the closeMarket function, when moving bids to the waste pile, if the market is not properly handled, it could leave dangling references. However, the code's logic for closedMarkets and userClosedMarketIndex may handle this.

The critical one is the use of assert where require should be used. The others depend on external factors like a compromised market or treasury, which might be outside the contract's scope.","```
None.
```",0.0,0
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        /* setup AccessControl

                         UBER_OWNER
            ┌───────────┬────┴─────┬────────────┬─────────┐
            │           │          │            │         │
          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD
            │           │
         GOVERNOR     MARKET
            │
         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE
        */
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",8609.0,920.0,"[H-02] UberOwner has too much power
The`Uber_Owner` has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code
The above functions can be used by the Uber Owner to completely change the functionality of the system. This goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.
Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.
  [M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol
The variable, `marketWhitelist`, is never initialized in the contract RCTreasury.sol. As a result, the function `marketWhitelistCheck()` does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.
The initial state variable is defined in RCTreasury.sol L75.
The state variable `marketWhitelist` is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281.
The function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.
Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.
  [M-03] Deposits don't work with fee-on transfer tokens
There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
The `deposit()` function will credit more deposits than the contract actually received:
``` erc20.safeTransferFrom(msgSender(), address(this), _amount);
user[_user].deposit += SafeCast.toUint128(_amount); ```",3.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";



contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;
 
    IRCOrderbook public override orderbook;
    
    IRCLeaderboard public override leaderboard;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    IRCFactory public override factory;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public override marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 public override marketBalanceTopup;

    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;


    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    
    mapping(address => bytes32) public marketWhitelist;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;
    
    mapping(address => bool) public override lockMarketPaused;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1_000_000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    
    modifier balancedBooks() {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

   
    
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    
    
    
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    
    
    
    
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        
        erc20.safeTransfer(msg.sender, _balance);
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        assessForeclosure(_user);
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            
            isForeclosed[_msgSender] = true;
            
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        
        return _amount;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        
        if (user[_user].lastRentCalc == 0) {
            
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                
                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    
}",5177.0,1,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Centralization Risks**:
   - The `UBER_OWNER` role has excessive privileges, including the ability to drain all funds via `globalExit()`, change the ERC20 token address (`setTokenAddress`), and modify critical system parameters. Compromise of this role could lead to total loss of funds or manipulation of contract behavior.
   - The `setBridgeAddress` function grants unlimited approval to the bridge contract, posing a risk if the bridge is compromised.

2. **Unprotected collectRentUser Function**:
   - The `collectRentUser` function is publicly callable by anyone, allowing malicious actors to forcibly trigger rent collection and foreclosure on any user. This can lead to premature foreclosures and disrupt user strategies.

3. **Incorrect Accounting in payRent**:
   - When `marketBalance` is insufficient to cover the requested rent (`_amount`), the logic for adjusting `marketBalanceTopup` may miscalculate the remaining top-up funds, potentially leading to incorrect balance tracking.

4. **Reentrancy via Malicious ERC20 Tokens**:
   - The `balancedBooks` modifier checks balances after external calls (via ERC20 transfers). If a malicious ERC20 token manipulates its `balanceOf` return value during reentrant calls, it could bypass the modifier's balance check, leading to inconsistent state.

5. **Foreclosure/Withdraw Race Condition**:
   - During `withdrawDeposit`, if a user's `bidRate` exceeds their remaining deposit after withdrawal, they are foreclosed. However, if the Orderbook fails to properly remove their bids (e.g., due to a logic error), the user might remain in the system with invalid bids.

6. **Public assessForeclosure Function**:
   - While not directly exploitable, allowing anyone to invoke `assessForeclosure` could enable unnecessary state changes and gas expenditure, though it doesn't directly compromise security.

7. **Role Management Risks**:
   - Critical roles (e.g., `OWNER`, `GOVERNOR`) are mutable via centralized functions (`setFactoryAddress`). Improper role revocation during upgrades could leave old contracts with privileged access.

8. **Market Whitelist Configuration Bypass**:
   - Markets can configure their own whitelist roles via `marketWhitelist`. If a market sets `bytes32(0)` as the required role, it bypasses whitelist checks entirely, potentially conflicting with global whitelist settings.

9. **Integer Precision Loss**:
   - Rent calculations (e.g., `rentOwedUser`) use integer division, which truncates results. Prolonged small-value transactions could lead to cumulative precision errors, though mitigated by high token decimals.

10. **Missing Event Emissions on Critical Actions**:
    - Functions like `setTokenAddress` and `setBridgeAddress` change core contract dependencies but do not emit events, reducing transparency and auditability.","### **[H-02] UberOwner has too much power**

**Report Description**:  
The `Uber_Owner` role has excessive privileges within the system, making the protocol resemble a centralized prediction market. The `Uber_Owner` can fundamentally alter the protocol's functionality, going beyond simple parameter adjustments. This poses a significant risk if the `Uber_Owner` address is compromised. The recommendation is to limit the `Uber_Owner`'s permissions and implement upgrades through a proxy contract in a standardized manner.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risks""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk posed by the `UBER_OWNER` role, including the ability to drain funds and modify critical system parameters. It aligns with the issue's description of excessive privileges and the associated risks. The response also implicitly supports the recommendation to limit such privileges, though it does not explicitly mention the use of a proxy contract.

---

### **[M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol**

**Report Description**:  
The `marketWhitelist` variable in `RCTreasury.sol` is never initialized, causing the `marketWhitelistCheck()` function to always return `true`. This bypasses any intended restrictions on whitelisted users for specific markets. The issue stems from the lack of methods to enable market creators to restrict their markets to specific roles. The recommendation is to ensure this behavior is intentional or add functionality to allow market creators to whitelist users.

**Match in Response List**:  
Matches with the issue titled **""Market Whitelist Configuration Bypass""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `marketWhitelist` configuration but focuses on the bypass risk when `bytes32(0)` is set as the required role. It does not explicitly address the uninitialized state of `marketWhitelist` or the fact that `marketWhitelistCheck()` always returns `true`. While related, the response misses critical details from the issue report.

---

### **[M-03] Deposits don't work with fee-on transfer tokens**

**Report Description**:  
The `deposit()` function does not account for fee-on-transfer or rebasing tokens, which can result in incorrect accounting. For example, fee-on-transfer tokens reduce the actual amount received by the contract, but the function credits the full `_amount` to the user's deposit. This discrepancy can lead to inconsistencies in the contract's state. The recommendation is to adjust the deposit logic to handle such tokens correctly.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer or rebasing tokens. This is a significant gap, as the issue highlights a critical vulnerability in the contract's accounting logic.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[H-02] UberOwner has too much power**

**Partially Correct Matches**:  
- **[M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol**

**Missed Issues from Issue Report**:  
- **[M-03] Deposits don't work with fee-on transfer tokens**

---

**Overall Assessment**:  
The response list covers some of the issues in the report but misses critical vulnerabilities, such as the handling of fee-on-transfer tokens. Additionally, some matches are only partially correct, as they fail to address all aspects of the reported issues. Improvements are needed to ensure comprehensive coverage of all identified vulnerabilities.",1,1,1,10,"Okay, I need to analyze this smart contract for vulnerabilities. Let's start by going through each function and the overall structure. 

First, looking at the imports. They use OpenZeppelin contracts for AccessControl, SafeCast, SafeERC20, which are generally secure. But maybe there's something wrong in how they're implemented here.

The contract is called RCTreasury and inherits AccessControl and NativeMetaTransaction. It has a lot of state variables, mappings, and events. The constructor sets up roles and initializes some parameters. There's a modifier called balancedBooks that checks the ERC20 balance against some totals. Let's see if that's done correctly.

In the constructor, roles like UBER_OWNER, OWNER, etc., are set up. The _setRoleAdmin functions configure role hierarchies. Maybe there's an issue with role permissions. For example, the OWNER role might have too much power.

Looking at the deposit function: it transfers ERC20 tokens from the user to the contract. It uses SafeERC20's safeTransferFrom. But there's a check on the allowance. However, the function uses msgSender() which comes from NativeMetaTransaction for meta transactions. Could there be a reentrancy issue here? The balancedBooks modifier is applied, which checks the balance after the function runs. But since the modifier runs after the function (_;), maybe there's a reentrancy risk if the ERC20 token is malicious. However, since they're using SafeERC20, maybe that's mitigated. But wait, the function updates user[_user].deposit and totalDeposits before transferring the tokens. Wait no, the code does safeTransferFrom first, then updates the state. So that's correct, following checks-effects-interactions. So no reentrancy here.

The withdrawDeposit function allows users to withdraw. It calls collectRentUser, which might modify the user's deposit. Then it reduces the deposit and transfers the tokens. Again, the transfer is after state changes, so reentrancy might not be an issue here. But there's a check on the user's last rental time. The modifier balancedBooks is applied again, which checks the balance after execution.

In the payRent function, which is only callable by MARKET, it subtracts from marketBalance and adds to marketPot. The require statements check if marketBalance is sufficient. But what if _amount is larger than marketBalance? It adjusts _amount to marketBalance. That could be a problem if the MARKET expects a certain amount. But maybe that's intentional.

The sponsor function allows a MARKET to transfer tokens from a sponsor. It uses safeTransferFrom, which is good. But the function doesn't check if the _sponsor has approved the amount. Wait, the function does have a check: erc20.allowance(_sponsor, address(this)) >= _amount. So that's correct. Then transfers the tokens into the contract.

Looking at the updateRentalRate function. It's called by ORDERBOOK. It adjusts rental rates for old and new owners. It uses SafeCast.toUint128, but if the subtraction underflows, it would revert. However, since ORDERBOOK is a trusted contract, maybe that's okay. But if ORDERBOOK is compromised, this could be a problem.

In the collectRentUser function, there's a calculation for rent owed. The function uses _timeToCollectTo which is passed as a parameter. But if someone calls this function with a past timestamp, could that cause issues? The function requires that _timeToCollectTo <= block.timestamp. So that's enforced.

There's a foreclosure mechanism. If a user's deposit is too low compared to their bidRate, they get foreclosed. The assessForeclosure function checks this. But maybe there's a scenario where this isn't updated correctly, leading to incorrect foreclosure status.

The grantRole and revokeRole functions are overridden. When granting or revoking WHITELIST role, they emit an event. But in the grantRole function, it's public and can be called by anyone with the appropriate role. However, since they're using AccessControl's grantRole, which includes permission checks, that should be okay. But maybe there's a role misconfiguration.

Looking at the role setup in the constructor. The contract grants OWNER, GOVERNOR, etc., roles to the factory address when setFactoryAddress is called. But if the factory is upgraded, the previous factory's roles might not be revoked properly. Wait, in setFactoryAddress, they revoke the roles from the old factory before granting to the new one. That seems correct.

Another thing: the globalExit function allows UBER_OWNER to transfer all ERC20 tokens out of the contract. That's a centralization risk, but maybe it's intended as an emergency function. However, if the UBER_OWNER's key is compromised, all funds can be stolen.

Reentrancy in functions: As most functions use the balancedBooks modifier which checks the balance after execution, but since ERC20 transfers are done via SafeERC20 which uses the checks-effects-interactions pattern, maybe reentrancy is not an issue here. But the modifier could be problematic if the ERC20 is a contract that calls back into the RCTreasury. However, since the modifier runs after the function logic, any reentrant call would have already modified the state. Wait, no: the modifier is applied with _; at the beginning (since it's modifier balancedBooks { _; require(...); }). Wait, no, looking at the modifier:

modifier balancedBooks() {
    _;
    require(
        erc20.balanceOf(address(this)) >=
            totalDeposits + marketBalance + totalMarketPots,
        ""Books are unbalanced!""
    );
}

So the code runs the function first, then checks the balance. This could allow a reentrant call where during the function execution, the balance is temporarily incorrect, but after the function, it's checked. However, if during the function, an external call is made (like transferring ERC20 tokens out), then the final check would catch that. But if a malicious ERC20 token returns false balanceOf, this could be a problem. But since the contract uses a known ERC20 (set via setTokenAddress), maybe that's not an issue. However, if the ERC20 is upgradable or malicious, this check could be bypassed.

Another issue: integer overflows and underflows. But since they're using SafeCast and Solidity 0.8.7, which has built-in overflow checks, that's mitigated.

The user struct uses uint128 for deposits and rates. If the values exceed 2^128-1, it would cause an error. But given the token's decimals (assuming 18), 2^128 is a huge number, so maybe it's acceptable.

In the withdrawDeposit function, after transferring the tokens, they check if the user's bidRate is too high relative to their deposit. If so, they foreclose. But during the withdrawal, if the user's deposit is reduced, and bidRate isn't updated, they could become undercollateralized. The code does call orderbook.removeUserFromOrderbook(_msgSender) in that case, which might remove their bids. But if the ORDERBOOK doesn't properly handle this, bids could remain, leading to potential issues.

The marketWhitelistCheck function uses msgSender() which is from the NativeMetaTransaction. If a market is allowed to set a requiredRole, then users must have that role to participate. But if the market is malicious, they could set a role that they control, allowing only certain users. However, the market must have the MARKET role, which is controlled by the factory, so maybe that's a trusted component.

In the collectRentUser function, when calculating rentOwedByUser, if the user's deposit is less than the rent owed, it calculates the time the deposit can cover and forecloses the user. But is there a scenario where the rent calculation is incorrect? For example, if the rental rate changes during the period. However, the rentalRate is updated via updateRentalRate when ownership changes, which should account for that.

The grantRole and revokeRole functions emit events when WHITELIST is changed. But in the grantRole function, if someone grants a different role, the event isn't emitted. That's correct, as it's only for WHITELIST.

In the setFactoryAddress function, they revoke roles from the old factory and grant to the new. But if the new factory is malicious, it could have OWNER and GOVERNOR roles, which allow it to change critical parameters. However, only UBER_OWNER can call setFactoryAddress, so that's a trusted role.

Another potential issue: the marketBalanceTopup variable is used when paying rent. If marketBalance is less than _amount, discrepancy is calculated. But if marketBalanceTopup is not sufficient, it's set to zero. This could lead to marketBalanceTopup being drained incorrectly.

In the payRent function, if the marketBalance is less than the requested _amount, discrepancy is _amount - marketBalance. Then, if discrepancy > marketBalanceTopup, topup is set to zero. But the code says:

if (discrepancy > marketBalanceTopup) {
    marketBalanceTopup = 0;
} else {
    marketBalanceTopup -= discrepancy;
}
_amount = marketBalance;

Wait, after that, marketBalance is subtracted by _amount (marketBalance -= _amount). But if marketBalance was already less than the original _amount, then _amount is set to marketBalance. So marketBalance becomes zero. But marketBalanceTopup is adjusted by discrepancy. However, if marketBalanceTopup is being used to cover the discrepancy, perhaps the calculation is incorrect. For example, if marketBalance is 100, _amount is 200, then discrepancy is 100. If marketBalanceTopup is 150, then marketBalanceTopup becomes 50 (150-100), and _amount is set to 100. Then marketBalance -= 100 (now 0). Then marketPot gets 100 added. But the totalMarketPots is increased by 100. But where did the 100 come from? It's taking from marketBalance (which was 100) and marketBalanceTopup (100 discrepancy, but topup is reduced by 100). So total is 100 (from balance) + 0 (from topup, since 100 was subtracted). Wait, maybe the logic is correct here. But this might be a potential area for accounting errors.

Another thing: in the withdrawDeposit function, the user can choose to withdraw via the bridge or locally. The bridge is set by UBER_OWNER. If the bridge is malicious, it could steal funds. But the approval is set to max in setBridgeAddress. So if the bridge is compromised, any funds sent there could be at risk.

The globalExit function allows UBER_OWNER to drain all tokens. Centralization risk here.

In the batchWhitelist function, it grants or revokes WHITELIST roles. But since it's called by GOVERNOR, and GOVERNOR is controlled by OWNER, which is controlled by UBER_OWNER, this is a centralized component.

Possible missing access control: for example, the assessForeclosure function is public. Can anyone call it? It emits an event, but does it have any side effects? The function updates isForeclosed[_user], which affects whether the user can participate. If someone calls assessForeclosure for another user, it could update their foreclosure status. However, the function only updates the status based on the current deposit and bidRate. Since the data is public, maybe it's okay. But if the foreclosure status is time-sensitive, this could allow someone to trigger foreclosure checks at will. But since the data is based on current state, maybe it's acceptable.

Another thing: in the collectRentUser function, newTimeLastCollectedOnForeclosure is returned. But if the function is called externally, maybe an attacker can manipulate the timing. However, the function requires that the caller is authorized (through some role?), looking at the function visibility. Wait, collectRentUser is a public function. So anyone can call it for any user. But since it's calculating rent up to block.timestamp, it's possible that anyone can trigger the rent collection for a user. This could lead to a user being foreclosed earlier than expected. For example, if a malicious actor calls collectRentUser for a user with a high rental rate, causing their deposit to be drained. However, the function requires that the _timeToCollectTo is <= block.timestamp. So even if someone calls it with block.timestamp, it's accurate. But since the rent is calculated based on the time since lastRentCalc, calling this function doesn't change anything that wouldn't have happened eventually. It just accelerates the foreclosure. But maybe this is a design choice. However, allowing anyone to trigger this function could be a vulnerability if it's not intended. For example, if a user's rental rate is high, but they plan to top up their deposit before the next rent collection, an attacker could call collectRentUser and cause them to be foreclosed immediately.

So the collectRentUser function is public and can be called by anyone. That's a potential issue. For example, Alice is a user with a high rentalRate and a low deposit. Bob notices this and calls collectRentUser for Alice, causing her to be foreclosed immediately. If Alice intended to add more funds before the next rent collection, Bob's action disrupts that. This could be considered a vulnerability as it allows third parties to force rent collection on any user, potentially leading to unfair foreclosures.

Another possible issue: in the updateRentalRate function, if the _timeOwnershipChanged is after the current block.timestamp, the collectRentUser function would process it. But the code requires that _timeToCollectTo <= block.timestamp in collectRentUser. However, in updateRentalRate, when adjusting for the new owner, if _timeOwnershipChanged is in the future, the code may not handle it correctly. But since _timeOwnershipChanged is presumably set by the ORDERBOOK, which is a trusted contract, maybe this is not an issue.

In the foreclosureTimeUser function, the calculation could potentially divide by zero if totalUserDailyRent + _newBid is zero. But if _newBid is zero and totalUserDailyRent is zero, then the else clause returns type(uint256).max, which is correct. So division by zero is avoided.

The marketWhitelistCheck function returns true if the requiredRole is bytes32(0), which means any user is allowed. If a market doesn't set a requiredRole, then there's no whitelist check. But if whitelistEnabled is true, then users still need the WHITELIST role. Wait, no. The marketWhitelistCheck is used in some context. Let's look at the function:

function marketWhitelistCheck(address _user) returns (bool) {
    bytes32 requiredRole = marketWhitelist[msgSender()];
    if (requiredRole == 0) {
        return true;
    } else {
        return hasRole(requiredRole, _user);
    }
}

This is used by markets to check if a user is allowed. But the whitelistEnabled flag in the contract controls whether the WHITELIST role is required during deposits. However, the marketWhitelistCheck is separate. So if a market sets a requiredRole, then even if whitelistEnabled is false, the user must have that role to pass the check. But if the market doesn't set a requiredRole, then any user can pass. However, the deposit function also checks for WHITELIST if whitelistEnabled is true. So there are two layers: the global whitelist and the per-market whitelist. If a market doesn't require a role, but the global whitelist is enabled, users still need the WHITELIST role to deposit. This could be a potential confusion, but not necessarily a vulnerability.

Another thing: the minRentalDayDivisor is set in the constructor to 24 * 6, which is 144. The comment says ""24 * 6"", which equals 144. But the variable name is minRentalDayDivisor, so the minimum rental time is 1 day / 144 = 10 minutes. But in withdrawDeposit, there's a check that the time since lastRentalTime is greater than 1 day / minRentalDayDivisor. So users can't withdraw if they've recently rented. But if minRentalDayDivisor is set to a very small number, this could allow users to withdraw too quickly. However, only the OWNER can change this via setMinRental. So if the owner is malicious, they could set it to 1, making the minimum rental time 1 day. But that's a centralization issue, not a code vulnerability.

Possible issues with role administration: The OWNER role can change critical parameters like minRentalDayDivisor, maxContractBalance, global pause, etc. If the OWNER is compromised, these can be manipulated. But that's a centralization risk, not a code bug.

In the setTokenAddress function, the UBER_OWNER can change the ERC20 token address. If this is set to a malicious token, the contract's balances could be manipulated. For example, a fake ERC20 that reports incorrect balances would cause the balancedBooks modifier to fail or allow incorrect accounting. This is a trust issue in the UBER_OWNER.

In the collectRentUser function, when rentOwedByUser exceeds the user's deposit, it calculates the time the deposit can cover. However, this calculation could be inaccurate if the rentalRate changes during that period. But the rentalRate is only modified via updateRentalRate, which should update the lastRentCalc time, so that shouldn't be an issue.

Another possible issue is front-running. For example, a user could deposit funds, someone else could front-run their transaction and call collectRentUser, causing the user's deposit to be reduced. But since collectRentUser is public, this is possible. However, the user's deposit is only reduced by the rent owed up to the current time, which is correct. So it's not a vulnerability, just a part of the system's design.

In summary, the potential vulnerabilities I can identify are:

1. **Centralization Risks**: The UBER_OWNER has too much power (globalExit, setTokenAddress, setBridgeAddress, etc.), which could lead to fund loss if compromised.

2. **Unprotected collectRentUser Function**: Anyone can call collectRentUser for any user, leading to forced foreclosures. This could be exploited to trigger foreclosures on users prematurely.

3. **Incorrect Accounting in payRent Function**: When adjusting marketBalanceTopup, there might be an error in how discrepancy is handled, leading to incorrect balances.

4. **Role Configuration Issues**: The roles are hierarchical, but if lower roles (like MARKET) are compromised, they could perform unauthorized actions. However, each function has proper role checks, so maybe not.

5. **Reentrancy in balancedBooks Modifier**: The modifier checks the balance after the function executes. If the ERC20 token is malicious and manipulates its balance during a transfer, it could bypass the check. However, since the token is set by UBER_OWNER, this depends on their trustworthiness.

6. **Foreclosure Assessment on Withdraw**: When a user withdraws, if their bidRate is too high relative to their deposit, they are foreclosed. However, if the ORDERBOOK doesn't properly remove their bids, they could still have active bids despite being foreclosed.

7. **Public assessForeclosure Function**: Allowing anyone to trigger foreclosure checks might not be a vulnerability, but it could lead to unnecessary gas usage or events.

8. **Market Whitelist Bypass**: If a market doesn't set a requiredRole, and whitelistEnabled is false, users might bypass intended restrictions. But this depends on the market's configuration.

9. **Bridge Approval Risk**: The contract approves the bridge to spend unlimited tokens. If the bridge is compromised, funds could be stolen.

10. **Integer Division Precision**: In rent calculations, division before multiplication could lead to precision loss, but the code uses SafeMath (via Solidity 0.8.7), and the order is correct.

The most critical issues seem to be the centralization risks and the public collectRentUser function allowing forced foreclosures.","```
1. Centralization Risks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Centralization Risks"".
   - In the ranked list of predictions, ""Centralization Risks"" appears at **rank 1**.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - \( AP = 1.0 \).

**Output**:
```
1.0
```",1
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    /////// CONTRACT VARIABLES ///////
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    /// @dev reference contract
    address public override referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public override referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(IRCMarket.Mode => address[]) public marketAddresses;

    ////// BACKUP MODE //////
    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data
    /// @dev the IPFS hash for each market
    mapping(address => string) public override ipfsHash;
    /// @dev the slug each market is hosted at
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    /// @dev the number of results to return in the backup view function
    uint256 public override marketInfoResults;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms initial pot
    uint256 public override sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev The number of users that are allowed to mint an NFT
    uint256 public override nftsToAward;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public override advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public override maximumDuration;
    /// @dev market closing time must be at least this many seconds after opening
    uint32 public override minimumDuration;
    /// @dev if false, anyone can create markets
    bool public override marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public override approvedAffiliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public override approvedArtistsOnly = true;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the maximum number of rent collections to have performed before locking the market
    uint256 public override maxRentIterationsToLockMarket;
    /// @dev the address of the arbitrator
    address public override arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public override timeout;
    /// @dev if true markets default to the paused state
    bool public override marketPausedDefaultState;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public override cardLimit;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;

    ///// OTHER /////
    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)
    /// @dev store the tokenURIs for when we need to mint them
    /// @dev we may want the original and the copies to have slightly different metadata
    /// @dev so we append the metadata for the copies to the end of this array
    mapping(address => mapping(uint256 => string)) tokenURIs;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // store contract instances
        treasury = _treasury;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setMinimumPriceIncreasePercent(10); // 10%
        setNumberOfNFTsToAward(3);
        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes
        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /// @notice fetch the current oracle, arbitrator and timeout settings
    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    /// @return Oracle Address
    /// @return Arbitrator Address
    /// @return Question timeout in seconds
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    /// @notice Returns market addresses and ipfs hashes
    /// @dev used for the UI backup mode
    /// @param _mode return markets only in the given mode
    /// @param _state return markets only in the given state
    /// @param _skipResults the number of results to skip
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in MegaBip (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice how many NFTs will be awarded to the leaderboard
    /// @param _nftsToAward the number of NFTs to award
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _cardLimit the limit to set
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        // event is emitted from the Oracle when the question is asked
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    /// @notice Allow the owner to update a token URI.
    /// @param _market the market address the token belongs to
    /// @param _cardId the index 0 card id of the token to change
    /// @param _newTokenURI the new URI to set
    /// @param _newCopyTokenURI the new URI to set for the copy
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        // reuse this event so the frontend can pickup the change
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    /// @notice change how many results are returned from getMarketInfo
    /// @dev would be better to pass this as a parameter in getMarketInfo
    /// @dev .. however we are limited because of stack too deep errors
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        // no event needed, only used for the backup view mode
        marketInfoResults = _results;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        // check it's an RC contract
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        // governors shouldn't have the ability to pause a market, only un-pause.
        // .. if a governor accidentally approves a market they should seek
        // .. assistance from the owner to decide if it should be paused.
        treasury.unPauseMarket(_market);
        // the market will however be hidden from the UI in the meantime
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /*╔═════════════════════════════════╗
      ║   GOVERNANCE - Role management  ║
      ╚═════════════════════════════════╝*/
    /// @dev the following functions could all be performed directly on the treasury
    /// @dev .. they are here as an interim solution to give governors an easy way
    /// @dev .. to change all their parameters via the block explorer.

    /// @notice Grant the artist role to an address
    /// @param _newArtist the address to grant the role of artist
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    /// @notice Remove the artist role from an address
    /// @param _oldArtist the address to revoke the role of artist
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    /// @notice Grant the affiliate role to an address
    /// @param _newAffiliate the address to grant the role of affiliate
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    /// @notice Remove the affiliate role from an address
    /// @param _oldAffiliate the address to revoke the role of affiliate
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades, this is separated so owner can be
    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    /// @notice change the reference contract for the contract logic
    /// @param _newAddress the address of the new reference contract to set
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice where the NFTs live
    /// @param _newAddress the address to set
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newOrderbook the address to set
    /// @dev set by the treasury to ensure all contracts use the same orderbook
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    /// @notice set the address of the leaderboard contract
    /// @param _newLeaderboard the address to set
    /// @dev set by the treasury to ensure all contracts use the same leaderboard
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all
    /// @param _ipfsHash the IPFS location of the market metadata
    /// @param _slug the URL subdomain in the UI
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata, originals followed by copies
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliates cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        // check nfthub has been set
        require(address(nfthub) != address(0), ""Nfthub not set"");

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check the number of NFTs to mint is within limits
        /// @dev we want different tokenURIs for originals and copies
        /// @dev ..the copies are appended to the end of the array
        /// @dev ..so half the array length if the number of tokens.
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        // affiliate
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        // tell Treasury and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        // update internals
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        // initialize the market
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        // store token URIs
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            // different statements to give clearer revert messages
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    /// @notice Called by the markets to mint the original NFTs
    /// @param _card the card id to be minted
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard
    /// @param _user the user to award the NFT to
    /// @param _cardId the tokenId to copy
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",7456.0,838.0,"[M-02] Parameter updates not propagated
Function `setNftHubAddress` to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results. Examples are:
``` function setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {
    require(address(_newAddress) != address(0), ""Must set Address"");
    nfthub = _newAddress;
} ```",1.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";


contract RCFactory is NativeMetaTransaction, IRCFactory {
    
    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    
    address public override referenceContractAddress;
    
    uint256 public override referenceContractVersion;
    
    
    mapping(IRCMarket.Mode => address[]) public marketAddresses;


    mapping(address => string) public override ipfsHash;
    
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    
    uint256 public override marketInfoResults;

    
    
    uint256[5] public potDistribution;
    
    uint256 public override sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint256 public override nftsToAward;
    
    uint32 public override advancedWarning;
    
    uint32 public override maximumDuration;
    
    uint32 public override minimumDuration;
    
    bool public override marketCreationGovernorsOnly = true;
    
    bool public override approvedAffiliatesOnly = true;
    
    bool public override approvedArtistsOnly = true;
    
    uint256 public override maxRentIterations;
    
    uint256 public override maxRentIterationsToLockMarket;
    
    address public override arbitrator;
    
    uint32 public override timeout;
    
    bool public override marketPausedDefaultState;
    
    uint256 public override cardLimit;

    
    
    mapping(address => bool) public override isMarketApproved;

    
    uint256 public constant PER_MILLE = 1000; 
    
    
    
    mapping(address => mapping(uint256 => string)) tokenURIs;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        treasury = _treasury;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setMinimumPriceIncreasePercent(10); 
        setNumberOfNFTsToAward(3);
        setCardLimit(100); 
        setMaxRentIterations(50, 25); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    
    
    
    
    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    
    
    
    
    
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    
    
    
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    
    
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    

    
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    
    
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    
    
    
    
    
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    
    
    
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        
        marketInfoResults = _results;
    }

    
    

    
    
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        
        
        
        treasury.unPauseMarket(_market);
        
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    
    

    
    
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    
    
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    
    
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    
    
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    
    
    
    

    
    
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    
    
    
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    
    
    
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    

    
    
    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        
        require(address(nfthub) != address(0), ""Nfthub not set"");

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        
        
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        
        
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        
        
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    
    
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    
    
    
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    
}",4268.0,0,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect TokenURIs Length Validation**: 
   - The `createMarket` function does not enforce that the `_tokenURIs` array length is even. This could lead to an inconsistent number of original and copy URIs, causing unexpected behavior when accessing token metadata.

2. **Pot Distribution Sum Not Enforced**: 
   - The `setPotDistribution` function allows the sum of distribution percentages to be less than 1000 (PER_MILLE). Unexplained or unallocated funds could result in improper fund distribution or stuck assets.

3. **Slug Collision and Uniqueness**:
   - The contract does not check for existing slugs when creating markets. Attackers can overwrite existing market entries by reusing slugs, potentially leading to phishing or front-end confusion.

4. **Incomplete Market Retrieval in `getMarketInfo`**:
   - The loop in `getMarketInfo` skips the earliest markets due to the condition `_marketIndex > 1`. Markets at lower indices (e.g., index 0) are excluded, leading to incomplete data retrieval.

5. **Mutable NFT Metadata**:
   - The `updateTokenURI` function allows the owner to alter NFT metadata post-minting, introducing centralization risk and potential misuse if URIs are expected to be immutable.

6. **Front-Runnable Market Creation via Slugs**:
   - The lack of slug uniqueness checks allows attackers to front-run market creation with the same slug, replacing legitimate market addresses with malicious ones.

7. **Unenforced Market Opening Time**:
   - When `advancedWarning` is zero, the contract does not validate that `_timestamps[0]` (market opening time) is in the future. Markets could be created with past opening times, leading to unintended states.

8. **Potential Underflow in Timestamp Checks**:
   - If `advancedWarning` is set to a value greater than `_timestamps[0]`, the calculation `_timestamps[0] - advancedWarning` could underflow, causing a revert. However, Solidity 0.8.x prevents this with automatic checks.

9. **Insecure Market Initialization**:
   - Reliance on the correctness of the `referenceContractAddress` for cloned markets. If the reference contract is compromised, all new markets inherit vulnerabilities.

10. **Centralized Control Risks**:
    - Key functions (e.g., updating metadata, changing critical parameters) are controlled by privileged roles (OWNER, UBER_OWNER), introducing risks if these roles are compromised.","### **[M-02] Parameter updates not propagated**

**Report Description**:
The function `setNftHubAddress` updates the `nfthub` parameter but does not propagate this change to other contracts that depend on it. This could lead to inconsistencies and unpredictable behavior across the system. For example, if `nfthub` is updated in one contract but not in others, it could result in mismatched states or failed interactions between contracts.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of parameter updates not being propagated to other contracts. This is a critical oversight, as it could lead to system-wide inconsistencies and vulnerabilities. The response list focuses on other vulnerabilities but misses this specific issue entirely.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-02] Parameter updates not propagated**

---

### **Conclusion**
The response list does not cover the issue of parameter updates not being propagated to other contracts. This is a significant gap, as it could lead to system-wide inconsistencies and vulnerabilities. The response list focuses on other vulnerabilities but misses this specific issue entirely.",0,0,1,10,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. The contract is called RCFactory and it's part of a system that creates markets, possibly for NFTs or similar tokens. Let me start by going through the code step by step.

First, I notice that the contract uses the Clones library from OpenZeppelin. Clones are used to deploy minimal proxy contracts, which are cheaper to deploy. That's a common practice, but maybe there are issues with how they're initialized or used here.

Looking at the constructor, they initialize the EIP712 domain for meta transactions. The constructor parameters include a treasury and some addresses for realitio and an arbitrator. The initial setup seems okay, but I should check if those addresses are properly validated. The constructor does have a require statement for the treasury address, which is good.

There are several state variables, including mappings for market addresses, IPFS hashes, slugs, etc. Some variables like potDistribution, sponsorshipRequired, and others are set by the owner. The permissions are managed through the treasury contract, which uses roles like UBER_OWNER, OWNER, GOVERNOR, etc. This is a role-based access control system, but I need to ensure that all functions are properly protected with the right modifiers.

Looking at the functions, there's a createMarket function that deploys a new market using Clones.clone. Let's check if the parameters passed to the new market are properly validated. For example, the _timestamps array is checked in _checkTimestamps. Let's see what that does.

The _checkTimestamps function verifies that the opening time is after the current block timestamp plus advancedWarning. It also checks that the locking time is within the maximumDuration and that the oracle resolution time is within a week of the locking time. But wait, the code says _timestamps[1] + 1 weeks > _timestamps[2], which might be a problem if the resolution time is set too far. Also, the minimumDuration is checked between opening and locking times. But maybe there's a miscalculation here. Let me check the code again.

In _checkTimestamps, they require that _timestamps[0] + minimumDuration < _timestamps[1]. Also, block.timestamp + minimumDuration < _timestamps[1]. Wait, that could be an issue. If the minimumDuration is set to, say, 1 day, then the market locking time must be at least 1 day after the market opening time and also 1 day after the current block timestamp. But if the market opening time is set in the future, then the block.timestamp check might not be necessary. For example, if the market opens in 2 days, then the locking time could be 3 days from now, which is 1 day after opening. But the code requires both _timestamps[0] + minimumDuration < _timestamps[1] and block.timestamp + minimumDuration < _timestamps[1]. So if the opening is in 2 days, and minimumDuration is 1 day, then locking needs to be at least 3 days from now (opening +1 day). But if block.timestamp is now, then locking needs to be at least 1 day from now. But if opening is in 2 days, then locking can't be 3 days from now because block.timestamp +1 day is 1 day from now, but 3 days is more than that. Wait, no, if opening is in 2 days, then opening + minimumDuration (1 day) is 3 days from now, which is the locking time. So the locking time must be >= 3 days from now. But the block.timestamp check is block.timestamp + minimumDuration (1 day) < locking time. So if the opening is in 2 days, then locking time is 3 days from now. So block.timestamp +1 day is 1 day from now, which is less than 3 days. So that check passes. So maybe that's okay. But perhaps there's a scenario where these checks could conflict, but maybe not. Need to think more.

Another thing in createMarket: they check that _tokenURIs.length / 2 is less than or equal to cardLimit. But why divide by 2? Oh, maybe because each card has an original and a copy URI. So the _tokenURIs array has entries for both original and copies. So if the number of cards is half the length of the array. But what if the array has an odd length? Then dividing by 2 would truncate. For example, if _tokenURIs.length is 3, then 3/2 is 1 in Solidity. But the code requires that each card has both URIs. So the createMarket function should require that _tokenURIs.length is even, but the code doesn't check that. So if someone passes an array of length 3, then (_tokenURIs.length / 2) would be 1, but the loop when initializing the tokenURIs would run for i < _tokenURIs.length (3 times), leading to possible index out of bounds when accessing the array. Wait, in the createMarket function, after cloning the market, they loop over _tokenURIs.length and set tokenURIs[_newAddress][i] = _tokenURIs[i]. But if the _tokenURIs array's length is odd, then when the market is initialized with (_tokenURIs.length / 2) as the number of cards, that might lead to an inconsistency. For example, if there are 3 token URIs, the number of cards would be 1 (3/2=1), but then the loop would run 3 times, writing to indexes 0, 1, 2. But the market would have 1 card, and copies would be stored starting from index 1 (since original is 0, copy is 1). Wait, the code says tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI. So if there's 1 card, then the copy is at index 1. But if the _tokenURIs array has 3 elements, then when the loop runs, i goes from 0 to 2. So for the new market, tokenURIs will have entries at 0, 1, 2. But the number of cards is 1. Then, when minting a copy, it would look at 0 + 1 = 1 for the copy URI, which is present. But index 2 is not used. So maybe this isn't a problem, but the code should probably require that _tokenURIs.length is even. Otherwise, it's possible to have an odd number of URIs, which could lead to unexpected behavior. So this is a possible vulnerability—lack of validation on the _tokenURIs array length being even.

Another thing: in the createMarket function, they check if _cardAffiliateAddresses.length is either 0 or equal to the number of cards. But the number of cards is _tokenURIs.length / 2. So if _tokenURIs has even length, then this is okay. But if the length is odd, as mentioned before, this could be a problem. For example, if _tokenURIs has length 3, then number of cards is 1 (3/2=1), and _cardAffiliateAddresses.length would need to be 0 or 1. But if the user passes 3 elements in _cardAffiliateAddresses, then it would fail. However, the code checks that _cardAffiliateAddresses.length is 0 or (_tokenURIs.length / 2). So in this example, it would check if 3 equals 1 (3/2=1). Which would fail. So if _tokenURIs has even length, then this check is okay, but if it's odd, the code would allow a mismatch. But again, the real problem is allowing _tokenURIs to have an odd length, which isn't validated here. So this is related to the previous point.

Another possible issue is the use of the Clones library. The createMarket function clones the referenceContractAddress, which is set by the Uber owner. But if the reference contract is not properly initialized or has vulnerabilities, all cloned markets would inherit those issues. However, the reference contract is supposed to be a market contract, and the code checks that newContractVariable.isMarket() returns true. But if the reference contract's isMarket() function can be manipulated or is incorrectly implemented, this check might not be sufficient. But this is more of a dependency issue rather than a vulnerability in this specific contract.

Looking at the setReferenceContractAddress function, it's only callable by Uber owner. They check that the new address is not zero and that it's a market. But if the Uber owner is compromised or makes a mistake, this could introduce vulnerabilities. But that's a trust issue with the admin, not a code flaw.

In the updateTokenURI function, the owner can update token URIs for a market. This function emits an event LogMarketCreated2, which might be misleading because it's not creating a market but updating it. Also, the event includes parameters like mode, tokenURIs, ipfsHash, timestamps, and totalNftMintCount. If this event is used by external systems to track market creation, they might misinterpret updates as new markets. This could lead to frontend or monitoring issues, but it's more of a code quality issue than a vulnerability.

Another potential issue is reentrancy. The createMarket function calls out to the treasury and nfthub contracts. If those contracts are malicious or have reentrancy vulnerabilities, this could affect the RCFactory. However, since the RCFactory is designed to work with specific contracts (like the treasury), this depends on the trustworthiness of those contracts. Assuming they're secure, this isn't an issue here. But if the treasury's addMarket function, for example, calls back into the RCFactory, there might be a reentrancy risk. But I don't see any such calls in the code provided.

The mintMarketNFT and mintCopyOfNFT functions are only callable by markets (using the onlyMarkets modifier). These functions mint NFTs through the nfthub. The token URIs are taken from the tokenURIs mapping, which is set during market creation and can be updated by the owner. If the owner can set arbitrary URIs, this could allow changing NFT metadata after minting, which might be undesirable. However, this is a design choice, not necessarily a vulnerability. But if the URIs are supposed to be immutable after creation, then allowing the owner to change them is a centralization risk or potential vulnerability if the owner is malicious.

In the setPotDistribution function, the owner can set the distribution percentages. The sum of the cuts must be <= 1000 (PER_MILLE). However, if the sum is less than 1000, the remaining percentage isn't accounted for. For example, if the total is 900, then 100 is unallocated. This could be intentional (e.g., kept as protocol fees), but the code doesn't enforce that the sum is exactly 1000. Depending on the intended behavior, this might be a issue. If the distribution is supposed to account for the entire 1000, then allowing less could lead to funds being unaccounted for, which might be a vulnerability. However, the comment in the constructor says setPotDistribution(20, 0, 0, 20, 100), which sums to 140, but PER_MILLE is 1000. That seems like a problem. Wait, the constructor's setPotDistribution call has (20,0,0,20,100). Summing those gives 20+0+0+20+100=140. That's way below 1000. So the sum is 140, which is 14% of the total. The comment says ""20, 0, 0, 20, 100"", which adds up to 140, but the code requires that the sum is <= 1000. But if the sum is less than 1000, then 860 parts are not allocated. That could mean that the remaining funds are kept in the contract or distributed elsewhere. But this depends on how the pot distribution is used in the market contracts. If the market contract sends the remaining funds to a certain address (like the treasury), then it's okay. Otherwise, there could be leftover funds that aren't distributed, leading to accounting issues. So this is a potential vulnerability if the sum isn't enforced to be exactly 1000. However, the code only checks that the sum is <= 1000, not that it's equal. So the owner could set a distribution that doesn't cover 100%, leading to unallocated funds. This could result in funds being stuck or not properly distributed.

Another issue: in the setMarketInfoResults function, the owner can set how many results are returned by getMarketInfo. If this is set to a very high number, it could cause the function to run out of gas when called, leading to a denial of service. However, since this is a view function, it doesn't affect the contract's state, but could impact the usability of the dApp.

In the createMarket function, the sponsorship is checked by calling treasury.checkSponsorship(_creator, _sponsorship). If the sponsorship is required, this function should ensure that the creator has enough tokens or whatever is used for sponsorship. However, the details depend on how the treasury implements checkSponsorship. If it's not properly implemented, this could be bypassed.

Looking at the initialization of the cloned market: IRCMarket(_newAddress).initialize(...). The parameters passed include _creator, which is msgSender(). If the initialize function is not protected against reinitialization, someone could call it again and change the parameters. But since the market is a clone, and clones typically use the initializer modifier from OpenZeppelin's Initializable library, this should be safe as long as the market's initialize function is properly secured. However, if the market contract's initialize function can be called multiple times, that's a vulnerability. But the RCFactory's code here is correct in calling it once after deployment.

The mintMarketNFT and mintCopyOfNFT functions use the onlyMarkets modifier, which checks that the caller has the MARKET role in the treasury. This ensures that only approved markets can mint NFTs, which is correct. However, if a malicious market is approved (due to a compromised governor), it could mint arbitrary NFTs, but that's a governance issue.

Another possible issue is the use of block.timestamp in _checkTimestamps. Since block.timestamp can be manipulated by miners to some extent, relying on it for critical timing could be risky. However, this is a common practice and usually acceptable unless the timing needs to be very precise. The impact here depends on how the market uses these timestamps.

In the updateTokenURI function, the owner can change the token URIs for existing markets. This could be a problem if the URIs are expected to be immutable. For example, if an NFT's metadata is changed after it's minted, it could lead to fraud or confusion. However, this is a design decision. If the system allows admins to update metadata, it's not a vulnerability per se, but it does centralize trust in the admin.

The code uses the NativeMetaTransaction contract, which allows for meta transactions (gasless transactions). If there's a vulnerability in the NativeMetaTransaction implementation, such as replay attacks or signature malleability, that could affect this contract. However, without seeing the implementation of NativeMetaTransaction, it's hard to say. Assuming it's a secure implementation, this should be fine.

There's also a potential front-running vulnerability in market creation. If the slug is unique and used to look up markets, someone could front-run the creation of a market with the same slug. However, the code uses a mapping from slug to address, so if two markets try to use the same slug, the second one would overwrite the first. The createMarket function does not check if the slug is already in use. So if a user creates a market with a slug that's already taken, the previous entry in slugToAddress would be overwritten. This could lead to confusion or phishing if slugs are used as identifiers. For example, if a popular market ""ethusd"" is created, an attacker could create another market with the same slug, replacing the address in the mapping. This is a vulnerability because the contract allows duplicate slugs, which can be exploited to trick users into interacting with a malicious market.

Additionally, the createMarket function does not check if the _slug is non-empty or valid. An attacker could create a market with an empty string as the slug, which might interfere with other functionality expecting valid slugs.

Another thing: the createMarket function emits LogMarketCreated1 and LogMarketCreated2 events. These events include parameters like the contract address, treasury, nfthub, etc. However, if the parameters passed to the events are incorrect (e.g., if the _newAddress is not properly initialized yet), the events might log wrong information. But since the events are emitted after the clone is created and initialized, this should be okay.

In the getMarketInfo function, there's a loop that starts from marketAddresses[_mode].length and decrements _marketIndex. However, if the marketAddresses array is empty, _marketIndex starts at 0, and then _marketIndex-- would underflow, causing a panic. But in Solidity 0.8.x, underflows cause a revert, so this code would revert if the marketAddresses array is empty. However, looking at the code, the loop condition is _marketIndex > 1. Wait, the loop starts with _marketIndex = marketAddresses[_mode].length. Then, while (_resultNumber < marketInfoResults && _marketIndex > 1). So if the length is 0, the loop doesn't execute. If the length is 1, then _marketIndex starts at 1, and the condition _marketIndex > 1 is false, so the loop doesn't run. If the length is 2, _marketIndex starts at 2, then _marketIndex-- becomes 1, and since 1 > 1 is false, the loop runs once. Wait, the condition is _marketIndex > 1. So when _marketIndex is 2, after decrementing to 1, the condition is no longer met. So the loop only runs if _marketIndex is greater than 1. So for a marketAddresses array of length 3, _marketIndex starts at 3. The loop runs while _marketIndex > 1. Each iteration decrements _marketIndex. So for 3, it becomes 2, then 1. So the loop runs for 3-1=2 times? Wait, let's see: initial _marketIndex is 3 (length is 3). Then in the loop, _marketIndex-- (to 2), check if state matches. Then, next iteration _marketIndex-- (to 1), which is not >1, so loop stops. So the loop runs two times. Wait, but the condition is _marketIndex > 1. So after decrementing, if the _marketIndex is 2, then it's still greater than 1. Wait, maybe I'm getting confused here. Let me step through an example:

Suppose marketAddresses has 3 elements (indices 0,1,2). The length is 3. So _marketIndex starts at 3. Then in the loop:

First iteration: _marketIndex-- → 2. Check if state matches. Then process.

Second iteration: check _marketIndex >1 → 2 >1 → true. _marketIndex-- →1. Process.

Third iteration: check _marketIndex >1 →1 >1 → false. Exit loop.

So the loop runs two times. So it's iterating from the end of the array towards the start, skipping the first element (index 0) if the length is 3. Wait, but the loop starts at marketAddresses.length (3) and subtracts 1 each time. So for marketAddresses of length 3, the loop starts at 3, subtract 1 → 2 (index 2), then 1 (index 1), then 0 (index 0) would be when _marketIndex is 0. But the loop condition is _marketIndex > 1. Wait, no:

Original code:

uint256 _marketIndex = marketAddresses[_mode].length;
while (_resultNumber < marketInfoResults && _marketIndex > 1) {
    _marketIndex--;
    ...
}

So if marketAddresses.length is 3, then _marketIndex starts at 3.

Loop condition: 3 >1 → true. Enter loop.

_marketIndex-- → 2. Process the market at index 2.

Increment _resultNumber if applicable.

Next iteration: _marketIndex is 2. Check condition: 2 >1 → true.

_marketIndex-- →1. Process index 1.

Next iteration: _marketIndex is1. Check condition:1 >1 → false. Exit.

So for a marketAddresses array of length 3, it processes indexes 2 and 1 (the last two elements). The first element (index 0) is never checked. So the getMarketInfo function may not return the earliest markets. This could be intentional (to get the most recent markets), but if the intention is to return all markets up to a certain number, this might be a bug. For example, if there are 5 markets, and marketInfoResults is 5, this loop would process the last two markets (indexes 4,3,2,1) until _resultNumber reaches 5. Wait, no: marketInfoResults is the number of results to return. Let's say marketInfoResults is 5. The loop runs while _resultNumber <5 and _marketIndex>1. Suppose the array has 10 elements. Then _marketIndex starts at 10. Each iteration decrements and checks. So indexes 9,8,7,6,5 (if state matches). But the loop stops when _marketIndex reaches 1. So this function skips the first element (index 0) and possibly others. This is likely a bug, as the function is intended to get the most recent markets, but if the array is ordered with the newest at the end, then starting from the end and moving backward would get the most recent. However, the code uses marketAddresses[_mode][marketAddresses[_mode].length -1] in getMostRecentMarket, which is correct. So in getMarketInfo, starting from the end and moving backward would get the most recent first. But the loop stops when _marketIndex >1, so for a marketAddresses array of length 1, the loop doesn't run. So this function would not return any markets if there's only one. Is this intended? It depends on the design. If marketInfoResults is set to a high number, but the array is small, the function would return fewer results. But the code may have an off-by-one error here. For example, if there are 2 markets, the loop runs once (index 1), but the first market (index 0) is not processed. So the function would miss the first market. This is a possible vulnerability if the function is supposed to return all markets that match the state, but instead skips some.

In summary, the vulnerabilities I can spot are:

1. Missing check that _tokenURIs array length is even in createMarket, leading to possible incorrect card counts and URIs assignment.

2. Pot distribution sum not enforced to be exactly 1000, leading to unallocated funds.

3. Slugs in createMarket are not checked for uniqueness, allowing duplicate slugs which can be used to overwrite existing entries and trick users.

4. getMarketInfo function may skip the first market(s) due to loop condition _marketIndex > 1, leading to incomplete data retrieval.

5. The updateTokenURI function allows the owner to change NFT metadata post-minting, which could be a centralization risk or allow rug-pulls if the owner is malicious.

6. Front-running possible in market creation by reusing existing slugs.

7. If the advancedWarning is set to zero, the check in _checkTimestamps that _timestamps[0] >= block.timestamp is not enforced because the require statement is inside the if (advancedWarning != 0) block. So if advancedWarning is zero, markets could have opening times in the past, which may not be intended.

Let me check point 7. In _checkTimestamps:

if (advancedWarning != 0) {
    require(
        _timestamps[0] >= block.timestamp,
        ""Market opening time not set""
    );
    require(
        _timestamps[0] - advancedWarning > block.timestamp,
        ""Market opens too soon""
    );
}

If advancedWarning is zero, these checks are skipped. So the market opening time could be in the past. This would allow creating markets that have already opened, which might be a problem. For example, if the market is supposed to start in the future, but due to advancedWarning being zero, a market could be created with an opening time in the past, leading to immediate locking or other unintended behavior.

Another thing: the setPotDistribution function allows setting the artistCut, winnerCut, etc., but if these are set such that the sum is less than 1000, the remaining funds aren't accounted for. This could lead to funds being stuck in the contract or not distributed properly.

So these are potential vulnerabilities. There might be others, but these are the ones I can spot for now.","```
None.
```",0.0,0
,,,,,,,,2,2,,,1,2,2,30,,,,