nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,Reasoning_Content,matchList,MAP,APs
LiquidityPool.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025.0,434.0,"[H-01] Can deposit native token for free and steal funds
The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed. Because the safe* version is used, the EOA not returning any data does not revert either.
This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.
  [H-03] Wrong formula when add fee incentivePool can lead to loss of funds.
The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR (10000000000)` each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract.
  [M-08] Incentive Pool can be drained without rebalancing the pool
`depositErc20()` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.
  [M-18] Possible frontrun on `deposits` on LiquidityPool
Rewards are given to a user for depositing either ERC20 tokens or their native token into the LiquidityPool. This reward is used to incentivize users to deposit funds into the liquidity pool when the pool is not in an equilibrium state.
For regular users, this liquidity pool state fluctuates based on the frequency and amount of deposits made to the liquidity pool. If a malicious user can control the state of the liquidity pool before a victim deposits tokens into the liquidity pool, they can gain double rewards.
To gain these double rewards, a malicious user can watch the mempool for transactions that will receive a reward when the deposit occurs. When a malicious user sees that victim deposit, the malicious user can attach a higher fee to their transaction and initiate a deposit. This will allow the malicious user's transaction to front-run before the victim's transaction.",4.0,"pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; 

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; 
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; 

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3573.0,2,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Event Emission in `withdrawNativeGasFee`**  
   The event `GasFeeWithdraw` emits `address(this)` as the token address when withdrawing native gas fees, instead of the correct `NATIVE` constant (0xEeeeeE...). This leads to misleading logs and misrepresentation of the actual token involved.

2. **Potential Underflow in `getCurrentLiquidity`**  
   The calculation `currentLiquidity = liquidityPoolBalance - totalLPFees - gasFeeAccumulatedByToken[tokenAddress] - incentivePool[tokenAddress]` may underflow if the sum of accumulated fees exceeds `liquidityPoolBalance`. This could cause denial of service (DoS) in core functionalities like deposits and withdrawals.

3. **Unchecked Fee Sum Causing Underflow in `amountToTransfer`**  
   In `getAmountToTransfer`, if `transferFeeAmount + gasFee` exceeds `amount`, the operation `amountToTransfer = amount - (transferFeeAmount + gasFee)` will underflow. This can occur if `transferFeePerc` (capped at `maxFee`) is set to 100% (1e10) or combined with high gas fees, leading to transaction reverts.

4. **Direct ETH Transfers Bypass Liquidity Tracking**  
   ETH sent directly to the contract (e.g., via `selfdestruct` or direct transfers) is not accounted for in `currentLiquidity`. Malicious executors can exploit this by invoking `sendFundsToUser` to drain untracked ETH, circumventing liquidity checks.

5. **Owner-Controlled `baseGas` Allows Excessive Fee Extraction**  
   The `baseGas` variable, which influences gas fee calculations, can be set to arbitrary values by the owner. This allows the owner to inflate gas fees, reducing the amount transferred to users and effectively stealing funds.

6. **Incorrect Permit Function Signatures Risk Signature Malleability**  
   The `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions assume specific permit implementations (EIP-2612 vs. non-standard). Mismatched token permit implementations could lead to failed transactions or unintended approvals, though EIP-2612 itself is resistant to signature malleability.

7. **Lack of Access Control on `checkHashStatus`**  
   The `checkHashStatus` function is publicly exposed, allowing anyone to query the status of transaction hashes. While not directly exploitable, this leaks information about processed transactions, which could aid attackers in identifying replay opportunities.

8. **Incentive Pool Mismanagement Risk**  
   If `incentivePool[tokenAddress]` is not sufficiently funded, `depositErc20` and `depositNative` may fail to distribute rewards, but this is a system-level issue rather than a code vulnerability.","### **Output**

---

**[H-01] Can deposit native token for free and steal funds**

**Report Description**:  
The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. The `SafeERC20Upgradeable.safeTransferFrom` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and low-level calls to EOAs always succeed. This allows an attacker to deposit infinite native tokens without paying anything, leading to the contract emitting a `Deposit` event and the attacker receiving native funds on the other chain.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves bypassing payment for native token deposits, which is a critical security flaw. The response list does not mention this specific exploit or its implications.

---

**[H-03] Wrong formula when add fee in incentivePool can lead to loss of funds**

**Report Description**:  
The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding a fee, but the formula is incorrect. The value of `incentivePool[tokenAddress]` is divided by `BASE_DIVISOR (10000000000)` each time, causing it to quickly become zero. This results in the locking of `tokenAddress` tokens in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect formula in `getAmountToTransfer` leading to the depletion of `incentivePool[tokenAddress]` is a significant vulnerability, but it is not mentioned or analyzed in the response list.

---

**[M-08] Incentive Pool can be drained without rebalancing the pool**

**Report Description**:  
The `depositErc20` function allows an attacker to specify the destination chain as the same as the source chain and the receiver account as the caller account. This enables the attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability to drain the incentive pool without rebalancing is a critical vulnerability, but it is not mentioned or analyzed in the response list.

---

**[M-18] Possible frontrun on deposits on LiquidityPool**

**Report Description**:  
Rewards are given to users for depositing tokens into the LiquidityPool. A malicious user can watch the mempool for transactions that will receive a reward and front-run them by attaching a higher fee to their transaction. This allows the attacker to gain double rewards by controlling the state of the liquidity pool before the victim's deposit.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The front-running vulnerability in the LiquidityPool deposit mechanism is a significant risk, but it is not mentioned or analyzed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Can deposit native token for free and steal funds**  
- **[H-03] Wrong formula when add fee in incentivePool can lead to loss of funds**  
- **[M-08] Incentive Pool can be drained without rebalancing the pool**  
- **[M-18] Possible frontrun on deposits on LiquidityPool**

---

### **Conclusion**  
The response list does not adequately address the issues reported in the `issue` list. None of the vulnerabilities in the `issue` list are correctly or partially matched in the `response_list`. This indicates a significant gap in the coverage of critical security concerns in the provided response list.",0,0,4,8,"Okay, I need to analyze this smart contract for vulnerabilities. Let's start by going through each function and the contract's structure. 

First, the contract imports several OpenZeppelin upgradeable contracts, which suggests it's using a proxy pattern. But since the question is about vulnerabilities, maybe the initialization functions are a point of concern. The initialize function sets up the contract, but I need to check if it's protected. Oh, right, it uses the initializer modifier, so that's probably okay. But maybe there's a missing check to ensure it's only called once. Wait, the initializer modifier from OpenZeppelin should handle that, so maybe not an issue here.

Looking at the modifiers: there's a onlyExecutor modifier that checks if the sender is an executor via executorManager.getExecutorStatus(msg.sender). If the executorManager can be changed by the owner, maybe there's a risk if a malicious executor is set. But the setExecutorManager function is onlyOwner, so if the owner is compromised, that's a problem. But that's more of a centralization risk rather than a code vulnerability.

Next, the tokenChecks modifier checks if a token is supported. The depositErc20 function uses this, so maybe tokens that are not supported are rejected properly. But perhaps there's a reentrancy issue despite the nonReentrant modifier. Wait, the contract inherits ReentrancyGuardUpgradeable and uses nonReentrant on functions. So maybe reentrancy is covered.

Looking at depositErc20: it transfers tokens from the user to the contract. SafeERC20Upgradeable.safeTransferFrom is used, which should handle non-compliant tokens. But what about the rewardAmount calculation? The getRewardAmount function subtracts from incentivePool. If the subtraction underflows, it could revert. But since getRewardAmount checks if currentLiquidity < providedLiquidity, maybe that's handled. However, if incentivePool[tokenAddress] is less than rewardAmount, subtracting could underflow. For example, if incentivePool[tokenAddress] is 0 and rewardAmount is positive, this would underflow. Let me check where incentivePool is modified. It's decreased in depositErc20 when rewardAmount !=0. But how is incentivePool funded? If the reward comes from the incentive pool, but the pool doesn't have enough, this could be a problem. So this is a possible vulnerability: insufficient incentive pool leading to underflow.

In getRewardAmount, there's a division by 1e10. If the numerator is very small, the division could result in 0, leading to rewardAmount being 0. But maybe that's intended. Not sure if that's a vulnerability.

Moving to sendFundsToUser: it's external, onlyExecutor, and uses tokenChecks. The key part is processing the hash to prevent replays. The checkHashStatus function uses keccak256 of tokenAddress, amount, receiver, and depositHash. If the depositHash is controlled by an attacker, maybe they can reuse it. But depositHash is probably generated by the system, so maybe not. However, if the executor can manipulate depositHash, they could replay transactions. But since only the executor can call this function, and if the executor is trusted, maybe not. However, if the executor is malicious, they could replay old hashes. The processedHash mapping prevents that, so that's probably okay.

In getAmountToTransfer, there are calculations for transfer fees. Let's look at the calculation of transferFeeAmount and lpFee. For example, transferFeePerc is divided by BASE_DIVISOR (1e10). If transferFeePerc is larger than equilibriumFee, then lpFee is equilibriumFee * amount / 1e10, and the difference is added to incentivePool. However, there's a possible division before multiplication issue. For example, (amount * (transferFeePerc - equilibriumFee)) / 1e10 could lose precision if not ordered properly. Wait, the code has:

incentivePool[tokenAddress] += (amount * (transferFeePerc - equilibriumFee)) / BASE_DIVISOR;

But since transferFeePerc is calculated via getTransferFee, which returns a value up to maxFee. If transferFeePerc is larger than equilibriumFee, the subtraction is okay. But if transferFeePerc is less than equilibriumFee, then this part isn't executed. Wait, the code says:

if (transferFeePerc > equilibriumFee) {
    lpFee = amount * equilibriumFee / BASE_DIVISOR;
    incentivePool += (amount * (transferFeePerc - equilibriumFee)) / BASE_DIVISOR;
} else {
    lpFee = amount * transferFeePerc / BASE_DIVISOR;
}

But in the else block, transferFeePerc is <= equilibriumFee, so lpFee is transferFeePerc * amount, and there's no addition to incentivePool. That seems okay.

Another possible issue: the gas fee calculation. The code uses initialGas - gasleft() to compute gas used. But gasleft() returns the remaining gas. The totalGasUsed is initialGas (gas left at the start) minus gasleft() after some operations. Then they add transferOverhead and baseGas. But this might not accurately reflect the actual gas used, especially since the remaining gas after the initial operations could vary. Also, baseGas is set by the owner, which could be manipulated to overcharge for gas. If the owner sets baseGas to a very high value, gas fees would be higher than actual, leading to users getting less funds. But since baseGas is controlled by the owner, this is a centralization risk.

In withdrawErc20GasFee and withdrawNativeGasFee, the functions subtract _gasFeeAccumulated from gasFeeAccumulatedByToken and set the executor's accumulated gas to zero. But if the token is NATIVE, the code for withdrawNativeGasFee uses address(this) in the emit, which is incorrect. The event should emit the token address (NATIVE), but the code emits address(this), which is the contract's address. That's a mistake and could lead to incorrect event logging.

In the transfer function, which is only callable by liquidityProviders, it transfers tokens or native currency. If the liquidityProviders contract is compromised, an attacker could drain funds. But since it's only callable by liquidityProviders, which is set by the owner, that's a trust assumption. Not a code vulnerability per se, but a dependency risk.

Looking at permitAndDepositErc20 and permitEIP2612AndDepositErc20: they use permit functions. The permit functions are called with _msgSender() as the owner. But if the permit is front-run, someone else could use the permit. However, since the permit is for the contract to spend the user's tokens, and the deposit is made by the user, maybe not an issue. But there's a possible signature reuse if the permit parameters are not correctly handled.

In getTransferFee, the code calculates fee as (providedLiquidity * equilibriumFee * maxFee) divided by [equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity]. If denominator is zero, it returns 0. But if resultingLiquidity is such that denominator is zero, division by zero would occur, but the code checks if denominator ==0. However, the variables are uint, so if denominator is zero, the else clause would have a division by zero. Wait, the code says:

if (denominator == 0) {
    fee = 0;
} else {
    fee = numerator / denominator;
}

So division by zero is prevented. That's okay.

Another possible issue is in the getCurrentLiquidity function. The current liquidity is calculated as liquidityPoolBalance minus fees and incentivePool. But if the sum of the fees and incentivePool exceeds liquidityPoolBalance, this would underflow. However, the code uses:

currentLiquidity = liquidityPoolBalance - totalLPFees - gasFeeAccumulatedByToken - incentivePool.

But since these fees are accumulated from deposits, perhaps the contract ensures that liquidityPoolBalance is always sufficient. If not, this subtraction could underflow, causing a revert. So if, for example, the totalLPFees plus gas fees and incentivePool exceed the liquidityPoolBalance, getCurrentLiquidity would revert. This could happen if fees are not properly tracked. This is a vulnerability because if the accumulated fees exceed the available liquidity, the function would fail, leading to potential denial of service in functions that depend on it, like depositErc20 and sendFundsToUser.

Also, in depositErc20 and depositNative, the code increases current liquidity by the amount. But if the currentLiquidity is already incorrect due to underflow, this could lead to incorrect liquidity tracking.

In sendFundsToUser, the amountToTransfer is calculated as amount minus fees and gas. If the sum of transferFeeAmount and gasFee exceeds the amount, amountToTransfer would underflow. However, the transferFeePerc is a percentage, and the code ensures that transferFeePerc is calculated such that the fees are a portion of the amount. But if due to a miscalculation, transferFeeAmount + gasFee exceeds amount, this would underflow. Let me check getAmountToTransfer:

amountToTransfer = amount - (transferFeeAmount + gasFee);

If (transferFeeAmount + gasFee) > amount, this would underflow, causing a revert. So the code must ensure that transferFeeAmount and gasFee do not exceed amount. The transferFeeAmount is (amount * transferFeePerc) / 1e10. Since transferFeePerc is capped at maxFee, which is a percentage (e.g., 1e10 is 100%), so transferFeePerc can be up to 1e10, making transferFeeAmount equal to amount. If transferFeePerc is 1e10, transferFeeAmount is amount, and gasFee could be added, leading to underflow. But in getTransferFee, the fee is calculated with numerator and denominator such that the fee can't exceed maxFee. Wait, the getTransferFee function's maximum possible fee would be maxFee. For example, when resultingLiquidity is 0, denominator becomes equilibriumFee * providedLiquidity, numerator is providedLiquidity * equilibriumFee * maxFee. So fee = (providedLiquidity * equilibriumFee * maxFee) / (equilibriumFee * providedLiquidity) ) = maxFee. So transferFeePerc can be up to maxFee. If maxFee is 1e10 (100%), then transferFeeAmount would be amount, and gasFee added would make (transferFeeAmount + gasFee) exceed amount. So if maxFee is set to 1e10 (100% fee), then transferFeeAmount is amount, and adding gasFee would cause underflow. But the code allows the owner to set maxFee via tokenManager. If the token's maxFee is set too high, this could cause underflow. Therefore, this is a vulnerability: if the transferFeePerc plus gasFee exceeds 100% of the amount, the subtraction underflows, reverting the transaction. However, the code in tokenManager should prevent setting maxFee beyond 1e10, but if it's allowed, this becomes a problem. Or if the gasFee is high enough, even with lower transferFeePerc, the sum could exceed amount. For example, if transferFeePerc is 5% (5e8), and gasFee is 96% of the amount, then 5% + 96% = 101% would cause underflow. So the code doesn't check that transferFeeAmount + gasFee <= amount. Therefore, this is a possible vulnerability.

Another issue is in the getRewardAmount function. The calculation for rewardAmount when currentLiquidity < providedLiquidity: rewardAmount is (amount * incentivePool * 1e10) / liquidityDifference / 1e10. But if liquidityDifference is zero, this would divide by zero. But currentLiquidity is less than providedLiquidity, so liquidityDifference = provided - current, which is positive. But if providedLiquidity equals currentLiquidity, liquidityDifference would be zero. Wait, in getRewardAmount:

if (currentLiquidity < providedLiquidity) {
    uint256 liquidityDifference = providedLiquidity - currentLiquidity;
    if (amount >= liquidityDifference) {
        rewardAmount = incentivePool[tokenAddress];
    } else {
        rewardAmount = (amount * incentivePool[tokenAddress] * 1e10) / liquidityDifference;
        rewardAmount = rewardAmount / 1e10;
    }
}

But liquidityDifference is providedLiquidity - currentLiquidity, which is positive since current < provided. So division by zero here is not possible. However, if liquidityDifference is very small, like 1 wei, and amount is large, then the calculation may not be accurate due to integer division, but that's a precision issue, not a vulnerability.

Looking at the ERC2771ContextUpgradeable integration. The contract uses _msgSender() which handles meta transactions. However, if the trusted forwarder is malicious, it could spoof the sender. But the trusted forwarder is set by the owner, so if the owner is compromised, that's a problem. But that's again a centralization issue, not a code flaw.

Another thing: the contract uses SafeERC20Upgradeable for ERC20 transfers, which is good. But for native transfers, it uses .call{value: ...}, which is okay, but the code checks the balance before transferring. However, in a case where the balance changes between the check and the transfer (due to another transaction), the transfer could fail. But since the function is nonReentrant and only called by the executor, maybe that's acceptable.

In the withdrawErc20GasFee function, the code subtracts _gasFeeAccumulated from gasFeeAccumulatedByToken[tokenAddress], but if multiple executors are withdrawing, this could underflow if not properly accounted for. However, the code first checks that the accumulated gas fee is non-zero and then subtracts it. Since gasFeeAccumulated[tokenAddress][msg.sender] is set to zero after withdrawal, this is safe. But gasFeeAccumulatedByToken could have a larger value than the sum of all executors' accumulated fees, leading to an underflow when subtracting. For example, if gasFeeAccumulatedByToken is 100, and an executor has 150, then 100 - 150 would underflow. But since gasFeeAccumulatedByToken is the sum of all executors' gas fees, the code should maintain that gasFeeAccumulatedByToken[tokenAddress] is the sum of gasFeeAccumulated[tokenAddress][executor]. So if each executor's accumulated is tracked properly, this should not happen. But if there's a bug in the accounting, this could be an issue. For example, if when adding to gasFeeAccumulated, the code increases both gasFeeAccumulatedByToken and the executor's individual balance, but when other operations modify these variables, the sum might not hold. However, in sendFundsToUser, gasFeeAccumulatedByToken and gasFeeAccumulated are both increased by gasFee, so the sum should be accurate. So the withdrawal functions should be safe.

In the depositErc20 function, the code transfers 'amount' from the user, but then emits Deposit with 'amount + rewardAmount'. However, the actual transferred amount is 'amount', and the reward is taken from the incentive pool. So if rewardAmount is non-zero, the contract must have enough incentivePool[tokenAddress] to cover it. If not, the subtraction incentivePool[tokenAddress] -= rewardAmount would underflow, causing a revert. So the code checks if rewardAmount != 0 before subtracting. However, if the incentive pool is less than rewardAmount, this would underflow. Therefore, the code should ensure that incentivePool[tokenAddress] >= rewardAmount. But where is this check? In depositErc20, after calling getRewardAmount, if rewardAmount !=0, it subtracts from incentivePool. But there's no require statement checking that incentivePool[tokenAddress] >= rewardAmount. So if getRewardAmount returns a rewardAmount greater than the incentive pool, the subtraction would underflow, causing the transaction to revert. This is a vulnerability because underflow would revert the transaction, making deposits impossible if the incentive pool is insufficient. However, the getRewardAmount function's logic should ensure that rewardAmount doesn't exceed incentivePool[tokenAddress]. Let's check:

In getRewardAmount, when currentLiquidity < providedLiquidity, the rewardAmount is either incentivePool[tokenAddress] (if amount >= liquidityDifference) or (amount * incentivePool * 1e10) / liquidityDifference / 1e10. In the first case, if amount >= liquidityDifference, rewardAmount is the entire incentivePool. But if the incentivePool is zero, rewardAmount would be zero. Wait, no. Let me see:

If currentLiquidity < providedLiquidity:

- liquidityDifference = provided - current.

If amount >= liquidityDifference, rewardAmount = incentivePool[tokenAddress].

But if the incentive pool has, say, 100, then rewardAmount is 100. But if the incentivePool is zero, rewardAmount would be zero. So in depositErc20, when rewardAmount is non-zero, it subtracts from incentivePool. But if getRewardAmount returns a value greater than incentivePool, then subtracting would underflow. So how does getRewardAmount calculate it?

When amount >= liquidityDifference, rewardAmount is set to incentivePool[tokenAddress]. So if the incentivePool is 50, then rewardAmount is 50. Then when subtracting, it's safe. But if the incentive pool is 50, and rewardAmount is 50, it's okay. But if the incentive pool is 0, then getRewardAmount would return 0, so the code doesn't subtract. So in that case, no problem. However, if for some reason getRewardAmount returns a value greater than incentivePool[tokenAddress], then subtracting would underflow. How can that happen?

In the else case (amount < liquidityDifference), rewardAmount is (amount * incentivePool * 1e10) / liquidityDifference / 1e10. So (amount * incentivePool) / liquidityDifference. If liquidityDifference is less than amount * incentivePool, this could result in rewardAmount exceeding incentivePool. For example, if amount is 100, incentivePool is 200, liquidityDifference is 50. Then (100 * 200) / 50 = 400. So rewardAmount would be 400 / 1e10 (but since it's divided by 1e10 again in code). Wait, in the code:

rewardAmount = (amount * incentivePool[tokenAddress] * 1e10) / liquidityDifference;
rewardAmount = rewardAmount / 1e10;

So it's (amount * incentivePool * 1e10) / liquidityDifference / 1e10. Which simplifies to (amount * incentivePool) / liquidityDifference. So if (amount * incentivePool) / liquidityDifference > incentivePool, that would require that amount / liquidityDifference > 1. Because:

(amount * incentivePool) / liquidityDifference > incentivePool

=> amount / liquidityDifference > 1

So if amount > liquidityDifference, but in the else clause, amount < liquidityDifference. Wait, the else clause is entered only when amount < liquidityDifference, since if amount >= liquidityDifference, the code uses the if clause. So in the else case, amount < liquidityDifference. Therefore, (amount / liquidityDifference) < 1. Therefore, (amount * incentivePool) / liquidityDifference < incentivePool. So rewardAmount in the else case cannot exceed incentivePool. Therefore, the rewardAmount can't exceed incentivePool[tokenAddress]. Therefore, when the code subtracts rewardAmount from incentivePool, there's no underflow. So this is safe.

But in the if clause (amount >= liquidityDifference), rewardAmount is set to incentivePool. Then subtracting that from incentivePool would set it to zero. So no underflow. Therefore, depositErc20's subtraction is safe.

Another possible issue is in the ERC20 permit functions. The permitAndDepositErc20 and permitEIP2612AndDepositErc20 functions call permit on the token. However, the parameters for the permit functions are different. For example, in permitAndDepositErc20, the permit is called with nonce, expiry, allowed, v, r, s, which matches the permit function signature for some tokens (like the standard permit). In permitEIP2612AndDepositErc20, the permit is called with value, expiry, v, r, s, which matches the EIP-2612 permit. However, if the token implements permit differently, this could lead to unintended behavior. For example, if the token's permit function has parameters in a different order, using these functions could result in incorrect permits. However, since the functions are named permitAndDeposit and permitEIP2612AndDeposit, it's up to the user to use the correct one. But if a user calls the wrong function for the token's permit type, the permit could fail or be incorrect. This is a potential user error, but not a contract vulnerability per se.

The contract also has a receive function that emits EthReceived. But if someone sends ETH directly to the contract (not through depositNative), it would be added to the contract's balance but not accounted for in the liquidity. This could lead to discrepancies. For example, if someone sends ETH directly, the liquidityProviders' current liquidity for NATIVE would not reflect this, leading to inconsistencies. The receive function emits an event but doesn't update any liquidity. So the sent ETH is not accounted for in the currentLiquidity, leading to potential issues when sending funds. For example, if the contract's ETH balance is higher than the tracked currentLiquidity, sendFundsToUser could allow sending more than intended. But sendFundsToUser checks the tokenAddress's balance (for native, address(this).balance) before transferring. However, the currentLiquidity is supposed to track the available funds minus fees. If extra ETH is sent to the contract, the sendFundsToUser function would allow sending it, even if it's not part of the tracked liquidity. This is a vulnerability because anyone can send ETH to the contract, increasing its balance, and the sendFundsToUser function would transfer it, bypassing the liquidity checks. This allows an attacker to send ETH directly to the contract, then have an executor call sendFundsToUser to drain it, as long as the tokenAddress is NATIVE and the other parameters are met. But since sendFundsToUser is only callable by an executor, who is supposed to be trusted, this depends on the executor's trustworthiness. However, if the executor is malicious, they could steal any ETH sent directly to the contract. So the contract's ETH balance is not fully protected, leading to possible fund leakage.

Another aspect: the getCurrentLiquidity function subtracts several fees from the liquidityPoolBalance. If these fees are not properly accounted for, the currentLiquidity could be incorrect. For example, if the sum of totalLPFees, gasFeeAccumulatedByToken, and incentivePool exceeds the liquidityPoolBalance, currentLiquidity would underflow, causing a revert. This would make functions that depend on getCurrentLiquidity (like depositErc20, getRewardAmount, etc.) fail. This could be exploited by an attacker to cause a denial of service. For example, if someone can manipulate the fees to be higher than the available liquidity, the contract would become unusable. However, the fees are accumulated as part of the contract's operation. If the system is designed such that fees are deducted from the liquidity, then the currentLiquidity should account for that. But if the fees are miscalculated, underflow could happen. Therefore, the contract should ensure that liquidityPoolBalance is always >= totalLPFees + gasFeeAccumulatedByToken + incentivePool. Otherwise, getCurrentLiquidity will revert, breaking core functionality.

In summary, the vulnerabilities I can identify are:

1. **Incorrect Event Emission in withdrawNativeGasFee**: The event GasFeeWithdraw emits address(this) instead of the NATIVE address, leading to incorrect logging.

2. **Potential Underflow in getCurrentLiquidity**: If the sum of fees (totalLPFees + gasFeeAccumulatedByToken + incentivePool) exceeds the liquidityPoolBalance, getCurrentLiquidity will underflow, causing reverts and potential DoS.

3. **Unchecked Transfer Fee and Gas Fee Sum in sendFundsToUser**: The amountToTransfer calculation could underflow if transferFeeAmount + gasFee exceeds the original amount. This can happen if transferFeePerc is high enough (up to maxFee, which could be 100%) and gasFee is non-zero.

4. **Direct ETH Transfers Can Be Stolen**: If ETH is sent directly to the contract (not through depositNative), it can be withdrawn by executors via sendFundsToUser, bypassing liquidity tracking.

5. **Incorrect Trust in Executor for Gas Fee Calculation**: The baseGas can be set arbitrarily by the owner, leading to inflated gas fees if set too high, potentially stealing user funds via excessive fees.

6. **Possible Signature Malleability in Permit Functions**: Depending on the token's permit implementation, the permit functions may be vulnerable to signature malleability, though EIP-2612 is designed to prevent this.

7. **Centralization Risks**: The contract relies on trusted owners and executors, which could act maliciously (e.g., changing executorManager to a malicious contract).

But the question says no need for mitigation, just list vulnerabilities. Let me verify each of these points to ensure they're valid.

1. **Incorrect Event Emission**: Yes, in withdrawNativeGasFee, the event is emit GasFeeWithdraw(address(this), ...), but the tokenAddress should be NATIVE (0xEee...). This is a mistake and a low-severity issue.

2. **Underflow in getCurrentLiquidity**: Yes, if liquidityPoolBalance < totalLPFees + gasFeeAccumulatedByToken + incentivePool, subtraction underflows. High severity as it can break core functionality.

3. **Underflow in amountToTransfer**: If transferFeePerc is 100% (1e10), transferFeeAmount is amount, and gasFee is non-zero, then amountToTransfer = amount - (amount + gasFee) underflows. However, transferFeePerc is calculated in getTransferFee, which can return up to maxFee. If maxFee is 1e10, then yes. But does the tokenManager allow setting maxFee to 1e10? If so, this is a problem. Therefore, if maxFee can be 1e10 and gasFee is non-zero, underflow. High severity.

4. **Direct ETH Transfers**: Yes, if someone sends ETH directly, sendFundsToUser can send it without being tracked in currentLiquidity. Medium severity, as it depends on executor being malicious.

5. **BaseGas Manipulation**: Owner can set baseGas to a high value, inflating gasFee. High severity as it allows owner to steal funds via excessive fees.

6. **Signature Malleability**: EIP-2612 permits are protected against malleability, but if a token uses a different permit with v=27/28, it might be vulnerable. Low likelihood, but possible.

7. **Centralization Risks**: Not code vulnerabilities but trust assumptions. Not listed as code vulns.

Other possible issues:

- **Incentive Pool Mismanagement**: If the incentivePool is not funded properly, rewards can't be given, but that's a system issue, not a code bug.

- **Reentrancy in sendFundsToUser**: But the function has nonReentrant, so safe.

So the main vulnerabilities are:

1. Incorrect Event Emission in withdrawNativeGasFee.

2. Potential underflow in getCurrentLiquidity.

3. Possible underflow in amountToTransfer if fees exceed amount.

4. Direct ETH transfers can be stolen.

5. BaseGas manipulation by owner.

6. Incorrect permit function usage leading to signature issues.

I need to list these. Let me check again.

Another possible issue: In sendFundsToUser, the code calls getAmountToTransfer, which modifies state (updates incentivePool and gasFeeAccumulated). However, the function is nonReentrant and only called by executors, which is okay.

Wait, in sendFundsToUser, after calculating amountToTransfer, it decreases currentLiquidity by amountToTransfer. But if the actual transfer is more than currentLiquidity, this could be an issue. However, the code checks the contract's balance before transferring, but currentLiquidity is supposed to represent available funds. If currentLiquidity is incorrect due to the issues mentioned earlier, this could lead to inconsistencies.

But perhaps that's part of the same underflow issue in getCurrentLiquidity.

So compiling the list:

1. **Incorrect Event Emission in withdrawNativeGasFee**: The event logs the contract address instead of the NATIVE token address.

2. **Underflow in Current Liquidity Calculation**: If the sum of fees exceeds the available liquidity, leading to denial of service.

3. **Unchecked Fee Sum Leading to Underflow in amountToTransfer**: If transferFeeAmount + gasFee > amount, causing a revert.

4. **Direct ETH Donations Can Be Stolen**: ETH sent via selfdestruct or direct transfer can be withdrawn by executors, bypassing liquidity checks.

5. **BaseGas Variable Set to High Values by Owner**: Leading to excessive gas fees and reduced user funds.

6. **Potential Signature Issues in Permit Functions**: If permit functions are used incorrectly for certain tokens.

Additionally, the code uses a constant NATIVE address (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) which is a common convention but not a real token. However, if in some contexts this is treated as an actual ERC20 token, but in the contract, it's correctly handled as native currency. Not a vulnerability.

Another thing: the tokenManager, liquidityProviders, and executorManager are upgradeable via the owner. If these contracts are maliciously upgraded, it can compromise the system. But this is a trust issue, not a code vulnerability.

So the answer should list the vulnerabilities found in the code.","```
None.
```",0.0,0
LiquidityProviders.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555.0,475.0,"[H-02] LiquidityProviders.sol The share price of the LP can be manipulated and making future liquidityProviders unable to `removeLiquidity()`
The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.
  [M-01] Unsupported tokens cannot be withdrawn In the function `addTokenLiquidity`, supported tokens can be turned off again. Users won't be able to withdraw their liquidity anymore because of this check in the function `removeLiquidity`.
  [M-11] LiquidityProviders: Setting new liquidity pool will break contract
Owners can change the `liquidityPool` variable any time with the `setLiquidityPool` function. If a liquidity pool was already set and users added liquidity with `addTokenLiquidity`, the tokens are directly transferred to the liquidity pool and not kept in the `LiquidityProviders` contract. Changing the `liquidityPool` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity` because the tokens are still in the old `liquidityPool` and cannot be retrieved.
  [M-12] LiquidityProviders: Setting new LP token will break contract
Owners can change the `lpToken` variable at any time with the `setLpToken` function. If an LP token was already set and users added liquidity with `addTokenLiquidity` and were minted a `lpToken` NFT, changing the `lpToken` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity`.
All users will lose their funds.
 
[M-17] wrong condition checking in price calculation
The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.
  [M-19] sharesToTokenAmount: Division by zero
The public `sharesToTokenAmount` function does not check if the denominator `totalSharesMinted[_tokenAddress]` is zero. Neither do the callers of this function. The function will revert. Calling functions like `getFeeAccumulatedOnNft` and `sharesToTokenAmount` from another contract should never revert.
  [M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state
In the function `removeLiquidity`, LP token holders can not redeem their tokens when the pool is in the deficit state, i.e. `currentLiquidity << providedLiquidity`. This is due to that LP shares are computed based on providedLiquidity and the actual available pool balance is based on currentLiquidity.",7.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    
    mapping(address => uint256) public totalReserve; 
    mapping(address => uint256) public totalLiquidity; 
    mapping(address => uint256) public currentLiquidity; 
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3709.0,1,6,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Inconsistent State When Burning All Shares in `removeLiquidity`**  
   - **Description**: When burning all shares (due to remaining shares < `BASE_DIVISOR`), the code subtracts the user-specified `_amount` from the NFT's supplied liquidity but sets the shares to zero. This leaves the NFT in an inconsistent state with non-zero `suppliedLiquidity` but zero shares, leading to incorrect fee calculations and potential loss of funds.  
   - **Impact**: Incorrect state tracking, affecting fee distributions and liquidity management.

2. **ETH Locking in Receive Function**  
   - **Description**: The `receive()` function allows direct ETH transfers to the contract but lacks a withdrawal mechanism. Accidentally sent ETH (not via `addNativeLiquidity`) becomes permanently locked.  
   - **Impact**: Loss of funds for users mistakenly sending ETH directly.

3. **Potential Division by Zero in `sharesToTokenAmount`**  
   - **Description**: If `totalSharesMinted[_tokenAddress]` is zero (e.g., for a token with no liquidity), calling `sharesToTokenAmount` results in division by zero. While the code prevents zero liquidity additions, a misconfigured token could trigger this.  
   - **Impact**: Transaction reverts, disrupting contract functionality.

4. **Rounding Errors in Share Calculations**  
   - **Description**: Integer division in share calculations (e.g., `mintedSharesAmount = (_amount * totalSharesMinted) / totalReserve`) can truncate fractional values, causing users to receive fewer shares than expected.  
   - **Impact**: Minor losses for users due to dust amounts, though mitigated by minimum share checks.

5. **Underflow Risk in `removeLiquidity` During LP Fee Deduction**  
   - **Description**: If `totalLPFees[_tokenAddress]` is smaller than `lpFeeAccumulated` (due to miscalculations or attacks), subtracting `lpFeeAccumulated` from `totalLPFees` underflows. However, the fee calculation logic should prevent this under normal conditions.  
   - **Impact**: Potential transaction reverts or incorrect state if fee accounting is compromised.","### **Output**

---

**[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidityProviders unable to `removeLiquidity()`**

**Report Description**:  
The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of share price manipulation or the potential overflow in `sharesToTokenAmount`. This is a critical vulnerability that could lead to frozen funds, and it is not covered in the responses.

---

**[M-01] Unsupported tokens cannot be withdrawn**

**Report Description**:  
In the function `addTokenLiquidity`, supported tokens can be turned off again. Users won't be able to withdraw their liquidity anymore because of this check in the function `removeLiquidity`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unsupported tokens being unable to withdraw liquidity. This is a significant oversight, as it directly impacts user funds.

---

**[M-11] LiquidityProviders: Setting new liquidity pool will break contract**

**Report Description**:  
Owners can change the `liquidityPool` variable any time with the `setLiquidityPool` function. If a liquidity pool was already set and users added liquidity with `addTokenLiquidity`, the tokens are directly transferred to the liquidity pool and not kept in the `LiquidityProviders` contract. Changing the `liquidityPool` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity` because the tokens are still in the old `liquidityPool` and cannot be retrieved.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of changing the `liquidityPool` variable, which could lead to users being unable to withdraw their liquidity. This is a critical vulnerability that is not covered.

---

**[M-12] LiquidityProviders: Setting new LP token will break contract**

**Report Description**:  
Owners can change the `lpToken` variable at any time with the `setLpToken` function. If an LP token was already set and users added liquidity with `addTokenLiquidity` and were minted a `lpToken` NFT, changing the `lpToken` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity`. All users will lose their funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of changing the `lpToken` variable, which could lead to users losing their funds. This is a critical vulnerability that is not covered.

---

**[M-17] Wrong condition checking in price calculation**

**Report Description**:  
The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might lead to a case where the price is calculated incorrectly, or a division by zero is happening.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect condition checking in the `getTokenPriceInLPShares` function, which could lead to incorrect price calculations or division by zero. This is a significant oversight.

---

**[M-19] sharesToTokenAmount: Division by zero**

**Report Description**:  
The public `sharesToTokenAmount` function does not check if the denominator `totalSharesMinted[_tokenAddress]` is zero. Neither do the callers of this function. The function will revert. Calling functions like `getFeeAccumulatedOnNft` and `sharesToTokenAmount` from another contract should never revert.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in `sharesToTokenAmount`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of potential division by zero in the `sharesToTokenAmount` function. It correctly explains the risks associated with this vulnerability, which aligns with Solidity best practices.

---

**[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

**Report Description**:  
In the function `removeLiquidity`, LP token holders cannot redeem their tokens when the pool is in the deficit state, i.e., `currentLiquidity << providedLiquidity`. This is due to LP shares being computed based on `providedLiquidity` and the actual available pool balance being based on `currentLiquidity`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of liquidity providers being unable to remove liquidity when the pool is in a deficit state. This is a significant vulnerability that is not covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-19] sharesToTokenAmount: Division by zero**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidityProviders unable to `removeLiquidity()`**
- **[M-01] Unsupported tokens cannot be withdrawn**
- **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**
- **[M-12] LiquidityProviders: Setting new LP token will break contract**
- **[M-17] Wrong condition checking in price calculation**
- **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

---

### **Conclusion**

The response list covers only one issue ([M-19]) correctly but misses several critical vulnerabilities identified in the issue report. The missed issues include significant risks such as share price manipulation, unsupported token withdrawals, and contract-breaking changes to the liquidity pool and LP token. These gaps highlight the need for a more comprehensive review of the smart contract to ensure all vulnerabilities are addressed.",1,0,6,5,"Okay, let's take a look at this smart contract and try to find any vulnerabilities. Hmm, the contract is called LiquidityProviders and it's using OpenZeppelin upgradeable contracts, which is good because they're generally secure. But let's dig deeper.

First, the contract has a modifier called onlyLiquidityPool which checks if the sender is the liquidityPool address. That makes sense for access control. But wait, are there any places where this could be bypassed? Let me check the functions that use this modifier. The increaseCurrentLiquidity and decreaseCurrentLiquidity functions are public and only callable by the liquidityPool. But those functions call private functions _increaseCurrentLiquidity and _decreaseCurrentLiquidity. The private functions modify the currentLiquidity mapping. Since the public functions are the only entry points and they have the modifier, that seems okay.

Next, looking at the tokenChecks modifier. It checks if the token is supported via _isSupportedToken which uses the tokenManager. So if the tokenManager is compromised or returns incorrect data, that could be an issue. But maybe that's outside the scope here. The modifier is used in addLPFee, addNativeLiquidity, addTokenLiquidity, etc. So if a token isn't supported, those functions should revert. Okay.

Now, looking at the addLPFee function. It adds to totalReserve and totalLPFees. But there's no check that _amount is valid. If the liquidityPool is malicious, maybe it can add arbitrary fees, but since onlyLiquidityPool can call this, maybe it's intended. But if the liquidityPool is compromised, this could be a problem. However, that's more of an external dependency.

In the _addLiquidity function, they mint an NFT and set initial data. Then _increaseLiquidity is called. Let's check _increaseLiquidity. It calculates mintedSharesAmount. If totalReserve is zero, it multiplies _amount by BASE_DIVISOR. Otherwise, it's (amount * totalSharesMinted) / totalReserve. Wait, when totalReserve is zero, they set mintedSharesAmount to BASE_DIVISOR * _amount. But if totalSharesMinted starts at zero, then this would set it to a large number. Wait, in _addLiquidity, when they first mint the NFT, the initial data is (token, 0, 0). Then in _increaseLiquidity, they check if totalReserve[token] is zero. So the first time, totalReserve is zero. So mintedSharesAmount is BASE_DIVISOR * _amount. Then totalSharesMinted[token] becomes that value. So the initial shares are proportional to the amount multiplied by 1e18. But when subsequent liquidity is added, the shares are calculated based on existing shares and reserves. That seems okay.

But wait, what if someone adds a very small amount first? Let's say _amount is 1 wei. Then totalSharesMinted becomes 1e18 * 1, which is 1e18. Then if another user adds a larger amount, like 1000 tokens, the shares would be (1000 * 1e18) / 1, which is 1e21. So the initial user would have a huge share. That could be an issue if the initial deposit is tiny, leading to disproportionate shares. But the require(mintedSharesAmount >= BASE_DIVISOR) is there. Wait, the first time, mintedSharesAmount is 1e18 * amount. So if the amount is 1, then mintedSharesAmount is 1e18, which meets the requirement. Then the next user adding 1 would get (1 * 1e18) / 1 = 1e18 shares. So the first user has 1e18 shares for 1 token, the second also 1e18 for 1 token. So their shares are proportional. Hmm, maybe that's okay. The initial calculation uses 1e18 * amount, which for the first deposit sets shares as amount * 1e18. Then subsequent deposits use the ratio. So maybe that's intended.

Now, looking at the removeLiquidity function. There's a part where they calculate eligibleLiquidity as sharesToTokenAmount(totalNFTShares, _tokenAddress). That converts the total shares of the NFT into tokens. Then they check if the nftSuppliedLiquidity is greater than eligibleLiquidity. If not, lpFeeAccumulated is eligibleLiquidity - nftSuppliedLiquidity. Then they subtract that from totalLPFees. Wait, but totalLPFees is a global variable. If multiple users are claiming fees, could there be an underflow here? For example, if totalLPFees is less than lpFeeAccumulated. Let's see: totalLPFees[_tokenAddress] -= lpFeeAccumulated. If lpFeeAccumulated is larger than totalLPFees, this would underflow. But when is lpFeeAccumulated calculated? It's eligibleLiquidity - nftSuppliedLiquidity. Eligible liquidity is (totalNFTShares * totalReserve) / totalSharesMinted. But totalReserve is total liquidity plus fees, maybe. Wait, totalReserve is increased when fees are added. So when a user removes liquidity, they can take their supplied amount plus their share of the fees. But if the calculation here allows lpFeeAccumulated to exceed totalLPFees, then subtracting would cause an underflow. But how?

Wait, let's think. totalLPFees is the total fees accumulated for the token. When a user claims their fee, their share is (eligibleLiquidity - suppliedLiquidity). But eligibleLiquidity is (totalNFTShares * totalReserve) / totalSharesMinted. totalReserve includes the totalLiquidity plus totalLPFees. So if the totalReserve is R = L + F, where L is totalLiquidity and F is totalLPFees. The eligibleLiquidity for the NFT is (shares / totalShares) * R. Then the user's supplied liquidity is S. So eligibleLiquidity - S = (shares/S_total) * R - S. But S is the user's supplied liquidity. Maybe there's a case where eligibleLiquidity is less than S, leading to a negative value. But the code checks if (nftSuppliedLiquidity > eligibleLiquidity), then lpFeeAccumulated is 0. Otherwise, it's eligibleLiquidity - nftSuppliedLiquidity. So that's safe. But how does that relate to totalLPFees? Let's say totalLPFees is F. When the user's eligible fee is (eligible - S), which is part of F. But the code subtracts that from totalLPFees. However, if multiple users are claiming, maybe the sum of all eligible fees could exceed F. For example, if two users each have eligible fees that add up to more than F. That would cause totalLPFees to underflow when subtracting the second user's fee. But how can that happen?

Because eligibleLiquidity is calculated as (totalNFTShares / totalSharesMinted) * totalReserve. But totalReserve is L + F. So eligibleLiquidity for each user is their share of the totalReserve, which includes both the liquidity and the fees. So when a user removes liquidity, they get their share of the totalReserve. But the totalLPFees is F. When they claim their fee, they are taking a part of F. However, if the sum of all (eligibleLiquidity - S) across all users exceeds F, then totalLPFees would underflow. Wait, let's see:

Suppose totalReserve is 100 (L=50, F=50). Suppose a user has shares such that eligibleLiquidity is 60. Their supplied liquidity S is 50. Then eligibleLiquidity - S is 10. So they take 10 from F. Now F becomes 40. But if another user also has eligibleLiquidity - S equal to 50, but F is now 40, subtracting 50 would cause underflow. But how could their eligibleLiquidity - S be 50 if F is 40? Because eligibleLiquidity is their share of totalReserve (which is L + F). If L is 50 and F is 40, totalReserve is 90. If their shares give them eligibleLiquidity of 90 (like they own all shares), then S is 50, so eligible - S is 40. So maybe the code prevents that. But perhaps in some edge cases, due to rounding or miscalculations, the sum of eligibleLiquidity - S across users could exceed totalLPFees. For example, if multiple users have fractions that add up to more than F.

This could happen if the eligibleLiquidity calculation allows for rounding up. For example, when calculating sharesToTokenAmount (which is (shares * totalReserve) / totalSharesMinted), if this rounds down, then eligibleLiquidity could be less than the actual value, but maybe in some cases, the sum of all (eligibleLiquidity - S) could exceed F. Let me think. Suppose totalReserve is 100, F is 50. User A has shares that give eligibleLiquidity of 60 (S=50), so fee is 10. User B has shares that give eligibleLiquidity of 55 (S=50), fee 5. Total fees claimed would be 15, but F is 50. So that's okay. But if totalReserve is 100 (F=50), and two users each have eligibleLiquidity of 75 (S=50 each), their fees would be 25 each. Total would be 50, which matches F. So maybe the code is safe here. Because the sum of eligibleLiquidity - S for all users is exactly F. So if each user's claim is their share of F, then totalLPFees can't underflow. But maybe due to integer division, some discrepancies could occur. For example, if a user's eligibleLiquidity is calculated as (shares * totalReserve) / totalSharesMinted, which could round down, but the actual fee might be a fraction. Then, when multiple users claim, the sum of their fees could be less than F, leaving some dust. But the code doesn't account for that. However, when the last user claims, the remaining F would be dust, which would be subtracted. But if the sum of all user fees is exactly F, then no problem. If due to rounding down, each user's fee is a little less, then F would have some leftover, but that's okay. The code allows for that. So maybe this part is safe. Hmm, not sure. Maybe this is a possible vulnerability. For example, if a user can claim more fees than are present in totalLPFees, causing an underflow. But according to the code, the eligibleLiquidity is calculated based on the user's shares and the totalReserve. So if totalReserve is L + F, and the user's eligibleLiquidity is (shares / totalShares) * (L + F), then eligibleLiquidity - S (their supplied liquidity) would be (shares / totalShares) * (L + F) - S. But S is their initial supplied liquidity, which is (shares / totalShares) * L. Wait, no. Because when the user adds liquidity, they get shares based on the existing reserves. So their S (supplied liquidity) is added to L, and shares are minted accordingly. So maybe S is not directly (shares / totalShares) * L. Hmm, perhaps the math here is more complex. Maybe there's a miscalculation in how the fees are being accounted for, leading to possible underflows in totalLPFees.

Another area to check is reentrancy. The contract uses ReentrancyGuardUpgradeable, so functions with nonReentrant should be safe. But let's check all external functions. For example, removeLiquidity has nonReentrant, so after burning shares and updating the state, it calls _transferFromLiquidityPool, which calls liquidityPool.transfer. If the liquidityPool's transfer function is a ERC20 which calls back into this contract, the nonReentrant modifier would prevent reentrancy. So that's probably safe.

Looking at the receive() function, which emits EthReceived. But there's no code to handle ETH sent here except emitting an event. If someone sends ETH directly to the contract, it would be stuck unless there's a way to recover it. But the contract doesn't have a function to withdraw ETH, except through the liquidity pool. So that's a possible issue if ETH gets stuck. But since the contract uses a liquidityPool to handle transfers, maybe it's intended. But if someone accidentally sends ETH here, it's lost. So that's a vulnerability—lack of a withdraw function for accidental ETH sends.

Another thing: when adding native liquidity, the code does a call to the liquidityPool with the msg.value. If the liquidityPool is a contract that doesn't handle ETH properly, this could fail. But the code checks if the call was successful. However, using call.value is generally not recommended because it forwards all gas. But since it's using .call{value: msg.value}(""""), which is okay, but the success is checked. So that's okay.

In the _transferFromLiquidityPool function, it calls liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount). If _tokenAddress is NATIVE (the ETH address), then liquidityPool's transfer function must handle ETH transfers. But if the liquidityPool expects a token address and uses it for ERC20 transfers, sending NATIVE (which is a fake address) might cause issues. For example, if the liquidityPool's transfer function uses IERC20(_token).transfer, but for NATIVE, that address isn't a real ERC20, so the call would fail. So this depends on how the liquidityPool is implemented. If the liquidityPool handles NATIVE correctly (i.e., uses address(0) or a specific check for ETH), then it's okay. But if not, then transferring ETH via this function would fail. However, this contract's code assumes that the liquidityPool can handle it, since in addNativeLiquidity, they send ETH to the liquidityPool. So maybe this is an external dependency issue, but not a vulnerability in this contract itself.

Looking at the getTokenPriceInLPShares function: if totalReserve is zero, it returns BASE_DIVISOR. But when totalReserve is zero, totalSharesMinted is also zero (since when the first liquidity is added, totalSharesMinted is set to BASE_DIVISOR * amount, and totalReserve is set to amount). Wait, no. When the first liquidity is added, totalReserve becomes _amount (from _addLiquidity calling _increaseLiquidity). In _increaseLiquidity, if totalReserve[token] ==0, then mintedSharesAmount is BASE_DIVISOR * _amount. Then totalReserve[token] += _amount (so it's _amount). So totalSharesMinted becomes BASE_DIVISOR * _amount. So getTokenPriceInLPShares would be (BASE_DIVISOR * _amount) / _amount = BASE_DIVISOR. Which is correct. So if totalReserve is zero (which shouldn't happen once liquidity is added), the function returns BASE_DIVISOR. But if totalReserve is zero and someone calls this function, it would return BASE_DIVISOR. But that scenario would only occur if no liquidity has been added yet. Maybe not a problem.

In the sharesToTokenAmount function, it's (shares * totalReserve) / totalSharesMinted. If totalSharesMinted is zero, this would cause a division by zero. But when is totalSharesMinted zero? Only if no liquidity has been added for that token. The function is called in getFeeAccumulatedOnNft and removeLiquidity. So if an NFT exists for a token that has no shares (which should not happen because when you add liquidity, you mint shares), then this could revert. But the modifiers check that the NFT exists and is owned by the caller. So if the NFT was created but no shares were minted, which shouldn't happen because in _addLiquidity, when adding the first liquidity, shares are minted. So maybe division by zero isn't possible here.

Another thing: the _burnSharesFromNft function updates the NFT's metadata by subtracting _shares and _tokenAmount. But if _shares is larger than the NFT's shares, or _tokenAmount is larger than the NFT's supplied liquidity, this would underflow. However, the function is called in removeLiquidity and claimFee. In removeLiquidity, lpSharesToBurn is calculated as lpSharesForInputAmount + lpSharesRepresentingFee. lpSharesForInputAmount is _amount * getTokenPriceInLPShares. getTokenPrice is totalSharesMinted / totalReserve. So if _amount is <= the NFT's supplied liquidity, and the calculations are correct, then the shares to burn should be <= the NFT's total shares. But if due to rounding errors, this could be an issue. For example, if the calculation of lpSharesToBurn is one more than the actual available shares. But the code has a check: if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR), then they set lpSharesToBurn = totalNFTShares. Wait, in removeLiquidity, after calculating lpSharesToBurn, there's a check:

if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
    lpSharesToBurn = totalNFTShares;
}

So if after burning lpSharesToBurn, the remaining shares are less than BASE_DIVISOR (1e18), then they burn all shares. That's to prevent dust amounts. But when burning all shares, then the _tokenAmount (supplied liquidity) must also be adjusted. Wait, in this case, _tokenAmount is _amount (the amount being removed). But if we burn all shares, then the _tokenAmount should be the entire supplied liquidity. But the code allows the user to specify any _amount <= nftSuppliedLiquidity. However, if after burning, the remaining shares are less than 1e18, the code burns all. So in that case, the user's entire position is burned, and they receive the entire eligibleLiquidity (supplied + fees). But this could lead to the user getting more than they intended if the shares are burned completely. Let's see: Suppose a user has 2e18 shares, and they try to remove an amount that requires burning 1.5e18 shares. Then after burning, the remaining shares would be 0.5e18, which is less than 1e18. So the code would burn all 2e18 shares. But then the user's _amount is part of their supplied liquidity. Wait, the code sets lpSharesToBurn to totalNFTShares, so the _tokenAmount (which is _amount) must be equal to the nftSuppliedLiquidity. Otherwise, there's inconsistency. Because if all shares are burned, then the eligibleLiquidity is totalNFTShares * totalReserve / totalSharesMinted, which would be (totalSharesMinted * totalReserve) / totalSharesMinted = totalReserve. But the user's supplied liquidity is part of the totalLiquidity. This part is confusing. Let's consider an example:

Suppose totalSharesMinted is 1e20, totalReserve is 100. So price per share is 100 / 1e20 = 1e-18 per share. If an NFT has 1e18 shares, eligibleLiquidity is 1e18 * 100 / 1e20 = 1. So the user's supplied liquidity is S. If the user tries to remove _amount = 0.5, which is less than S (assuming S is 0.5). The shares needed would be 0.5 * 1e20 / 100 = 5e17. Then after burning 5e17, remaining shares are 5e17, which is less than 1e18. So the code would burn all 1e18 shares. But then the user's _amount is 0.5, but they end up burning all shares and withdrawing eligibleLiquidity (1) instead of 0.5 + fee. This would cause the user to receive more than they intended. But how does the code handle this?

In removeLiquidity, after burning the shares, the code subtracts _amount from totalLiquidity and lpSharesToBurn from totalSharesMinted. If lpSharesToBurn is set to totalNFTShares, then the code would set _amount to nftSuppliedLiquidity. But wait, in the code, after burning, the NFT's supplied liquidity is set to nftSuppliedLiquidity -= _tokenAmount. But if _tokenAmount is less than the total, but all shares are burned, this would result in underflow. Wait, let me check:

In the code:

nftSuppliedLiquidity -= _tokenAmount;

But if _tokenAmount is, say, 50, and nftSuppliedLiquidity is 100, then after subtracting 50, it becomes 50. But if all shares are burned (due to remaining shares < 1e18), then lpSharesToBurn is totalNFTShares. But _tokenAmount is the original _amount passed to removeLiquidity, which the user specified. So in this scenario, if the user tries to remove 50, but due to shares being burned completely, the code would subtract 50 from nftSuppliedLiquidity, but the shares are all gone. Then the NFT's metadata would have nftSuppliedLiquidity = 50 and nftShares = 0, which is invalid. Because if shares are zero, the supplied liquidity should also be zero. This seems like a logical error. So in this case, burning all shares but only subtracting part of the supplied liquidity would leave the NFT in an inconsistent state. The NFT would have positive supplied liquidity but zero shares. Which is a problem because when claiming fees, it would calculate eligibleLiquidity as zero (since shares are zero), leading to fees being zero. But the supplied liquidity is still 50. So this is a bug.

So the vulnerability here is that when the remaining shares after burning are less than BASE_DIVISOR, the code burns all shares but does not adjust the _tokenAmount to be the full nftSuppliedLiquidity. This results in the NFT's supplied liquidity being incorrect (non-zero) while the shares are zero. This inconsistency can lead to incorrect fee calculations and potential loss of funds.

Another issue: in the removeLiquidity function, when the code does:

uint256 amountToWithdraw = _amount + lpFeeAccumulated;

But if the user is allowed to withdraw _amount, which is part of their supplied liquidity, plus the fee accumulated. However, the totalReserve is decreased by amountToWithdraw. But totalReserve is supposed to be the sum of totalLiquidity and totalLPFees. So when a user withdraws, the amountToWithdraw should be covered by the totalReserve. But if the calculations are wrong, this could lead to underflow in totalReserve. However, the code has:

totalReserve[_tokenAddress] -= amountToWithdraw;

But amountToWithdraw is _amount (part of the supplied liquidity) plus lpFeeAccumulated (part of the fees). The totalReserve is totalLiquidity + totalLPFees. So subtracting amountToWithdraw (which is _amount + lpFee) would correctly reduce totalReserve by that sum. Then totalLiquidity is reduced by _amount, and totalLPFees is reduced by lpFee. So that part seems correct.

Another possible issue: in the claimFee function, when calculating eligibleLiquidity, it's sharesToTokenAmount(totalNFTShares, _tokenAddress). But in claimFee, the code does not check if the user's eligibleLiquidity is actually part of the fees. For example, if the eligibleLiquidity is greater than the totalLPFees, then subtracting lpFeeAccumulated from totalLPFees would underflow. Let's see: totalLPFees is a global variable. When a user claims fees, lpFeeAccumulated is eligibleLiquidity - nftSuppliedLiquidity. But eligibleLiquidity is sharesToTokenAmount(totalNFTShares, _tokenAddress). If eligibleLiquidity is greater than totalReserve, that can't happen because sharesToTokenAmount is (totalNFTShares * totalReserve) / totalSharesMinted. Since totalNFTShares <= totalSharesMinted, eligibleLiquidity can't exceed totalReserve. But totalLPFees is part of totalReserve (totalReserve = totalLiquidity + totalLPFees). So eligibleLiquidity - nftSuppliedLiquidity is the user's share of the fees. But if multiple users claim, their shares could add up to more than totalLPFees. Wait, but the sum of all (eligibleLiquidity - nftSuppliedLiquidity) across all NFTs should be equal to totalLPFees. Because eligibleLiquidity is (shares / totalShares) * (L + F). And nftSuppliedLiquidity is the user's contribution to L. So (eligibleLiquidity - S) = (shares / totalShares) * (L + F) - S. But S is (shares / totalShares) * L. So (eligibleLiquidity - S) = (shares / totalShares) * F. So the sum of all (eligibleLiquidity - S) across all users would be F. Therefore, when users claim their fees, the sum of their claimed fees would exactly be F. So totalLPFees should not underflow. But if there's a rounding error in the calculation, maybe some users can claim slightly more, leading to underflow. For example, if (shares * F) / totalShares rounds down, but when summed across all users, it's less than F, leaving some dust. But in the code, when a user claims, they take eligibleLiquidity - S, which is (shares * F) / totalShares. If this is rounded down, then the total claimed would be less than F. However, in the code, when the last user claims, the remaining F would be exactly the calculated amount. So maybe this is safe. But if the code uses division before multiplication, it could lead to inaccuracies. Let's see: in sharesToTokenAmount, it's (shares * totalReserve) / totalSharesMinted. So the order is multiply then divide. Which can lead to truncation. But the eligibleLiquidity is calculated correctly as per the user's share of the totalReserve. So if eligibleLiquidity is S + (shares / totalShares * F), then subtracting S gives (shares / totalShares * F). So the sum of all (eligibleLiquidity - S) is F. So each user's claim is a portion of F. Therefore, when claiming, the code should not underflow totalLPFees. So this part seems safe.

Another potential issue: the getFeeAccumulatedOnNft function returns eligibleLiquidity - nftSuppliedLiquidity if nftSuppliedLiquidity <= eligibleLiquidity, else 0. But eligibleLiquidity is based on the current totalReserve and totalSharesMinted. However, if the user's supplied liquidity (nftSuppliedLiquidity) is higher than eligibleLiquidity, which could happen if the pool lost funds (e.g., due to a hack or slippage), then the user's fee would be zero. But this is a design decision rather than a vulnerability.

Looking at the ERC2771ContextUpgradeable, which is for meta transactions. The contract uses _msgSender() which handles the trusted forwarder. However, if the trusted forwarder is malicious or compromised, it could spoof the sender. But the contract's owner sets the trusted forwarder, so if that's set incorrectly, it's a problem. But that's an admin risk, not a code vulnerability.

In the increaseTokenLiquidity function, they check if the token is supported via _isSupportedToken(token), but token is retrieved from the NFT's metadata. So if the token was once supported but is now unsupported, the function would revert. Which is correct.

Now, checking for access control issues. The functions like setLpToken, setTokenManager, setLiquidityPool are onlyOwner, which is correct. The initialize function is initializer, so it can only be called once. But since it's using the upgradeable pattern, the owner could be a proxy admin, but that's outside the contract's scope.

Another thing: the Pausable contract's __Pausable_init is called with _pauser. The Pausable contract from ""../security/Pausable.sol"" is not shown here, but assuming it's similar to OpenZeppelin's, the pauser can pause the contract. If the pauser is compromised, they can pause the contract, which is a centralization risk but not a code vulnerability.

In the _increaseLiquidity function, they call whiteListPeriodManager.beforeLiquidityAddition. If this function call fails, the whole transaction reverts. But that's intended.

Possible rounding errors: in several places, divisions and multiplications can lead to truncation. For example, when minting shares in _increaseLiquidity:

mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];

If (_amount * totalSharesMinted) is not perfectly divisible by totalReserve, the mintedSharesAmount is truncated. This means the user may get slightly fewer shares than expected, leading to tiny losses. But this is a common issue in liquidity pools and is usually handled by requiring a minimum amount. The code has require(mintedSharesAmount >= BASE_DIVISOR), which ensures that at least 1e18 shares are minted. But this is only checked in the _increaseLiquidity function. So when adding initial liquidity, the first user must add enough to get at least 1e18 shares, which would require _amount >= 1 (since 1 * 1e18 >= 1e18). But if the token has decimals different from 18, this could be an issue. For example, a token with 6 decimals: adding 1e6 tokens would result in 1e18 * 1e6 = 1e24 shares. The require would pass. So that's okay.

Other issues: The code uses unchecked blocks in a few places. For example, when calculating lpFeeAccumulated as eligibleLiquidity - nftSuppliedLiquidity, it's in an unchecked block. But since the code first checks if nftSuppliedLiquidity > eligibleLiquidity, else it does the subtraction. So the unchecked is safe here. But in Solidity 0.8.x, underflow/overflow checks are enabled by default, so using unchecked is okay if the code ensures it's safe.

Another thing: the tokenMetadata in lpToken is stored as a struct with token, suppliedLiquidity, and shares. When updating the metadata in _burnSharesFromNft, it subtracts _shares and _tokenAmount. But if _shares exceeds the shares in the NFT, it would underflow. However, the code calculates lpSharesToBurn based on the NFT's shares, so this shouldn't happen. For example, in removeLiquidity, lpSharesToBurn is lpSharesForInputAmount + lpSharesRepresentingFee. But lpSharesForInputAmount is _amount * getTokenPriceInLPShares, which is (_amount * totalSharesMinted) / totalReserve. Since totalReserve is totalLiquidity + totalLPFees, and the user's _amount is <= their supplied liquidity, which is part of totalLiquidity, then lpSharesForInputAmount would be <= the NFT's shares. Similarly, lpSharesRepresentingFee is calculated as eligibleLiquidity - nftSuppliedLiquidity multiplied by getTokenPriceInLPShares. But this is capped by the NFT's remaining shares. So lpSharesToBurn should not exceed the NFT's total shares. But the code has the check for (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) which can set lpSharesToBurn to totalNFTShares. So if the initial calculation allows lpSharesToBurn to be up to totalNFTShares, then it's safe.

In summary, the vulnerabilities I can identify are:

1. **Inconsistent State When Burning All Shares in removeLiquidity**: When the remaining shares after a partial burn are less than BASE_DIVISOR, the code burns all shares but subtracts only the specified _amount from the NFT's supplied liquidity, leading to an inconsistent state where the NFT has positive supplied liquidity but zero shares. This can cause incorrect fee calculations and potential loss of funds.

2. **ETH Handling and Locked Ether**: The contract's receive() function allows ETH to be sent directly, but there's no way to recover it except through the liquidity pool. If ETH is mistakenly sent to the contract without using the addNativeLiquidity function, it becomes locked.

3. **Potential Division by Zero in sharesToTokenAmount**: If totalSharesMinted is zero for a token, calling sharesToTokenAmount would cause a division by zero. However, given the checks in _increaseLiquidity, this scenario should not occur under normal operation, but if a token is somehow added without initializing shares, this could be a problem.

4. **Rounding Errors Leading to Dust**: Due to integer division in share calculations, users might receive slightly fewer shares than expected when adding liquidity, leading to dust amounts. However, this is a common issue in liquidity pools and is partially mitigated by requiring a minimum share amount.

5. **Underflow in totalLPFees During Fee Claim**: If the sum of eligible fees across users exceeds totalLPFees due to a miscalculation, it could cause an underflow. However, based on the calculations, this should not happen under normal circumstances.","```
1. Potential Division by Zero in `sharesToTokenAmount`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Division by Zero in `sharesToTokenAmount`"".
   - This appears at rank 3 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.333 \).

**Output**:
```
0.333
```",0.333
LiquidityFarming.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691.0,373.0,"[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased
When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards. In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.
However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.
There is no way for the user to get back this `unpaidRewards` anymore
  [H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss
“function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) ”,  the accTokenPerShare is calculated based on the total staked shares.
  [M-04] Owners have absolute control over protocol
Owners have full control over the protocol.
 
[M-06] DoS by gas limit
In `deposit` function it is possible to push to nftIdsStaked of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.
  [M-10] Call to non-existing contracts returns success
Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed).
This makes a user be able to send his funds to non-existing addresses.
  [M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases
In the current implementation of `withdraw()`, it calls `_sendRewardsForNft()` at L243 which calls `updatePool()` at L129 which calls `getUpdatedAccTokenPerShare()` at L319.
`getUpdatedAccTokenPerShare()` will loop over `rewardRateLog` to calculate an up to date value of accTokenPerShare.",6.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    
    mapping(address => PoolInfo) public poolInfo;

    
    mapping(uint256 => NFTInfo) public nftInfo;

    
    

    
    mapping(address => address) public rewardTokens;

    
    mapping(address => uint256[]) public nftIdsStaked;

    
    mapping(address => uint256) public totalSharesStaked;

    
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    
    
    
    
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    
    
    
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    
    
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    
    
    
    
    
    
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    
    
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    
    
    
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    
    
    
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    
    
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        
        
        
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    
    
    
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    
    
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    
    
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3032.0,2,4,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Typo in `initalizeRewardPool` Function (Critical Severity)**  
   The function `initalizeRewardPool` is misspelled (missing the second 'i' in ""initialize""), which prevents proper initialization of reward pools. This typo would block the setup of critical parameters (`rewardTokens`), rendering the contract non-functional for staking in uninitialized pools.

2. **Precision Loss in Stake Accounting (High Severity)**  
   When calculating `amount` for staking (via division by `BASE_DIVISOR`), truncation occurs before summing into `totalSharesStaked`. This understates the total shares, leading to inflated `accTokenPerShare` and excessive reward distribution. For example, staking 1.5e18 tokens (divided to 1) results in higher per-share rewards than deserved.

3. **Unchecked Arithmetic in Reward Accumulation (High Severity)**  
   The `getUpdatedAccTokenPerShare` function uses `unchecked` for accumulator updates. A large `rewardsPerSecond` or time delta could cause integer overflow, corrupting reward calculations and enabling incorrect reward payouts.

4. **Over-issuance of Rewards Due to Truncated Total Shares (High Severity)**  
   The sum of individually truncated `amount / BASE_DIVISOR` values in `totalSharesStaked` results in a lower denominator for reward distribution. This inflates rewards per share, allowing users to claim more rewards than their actual proportional stake.

5. **Centralization Risk in `reclaimTokens` (Low Severity)**  
   The `reclaimTokens` function allows the owner to withdraw arbitrary tokens, including reward funds. While intended, this poses a centralization risk if the owner acts maliciously.

6. **Incorrect Reward Pool Initialization (Critical Severity)**  
   Due to the typo in `initalizeRewardPool`, reward pools cannot be initialized correctly, causing dependent functions (e.g., `deposit`) to revert and rendering the contract unusable for intended purposes.

**Summary of Key Issues:**  
- The misspelled initialization function and truncation errors critically undermine the contract's functionality and reward distribution integrity.  
- Unchecked arithmetic and improper stake summation lead to exploitable reward over-issuance.  
- Centralized control over funds poses trust risks but is an inherent design choice.","### **Output**

---

**[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased**

**Report Description**:  
When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` is invoked to send rewards. If `address(this).balance` is insufficient, `nft.unpaidRewards = pending - balance` is recorded for future retrieval. However, at L244, the entire `nftInfo` is deleted, erasing `nft.unpaidRewards`. This permanently prevents users from reclaiming their unpaid rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of deleting `nftInfo` and its impact on `unpaidRewards`. This is a critical oversight, as it directly affects user funds and contract integrity.

---

**[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Report Description**:  
In `getUpdatedAccTokenPerShare(address _baseToken)`, `accTokenPerShare` is calculated based on total staked shares. Precision loss occurs when the total shares are too large, leading to significant or total loss of rewards for users.

**Match in Response List**:  
Matches with the issue titled **""Precision Loss in Stake Accounting""**.

**Validation**:  
**Partially Correct**. The response identifies precision loss in stake accounting but focuses on truncation during division by `BASE_DIVISOR`. It does not explicitly address the impact of large total shares on `accTokenPerShare` and reward distribution, which is the core issue in the report.

---

**[M-04] Owners have absolute control over protocol**

**Report Description**:  
Owners have full control over the protocol, posing a centralization risk.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risk in `reclaimTokens`""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk associated with owner control, specifically mentioning the `reclaimTokens` function. This aligns with the issue report's concern about absolute owner control.

---

**[M-06] DoS by gas limit**

**Report Description**:  
In the `deposit` function, an attacker can push too many NFTs to another user's `nftIdsStaked`. When the user attempts to withdraw an NFT at the end of the list, the iteration may revert due to gas limits, causing a denial of service.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the DoS risk caused by unbounded iterations in the `deposit` function. This is a significant oversight, as it directly impacts contract usability and security.

---

**[M-10] Call to non-existing contracts returns success**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, `staticcall`) return success if the called contract doesn’t exist (not deployed or destructed). This allows users to send funds to non-existing addresses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of low-level calls returning success for non-existing contracts. This is a critical vulnerability, as it can lead to permanent loss of funds.

---

**[M-14] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases**

**Report Description**:  
In `withdraw()`, `_sendRewardsForNft()` calls `updatePool()`, which calls `getUpdatedAccTokenPerShare()`. The latter loops over `rewardRateLog` to calculate `accTokenPerShare`. Unbounded loops can freeze users' funds in edge cases.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unbounded loops in `getUpdatedAccTokenPerShare()`. This is a significant oversight, as it directly impacts contract performance and user funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] Owners have absolute control over protocol**

**Partially Correct Matches**:

- **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Missed Issues from Issue Report**:

- **[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased**
- **[M-06] DoS by gas limit**
- **[M-10] Call to non-existing contracts returns success**
- **[M-14] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases**

--- 

The response list fails to address several critical and medium-severity issues, particularly those related to fund loss, DoS risks, and unbounded loops. While it correctly identifies centralization risks and partially addresses precision loss, significant gaps remain in coverage and accuracy.",1,1,4,6,"Okay, let's try to analyze this smart contract for vulnerabilities. I'm a bit new to this, so I'll take it step by step.

First, I'll look at the overall structure. The contract is called HyphenLiquidityFarming and uses several OpenZeppelin upgradeable contracts like ReentrancyGuardUpgradeable, OwnableUpgradeable, etc. It also implements IERC721ReceiverUpgradeable, which means it can receive ERC721 tokens. 

Looking at the state variables, there are mappings for poolInfo, nftInfo, rewardTokens, nftIdsStaked, totalSharesStaked, and rewardRateLog. The main functionalities seem to be staking NFTs, accumulating rewards, and withdrawing.

Possible vulnerabilities to check for include reentrancy, access control issues, arithmetic issues, incorrect state updates, and logical errors.

Starting with reentrancy: The contract uses ReentrancyGuardUpgradeable, and the functions deposit, withdraw, extractRewards, and reclaimTokens have the nonReentrant modifier. That should prevent reentrancy attacks in those functions. However, need to check if there are any external calls that could be used for reentrancy before state changes. For example, in _sendRewardsForNft, there's a call to transfer native tokens or ERC20. Since nonReentrant is on withdraw, which calls _sendRewardsForNft, maybe that's covered. But if another function without nonReentrant calls _sendRewardsForNft, that could be a problem. Let me check. The extractRewards function calls _sendRewardsForNft and has nonReentrant, so that's okay. The withdraw function also does. So maybe reentrancy is covered here.

Next, access control. The initialize function is called once, and initalizeRewardPool (note the typo in ""initalize"") is onlyOwner. But wait, there's a function called initalizeRewardPool (spelled wrong). Is that a typo? If someone can call initializeRewardPool again, but the function has a require that checks if rewardTokens[_baseToken] is address(0), so once set, it can't be called again. But maybe the typo doesn't affect since it's a function name. However, that's a possible mistake. The function is supposed to be initializeRewardPool, but the typo could lead to issues if the correct function isn't called. But since it's a separate function, maybe not a vulnerability, but a typo. But as a user, maybe the owner could call it again if the name is different. Wait, the function is named initalizeRewardPool (missing an 'i'), so maybe it's a mistake. If that's the case, perhaps the intended function initializeRewardPool isn't properly named, leading to the function not being called correctly. But the current function has onlyOwner, so maybe not a vulnerability, but a code error. However, in terms of vulnerabilities, this might be a high severity issue if the function was supposed to have a different name and is misspelled, leading to uninitialized pools. Wait, the function initalizeRewardPool checks if the reward token is address(0), so each base token can be initialized once. But if the function is named incorrectly, the owner might not be able to initialize the reward pool properly. But in the code given, the function is named correctly? Let me check the code: the function is spelled 'initalizeRewardPool' (missing the second 'i' in 'initialize'). That's a typo. So the function name is incorrect, which could mean that the owner cannot properly initialize reward pools because the function is not named correctly. Wait, but the code as written has the function as 'initalizeRewardPool', which is a typo. This would prevent the owner from initializing the reward pools unless they call the misspelled function. That's a critical issue because the function cannot be called as intended. But in the given code, is that the case? Let me check again. The code defines the function as 'initalizeRewardPool' (instead of 'initializeRewardPool'), so yes, that's a typo. Therefore, the owner might not be able to initialize reward pools correctly, leading to pools not being initialized, which would cause other functions to fail since they require the reward token to be set. So this is a critical vulnerability because it's a typo in the function name, making it impossible to initialize reward pools properly. That's a big problem.

Another access control issue: the reclaimTokens function is onlyOwner, which allows the owner to withdraw any tokens, including reward tokens. That's intended, but in some cases, it could be a centralization risk. However, since the contract is Ownable, that's by design. But if the reward tokens are supposed to be only sent to users, the owner could drain them. That's a potential issue if the owner is malicious, but it's an admin function, so not a vulnerability per se, but a centralization risk.

Next, arithmetic issues: The contract uses SafeERC20Upgradeable, which is good. Division is done in several places, like amount /= liquidityProviders.BASE_DIVISOR(). Need to check if division before multiplication can lead to precision loss. For example, when amount is divided by BASE_DIVISOR, and then multiplied by accTokenPerShare. If BASE_DIVISOR is a value like 1e18, dividing first could lead to truncation, reducing the precision. For example, if amount is 1e18 and BASE_DIVISOR is 1e18, it becomes 1, but if amount is 1.5e18, it becomes 1.5, but in Solidity, it would truncate to 1. So if the division is done before multiplication, it could lead to loss of precision. Let's check where this is used. In _sendRewardsForNft, the amount is divided by BASE_DIVISOR, then multiplied by pool.accTokenPerShare. If the division is done first, that could result in loss of precision. This is a possible vulnerability because users might not get the correct amount of rewards due to truncation in integer division. For example, if a user's amount is 1.999e18, dividing by 1e18 gives 1, which is a loss of 0.999e18. That's a significant issue. Therefore, the division should be done after multiplication. So the calculation (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION would be better done with the division as the last step. Wait, but the code does (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION, where amount is already divided by BASE_DIVISOR. So if the original amount was in higher precision (e.g., 1e18), dividing by BASE_DIVISOR (which is probably 1e18) gives 1. But if there's any remainder, it's lost. So this could lead to under-accounting of rewards. For example, if a user has 1.5e18 tokens, and BASE_DIVISOR is 1e18, then amount becomes 1.5, but in Solidity, since it's integer division, 1.5e18 / 1e18 would be 1. So the 0.5e18 is lost. Then when multiplied by accTokenPerShare, which is per share, the rewards would be based on the truncated amount. This is a precision loss vulnerability. Thus, users who deposit amounts that are not exact multiples of BASE_DIVISOR would lose precision in their reward calculations. This could lead to loss of rewards for users, which is a medium severity issue.

Another arithmetic issue: in the getUpdatedAccTokenPerShare function, there's a loop over the rewardRateLog entries. The code uses unchecked blocks for accumulator += rewardRateLog[...] * (counter - max(...)). If the reward rates are high and multiplied by large time differences, could this cause an overflow? Since Solidity 0.8.0 has default overflow checks, but the code uses an unchecked block. Wait, looking at the code:

In getUpdatedAccTokenPerShare:

unchecked {
    accumulator +=
        rewardRateLog[_baseToken][i].rewardsPerSecond *
        (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
}

Wait, the code uses unchecked here. So if the multiplication or the addition overflows, it will wrap around, which is a problem. Since accumulator is a uint256, but if rewardsPerSecond is very large and multiplied by a large time delta, the product could exceed 2^256 -1, causing an overflow and incorrect accumulator value. This would be a critical vulnerability, as rewards calculations would be wrong. For example, if rewardsPerSecond is 1e36 and time delta is 1e6 seconds, the product is 1e42, which is way larger than 2^256 (which is ~1e77). Wait, 2^256 is approximately 1.1e77, so 1e42 is way under. But depending on how the rewards are set, it's possible. If the owner sets a very high rewardPerSecond, this could overflow. Since the code is using Solidity 0.8.0, which has built-in overflow checks except in unchecked blocks, the code here is using unchecked, which disables the checks. So if there's an overflow here, it would cause incorrect calculations. This is a potential vulnerability. Therefore, the code should avoid using unchecked here or ensure that the reward rates and time deltas cannot cause overflow. However, given that the owner controls rewardPerSecond, they can set it to a value that could cause overflow, leading to incorrect reward calculations. This is a high severity issue.

Another possible issue: in the withdraw function, after finding the index of the NFT in nftIdsStaked[msgSender], the code does:

nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
nftIdsStaked[msgSender].pop();

This is a standard way to delete an element from an array without leaving gaps. However, if the array has only one element, then after popping, the array is empty. But what if the same NFT is added multiple times? Wait, no, because when you deposit, the code checks that the NFT is not already staked. So each NFT can only be staked once. So the array should not have duplicates. Therefore, this part is safe.

Another issue: in _sendRewardsForNft, when the reward token is NATIVE, the code checks if pending > balance. If so, sends the balance and sets unpaidRewards to pending - balance. However, pending is calculated as ((amount * pool.accTokenPerShare) / ... ) - ... + unpaidRewards. If the contract's balance is less than pending, then the user gets the current balance, and the rest is added to unpaidRewards. But if the contract never receives enough funds, the user's unpaidRewards will keep increasing, but they can't get them. This is a design choice, but could lead to users not being able to claim their full rewards if the contract is underfunded. However, the owner could top it up. Not sure if this is a vulnerability, but it's a potential issue if the contract doesn't have sufficient funds.

In the same function, when dealing with ERC20 rewards, the code does a similar check: if pending > balance, send balance, else send pending. However, the code uses _sendErc20AndGetSentAmount, which sends the balance. But if the ERC20 token has a fee on transfer, the received amount might be less than the sent amount, but the code calculates the difference between the recipient's balance before and after. That's correct because it uses the actual transferred amount. So that's handled properly.

Another possible issue: the updatePool function is public and can be called by anyone. This is intentional to ensure that the pool's accTokenPerShare is up to date. But if it's called frequently, it could incur gas costs. However, this is a normal design in farming contracts.

Check for front-running: The deposit and withdraw functions update the pool before modifying the user's stake. That's correct because they call updatePool before updating the user's rewardDebt. So front-running shouldn't affect reward calculations.

Check for incorrect reward distribution: The rewardDebt is calculated as (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION. When the user deposits, the rewardDebt is set based on the current accTokenPerShare, which is correct. When they withdraw, they get the difference between the current accTokenPerShare and their rewardDebt, plus unpaidRewards. That logic seems correct.

Possible issue in getUpdatedAccTokenPerShare: The loop starts from the last entry in rewardRateLog and goes backward. The code uses 'i' as the index and decrements it. Let's see:

The function is supposed to calculate the accumulated rewards since the last update. The code does:

uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
uint256 counter = block.timestamp;
uint256 i = rewardRateLog[_baseToken].length - 1;
while (true) {
    if (lastUpdatedTime >= counter) {
        break;
    }
    unchecked {
        accumulator +=
            rewardRateLog[_baseToken][i].rewardsPerSecond *
            (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
    }
    counter = rewardRateLog[_baseToken][i].timestamp;
    if (i == 0) {
        break;
    }
    --i;
}

Wait, the entries in rewardRateLog are stored with timestamps. The latest entry is the last one. So when the reward rate changes over time, each entry has a timestamp. The code is trying to accumulate rewards from the oldest to the newest? Or the other way around?

Wait, the loop starts at the last index (most recent entry) and goes backward to older entries. For each entry, it checks the time between the entry's timestamp and the current counter (which is initially block.timestamp). If the entry's timestamp is before the lastUpdatedTime, then the max is lastUpdatedTime, so the delta is counter - lastUpdatedTime. Otherwise, it's counter - entry's timestamp. Then the counter is set to the entry's timestamp, moving backward in time.

But if the entry's timestamp is after the lastUpdatedTime, then the time period between entry's timestamp and counter (block.timestamp) is covered by the current reward rate. Then, moving to the previous entry, the counter is set to the current entry's timestamp, so the next iteration covers from that timestamp to the next entry.

Wait, maybe the logic is correct. Suppose we have multiple reward rate changes over time. The code accumulates the rewards from the most recent rate backward. Each entry in rewardRateLog has a timestamp indicating when that rate started. The code calculates how much time each rate was active since the last pool update.

For example, if the last update was at time T0, and there are two rate changes at T1 and T2 (where T1 < T2 < now), then the code would first calculate the time from now to T2, using the rate at T2. Then from T2 to T1, using the rate at T1. Then from T1 to T0, but since T0 is the last update time, if T1 is before T0, the time period would be T0 to T1, but since T0 is the last update, the delta would be zero. Wait, maybe not. Let's take an example:

Assume:

lastUpdatedTime = 1000

Now (block.timestamp) = 2000

rewardRateLog entries:

index 0: timestamp=500, rate=100

index 1: timestamp=1500, rate=200

So the rewardRateLog is ordered with increasing timestamps. The current code starts at i=1 (last entry). counter = 2000.

Check if lastUpdatedTime (1000) >= counter (2000) → no. So proceed.

Compute delta = counter (2000) - max(1000, 1500) → max is 1500. delta = 2000 -1500=500.

accumulator += 200 *500 = 100,000.

Then, counter = 1500.

Now i=0. Check if lastUpdatedTime (1000) >= counter (1500) → no.

delta = 1500 - max(1000, 500) → max is 1000. delta=1500 -1000=500.

accumulator += 100 *500 =50,000 → total 150,000.

Then, counter =500. i becomes -1 (but since i is uint256, underflow would occur). Wait, no. The loop has a check if i==0, then break. After i is decremented (i was 0, then --i would underflow, but in Solidity 0.8, that would revert. Wait, no. The code is in a while(true) loop, and after processing i=0, it checks if i==0, then breaks. Let's see:

Starting with i=1 (second entry), after processing, counter becomes 1500, i is decremented to 0. Then, the loop continues. The code processes i=0, then checks if i==0 → yes, breaks. So in the example, the loop would process both entries.

But in the case where an entry's timestamp is before the lastUpdatedTime, like:

lastUpdatedTime = 1000.

An entry at timestamp 800. Then, when calculating delta, it's counter (say, 2000) - max(1000, 800) → 1000. So delta is 2000-1000=1000. But the entry's timestamp is 800, which is before the lastUpdatedTime (1000). So the active period for that entry would be from 800 to 1000, but since the lastUpdatedTime is 1000, the delta is 1000 (from 1000 to 2000). Wait, no. The entry's timestamp is when the rate was set. So the rate applies from the timestamp onwards, until the next rate change. But if the lastUpdatedTime is 1000, and the current entry's timestamp is 800, then the rate from 800 to the next entry's timestamp (say 1500) would be active. But between 1000 and 1500, the rate at 800 is active. Wait, maybe the code is not correctly accounting for the time periods.

Alternatively, the code may have a flaw in calculating the correct time intervals for each reward rate, leading to incorrect reward accumulation. For example, if the lastUpdatedTime is 1000, and there's a reward rate entry with timestamp 800, the code would consider the time between max(800, 1000) = 1000 and the next entry's timestamp. But if there's no next entry, it would consider from 1000 to block.timestamp. Hmm, this part is a bit complex and could be a source of errors.

Another example: suppose lastUpdatedTime was 500, and the rewardRateLog has entries at 1000 (rate 100) and 1500 (rate 200). Now, block.timestamp is 2000. The code would start from the latest entry (i=1, timestamp=1500). The delta would be 2000 - max(500, 1500) = 2000-1500=500. accumulator += 200 *500=100000. Then, counter=1500. i=0, timestamp=1000. delta=1500 - max(500, 1000)=1500-1000=500. accumulator +=100*500=50000 → total 150000. Then, since i==0, break. Then, the total accumulator is 150000. Then, the code does accumulator * ACC_TOKEN_PRECISION / totalSharesStaked. But if totalSharesStaked is zero, this would cause a division by zero. Wait, but in updatePool, they check if totalSharesStaked is >0 before updating. So the getUpdatedAccTokenPerShare function is only called when totalSharesStaked >0. So division by zero is avoided.

But back to the time calculation. The code seems to calculate the time intervals correctly for each reward rate, accumulating the rewards based on the time each rate was active since the last update. So maybe the logic is correct. However, if the rewardRateLog entries are not in chronological order, this would break. But the setRewardPerSecond function pushes entries into rewardRateLog, so they are in order of when they were set. Therefore, the timestamps should be in increasing order. So the code is correct in assuming that rewardRateLog entries are ordered by timestamp.

Another possible issue: when a new reward rate is set with setRewardPerSecond, it's added to the rewardRateLog array. However, if the owner sets a new rate with a timestamp that is in the past relative to previous entries, this would break the logic. But since each new entry is added with block.timestamp, which should be increasing, this shouldn't happen unless the owner can manipulate the block timestamp, which they can't. So the entries are correctly ordered.

Another vulnerability: the _sendErc20AndGetSentAmount function uses the difference in the recipient's balance to determine how much was sent. This is necessary for tokens with transfer fees, but if the recipient's balance is changed by another transaction between the two balanceOf calls, the calculation could be incorrect. However, since this is done within the same transaction (the function is private and called within a nonReentrant function), the recipient's balance can't change between the two balanceOf calls. So this is safe.

Possible denial-of-service in deposit function: The deposit function transfers the NFT to the contract. If the NFT's tokenMetadata returns an incorrect baseToken or amount, it could affect the rewards. But the contract relies on the lpToken's tokenMetadata function, which is an external contract. If that contract is malicious or returns incorrect data, it could cause issues. However, since lpToken is set during initialization and is an external dependency, this is a trust assumption. If the lpToken is compromised, the contract's behavior is affected, but that's outside the scope of this contract's vulnerabilities.

In the withdraw function, after sending rewards, the code deletes nftInfo[_nftId]. However, when the NFT is transferred back to the user, the lpToken.safeTransferFrom is called. If the NFT contract has a callback that could fail, this would revert the transaction. But since the NFT is being transferred back to the original owner (msgSender), who is the owner of the NFT, it should be safe. The contract uses safeTransferFrom, which checks that the recipient can receive ERC721 tokens, but since the recipient is the original owner, they should handle it.

Another possible issue: the totalSharesStaked is a sum of all staked amounts for a baseToken. However, when an NFT is deposited, the amount is divided by BASE_DIVISOR. If multiple NFTs are deposited with amounts that don't sum properly (due to division truncation), totalSharesStaked could be incorrect. For example, if two NFTs each have 1.5e18 as amount, divided by 1e18, each contributes 1, so total is 2, but the actual sum is 3e18 /1e18=3. This is a discrepancy. Wait, no: each amount is divided by BASE_DIVISOR before being added to totalSharesStaked. So if two NFTs have amounts 1.5e18 and 1.5e18, their divided amounts are 1 and 1, totalSharesStaked becomes 2. But the actual total is 3e18 / 1e18 =3. But the contract uses the divided amounts (sum of 1+1=2). So the totalSharesStaked is the sum of the divided amounts, not the sum of the original amounts divided. This could lead to undercounting the total shares, thus inflating the accTokenPerShare, since the rewards are distributed per share. For example, if totalSharesStaked is 2, but the actual sum is 3e18 /1e18 =3, then the rewards would be distributed over 2 shares instead of 3, leading to higher rewards per share than intended. This is a critical issue because it allows users to get more rewards than they should. Wait, let's see:

When a user deposits an NFT, the amount is taken from the lpToken's tokenMetadata, then divided by BASE_DIVISOR. Suppose the BASE_DIVISOR is 1e18. If the user's amount is 1.5e18, divided by 1e18 gives 1 (due to integer division). So totalSharesStaked increases by 1. However, the actual value is 1.5e18 /1e18 =1.5, but Solidity truncates to 1. So the totalSharesStaked is less than the actual sum of (amount / BASE_DIVISOR). Therefore, when calculating rewards, the contract uses totalSharesStaked as the denominator, which is lower than the actual sum, leading to higher accTokenPerShare. This would result in users receiving more rewards than they deserve. For example, if two users each have 1.5e18, their shares are 1 each, total 2. But the actual sum is 3e18 /1e18 =3. So the rewards per share would be (rewards * time) / 2 instead of 3, which is higher. Therefore, users get more rewards per share, leading to overpayment. This is a high severity vulnerability due to incorrect accounting.

This issue arises because the division by BASE_DIVISOR is done before adding to totalSharesStaked, truncating the value. To avoid this, the division should be the last operation, after summing the amounts. But since each NFT's amount is divided individually, truncation occurs at the individual level, leading to an undercount of total shares. Therefore, the totalSharesStaked is the sum of (amount_i / BASE_DIVISOR) for each NFT, which could be less than the sum of amount_i divided by BASE_DIVISOR. For example, if there are two NFTs with amounts 1e18 +1, their individual divisions would be 1 and 0 (if BASE_DIVISOR is 1e18), summing to 1, whereas the total sum is 1e18 +1 divided by 1e18 would be 1.000000000000000001, which truncates to 1. So in this case, it's the same. But for amounts that sum to more than a multiple when divided individually vs together, this can be an issue.

Wait, actually, the sum of (amount_i / BASE_DIVISOR) can be less than or equal to (sum amount_i) / BASE_DIVISOR. Because integer division truncates towards zero. For example, two amounts: 1.5 and 1.5. Sum is 3.0. If divided individually, each becomes 1, sum 2. If summed first and then divided, 3.0 becomes 3. So sum of individual divisions is 2, sum after division is 3. So in this case, totalSharesStaked is 2, but the actual sum is 3. This leads to the totalSharesStaked being lower than the actual value, which when used as the denominator in the rewards calculation, increases the accTokenPerShare more than it should. For example, if rewards are 300 per second, and time is 1 second:

accTokenPerShare would be (300 * 1 * 1e12) / 2 = 150e12

But if the actual total shares were 3, it should be (300 *1e12) /3 = 100e12.

Thus, each share gets 150e12 instead of 100e12. Users would earn more rewards, leading to over-issuance.

This is a critical vulnerability because it allows users to accumulate more rewards than they should, potentially draining the reward pool.

Another vulnerability: in the deposit function, the code checks if the msgSender is approved to transfer the NFT. However, the code uses lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this). This is correct, but if the lpToken's getApproved function returns the correct approved address for the NFT. However, there's a potential issue if the lpToken is not a standard ERC721, but that's an external dependency.

Additionally, the code uses safeTransferFrom to transfer the NFT to itself. Since the contract implements onERC721Received, this is handled correctly. So the deposit function is safe in that regard.

Another issue: the _sendRewardsForNft function allows the staker (nft.staker) to send rewards to any address (_to). However, the extractRewards function requires that the _msgSender() is the staker, but the _to can be any address. So a user can direct their rewards to any address, which may be intended, but could be a issue if combined with other vulnerabilities.

Now, let's summarize the vulnerabilities found:

1. **Typo in Function Name (Critical):** The function `initalizeRewardPool` is misspelled (missing an 'i'), which would prevent the owner from initializing reward pools correctly if the correct function name is not called. This would leave pools uninitialized, causing functions like deposit to revert, as they require the reward token to be set.

2. **Precision Loss in Reward Calculation (High):** When staking an NFT, the amount is divided by BASE_DIVISOR before being used in reward calculations. This truncation can lead to undercounting of the user's stake, but when summed across multiple users, the totalSharesStaked may be significantly lower than the actual total. This results in higher accTokenPerShare, over-issuing rewards to users.

3. **Unchecked Arithmetic in getUpdatedAccTokenPerShare (High):** The accumulator in getUpdatedAccTokenPerShare uses unchecked arithmetic, which could overflow if the reward rate or time delta is too large. This would result in incorrect reward calculations, potentially leading to loss of rewards or excessive issuance.

4. **Incorrect Reward Distribution Due to Truncation (High):** As discussed, truncation when dividing individual amounts by BASE_DIVISOR leads to lower totalSharesStaked, causing over-issuance of rewards.

5. **Potential Division by Zero in getUpdatedAccTokenPerShare (Medium):** Although updatePool checks if totalSharesStaked is zero before calling getUpdatedAccTokenPerShare, if somehow totalSharesStaked is zero when getUpdatedAccTokenPerShare is called (e.g., via pendingToken view function), it would cause a division by zero. However, in pendingToken, it checks if totalSharesStaked is zero and skips the calculation, so this may not be an issue. Need to check:

In pendingToken:

if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
    accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
}

So if totalSharesStaked is zero, getUpdatedAccTokenPerShare is not called. Therefore, division by zero is avoided. So this is not a vulnerability.

6. **Uninitialized Pool Vulnerability Due to Misspelled Function (Critical):** As mentioned in point 1, the typo in the function name means that reward pools cannot be initialized properly, leading to functionality breakdown.

7. **Reward Rate Log Ordering Assumption (Medium):** The code assumes that rewardRateLog entries are added in chronological order. Since setRewardPerSecond appends entries with block.timestamp, they should be ordered correctly. However, if there's a way to add entries with older timestamps, this would break the logic. But given that setRewardPerSecond uses block.timestamp, this is not possible, so this is not a vulnerability.

8. **Centralization Risk with reclaimTokens (Low):** The owner can withdraw any tokens from the contract, including user rewards. While this is an admin function, it's a centralization risk, but not a vulnerability in the code itself.

Other possible issues:

- **Lack of Event Emission on Critical Operations:** Some functions may not emit events, but the code includes events for deposits, withdraws, etc. Seems okay.

- **Incorrect Use of msg.sender vs _msgSender():** The contract uses ERC2771ContextUpgradeable, which is for meta transactions. The _msgSender() function correctly handles this. All functions use _msgSender() where necessary, so this is handled.

So the main vulnerabilities are the typo in the function name, precision loss in reward calculations due to early truncation, and potential arithmetic overflow in getUpdatedAccTokenPerShare.","```
1. Centralization Risk in `reclaimTokens`
```",0.16666666666666700,0.166666666666667
WhitelistPeriodManager.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",2422.0,291.0,"[M-05] Frontrunning of setPerTokenWalletCap edge case
The `setPerTokenWalletCap()` function in WhitelistPeriodManager.sol contains a comment stating:
Special care must be taken when calling this function
There are no checks for `_perTokenWalletCap (since it's onlyOwner)`, but it's essential that it should be >= max lp provided by an lp.
Checking this on chain will probably require implementing a bbst, which needs more bandwidth
Call the view function `getMaxCommunityLpPositon()` separately before changing this value
  [M-15] WhitelistPeriodManager: Improper state handling of exclusion removals
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.
In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.
  [M-16] WhitelistPeriodManager: Improper state handling of exclusion additions
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is added to the `isExcludedAddress` mapping. This affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, which implicitly assumes that whitelisted addresses will have 0 liquidity, for addresses with non-zero liquidity at the time of addition to the whitelist.",3.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    
    
    mapping(address => bool) public isExcludedAddress;
    
    mapping(address => uint256) private totalLiquidity;
    
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    
    
    mapping(address => uint256) public perTokenTotalCap;
    
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        
        _beforeLiquidityRemoval(_from, _token, _amount);

        
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",1958.0,0,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Gas Exhaustion in `getMaxCommunityLpPositon` Function**  
   The `getMaxCommunityLpPositon` function iterates through all LP tokens (from 1 to `totalSupply`). If the `totalSupply` is large, this loop will consume excessive gas, causing the function to revert. This makes the function impractical for on-chain use and could disrupt dependent processes.

2. **Lack of Reentrancy Protection**  
   Critical functions like `beforeLiquidityAddition`, `beforeLiquidityRemoval`, and `beforeLiquidityTransfer` lack reentrancy guards. While these functions are restricted to specific contracts (via `onlyLiquidityPool` and `onlyLpNft`), a compromised or malicious caller contract could exploit reentrancy to manipulate state inconsistently.

3. **Incorrect Token Support Assumption in Liquidity Operations**  
   The `beforeLiquidityAddition` function does not explicitly check if the token is supported via `tokenManager`. Instead, it relies on `perTokenTotalCap` being zero (enforced by `setTotalCap`). While this indirectly blocks unsupported tokens, it introduces implicit dependency on correct configuration by the owner, risking oversight.

4. **Dependence on External Contract Security**  
   The contract assumes that `liquidityProviders`, `lpToken`, and `tokenManager` are secure and properly implemented. Compromises in these contracts (e.g., allowing unauthorized calls to `beforeLiquidityAddition` or `beforeLiquidityRemoval`) could bypass intended restrictions or corrupt state tracking.

5. **Typographical Error in Function Name**  
   The function `getMaxCommunityLpPositon` has a typo (""Positon"" instead of ""Position""). While not a direct vulnerability, it indicates code quality issues that could lead to errors in integration or maintenance.

6. **Unbounded Loops in Administrative Functions**  
   Functions like `setCaps` and `setIsExcludedAddressStatus` use loops over input arrays. If these arrays are excessively large, transactions could fail due to gas limits, hindering governance actions.","### **Output**

---

**[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Report Description**:  
The `setPerTokenWalletCap()` function in `WhitelistPeriodManager.sol` lacks checks to ensure that `_perTokenWalletCap` is greater than or equal to the maximum LP provided by an LP. This could lead to inconsistencies if the value is set incorrectly. The issue is mitigated by suggesting the use of the `getMaxCommunityLpPositon()` function before changing the value, but this is not enforced on-chain.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of frontrunning or the lack of checks for `_perTokenWalletCap` in the `setPerTokenWalletCap()` function. This is a missed issue in the response list.

---

**[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**

**Report Description**:  
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. This can lead to subtraction overflow issues, preventing users from withdrawing their staked LP tokens if the address becomes non-excluded.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the improper state handling of exclusion removals, which is a critical issue affecting the contract's functionality and security.

---

**[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

**Report Description**:  
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is added to the `isExcludedAddress` mapping. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function, as it assumes whitelisted addresses will have zero liquidity, which may not be the case.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the improper state handling of exclusion additions, which is a critical issue affecting the contract's functionality and security.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-05] Frontrunning of setPerTokenWalletCap edge case**  
- **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**  
- **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

---

### **Conclusion**  
The response list does not adequately address the issues reported in the `issue` list. Key vulnerabilities related to frontrunning, improper state handling of exclusions, and missing checks in critical functions were missed. The response list focuses on other issues like gas exhaustion, reentrancy, and external contract dependencies but fails to cover the specific vulnerabilities highlighted in the `issue` report.",0,0,3,6,"Okay, let's start analyzing this smart contract. The goal is to find all possible vulnerabilities. I'm going to go through the code step by step.

First, looking at the pragma statement: it's using Solidity 0.8.0. That's good because 0.8.0 has built-in overflow checks, so arithmetic overflows shouldn't be an issue. But I should still check for any other issues.

The contract imports several OpenZeppelin upgradeable contracts, like OwnableUpgradeable, Initializable, PausableUpgradeable, ReentrancyGuardUpgradeable. Wait, but the contract itself inherits from Pausable (from ../security/Pausable.sol) and ERC2771ContextUpgradeable. There's a mix of upgradeable and non-upgradeable components? Wait, maybe not. The Pausable.sol import is from the project's own security folder. Let me check if that's compatible with the upgradeable versions. If the Pausable contract in the project is not designed for upgradeable contracts, that might be a problem. For example, the initializers might clash. But in the initialize function, they call __Pausable_init(_pauser). The OpenZeppelin PausableUpgradeable uses a different initializer, maybe without a pauser parameter. So if the custom Pausable.sol is an upgradeable contract with a __Pausable_init that takes a pauser, then it's okay. But if not, there could be initialization issues. However, without seeing the actual code of Pausable.sol, it's hard to tell. But this might not be a vulnerability in this contract per se, but maybe a dependency issue.

Next, looking at the state variables. The contract uses mappings for tracking totalLiquidity and totalLiquidityByLp. The modifiers like onlyLiquidityPool and onlyLpNft check that the caller is the respective contract. Let's check the functions that use these modifiers.

The beforeLiquidityAddition function is called by the liquidity pool, and it updates the totalLiquidity and totalLiquidityByLp. The checks involve perTokenTotalCap and perTokenWalletCap. The function uses ifEnabled to conditionally enforce these checks. If areWhiteListRestrictionsEnabled is false, the checks are bypassed. Wait, no: the ifEnabled function returns !areWhiteListRestrictionsEnabled || (restrictions enabled and condition). So if restrictions are enabled, the condition must be true. If they're disabled, the condition is ignored. So the checks are only applied when restrictions are enabled. That seems okay.

But looking at the _beforeLiquidityAddition function: when a user adds liquidity, if they're excluded, it returns. Otherwise, it checks if the total plus the new amount is within the cap, then increments the totals. Similarly for removal. But when transferring liquidity (beforeLiquidityTransfer), it removes from the sender and adds to the receiver. But here's a potential issue: when transferring, if the sender is excluded, their total isn't decremented, but the receiver's addition is handled. If the receiver is not excluded, their total could exceed the cap. Wait, let's see. If the sender is excluded, then during _beforeLiquidityRemoval, since they're excluded, it skips updating their totalLiquidityByLp and totalLiquidity. Then when adding to the receiver, if the receiver isn't excluded, the code checks if adding the amount would exceed their perTokenWalletCap and the total cap. So even if the sender is excluded, the receiver's addition would still check against their caps. That seems okay. But if the receiver is excluded, then the addition would bypass the checks. However, that's intended since excluded addresses are not subject to caps. So maybe that's by design.

Now, let's look at the functions that update the caps. The setTotalCap function checks that the new totalCap is >= the current totalLiquidity. But what if totalCap is set to a lower value than the current totalLiquidity? The require statement here would prevent that. So that's good.

The setPerTokenWalletCap function checks that the new perTokenWalletCap is <= perTokenTotalCap. Also, when setting via setCap, they first set the total cap and then the perTokenWalletCap. So the order ensures that perTokenWalletCap doesn't exceed the total. But wait, when setting via setCap, the setPerTokenWalletCap is called after setTotalCap, so the new perTokenWalletCap must be <= the new perTokenTotalCap. That's correct.

But there's a possible issue in the setCaps function. The loop calls setCap for each token, which in turn calls setTotalCap and setPerTokenWalletCap. But if during the loop, one of the setTotalCap calls fails, the entire transaction would revert. However, the code uses external calls in a loop, which could be gas-intensive. However, since the owner is expected to call this, maybe it's acceptable.

Another thing to check is the getMaxCommunityLpPositon function. There's a typo in the function name: ""Positon"" should be ""Position"". Not a vulnerability, but a code quality issue. The function loops from 1 to totalSupply inclusive, which is correct since LP tokens are likely 1-indexed. However, if totalSupply is very large, this loop could consume too much gas and revert. For example, if there are thousands of LP tokens, this function would be impossible to call. So this is a potential denial-of-service or gas exhaustion issue. But since this is a view function, maybe it's intended to be called off-chain. However, if it's used on-chain, it's a problem. The function is marked as view, but if called on-chain with a high totalSupply, it would fail.

Another vulnerability: reentrancy. The contract uses ReentrancyGuardUpgradeable in the imports, but the contract itself doesn't inherit from ReentrancyGuardUpgradeable. Wait, looking at the contract inheritance: the contract inherits from Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable. So ReentrancyGuard is not used here. Are there any functions that could be susceptible to reentrancy? The beforeLiquidityAddition, beforeLiquidityRemoval, and beforeLiquidityTransfer functions are called by other contracts (liquidityProviders and lpToken). If those external contracts make external calls back into this contract during their operations, it might lead to reentrancy. However, since these functions only update internal state variables and don't make external calls themselves, maybe the risk is low. But the code doesn't include a reentrancy guard, so if the caller (liquidityProviders or lpToken) is malicious and reenters, could that cause issues? For example, during a transfer, if the lpToken contract calls back into the WhitelistPeriodManager's beforeLiquidityTransfer function during the transfer process, maybe the state could be manipulated. But since the modifiers only allow these functions to be called by specific contracts (onlyLiquidityPool and onlyLpNft), and if those contracts are trusted, then it's okay. However, if those contracts have vulnerabilities, this contract could be affected. But the code here doesn't include reentrancy guards, so that's a possible vulnerability if the caller contracts are not properly secured.

Another point: the use of _msgSender() from ERC2771ContextUpgradeable. This is for meta-transactions, where the actual sender is different from the transaction signer. But in the modifiers like onlyOwner, the owner is the contract's owner, and since the _msgSender() is used, that should correctly handle meta-transactions. However, there's a potential for confusion between msg.sender and the meta-transaction sender, but since the contract uses ERC2771 correctly, this might be okay.

Looking at the tokenChecks modifier: it checks if the token is supported via _isSupportedToken, which calls tokenManager.getTokensInfo(_token).supportedToken. If the tokenManager is compromised or returns incorrect data, that's a problem. But this is an external dependency, not a vulnerability in this contract itself.

Another possible issue: in the setIsExcludedAddressStatus function, the owner can set excluded addresses. If the owner is malicious or compromised, they can bypass the caps. But that's a trust issue with the owner, not a code vulnerability.

In the beforeLiquidityTransfer function, when transferring from _from to _to, the code first removes liquidity from _from and then adds to _to. If during this process, the addition to _to fails (e.g., due to caps), the removal from _from has already happened. This could lead to an inconsistent state. Let's see: the function calls _beforeLiquidityRemoval, which subtracts the _amount from _from's totals (if not excluded), and then calls _beforeLiquidityAddition for _to. If the addition fails (e.g., the receiver's total would exceed the cap), then the function would revert, right? Because the entire transaction would revert, so the state changes from the removal would be rolled back. Wait, no: in Solidity, if a function call reverts, all state changes in that call (and any subcalls) are reverted. So if during beforeLiquidityTransfer, the _beforeLiquidityAddition reverts, then the entire transaction is reverted, including the _beforeLiquidityRemoval. Therefore, the state remains consistent. So that's okay.

Another thing: the totalLiquidity and totalLiquidityByLp mappings are updated in _beforeLiquidityAddition and _beforeLiquidityRemoval. If the actual liquidity in the system doesn't match these totals (due to a bug or external manipulation), the caps could be enforced incorrectly. For example, if someone can add liquidity without calling beforeLiquidityAddition, then the totals would be incorrect. But since the modifiers ensure that only the liquidityProviders contract can call these functions, and assuming that contract correctly calls them when adding/removing liquidity, then it's okay. But if the liquidityProviders contract has a bug, this contract's state could be incorrect.

Another vulnerability: integer underflow. The contract uses Solidity 0.8.0, which has built-in overflow/underflow checks. So in _beforeLiquidityRemoval, when subtracting _amount from totalLiquidityByLp and totalLiquidity, if the amount is larger than the current total, it would revert. Which is correct. So no underflow issues.

In the setTotalCap function, there's a check that the new totalCap is >= perTokenWalletCap. Because when you setTotalCap, you need to ensure that the perTokenWalletCap doesn't exceed the totalCap. But the code does require(_totalCap >= perTokenWalletCap[_token]), so if the current perTokenWalletCap is higher than the new _totalCap, the require would fail. But when setting the totalCap first, then the perTokenWalletCap, this is handled. So that's okay.

But in the setCap function, which calls setTotalCap and then setPerTokenWalletCap, if the setTotalCap succeeds but setPerTokenWalletCap fails (e.g., because _perTokenWalletCap > new totalCap), then the entire transaction would revert. So the function is safe.

Now, looking at the mappings: totalLiquidity and totalLiquidityByLp. These are updated when adding/removing liquidity. But what happens when a token is removed from the tokenManager's supported tokens? The _isSupportedToken check is in the tokenChecks modifier, which is used in functions like setTotalCap. But when liquidity is added or removed, the token must still be supported. However, if a token is unsupported after liquidity was added, the existing liquidity would still be tracked. But adding new liquidity would fail because the token is no longer supported. However, removing liquidity would still work because the tokenChecks modifier is not applied to removal functions. Wait, looking at beforeLiquidityAddition: it's called via onlyLiquidityPool, which uses the tokenChecks modifier. Wait, no: the beforeLiquidityAddition function has the modifier onlyLiquidityPool and whenNotPaused. But the tokenChecks modifier is not applied. Wait, looking at the code:

function beforeLiquidityAddition(
    address _lp,
    address _token,
    uint256 _amount
) external onlyLiquidityPool whenNotPaused {
    _beforeLiquidityAddition(_lp, _token, _amount);
}

So there's no tokenChecks modifier here. That means that even if the token is not supported, as long as it's called by the liquidity pool, it can proceed. But the _beforeLiquidityAddition function calls _isSupportedToken(_token) as part of the require statement. Let's check:

In _beforeLiquidityAddition:

require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""..."");
require(ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]), ""..."");

Wait, no, the token checks are in the tokenChecks modifier, but that's applied to functions like setTotalCap. The beforeLiquidityAddition function does not have the tokenChecks modifier. So the check for _isSupportedToken is not done here. Wait, looking into the code:

Inside _beforeLiquidityAddition, there's no check that the token is supported. Wait, the code inside _beforeLiquidityAddition starts with:

if (isExcludedAddress[_lp]) {
    return;
}
Then the requires:

require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""..."");
require(ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]), ""..."");

But there's no check that the token is supported. However, the tokenChecks modifier is used in other functions like setTotalCap, but not in beforeLiquidityAddition. So if a token is not supported, but the liquidityProviders contract calls beforeLiquidityAddition for that token, the code would proceed. However, the _isSupportedToken is checked in the tokenManager's functions when adding liquidity? Or is that handled elsewhere?

Wait, the liquidityProviders contract would presumably check that the token is supported before allowing liquidity to be added. But if it doesn't, then this contract's beforeLiquidityAddition would process it even for unsupported tokens. That could lead to tracking liquidity for unsupported tokens, which might not be intended. For example, the perTokenTotalCap and perTokenWalletCap for that token might not be set, leading to potential issues.

But in the code, the perTokenTotalCap and perTokenWalletCap are mappings that default to 0. So if a token is not supported (so not supposed to be added), but someone manages to call beforeLiquidityAddition for it, the code would check totalLiquidity[_token] + _amount <= perTokenTotalCap[_token], which is 0. Unless the token has been configured, which requires the owner to set the caps, which would have required the token to be supported. But if the owner set the caps for an unsupported token (which they can't because setTotalCap has the tokenChecks modifier), then maybe it's possible. Wait, setTotalCap uses tokenChecks, which requires the token to be supported. Therefore, perTokenTotalCap can only be set for supported tokens. So if the token is not supported, perTokenTotalCap is 0. Therefore, when adding liquidity for an unsupported token, the code would check if totalLiquidity + amount <= 0, which would fail unless amount is 0. Therefore, adding liquidity for an unsupported token would be blocked by the first require statement, as perTokenTotalCap is 0.

But the problem is that the code allows the beforeLiquidityAddition to be called for any token, even unsupported ones. However, because perTokenTotalCap is 0 (since you can't set it for unsupported tokens), the require(totalLiquidity + amount <= 0) would fail. Therefore, the addition would revert. So even though the token isn't checked here, the caps being 0 would prevent adding liquidity. But if the owner sets the caps for a token that is not supported, which they can't because setTotalCap uses tokenChecks, which checks if the token is supported.

Wait, no: setTotalCap has the tokenChecks modifier. Therefore, the owner can only set caps for supported tokens. So perTokenTotalCap is only non-zero for supported tokens. Therefore, when a token is not supported, perTokenTotalCap is 0, so adding any amount would fail the first require. Therefore, even if the liquidityProviders contract allows adding an unsupported token, this contract's beforeLiquidityAddition would block it. So that's okay.

Another possible issue: if a token is removed from the supported list in the tokenManager, existing liquidity can still be removed because the beforeLiquidityRemoval function does not check if the token is supported. Let's see: when removing liquidity, beforeLiquidityRemoval is called, which does not have the tokenChecks modifier. Therefore, even if the token is no longer supported, the removal can proceed. But since the token is no longer supported, maybe that's an issue. However, the caps are still in place if the token was previously supported. But in the code, when a token is unsupported, the owner can't set its caps anymore. However, existing caps remain. So when removing liquidity, the code subtracts from totalLiquidity and totalLiquidityByLp. This is correct because even if the token is no longer supported, the existing liquidity should be allowed to be removed. So no issue here.

Now, checking for access control issues. The functions that modify critical parameters (like setTokenManager, setLiquidityProviders, setLpToken, setIsExcludedAddressStatus, setTotalCap, etc.) are all protected by the onlyOwner modifier, which is correct. The modifiers onlyLiquidityPool and onlyLpNft ensure that only the designated contracts can call those functions, which is correct assuming those contracts are properly secured.

Another possible issue: the initializer function is public. However, since it's using the initializer modifier from OpenZeppelin, it can only be called once. So that's okay. But if someone else calls it after deployment, they could reinitialize the contract. But the initializer modifier prevents that.

What about the ERC2771ContextUpgradeable integration? The contract overrides _msgSender() and _msgData() to handle meta-transactions. This should be okay as long as the trusted forwarder is correctly set and secured. If the trusted forwarder is malicious, it could spoof the sender. So the owner must ensure that the trustedForwarder is a legitimate contract.

Another thing: the Pausable contract's __Pausable_init is called with _pauser, but if the Pausable contract is not properly initialized, that could be a problem. But since the contract inherits from Pausable, and assuming that the __Pausable_init function is correctly implemented in Pausable.sol, then it's okay.

Looking for front-running possibilities: since the owner can change the caps or exclude addresses, users might have their transactions front-run to change these parameters. For example, a user's liquidity addition could be front-run by the owner reducing the cap, causing the user's transaction to fail. However, this is a governance issue, not a smart contract vulnerability.

Another thing: the getMaxCommunityLpPositon function loops through all LP tokens, which could be very gas-intensive. If there are a large number of LP tokens, this function could run out of gas. This could be a problem if this function is called on-chain. However, as a view function, it's likely intended for off-chain use. But if another contract relies on this function on-chain, it could be a vulnerability.

In summary, the vulnerabilities I can identify are:

1. **Potential Gas Exhaustion in getMaxCommunityLpPositon**: The function loops through all LP tokens, which could be a very large number, leading to out-of-gas errors.

2. **Lack of Reentrancy Guards**: Although the contract uses ReentrancyGuardUpgradeable in imports, it doesn't inherit or use it. If the liquidityProviders or lpToken contracts are compromised and allow reentrant calls, this contract's state could be manipulated. However, since the modifiers restrict access to these contracts, the risk might be mitigated if those contracts are secure.

3. **Incorrect Token Support Check in Liquidity Addition/Removal**: The beforeLiquidityAddition and beforeLiquidityRemoval functions do not explicitly check if the token is supported. However, due to the perTokenTotalCap being zero for unsupported tokens, this might not be an issue. But this relies on the assumption that the caps are correctly managed, which is enforced in setTotalCap. So this might not be a vulnerability.

4. **Dependency on External Contracts**: The contract relies on the correct implementation of liquidityProviders, tokenManager, and lpToken. If these contracts have vulnerabilities or are upgraded maliciously, it could affect this contract. But this is an external risk, not a direct vulnerability in this contract.

So the main vulnerabilities are the gas exhaustion in getMaxCommunityLpPositon and potential reentrancy if the caller contracts are vulnerable.","```
None.
```",0.0,0
TokenManager.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169.0,146.0,"[M-09] Improper Upper Bound Definition on the Fee
The `equilibriumFee` and `maxFee` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.",1.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1066.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Missing Validation in `changeFee` Function**  
   The `changeFee` function fails to validate that `_equilibriumFee ≤ _maxFee`. This allows the owner to set an equilibrium fee higher than the maximum fee, leading to potential logical errors in fee-dependent components.

2. **Incorrect Fee Initialization in `addSupportedToken`**  
   The `addSupportedToken` function does not enforce non-zero values for `equilibriumFee` and `maxFee`. This can result in tokens being added with zero fees, which may cause division-by-zero errors or invalid fee calculations in other parts of the system.

3. **Missing `whenNotPaused` Modifier on Critical Functions**  
   Administrative functions (e.g., `addSupportedToken`, `removeSupportedToken`, `setDepositConfig`) lack the `whenNotPaused` modifier. If the contract is paused (e.g., during an emergency), the owner can still alter configurations, reducing the effectiveness of pausing.

4. **Inconsistent Configuration for Unsupported Tokens**  
   The `setDepositConfig` function allows setting deposit configurations for unsupported tokens. This may lead to unintended behavior if downstream logic assumes deposit configurations apply only to supported tokens.

5. **Redundant Storage in `TokenInfo` Struct**  
   The `tokenConfig` field in the `TokenInfo` struct is stored redundantly. It is initialized during token addition but not updated when `transferConfig` changes. While not directly exploitable, it introduces data inconsistency risks if future code erroneously relies on this field.","### **[M-09] Improper Upper Bound Definition on the Fee**

**Report Description**:  
The `equilibriumFee` and `maxFee` parameters do not have any upper or lower bounds defined. This lack of validation can lead to critical issues:  
- If the values are too large, they may cause reversions in several critical functions.  
- If the values are too high, liquidity providers (LPs) could lose all their funds when paying the fee.  
This oversight poses a significant risk to the contract's functionality and user funds.

**Match in Response List**:  
Matches with the issue titled **""Missing Validation in `changeFee` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of missing validation in the `changeFee` function, specifically the failure to ensure `_equilibriumFee ≤ _maxFee`. While this partially addresses the broader issue of improper fee bounds, it does not fully cover the risks associated with excessively large or small values for `equilibriumFee` and `maxFee`. The response misses the critical impact of unbounded fees on contract functionality and user funds, which is a key aspect of the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-09] Improper Upper Bound Definition on the Fee**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis and Recommendations**

The response list partially addresses the issue of improper fee bounds but does not fully capture the severity and scope of the problem. To improve coverage and accuracy, the response should:  
1. Highlight the risks of excessively large or small fee values, including potential reversions and fund loss for LPs.  
2. Recommend implementing upper and lower bounds for both `equilibriumFee` and `maxFee` to mitigate these risks.  
3. Emphasize the importance of validating fee values during initialization and updates to ensure they remain within safe and functional limits.  

By addressing these gaps, the response would provide a more comprehensive and accurate solution to the reported issue.",0,1,0,5,"Okay, let's take a look at this smart contract. I need to find all the vulnerabilities here. The user doesn't want mitigations, just the list. Let me start by going through the code step by step.

First, the contract imports several OpenZeppelin contracts like Ownable, Pausable, and ERC2771Context. It also has a custom interface ITokenManager. The contract TokenManager implements these and has mappings for tokensInfo, depositConfig, and transferConfig. There are various functions to manage tokens, fees, configurations, etc.

Let me check for common vulnerabilities. Reentrancy? I don't see any external calls here, so maybe not. But maybe other issues like access control, input validation, state inconsistencies, etc.

Looking at the addSupportedToken function: it's onlyOwner, which is good. It checks tokenAddress isn't zero. Then sets supportedToken to true, updates transferConfig, and assigns to tokensInfo. Wait, here's a possible problem. The code sets transferConfig[tokenAddress].min and max, then assigns tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress]. But in Solidity, struct assignments are by value, not reference. So if later transferConfig is updated via updateTokenCap, the tokensInfo's tokenConfig won't automatically update. That could lead to inconsistencies. For example, when getTokensInfo is called, it returns transferConfig[tokenAddress], which might be different from what's stored in tokensInfo. So the tokenConfig in TokenInfo is not correctly linked. That's a data inconsistency issue.

Another point: the addSupportedToken function sets transferConfig[tokenAddress], which is a mapping. Then tokensInfo[tokenAddress].tokenConfig is set to that struct. But when updateTokenCap is called later, it modifies transferConfig again, but tokensInfo's tokenConfig isn't updated. So getTokensInfo returns the current transferConfig, which is correct, but if someone stored the TokenInfo struct from an earlier call, their tokenConfig would be outdated. Wait, no. Wait, the getTokensInfo function constructs a new TokenInfo struct each time, pulling transferConfig[tokenAddress]. So maybe that's okay. Let me check:

In addSupportedToken, they set transferConfig[tokenAddress], then tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress]. But tokensInfo[tokenAddress].tokenConfig is a struct copy. Then, in getTokensInfo, they create a new TokenInfo struct, where the tokenConfig is taken from transferConfig[tokenAddress], not from tokensInfo's storage. So there's a discrepancy here. Because when you call getTokensInfo, the tokenConfig in the returned struct is the current transferConfig, but the tokensInfo's tokenConfig field is not updated when transferConfig changes. So tokensInfo's tokenConfig is outdated. But since getTokensInfo doesn't use that, maybe it's not a problem? Wait, in the code:

The TokenInfo struct in getTokensInfo is built with:

TokenInfo(
    tokensInfo[tokenAddress].transferOverhead,
    tokensInfo[tokenAddress].supportedToken,
    tokensInfo[tokenAddress].equilibriumFee,
    tokensInfo[tokenAddress].maxFee,
    transferConfig[tokenAddress]
)

So the tokenConfig part is directly taken from transferConfig, not from tokensInfo[tokenAddress].tokenConfig. That means the tokenConfig in tokensInfo is actually not used anywhere except when it's initially set in addSupportedToken. Because in addSupportedToken, they do:

tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];

But after that, if transferConfig is updated via updateTokenCap, tokensInfo's tokenConfig is not updated. However, when someone calls getTokensInfo, they get transferConfig's current value, not the one stored in tokensInfo. So maybe the tokenConfig in tokensInfo is redundant? Because it's not used anywhere else. So the code might have a redundant storage variable. That's a possible issue because it's storing data that's not used, leading to inconsistency. But maybe not a vulnerability, just a code inefficiency. Hmm, maybe not a security issue, but worth noting. Wait, but maybe in other functions, the tokenConfig from tokensInfo is used? Let me check.

Looking through the code, in the addSupportedToken function, after setting transferConfig, they set tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress]. But in other functions like updateTokenCap, they only modify transferConfig, not the tokenConfig in tokensInfo. So tokensInfo's tokenConfig becomes outdated. However, since getTokensInfo uses transferConfig directly, this might not be a problem. But why is there a tokenConfig field in tokensInfo if it's not used? That's a possible mistake. For example, if another function were added later that uses tokensInfo's tokenConfig, it would have stale data. But in the current code, it's not used. So maybe the tokenConfig in TokenInfo is redundant and incorrectly set. But in getTokensInfo, the code correctly uses transferConfig[tokenAddress], so maybe it's okay. But the code as written has redundant storage. So maybe that's a code quality issue, but not a vulnerability.

Moving on. Let's check for access control issues. The functions are mostly protected with onlyOwner, which is correct since it's using OpenZeppelin's Ownable. But let's check the modifiers. For example, the removeSupportedToken function uses the tokenChecks modifier, which checks that the token is supported. But since the owner can remove a supported token, that's okay. But what if a token is not supported but someone calls removeSupportedToken? The modifier checks that it is supported, so it would revert. So that's okay.

Another point: the setDepositConfig function takes arrays of toChainId, tokenAddresses, and tokenConfig. It checks that all arrays have the same length. Then loops through each and sets depositConfig based on toChainId[index], tokenAddresses[index]. But there's no check that tokenAddresses[index] is a supported token. So the owner can set deposit config for any token, even unsupported ones. Is that a problem? The depositConfig is a separate mapping, and perhaps other parts of the system use it regardless of whether the token is supported. But if the contract's logic requires that deposit config is only set for supported tokens, then this function allows setting it for any, which could be a misconfiguration. However, since the function is onlyOwner, it's up to the owner's discretion. Maybe it's intended. Not sure if this is a vulnerability, but possibly a logical inconsistency if other functions expect depositConfig to only exist for supported tokens.

In addSupportedToken, after adding the token, it sets transferConfig[tokenAddress].min and max. But the updateTokenCap function allows updating the min and max for the transferConfig. Both functions are onlyOwner, so that's fine. But when adding a supported token, the code doesn't check if the token was already added. So if the owner accidentally calls addSupportedToken twice on the same token, it would overwrite the existing data and set supportedToken to true again. But that's not a vulnerability, just a potential user error. Since the owner is a trusted entity, maybe it's acceptable.

Another thing: the changeFee function requires that _equilibriumFee and _maxFee are not zero. But what if the owner sets equilibriumFee higher than maxFee? There's no check for that. The function allows setting equilibriumFee greater than maxFee, which might be a logical error. For example, if equilibriumFee is meant to be a fee that's between 0 and maxFee, then not checking this could lead to incorrect fee calculations elsewhere. That's a possible vulnerability. Because if equilibriumFee is higher than maxFee, then when other contracts use these values, they might behave unexpectedly. So this is a missing validation in changeFee.

Looking at the addSupportedToken function: it requires that maxCapLimit > minCapLimit. But when updating via updateTokenCap, the same check is present. So that's good. However, when adding a new token, the code doesn't check that equilibriumFee and maxFee are non-zero. Wait, in addSupportedToken, the parameters are minCapLimit, maxCapLimit, equilibriumFee, maxFee. The function checks maxCapLimit > minCapLimit, but doesn't check that equilibriumFee and maxFee are non-zero. However, in the changeFee function, those are checked. So if you add a token with equilibriumFee 0, then the changeFee function would allow changing it, but during addition, the fees could be zero. However, in addSupportedToken, the code sets equilibriumFee and maxFee to the provided parameters. So if the owner passes 0 for equilibriumFee or maxFee here, the token would be added with 0 fees. But the changeFee function requires that these are non-zero. So adding a token with zero fees is possible, which might be a problem if other parts of the system rely on fees being non-zero. For example, if another contract calls getEquilibriumFee and divides by it, leading to a division by zero. Therefore, the addSupportedToken function lacks validation on equilibriumFee and maxFee to ensure they are non-zero. That's a vulnerability.

Another issue: the ERC2771Context is used, which is a trusted forwarder for meta-transactions. The contract overrides _msgSender() and _msgData() to use ERC2771Context's implementation. However, both Ownable and Pausable use the _msgSender() function for access control. Since ERC2771Context's _msgSender() returns the actual sender in a meta-transaction (not the forwarder), this is correct. But there might be a conflict if other contracts aren't expecting meta-transactions. However, since this contract is properly using ERC2771Context, maybe that's intended. But possible issues if, for example, the trusted forwarder is malicious or compromised. But that's more of a trust issue in the forwarder, not a code vulnerability in this contract.

Looking at the pause functionality: the contract inherits Pausable, and some functions (like changeFee) have the whenNotPaused modifier. But other functions like addSupportedToken, removeSupportedToken, setDepositConfig, etc., are only protected by onlyOwner but not paused. So if the contract is paused, the owner can still add/remove tokens, change deposit configs, etc. Depending on the intended functionality, maybe those functions should also be pausable. For example, if the system is paused to prevent changes, but the owner can still modify token configurations, that could be a privilege escalation or unexpected behavior. So the absence of whenNotPaused on critical functions like addSupportedToken could be a vulnerability. If an attacker gains control of the owner account, they could modify configurations even when the contract is paused. But since the owner is supposed to be trusted, maybe it's acceptable. However, according to best practices, administrative functions should also be pausable in case the owner's keys are compromised. So this is a possible vulnerability: missing whenNotPaused modifier on administrative functions.

Another thing: the depositConfig is a mapping that can be set for any toChainId and tokenAddress. However, there's no check in setDepositConfig that the tokenAddress is a supported token. So even if a token isn't supported, the owner can set deposit config for it. Depending on the system's logic, this could be an issue. For example, if other parts of the system check if a token is supported before using deposit config, then it's okay. But if they don't, they might use deposit config for an unsupported token, leading to unexpected behavior. Since this function is onlyOwner, it's up to the owner's configuration, but it's a possible inconsistency.

Reentrancy again: the functions don't have external calls, so reentrancy isn't an issue here.

Another possible issue: in setDepositConfig, the function takes three arrays and loops through them. If the arrays are very large, this could run out of gas. However, since it's an onlyOwner function, the owner should be careful with the array size. Not a vulnerability per se, but a potential gas trap.

Check for front-running: since all the functions are onlyOwner, front-running isn't a concern here.

In the addSupportedToken function, the code sets transferConfig[tokenAddress] and then assigns tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress]. But as mentioned before, since struct assignments are copies, tokensInfo[tokenAddress].tokenConfig will not update when transferConfig is changed later. But since getTokensInfo uses the current transferConfig, this might be okay. However, if any other function uses tokensInfo[tokenAddress].tokenConfig, it would have outdated data. Looking at the code, the only place where tokenConfig is used is in the getTokensInfo function, which uses the current transferConfig, not the one stored in tokensInfo. Therefore, the tokenConfig in tokensInfo is redundant and not used. This is a storage inefficiency but not a vulnerability.

Another possible vulnerability: the getTokensInfo function returns a struct that includes the transferConfig for the token. But if the transferConfig is updated after the TokenInfo was stored, the returned struct would have the latest values. However, since it's a view function, it's supposed to reflect the current state. So that's correct.

What about the tokenChecks modifier: it checks that the token is supported. But in functions like setTokenTransferOverhead, which uses the tokenChecks modifier, it's possible that a token was once supported but then removed. Wait, no. The modifier checks that tokensInfo[tokenAddress].supportedToken is true. So if the token was removed (supportedToken set to false), then the modifier would prevent access. So that's okay.

Now, let's summarize the possible vulnerabilities:

1. **Missing Validation in changeFee Function**: The changeFee function does not check that _equilibriumFee is less than or equal to _maxFee. This could lead to setting equilibriumFee higher than maxFee, causing logical errors in fee calculations elsewhere.

2. **Incorrect Fee Initialization in addSupportedToken**: The addSupportedToken function does not validate that equilibriumFee and maxFee are non-zero. This allows the owner to add a token with zero fees, which might cause issues in other parts of the system that rely on non-zero fees.

3. **Missing Pausable Modifier on Administrative Functions**: Functions such as addSupportedToken, removeSupportedToken, setDepositConfig, etc., are not protected by the whenNotPaused modifier. This means that even if the contract is paused, the owner can still modify critical configurations, which could be problematic if the owner's account is compromised.

4. **Potential Inconsistency in depositConfig**: The setDepositConfig function allows setting configurations for tokens that are not supported. Depending on the system's logic, this could lead to deposit configurations being used for unsupported tokens, causing unexpected behavior.

5. **Redundant Storage in TokenInfo Struct**: The TokenInfo struct includes a tokenConfig field that is stored but not used, leading to redundant storage and potential confusion. While not a direct vulnerability, it could cause inconsistencies if future code changes mistakenly rely on this field.

Let me check again for other issues. For example, integer overflows? The contract uses Solidity 0.8.0, which has built-in checks for overflows, so that's handled.

Another thing: the constructor sets up the ERC2771Context with a trustedForwarder. If the trustedForwarder is malicious or gets compromised, it could allow spoofing of _msgSender(). But that's a trust issue, not a code vulnerability in this contract.

In the setDepositConfig function, there's a loop over tokenConfig.length. If the arrays are too large, it could run out of gas. But since it's an onlyOwner function, the owner should handle it. Not a vulnerability per se.

So the main vulnerabilities are the ones listed above. Let me make sure I didn't miss anything else.","```
None.
```",0.0,0
,,,,,,,,5,16,,,2,2,17,30,,,,0.499666666666667