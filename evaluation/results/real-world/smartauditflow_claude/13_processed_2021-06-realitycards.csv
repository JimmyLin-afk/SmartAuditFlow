nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public orderbook;
    /// @dev nfthub instance, to query current card owner
    IRCNftHubL2 public nfthub;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev address of the Factory so only the Factory can add new markets
    address public override factoryAddress;
    /// @dev so only markets can use certain functions
    mapping(address => bool) public override isMarket;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public marketBalance;
    /// @dev a quick check if a uesr is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 marketBalanceDiscrepancy;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent any cards for specific market
    mapping(address => bool) public override marketPaused;

    /*╔═════════════════════════════════╗
      ║            UBER OWNER           ║
      ╚═════════════════════════════════╝*/
    /// @dev high level owner who can change the factory address
    address public override uberOwner;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1000000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /// @notice only allow markets to call these functions
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    /// @notice only allow orderbook to call these functions
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║           ADD MARKETS           ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can move funds from deposits to marketPots and vice versa
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyOwner
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental for a specific market
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add a user to the whitelist
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    /// @notice Add multiple users to the whitelist
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract (newRental) or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // stpe 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    /// @notice provides the sum total of a users bids accross all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                // they have enough funds, just collect the extra
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /// @dev called when all a user's bids have been removed, disables foreclosure state
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calcualtion and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calcualtes the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the amount of deposit a user is able to withdraw
    /// @notice ..after considering rent due to be paid
    /// @param _user the user to query
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)
            //                   = (deposit * 1day) / totalUserDailyRent
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                // calculate how long they can own the new card for
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            // if no rentals they'll foreclose after the heat death of the universe
            return type(uint256).max;
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepsitLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets availiable balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7143,761,"[H-01] Unchecked ERC20 transfers can cause lock up
Some major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.
Today many tools, including OpenZeppelin, offer a wrapper for “safe ERC20 transfer”:
RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the balancedBooks modifier:
``` modifier balancedBooks {
    _;
    // using >= not == in case anyone sends tokens direct to contract
    require(
        erc20.balanceOf(address(this)) >=
            totalDeposits + marketBalance + totalMarketPots,
        ""Books are unbalanced!""
    );
}
```
This modifier is present on most functions, but is missing on topupMarketBalance:
``` function topupMarketBalance(uint256 _amount) external override {
    erc20.transferFrom(msgSender(), address(this), _amount);
    if (_amount > marketBalanceDiscrepancy) {
        marketBalanceDiscrepancy = 0;
    } else {
        marketBalanceDiscrepancy -= _amount;
    }
    marketBalance += _amount;
}
```
In the case where an ERC20 token which is not reverting on failures is used, a malicious actor could call topupMarketBalance with a failing transfer, but also move the value of marketBalance above the actual holdings. After this, deposit, withdrawDeposit, payRent, payout, sponsor, etc. could be locked up and always failing with “Books are unbalanced”.
 [H-02] Can access cards of other markets
Within `RCMarket.sol` the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.
You can still only move cards you own.
``` // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards
        return nfthub.ownerOf(_tokenId);
    }

https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313
  modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner""); // _token could be higher than numberOfCards,
        _;
    }

function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,
    _checkState(States.WITHDRAW);
    require(
        !factory.trapIfUnapproved() ||
            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market
        ""Upgrade blocked""
    );
    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market
    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
    nfthub.withdrawWithMetadata(_tokenId);
    emit LogNftUpgraded(_card, _tokenId);
} ```   [H-04] Anyone can affect deposits of any user and turn the owner of the token
On RCTreasury, we have the method collectRentUser. This method is public, so anyone can call it using whatever user and whatever timestamp. So, calling this method using user = XXXXX and _timeToCollectTo = type(uint256).max), would make isForeclosed[user] = true.
See issue page for referenced code
Now, we can do the same for all the users bidding for a specific token. Finally, I can become the owner of the token by just calling newRental and using a small price. newRental will iterate over all the previous bid and will remove them because there are foreclosed.
Recommend that collectRentUser should be private and create a new public method with onlyOrderbook modifier.
 [M-01] payout doesn't fix isForeclosed state
The function `payout` of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.
For example the function refundUser doesn't check and update the isForeclosed status in RCTreasury on L429 and line 447.
Recommend checking and updating the isForeclosed state in the payout function.
 [M-02] Critical uberOwner address changes should be a two-step process
As specified, uberOwners of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.
 The contracts allow for `uberOwners` to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.
  [M-03] Missing balancedBooks modifier could result in failed system insolvency detection
The `balancedBooks` modifier is used to “check that funds haven't gone missing during this function call” and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.
However, this modifier is missing in the refundUser() and topupMarketBalance() functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.
  [M-16] Deposits can be denied by abusing maxContractBalance
The treasury implements a max contract balance check in the `deposit` function: ```
require(
    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
    ""Limit hit""
);
```
A whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.
  [M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected
The function `foreclosureTimeUser` of RCTreasury underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.
The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable timeLeftOfDeposit indicates the time left of deposit, starting from now. However, at line 672, the foreclosureTimeWithoutNewCard is calculated by timeLeftOfDeposit plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.",8,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";




contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    
    
    IRCOrderbook public orderbook;
    
    IRCNftHubL2 public nfthub;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    address public override factoryAddress;
    
    mapping(address => bool) public override isMarket;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 marketBalanceDiscrepancy;

    
    
    
    
    
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    
    
    
    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;

    
    
    address public override uberOwner;

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        uberOwner = msgSender();

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1000000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    

    
    modifier balancedBooks {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    

    
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    

    
    

    

    
    
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    

    
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            
            
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            
            return type(uint256).max;
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    
}",4101,3,5,"Based on the comprehensive analysis of the RCTreasury contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the balancedBooks modifier for potential bypass mechanisms"",
        ""Verify SafeCast usage prevents integer overflow/underflow in all conversion operations"",
        ""Check for potential reentrancy vulnerabilities in deposit and withdrawal functions"",
        ""Validate access control checks in critical functions like collectRentUser and updateRentalRate"",
        ""Review external calls to ensure they cannot be manipulated by malicious contracts""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the uberOwner mechanism for potential centralization risks"",
        ""Verify the scope and limitations of onlyMarkets and onlyOrderbook modifiers"",
        ""Review whitelist implementation for potential circumvention"",
        ""Analyze the multi-layered ownership structure (owner vs uberOwner)"",
        ""Check for potential privilege escalation vulnerabilities""
      ]
    },
    {
      ""Area"": ""Financial Mechanics"",
      ""Tasks"": [
        ""Thoroughly validate the rent calculation logic in rentOwedUser and rentOwedBetweenTimestmaps"",
        ""Analyze foreclosure mechanism for potential edge cases"",
        ""Review marketBalanceDiscrepancy tracking for potential accounting issues"",
        ""Verify the accuracy of total deposits and market pot calculations"",
        ""Check cross-contract interactions for potential financial manipulation""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit bridge withdrawal mechanisms for cross-chain security"",
        ""Verify token approval and transfer mechanisms"",
        ""Check interface interactions with Orderbook, NftHub, and Factory contracts"",
        ""Validate address setting functions against potential NULL address attacks"",
        ""Review external contract call patterns for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency Controls"",
      ""Tasks"": [
        ""Analyze global pause mechanism for comprehensive coverage"",
        ""Verify market-specific pause functionality"",
        ""Check the implications of emergency stops on ongoing transactions"",
        ""Review the completeness of pause checks across different function types""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Identify potential gas-intensive operations in complex functions"",
        ""Review loop structures for gas efficiency (e.g., batchAddToWhitelist)"",
        ""Analyze storage variable packing and optimization opportunities"",
        ""Check for redundant calculations or unnecessary storage writes""
      ]
    },
    {
      ""Area"": ""Economic Attack Vectors"",
      ""Tasks"": [
        ""Analyze potential economic exploits in rental rate calculations"",
        ""Review whitelist bypass mechanisms"",
        ""Check for potential front-running in deposit and withdrawal functions"",
        ""Validate economic incentives and potential manipulation points"",
        ""Review foreclosure mechanism for potential economic attacks""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC20 token interaction compliance"",
        ""Check NativeMetaTransaction implementation against EIP-712 standard"",
        ""Review event emissions for completeness and accuracy"",
        ""Validate interface implementations match expected behaviors""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, financial, and operational aspects of the contract.
2. Each area addresses specific risks identified in the initial code review.
3. Tasks are designed to be specific, actionable, and targeted to the contract's unique architecture.
4. The breakdown allows for systematic and thorough auditing across multiple dimensions.

Recommended Next Steps:
- Prioritize tasks based on potential impact and likelihood of vulnerability
- Conduct a line-by-line code review following these task categories
- Use static analysis tools to complement manual audit tasks
- Perform comprehensive testing scenarios for edge cases

Would you like me to elaborate on any specific area or provide more detailed analysis of potential vulnerabilities?","I've performed a thorough audit of the provided smart contract code. Here are my findings:

{
  ""ReviewingTheCode"": ""The code implements a treasury contract for a Reality Cards platform, managing deposits, rent payments, and market operations. It handles user funds, rental rates, bidding, and foreclosure mechanisms in a decentralized marketplace environment."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCTreasury"",
    ""Purpose"": ""To manage user deposits, rental payments, market balances, and handle financial operations for the Reality Cards protocol on Layer 2."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""NativeMetaTransaction"", ""IRCTreasury""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/utils/math/SafeCast.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""hardhat/console.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCOrderbook.sol"",
        ""./interfaces/IRCNftHubL2.sol"",
        ""./interfaces/IRCFactory.sol"",
        ""./interfaces/IRCBridge.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""orderbook"",
        ""Type"": ""IRCOrderbook"",
        ""Purpose"": ""Interface to the orderbook contract""
      },
      {
        ""Name"": ""nfthub"",
        ""Type"": ""IRCNftHubL2"",
        ""Purpose"": ""Interface to the NFT hub contract on Layer 2""
      },
      {
        ""Name"": ""erc20"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The ERC20 token used for payments in the system""
      },
      {
        ""Name"": ""bridgeAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the bridge contract for cross-chain transfers""
      },
      {
        ""Name"": ""factoryAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the factory contract that creates markets""
      },
      {
        ""Name"": ""isMarket"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps addresses to whether they are recognized markets""
      },
      {
        ""Name"": ""totalDeposits"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total user deposits held by the treasury""
      },
      {
        ""Name"": ""marketPot"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maps market addresses to their accumulated funds""
      },
      {
        ""Name"": ""totalMarketPots"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total funds across all market pots""
      },
      {
        ""Name"": ""marketBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Available balance for market operations""
      },
      {
        ""Name"": ""isForeclosed"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks whether a user's account is foreclosed""
      },
      {
        ""Name"": ""marketBalanceDiscrepancy"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks discrepancies in market balance for bookkeeping""
      },
      {
        ""Name"": ""user"",
        ""Type"": ""mapping(address => User)"",
        ""Purpose"": ""Maps user addresses to their data structure""
      },
      {
        ""Name"": ""minRentalDayDivisor"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Divisor for daily rental rate calculations""
      },
      {
        ""Name"": ""maxContractBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum balance the contract can hold""
      },
      {
        ""Name"": ""isAllowed"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Whitelist of allowed users""
      },
      {
        ""Name"": ""whitelistEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Toggle for whitelist functionality""
      },
      {
        ""Name"": ""globalPause"",
        ""Type"": ""bool"",
        ""Purpose"": ""Global pause switch for all operations""
      },
      {
        ""Name"": ""marketPaused"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps markets to their paused status""
      },
      {
        ""Name"": ""uberOwner"",
        ""Type"": ""address"",
        ""Purpose"": ""Super admin with special privileges""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""balancedBooks"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Ensures contract's books are balanced after function execution""
      },
      {
        ""Name"": ""onlyMarkets"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function calls to registered markets""
      },
      {
        ""Name"": ""onlyOrderbook"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function calls to the orderbook contract""
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to deposit tokens into their account"",
        ""Parameters"": [""uint256 _amount"", ""address _user""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""withdrawDeposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their deposits"",
        ""Parameters"": [""uint256 _amount"", ""bool _localWithdrawal""],
        ""Returns"": []
      },
      {
        ""Name"": ""payRent"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by markets to pay rent from market balance to market pot"",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""payout"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers funds from market pot to user deposit"",
        ""Parameters"": [""address _user"", ""uint256 _amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""refundUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Refunds a user from market balance"",
        ""Parameters"": [""address _user"", ""uint256 _refund""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateRentalRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates rental rates when ownership changes"",
        ""Parameters"": [""address _oldOwner"", ""address _newOwner"", ""uint256 _oldPrice"", ""uint256 _newPrice"", ""uint256 _timeOwnershipChanged""],
        ""Returns"": []
      },
      {
        ""Name"": ""collectRentUser"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Collects rent owed by a user"",
        ""Parameters"": [""address _user"", ""uint256 _timeToCollectTo""],
        ""Returns"": [""uint256 newTimeLastCollectedOnForeclosure""]
      },
      {
        ""Name"": ""foreclosureTimeUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates when a user will be foreclosed based on their deposit and rental rate"",
        ""Parameters"": [""address _user"", ""uint256 _newBid"", ""uint256 _timeOfNewBid""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""addMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Registers a new market contract"",
        ""Parameters"": [""address _newMarket""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMinRental"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the minimum rental day divisor"",
        ""Parameters"": [""uint256 _newDivisor""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxContractBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the maximum contract balance"",
        ""Parameters"": [""uint256 _newBalanceLimit""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRCOrderbook - Interacts with the orderbook for bid management"",
    ""IRCNftHubL2 - Interacts with NFT operations on Layer 2"",
    ""IERC20 - Interacts with the ERC20 token for transfers and approvals"",
    ""IRCFactory - Interacts with factory for market creation and governance checks"",
    ""IRCBridge - Interacts with bridge for cross-chain withdrawals""
  ],
  ""SpecialMechanisms"": [
    ""Rent calculation mechanism based on time elapsed and rental rates"",
    ""Foreclosure system that tracks when users cannot afford their rental obligations"",
    ""Meta-transaction pattern for gas-less transactions via NativeMetaTransaction"",
    ""Whitelist mechanism for controlling who can use the platform"",
    ""UberOwner pattern with special administrative privileges beyond normal owner functions"",
    ""Balanced books accounting ensuring contract assets match liabilities"",
    ""Layer 2 to mainnet withdrawal bridge integration""
  ],
  ""Questions"": [
    ""What happens if the marketBalanceDiscrepancy grows too large? Is there a mechanism to reconcile it fully?"",
    ""How are the NFTs represented that users are paying rent for?"",
    ""What happens if there's an out-of-gas error during collectRentUser, especially if a user is about to be foreclosed?"",
    ""Could the 'balancedBooks' modifier create issues if external token transfers are made to the contract without using the contract's functions?"",
    ""How does the bridge mechanism prevent double-withdrawals across chains?"",
    ""Is there a mechanism to recover funds if they are accidentally sent to the contract instead of deposited through the deposit function?"",
    ""What security measures prevent a malicious orderbook contract from draining user funds via the updateRentalRate function?""
  ]
}","I've analyzed the data containing multiple issue reports for the RCTreasury contract. After consolidating similar issues and removing redundancies, I've organized the findings by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in withdrawDeposit"",
      ""Severity"": ""High"",
      ""Description"": ""The withdrawDeposit function performs external calls (erc20.transfer or bridge.withdrawToMainnet) after state changes but without proper reentrancy protection. The contract updates state variables (user deposits and totalDeposits) before making external calls, creating a classic reentrancy vulnerability pattern."",
      ""Impact"": ""An attacker could potentially drain funds by reentering the contract through callbacks before state updates are completed, potentially allowing double withdrawals or other state manipulation attacks."",
      ""Location"": ""withdrawDeposit function (lines 244-336)""
    },
    {
      ""Issue"": ""Unbounded Token Approval to Bridge Contract"",
      ""Severity"": ""High"", 
      ""Description"": ""In the setBridgeAddress function, the contract approves the bridge to spend an unlimited amount of tokens (type(uint256).max). This is a risky practice as a compromised bridge could drain all funds."",
      ""Impact"": ""If the bridge contract is compromised, an attacker could drain all ERC20 tokens from the treasury contract."",
      ""Location"": ""setBridgeAddress function (line 245-254)""
    },
    {
      ""Issue"": ""Improper Access Control and Centralized Power"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract implements a two-tier ownership model with 'owner' and 'uberOwner' roles that have extensive control over the system. The uberOwner can change critical addresses and configurations without timelock or governance mechanisms. Some critical functions use msgSender() == uberOwner without a proper modifier, which is error-prone."",
      ""Impact"": ""If privileged accounts are compromised, an attacker could disrupt the entire system, steal funds, or manipulate the contract's behavior by changing critical addresses or parameters."",
      ""Location"": ""Functions with onlyOwner modifier and those requiring uberOwner, particularly setFactoryAddress, setOrderbookAddress, setNftHubAddress, setTokenAddress, setBridgeAddress, changeUberOwner""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using Solidity 0.8.4 which has built-in overflow protection, the contract uses SafeCast for downcasting to smaller integer types (uint128, uint64). There are complex arithmetic operations in functions like rentOwedUser and foreclosureTimeUser without proper validation that values will fit into target types before casting."",
      ""Impact"": ""Large transactions or extreme edge cases could cause unexpected behavior, accounting errors, incorrect rent calculations, or foreclosures at incorrect times due to overflow when casting to smaller integer types."",
      ""Location"": ""Throughout the contract where SafeCast is used, such as in deposit, withdrawDeposit, updateRentalRate functions, rentOwedUser, rentOwedBetweenTimestmaps""
    },
    {
      ""Issue"": ""Missing Zero-Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor takes a token address parameter but doesn't validate that it's not the zero address. While later setter functions have this validation, the initial constructor and some user-facing functions don't implement this basic safety check."",
      ""Impact"": ""If the contract is deployed with the zero address as the token, it would require immediate redeployment, wasting gas and potentially causing confusion among users. Tokens could also be sent to inaccessible addresses."",
      ""Location"": ""Constructor (lines 108-116) and some user-facing functions""
    },
    {
      ""Issue"": ""Rent Collection Precision Issues"",
      ""Severity"": ""Medium"",
      ""Description"": ""The rentOwedUser and rentOwedBetweenTimestmaps functions calculate rent based on daily rates but divide by 1 days (86400 seconds). This division can lead to precision loss, especially for small rental amounts or time periods less than a day."",
      ""Impact"": ""Users could be charged slightly incorrect rent amounts due to integer division rounding down. Over time and across many users, this could lead to protocol fund imbalances."",
      ""Location"": ""rentOwedUser (lines 562-568) and rentOwedBetweenTimestmaps (lines 579-588)""
    },
    {
      ""Issue"": ""Improper Foreclosure Logic and Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The deposit function uses complex foreclosure logic that depends on a comparison between the user's deposit and their bid rate divided by minRentalDayDivisor. The foreclosure state is updated based on a direct comparison between deposit and bidRate without considering the actual rent owed."",
      ""Impact"": ""Users might be incorrectly marked as foreclosed or not foreclosed, affecting their ability to interact with the system and allowing them to continue bidding when they shouldn't be able to."",
      ""Location"": ""deposit function (lines 190-216, 284-288)""
    },
    {
      ""Issue"": ""Market Balance Discrepancy Tracking Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses marketBalance and marketBalanceDiscrepancy to track market funds, with ad-hoc adjustments in functions like payRent and topupMarketBalance. This complicated approach makes it difficult to reason about the correctness of balance tracking."",
      ""Impact"": ""The contract could develop persistent accounting mismatches that become difficult to reconcile over time, potentially leading to fund loss or incorrect market payouts."",
      ""Location"": ""payRent function (lines 341-389), topupMarketBalance function (lines 284-356)""
    },
    {
      ""Issue"": ""Insufficient Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Many functions lack proper input validation for critical parameters. For example, setMinRental and setMaxContractBalance don't validate that inputs are reasonable, and updateRentalRate doesn't validate that timestamps and prices make logical sense."",
      ""Impact"": ""Setting extreme values could break contract functionality, create denial of service conditions, or lead to unexpected behaviors and accounting errors."",
      ""Location"": ""setMinRental, setMaxContractBalance, updateRentalRate, collectRentUser functions""
    },
    {
      ""Issue"": ""Unchecked Return Values on ERC20 Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not use SafeERC20 for token operations and doesn't check the return values of ERC20 transfer and transferFrom calls. Some ERC20 tokens return a boolean to indicate success, and failing to check this can lead to silent failures."",
      ""Impact"": ""Failed withdrawals or transfers might not be detected, leading to accounting errors where the contract thinks a transfer succeeded when it didn't."",
      ""Location"": ""Throughout the contract where erc20.transfer or erc20.transferFrom is used""
    },
    {
      ""Issue"": ""Approval Race Condition"",
      ""Severity"": ""Medium"",
      ""Description"": ""In functions like deposit(), the contract checks allowance and then transfers tokens in separate steps. This creates a potential race condition where an allowance could be modified between checking and transferring."",
      ""Impact"": ""An attacker could exploit this vulnerability by front-running transactions, potentially causing unexpected transfers or failed transactions."",
      ""Location"": ""deposit() function""
    },
    {
      ""Issue"": ""Denial of Service in collectRentUser"",
      ""Severity"": ""Medium"",
      ""Description"": ""The collectRentUser function relies on complex calculations to determine rent owed and update user states. There's no upper bound on the time difference calculation, which could lead to gas-limit issues for users who haven't used the system for extended periods."",
      ""Impact"": ""Users might be unable to interact with the contract if the rental calculation becomes too gas-intensive, effectively locking their funds."",
      ""Location"": ""collectRentUser function (lines 510-543)""
    },
    {
      ""Issue"": ""Timestamp Dependence for Critical Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract heavily relies on block.timestamp for calculating rent and determining foreclosure. Miners have some flexibility in setting timestamps, which could be manipulated in some cases."",
      ""Impact"": ""In edge cases, miners could slightly manipulate timestamps to influence rent calculations and foreclosures, potentially to their advantage."",
      ""Location"": ""Multiple locations including collectRentUser and foreclosureTimeUser functions""
    },
    {
      ""Issue"": ""Lack of Event Emissions for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Several important functions that modify critical state variables don't emit events, making it difficult to track changes off-chain. For example, setting addresses like bridgeAddress and factoryAddress doesn't emit events."",
      ""Impact"": ""Reduced transparency and difficulty tracking important contract changes, which can impact security auditing and monitoring."",
      ""Location"": ""Functions like setTokenAddress, setBridgeAddress, and administrative functions""
    },
    {
      ""Issue"": ""Unbounded Operation in balancedBooks Modifier"",
      ""Severity"": ""Low"",
      ""Description"": ""The balancedBooks modifier checks after function execution that the contract's token balance is sufficient to cover all obligations. This pattern could lead to locked funds if the check fails, as the transaction would revert after all operations. Additionally, it doesn't place an upper bound, allowing excess funds accumulation."",
      ""Impact"": ""Functions could fail at the very end of execution, wasting gas and potentially confusing users. The contract could also accumulate excess funds that aren't properly tracked."",
      ""Location"": ""balancedBooks modifier (lines 119-128) and all functions using it""
    },
    {
      ""Issue"": ""Complex State Management"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses complex state management with multiple interrelated variables tracking balances, deposits, and rates, making it difficult to reason about correctness and increasing the likelihood of logical errors."",
      ""Impact"": ""Higher chance of accounting discrepancies, bugs, or unexpected behavior due to the complexity of state management."",
      ""Location"": ""Throughout the contract, especially in functions that manage user deposits, market balances, and rental rates""
    }
  ],
  ""IssueNumber"": 81,
  ""OutputList"": 16
}",467.50121808052063,92159.0,32.0,"### **Summary of Matches and Gaps**

---

#### **[H-01] Unchecked ERC20 transfers can cause lock up**

**Report Description**:
The issue highlights that some ERC20 tokens do not revert on failure but instead return `true` or `false`. The `topupMarketBalance` function in the contract does not use a safe ERC20 transfer wrapper, and the `balancedBooks` modifier is missing from this function. This could allow a malicious actor to call `topupMarketBalance` with a failing transfer, causing the `marketBalance` to exceed actual holdings and lock up functions like `deposit`, `withdrawDeposit`, `payRent`, and `payout`.

**Match in Response List**:
Matches with the issue titled **""Unchecked Return Values on ERC20 Transfers""**.

**Validation**:
**Correct**. The response accurately identifies the issue with unchecked ERC20 transfers and explains the risks associated with not validating return values. This aligns with the issue report and Solidity best practices.

---

#### **[H-02] Can access cards of other markets**

**Report Description**:
The `ownerOf` and `onlyTokenOwner` functions in `RCMarket.sol` do not check if the `_cardId` or `_token` is within the bounds of `numberOfCards`. This allows access to cards in other markets, particularly in the `upgradeCard` function, where the `isMarketApproved` check can be circumvented by calling the function via another market.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves improper access control and boundary checks in the `RCMarket.sol` contract.

---

#### **[H-04] Anyone can affect deposits of any user and turn the owner of the token**

**Report Description**:
The `collectRentUser` function in `RCTreasury.sol` is public and can be called by anyone with arbitrary parameters, allowing malicious actors to mark users as foreclosed. This can be exploited to manipulate the ownership of tokens by calling `newRental` with a small price after foreclosing all other users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves improper access control and the potential for malicious manipulation of user states.

---

#### **[M-01] payout doesn't fix isForeclosed state**

**Report Description**:
The `payout` function in `RCTreasury.sol` does not update the `isForeclosed` state of a user, even though receiving funds should remove the foreclosure status. This could lead to incorrect user states and prevent users from interacting with the system.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves improper state management in the `payout` function.

---

#### **[M-02] Critical uberOwner address changes should be a two-step process**

**Report Description**:
The `changeUberOwner` function allows the `uberOwner` to change the address without a two-step process or validation of the new address. If an invalid address is used, the system could be permanently locked.

**Match in Response List**:
Matches with the issue titled **""Improper Access Control and Centralized Power""**.

**Validation**:
**Partially Correct**. The response identifies the issue with centralized power and improper access control but does not specifically address the lack of a two-step process for `uberOwner` changes.

---

#### **[M-03] Missing balancedBooks modifier could result in failed system insolvency detection**

**Report Description**:
The `balancedBooks` modifier is missing from the `refundUser` and `topupMarketBalance` functions, which could lead to miscalculations and system insolvency if funds go missing during these operations.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves missing critical checks in the `refundUser` and `topupMarketBalance` functions.

---

#### **[M-16] Deposits can be denied by abusing maxContractBalance**

**Report Description**:
The `deposit` function in `RCTreasury.sol` includes a check for `maxContractBalance`. A whale could front-run a user's deposit to push the contract balance to the limit, causing the user's deposit to fail.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves a potential denial-of-service attack via front-running.

---

#### **[M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected**

**Report Description**:
The `foreclosureTimeUser` function in `RCTreasury.sol` underestimates the user's foreclosure time by incorrectly calculating `timeLeftOfDeposit`. This could lead to incorrect results when determining the new owner of a card.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves incorrect calculations in the `foreclosureTimeUser` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Unchecked ERC20 transfers can cause lock up**

**Partially Correct Matches**:

- **[M-02] Critical uberOwner address changes should be a two-step process**

**Missed Issues from Issue Report**:

- **[H-02] Can access cards of other markets**
- **[H-04] Anyone can affect deposits of any user and turn the owner of the token**
- **[M-01] payout doesn't fix isForeclosed state**
- **[M-03] Missing balancedBooks modifier could result in failed system insolvency detection**
- **[M-16] Deposits can be denied by abusing maxContractBalance**
- **[M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected**

---

The response list covers some issues but misses several critical vulnerabilities and risks identified in the issue report. Improvements are needed to address the gaps in coverage, particularly in access control, state management, and arithmetic calculations.","```
1. Unchecked Return Values on ERC20 Transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked Return Values on ERC20 Transfers"".
   - This issue appears at rank 11 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 11 (\( P@11 \)) is calculated as the number of true positives up to rank 11 divided by 11.
   - Since there is only one true positive up to rank 11, \( P@11 = \frac{1}{11} \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = P@11 = \frac{1}{11} \).

**Average Precision (AP)**: 0.0909"
RCMarket.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",10267,1122,"[H-03] anyone can call function sponsor

Submitted by paulius.eth, also found by 0xRajeev, cmichel, and shw
This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:
```     /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }
``  [M-07] maxSumOfPrices check is broken
`rentAllCards()` requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.
However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total number of bids placed greater than the _maxSumOfPrices specified.
The impact of this is that the user may not have sufficient deposited, be foreclosed upon and/or impacted on other bids/markets.
  [M-13] Wrong calculation on _collectRentAction
The method _collectRentAction contains the following code:
in case 6, it is doing: ```
_refundTime = block.timestamp - marketLockingTime;
```
instead of: ```
_refundTime = _timeUserForeclosed - marketLockingTime;
```",3,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";




contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    

    
    
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    
    bool public constant override isMarket = true;
    
    
    uint256 public totalNftMintCount;

    
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    
    
    mapping(uint256 => uint256) public cardPrice;
    
    mapping(address => uint256) public rentCollectedPerUser;
    
    mapping(uint256 => uint256) public rentCollectedPerCard;
    
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    
    uint256 public totalRentCollected;
    
    mapping(address => uint256) public exitedTimestamp;

    
    
    
    uint256 public minimumPriceIncreasePercent;
    
    uint256 public minRentalDayDivisor;
    
    uint256 public maxRentIterations;

    
    
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    
    mapping(uint256 => uint256) public totalTimeHeld;
    
    mapping(uint256 => uint256) public timeLastCollected;
    
    mapping(uint256 => uint256) public longestTimeHeld;
    
    mapping(uint256 => address) public longestOwner;
    
    mapping(uint256 => uint256) public cardTimeLimit;

    
    
    uint32 public marketOpeningTime;
    
    uint32 public override marketLockingTime;
    
    
    uint32 public oracleResolutionTime;

    
    uint256 public winningOutcome;
    
    mapping(address => bool) public userAlreadyWithdrawn;
    
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; 
    
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    
    uint256 public winnerCut;
    
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    

    
    
    
    
    
    
    
    
    
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        
        winningOutcome = MAX_UINT256; 

        
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        
        
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    

    
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    

    
    
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); 
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    
    
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    
    
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    

    
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    
    
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        
        setWinner(uint256(_winningOutcome));
    }

    
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    

    
    
    
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    
    
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    
    
    
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    
    function _returnRent() internal {
        
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    
    
    
    

    
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    
    
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    

    

    
    
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    
    
    function rentAllCards(uint256 _maxSumOfPrices) external {
        
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    
    
    
    
    
    
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    
    
    
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    
    
    
    
    
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        
        exitedTimestamp[_msgSender] = block.timestamp;

        
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    
    
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    
    
    
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    

    
    
    
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        
        
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            
            bool _newOwner;
            uint256 _refundTime; 

            

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                
                
                
                
                
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < marketLockingTime) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                
                
                
                
                
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); 

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            
            
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    
    
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    

    
    
    
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    
}",6724,1,2,"Based on the detailed analysis of the RCMarket contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the re-entrancy protection in external contract calls (treasury, nfthub, orderbook)"",
        ""Review all mathematical operations for potential overflow/underflow risks"",
        ""Verify SafeCast library usage and ensure safe type conversions"",
        ""Check for potential unauthorized access through meta-transaction mechanisms"",
        ""Validate input validation and sanitization in all public/external functions""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Audit the implementation of onlyTokenOwner and other access control modifiers"",
        ""Verify the scope and security of admin/owner functions like circuitBreaker and setAmicableResolution"",
        ""Review the authorization flow for stakeholder payment functions (payArtist, payMarketCreator, etc.)"",
        ""Ensure proper access controls in state transition methods""
      ]
    },
    {
      ""Area"": ""Oracle and External Interactions"",
      ""Tasks"": [
        ""Thoroughly examine the Reality.eth oracle integration and resolution mechanism"",
        ""Analyze potential oracle manipulation vectors in getWinnerFromOracle"",
        ""Review the fallback and emergency resolution mechanisms"",
        ""Verify timeout and arbitration settings for oracle interactions"",
        ""Check the robustness of questionFinalised and isFinalized checks""
      ]
    },
    {
      ""Area"": ""State Management and Market Mechanics"",
      ""Tasks"": [
        ""Validate the state machine logic and transition conditions"",
        ""Review the complex rent collection mechanism in _collectRent and _collectRentAction"",
        ""Analyze the different market modes (CLASSIC, WINNER_TAKES_ALL, SAFE_MODE)"",
        ""Check the time-based ownership and rental limit implementations"",
        ""Verify the correctness of market locking and withdrawal processes""
      ]
    },
    {
      ""Area"": ""Financial Calculations and Reward Distribution"",
      ""Tasks"": [
        ""Audit the rent calculation and collection algorithms"",
        ""Verify the accuracy of stakeholder cut calculations"",
        ""Review the payout mechanisms in _payoutWinnings and _returnRent"",
        ""Check for potential rounding errors or economic exploits"",
        ""Validate the sponsor and sponsorship tracking mechanisms""
      ]
    },
    {
      ""Area"": ""Proxy and Upgradability"",
      ""Tasks"": [
        ""Review the initializer function for potential initialization vulnerabilities"",
        ""Verify the correct implementation of the Initializable pattern"",
        ""Check for potential storage collision risks"",
        ""Analyze the upgrade path and potential upgrade-related security issues""
      ]
    },
    {
      ""Area"": ""Meta-Transaction and Gas Optimization"",
      ""Tasks"": [
        ""Audit the NativeMetaTransaction implementation"",
        ""Verify the gas efficiency of complex functions like collectRentAllCards"",
        ""Review the maxRentIterations limit and its potential impact"",
        ""Check for potential gas griefing or DoS vectors"",
        ""Analyze the meta-transaction signature verification process""
      ]
    },
    {
      ""Area"": ""Emergency and Circuit Breaker Mechanisms"",
      ""Tasks"": [
        ""Review the circuitBreaker function and its activation conditions"",
        ""Verify the emergency stop and market closure mechanisms"",
        ""Check the robustness of fallback resolution methods"",
        ""Analyze potential centralization risks in emergency procedures""
      ]
    },
    {
      ""Area"": ""Cross-Functional Integration"",
      ""Tasks"": [
        ""Verify interactions between RCMarket and other contracts (Treasury, NFTHub, Orderbook)"",
        ""Check the consistency of interfaces and method calls"",
        ""Review error handling and failure modes in cross-contract interactions"",
        ""Validate the integration of multiple contracts in the market ecosystem""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the RCMarket contract, covering critical areas of security, functionality, and potential vulnerabilities. Each area is broken down into specific, actionable tasks that address the complex nature of the contract's design and implementation.

The tasks are designed to:
- Identify potential security risks
- Verify the correctness of complex logic
- Ensure robust access controls
- Validate external interactions
- Check financial calculation accuracy
- Review upgradability and meta-transaction mechanisms
- Assess emergency and circuit breaker functions

Would you like me to elaborate on any of these tasks or provide more detailed guidance for the audit?","I've performed a thorough audit of the RCMarket contract. Here is my analysis:

{
  ""ReviewingTheCode"": ""This is a Reality Cards market contract that implements a rentable NFT marketplace with features for time-based ownership, multiple outcome selections, different game modes, and integration with an oracle. The contract manages a prediction market where users can rent NFT cards representing different outcomes for events."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCMarket"",
    ""Purpose"": ""A decentralized platform for event prediction markets where users can rent NFT cards representing different outcomes. The contract manages rental payments, tracks ownership time, determines winners, and distributes rewards following event resolution."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""NativeMetaTransaction"", ""IRCMarket""],
      ""Imports"": [
        ""@openzeppelin/contracts/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts/utils/math/SafeCast.sol"",
        ""hardhat/console.sol"",
        ""./interfaces/IRealitio.sol"",
        ""./interfaces/IRCFactory.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCNftHubL2.sol"",
        ""./interfaces/IRCOrderbook.sol"",
        ""./lib/NativeMetaTransaction.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""numberOfCards"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the total number of cards/outcomes available in this market""
      },
      {
        ""Name"": ""state"",
        ""Type"": ""States"",
        ""Purpose"": ""Tracks the current state of the market (CLOSED, OPEN, LOCKED, WITHDRAW)""
      },
      {
        ""Name"": ""mode"",
        ""Type"": ""Mode enum"",
        ""Purpose"": ""Defines the market mode (CLASSIC, WINNER_TAKES_ALL, SAFE_MODE)""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""IRCTreasury"",
        ""Purpose"": ""Interface to the treasury contract that handles payments and deposits""
      },
      {
        ""Name"": ""factory"",
        ""Type"": ""IRCFactory"",
        ""Purpose"": ""Interface to the factory contract that created this market""
      },
      {
        ""Name"": ""nfthub"",
        ""Type"": ""IRCNftHubL2"",
        ""Purpose"": ""Interface to the NFT management contract""
      },
      {
        ""Name"": ""orderbook"",
        ""Type"": ""IRCOrderbook"",
        ""Purpose"": ""Interface to the orderbook contract for bids and ownership""
      },
      {
        ""Name"": ""cardPrice"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Tracks the current rental price for each card""
      },
      {
        ""Name"": ""winningOutcome"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Stores the ID of the winning outcome/card after resolution""
      },
      {
        ""Name"": ""realitio"",
        ""Type"": ""IRealitio"",
        ""Purpose"": ""Interface to the Reality.eth oracle for resolving outcomes""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the market contract with required parameters"",
        ""Parameters"": [""_mode"", ""_timestamps"", ""_numberOfCards"", ""_totalNftMintCount"", ""_artistAddress"", ""_affiliateAddress"", ""_cardAffiliateAddresses"", ""_marketCreatorAddress"", ""_realitioQuestion""],
        ""Returns"": []
      },
      {
        ""Name"": ""transferCard"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers ownership of a card from one address to another"",
        ""Parameters"": [""_from"", ""_to"", ""_cardId"", ""_price"", ""_timeLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""newRental"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates a new rental bid for a card with specified price and time limit"",
        ""Parameters"": [""_newPrice"", ""_timeHeldLimit"", ""_startingPosition"", ""_card""],
        ""Returns"": []
      },
      {
        ""Name"": ""exit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to exit their rental position on a specific card"",
        ""Parameters"": [""_card""],
        ""Returns"": []
      },
      {
        ""Name"": ""lockMarket"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Locks the market when it's time to conclude, preventing further rentals"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their winnings or get rent refunds after market resolution"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""autoUnlock"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Automatically unlocks the market if the opening time has passed"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""autoLock"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Automatically locks the market if the locking time has passed"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyTokenOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the owner of a specified token"",
        ""Parameters"": [""_token""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IRCFactory - The factory contract that creates and manages markets"",
    ""IRCTreasury - Handles all payment processing, deposits, and withdrawals"",
    ""IRCNftHubL2 - Manages the NFT tokens representing cards/outcomes"",
    ""IRCOrderbook - Manages bids and ownership transitions in an order book"",
    ""IRealitio - Oracle interface (Reality.eth) for resolving event outcomes"",
    ""NativeMetaTransaction - Enables gasless transactions through meta-transactions""
  ],
  
  ""SpecialMechanisms"": [
    ""State Machine Pattern - Contract uses explicit states (CLOSED, OPEN, LOCKED, WITHDRAW) to control functionality"",
    ""Proxy Pattern - Contract is designed to be used with a proxy (uses Initializable instead of constructor)"",
    ""Time-based Ownership - Tracks the duration each user holds a card to calculate rewards"",
    ""Meta-transactions - Implements NativeMetaTransaction to support gasless transactions"",
    ""Rent Collection - Complex mechanism for calculating and collecting time-based rent"",
    ""Oracle Integration - Uses Reality.eth for trustless outcome resolution"",
    ""Multiple Distribution Models - Supports different reward distribution modes (CLASSIC, WINNER_TAKES_ALL, SAFE_MODE)""
  ],
  
  ""Questions"": [
    ""How is rent collection handled during periods of high market activity?"",
    ""What happens if the oracle never returns a result or returns an invalid result?"",
    ""How are foreclosures handled if a user runs out of deposit funds?"",
    ""What's the exact mechanism to prevent front-running in the rental market?"",
    ""How are the Meta-transactions implemented and what security measures are in place?"",
    ""How does the circuit breaker function work and what triggers might activate it?"",
    ""What happens to unclaimed funds if some winners never withdraw their earnings?"",
    ""How is the integration with Reality.eth secured against manipulation?""
  ]
}

Based on my audit, I've identified several key vulnerabilities and potential issues:

1. **Re-entrancy risk**: The contract calls external contracts (treasury, nfthub, orderbook) but doesn't always follow the checks-effects-interactions pattern.

2. **Gas limitation**: The `_collectRent` function uses a loop with a counter limit, which may lead to incomplete operations if there are too many ownership transitions.

3. **Oracle dependency**: Heavy reliance on the Reality.eth oracle creates a centralization risk if the oracle fails or is manipulated.

4. **Complex state management**: The contract uses multiple states and timestamps which increases the risk of logic errors.

5. **Time manipulation**: Functions that depend on `block.timestamp` could potentially be manipulated by miners within a small window.

6. **Unchecked mathematical operations**: Some calculations could potentially overflow or underflow, especially when dealing with time differences and price calculations.

7. **Upgrade vulnerabilities**: As an initializable proxy contract, careful management of the implementation upgradeability is required to prevent security issues.

8. **Authorization issues**: Some functions rely on `msgSender()` which behaves differently than `msg.sender` with meta-transactions, potentially creating authorization confusion.

The contract is complex with multiple stakeholders (artists, creators, affiliates) and handles financial transactions, making it a high-value target requiring thorough security measures.","I've analyzed the provided issues across the different audit inputs and consolidated similar findings while preserving key information. Here's the structured summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Payout Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (_payoutWinnings, _returnRent, withdraw) set state variables after making external calls via _payout, which calls treasury.payout(). This creates potential reentrancy vulnerabilities as the contract doesn't follow the checks-effects-interactions pattern consistently. The function uses assert statements instead of proper return value checks, exacerbating the issue."",
      ""Impact"": ""An attacker could potentially call withdraw() multiple times before the state variable is updated, draining more funds than they're entitled to. This could lead to theft of funds through multiple withdrawals."",
      ""Location"": ""withdraw() function, _payout() function, _payoutWinnings(), _returnRent(), _processStakeholderPayment()""
    },
    {
      ""Issue"": ""Missing Access Control for Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The setAmicableResolution function can be called to determine the winner, bypassing the oracle. While it checks for the factory owner, this represents a significant centralization point that could undermine the trustlessness of the prediction market."",
      ""Impact"": ""Factory owner could manipulate market outcomes, potentially stealing funds from participants by declaring an incorrect winner."",
      ""Location"": ""setAmicableResolution function""
    },
    {
      ""Issue"": ""Inadequate Circuit Breaker Implementation"",
      ""Severity"": ""High"",
      ""Description"": ""The circuitBreaker() function only checks that 12 weeks have passed since oracleResolutionTime, but doesn't verify the current state. This means the function can be called to force the contract into WITHDRAW state regardless of its current state, potentially bypassing important state transitions."",
      ""Impact"": ""An attacker could prematurely force the contract into WITHDRAW state, allowing funds to be withdrawn before proper settlement and potentially leading to financial loss for users."",
      ""Location"": ""circuitBreaker() function""
    },
    {
      ""Issue"": ""Inconsistent State Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on state transitions to manage its lifecycle, but there are edge cases where the state might become inconsistent. For example, the setWinner() function advances state from LOCKED to WITHDRAW but doesn't check if market was properly locked first. If called when state is OPEN, it attempts to lock the market but doesn't verify this succeeded before advancing to WITHDRAW state."",
      ""Impact"": ""Contract could get stuck in an incorrect state, preventing normal operation or fund distribution. If market locking fails, users could still potentially withdraw funds in an inconsistent state."",
      ""Location"": ""lockMarket, setWinner functions and autoLock modifier""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Risks in Time Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using Solidity 0.8.4 which has built-in overflow protection, complex time-based calculations throughout the contract (especially in _collectRentAction) could still lead to logical errors. For example, when calculating time differences, refund amounts, or decrementing cardTimeLimit without proper checks."",
      ""Impact"": ""Incorrect rent calculations, potential loss of funds for users or the protocol. In edge cases with extreme values, calculations might result in unexpected behavior."",
      ""Location"": ""_collectRentAction function, _processRentCollection function, and various time calculations throughout the contract""
    },
    {
      ""Issue"": ""Excessive Gas Consumption in Loops"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions contain unbounded loops over all cards (e.g., collectRentAllCards, rentAllCards, exitAll), which could potentially hit block gas limits if the number of cards is large. While there is a maxRentIterations limit for inner loops in _collectRent, the outer loops remain unbounded."",
      ""Impact"": ""Functions may become unusable if the gas required exceeds block limits, potentially locking funds or breaking contract functionality. Transactions could run out of gas and fail, potentially leaving the contract in an inconsistent state."",
      ""Location"": ""collectRentAllCards, rentAllCards, exitAll functions""
    },
    {
      ""Issue"": ""Oracle Dependency and Centralization Risk"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on an external oracle (Realitio) for determining outcomes. If the oracle is compromised or fails to respond, the market could be stuck in an unresolvable state. The setAmicableResolution function also introduces centralization by allowing the factory owner to set the winning outcome directly."",
      ""Impact"": ""Market might not be able to resolve and distribute winnings properly if the oracle fails. Users may lose trust in the platform if they believe outcomes can be manipulated by a central authority."",
      ""Location"": ""getWinnerFromOracle function, setAmicableResolution function""
    },
    {
      ""Issue"": ""Timestamp Dependence"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on block.timestamp for critical logic including rent calculations, market state changes, and time-based validations. Miners can manipulate timestamps slightly, potentially affecting outcomes."",
      ""Impact"": ""Slight manipulation of rent amounts, premature market state transitions, or gaming time-held calculations. In edge cases where rent is calculated for very short time periods, miners could manipulate timestamps to affect rent calculations."",
      ""Location"": ""Used throughout the contract, especially in _collectRentAction(), lockMarket(), and newRental()""
    },
    {
      ""Issue"": ""Insufficient Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack proper input validation. The initialize function does not properly validate all inputs such as _timestamps array length or chronological order. Similarly, _cardAffiliateAddresses validation is minimal, and newRental() only partially validates inputs."",
      ""Impact"": ""Potential misconfiguration of the market with invalid parameters. Malicious addresses could be set as card affiliates, potentially leading to fund theft or contract manipulation."",
      ""Location"": ""initialize() function, newRental() function, updateTimeHeldLimit() function""
    },
    {
      ""Issue"": ""Multiple Division Operations Risk Precision Loss"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calculations involve multiple division operations which can lead to precision loss in Solidity's integer math, particularly in rent and payout calculations. Rent calculations involve division by 1 days, which can lead to precision loss, especially for short time periods."",
      ""Impact"": ""Users might receive slightly less (or more) funds than they should due to rounding errors. Incorrect rent or payout calculations, potentially favoring either the platform or users unfairly."",
      ""Location"": ""_payoutWinnings, _processRentCollection functions""
    },
    {
      ""Issue"": ""Unchecked Return Values for External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several external calls use assert() to check return values (like treasury.payout, nfthub.transferNft) rather than proper error handling. Assert should only be used for invariant checking, not for validating external calls, and some calls don't check return values at all."",
      ""Impact"": ""If an external call fails for legitimate reasons, the contract will revert with a generic error message and consume all gas, making debugging difficult and potentially causing unnecessary transaction failures."",
      ""Location"": ""_payout() function and other functions using assert for external call validation""
    },
    {
      ""Issue"": ""Dependency on External Contract States"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on external contracts like treasury, factory, nfthub, and orderbook. If any of these contracts have vulnerabilities or are compromised, it directly affects the security of this contract. There's no fallback mechanism if these dependent contracts fail."",
      ""Impact"": ""Failure or compromise of any dependent contract could lead to fund loss or contract functionality breakdown."",
      ""Location"": ""Throughout the contract, particularly in initialize() and any function using external contracts""
    },
    {
      ""Issue"": ""Inadequate Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes don't emit events, making it difficult to track the contract's history off-chain. For example, when exiting a card position or updating cardPrice in transferCard, no specific event is emitted to record these actions."",
      ""Impact"": ""Reduced transparency and difficulty in auditing the contract's operation. More difficult debugging/monitoring of the contract."",
      ""Location"": ""Various functions throughout the contract, including exit() function and transferCard()""
    },
    {
      ""Issue"": ""Time-based Logic Complexity"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract contains extremely complex time-based logic, particularly in the _collectRentAction function, with many branches and conditions. This complexity increases the risk of logical errors."",
      ""Impact"": ""Might lead to incorrect rent collection or time tracking under certain conditions."",
      ""Location"": ""_collectRentAction function""
    },
    {
      ""Issue"": ""Inefficient Storage Access Patterns"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract makes multiple reads and writes to storage variables within loops, which is gas-inefficient. For example, in _processRentCollection, multiple storage variables are updated repeatedly."",
      ""Impact"": ""Higher gas costs for users interacting with the contract, particularly in functions with loops."",
      ""Location"": ""_processRentCollection, collectRentAllCards functions""
    }
  ],
  ""IssueNumber"": 67,
  ""OutputList"": 15
}",464.2998468875885,126426.0,32.0,"### **[H-03] Anyone can call function sponsor**

**Report Description**:
The `sponsor` function should only be called by the factory, but it lacks any access control checks. This allows anyone to call it with an arbitrary `_sponsorAddress` and transfer tokens from them if the allowance is greater than 0. This oversight could lead to unauthorized token transfers and potential exploitation by malicious actors.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing access control in the `sponsor` function. While there is a finding titled ""Missing Access Control for Critical Functions,"" it specifically discusses the `setAmicableResolution` function and does not cover the `sponsor` function. This issue remains unaddressed in the response list.

---

### **[M-07] maxSumOfPrices check is broken**

**Report Description**:
The `rentAllCards()` function requires the sender to specify a `_maxSumOfPrices` parameter, which is intended to limit the sum of the bids placed. However, the function implementation does not enforce this constraint, allowing the total number of bids placed to exceed the specified `_maxSumOfPrices`. This could lead to users not having sufficient deposited funds, resulting in foreclosure or impacts on other bids/markets.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the broken `_maxSumOfPrices` check in the `rentAllCards()` function. This issue is not covered in any of the findings provided in the response list.

---

### **[M-13] Wrong calculation on _collectRentAction**

**Report Description**:
The `_collectRentAction` method contains an incorrect calculation in case 6. It calculates `_refundTime` as `block.timestamp - marketLockingTime` instead of `_timeUserForeclosed - marketLockingTime`. This error could lead to incorrect rent calculations and potential financial discrepancies.

**Match in Response List**:
Matches with the issue titled **""Integer Overflow/Underflow Risks in Time Calculations""**.

**Validation**:
**Partially Correct**. The response identifies the general risk of incorrect time calculations in the `_collectRentAction` function but does not specifically address the exact issue of the wrong calculation in case 6. The response focuses on overflow/underflow risks rather than the logical error in the calculation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-13] Wrong calculation on _collectRentAction**

**Missed Issues from Issue Report**:
- **[H-03] Anyone can call function sponsor**
- **[M-07] maxSumOfPrices check is broken**

---

### **Conclusion**
The response list partially addresses one of the issues ([M-13]) but misses the other two critical issues ([H-03] and [M-07]). The findings in the response list do not provide sufficient coverage for the vulnerabilities identified in the issue report. Specifically, the lack of access control in the `sponsor` function and the broken `_maxSumOfPrices` check in `rentAllCards()` remain unaddressed. The response list could be improved by including findings that directly address these issues.","```
None.
```",0.0
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    //≡≡≡≡≡≡≡ CONTRACT VARIABLES ≡≡≡≡≡≡≡//
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    ///// CONTRACT ADDRESSES /////
    /// @dev reference contract
    address public referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms iniital pot
    uint256 public sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public maximumDuration;
    /// @dev list of governors
    mapping(address => bool) public governors;
    /// @dev if false, anyone can create markets
    bool public marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public approvedAffilliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public approvedArtistsOnly = true;
    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity
    bool public override trapIfUnapproved = true;
    /// @dev high level owner who can change the factory address
    address public uberOwner;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the address of the arbitrator
    address public arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public timeout;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;
    /// @dev allows artist to receive cut of total rent
    mapping(address => bool) public isArtistApproved;
    /// @dev allows affiliate to receive cut of total rent
    mapping(address => bool) public isAffiliateApproved;
    /// @dev allows card affiliate to receive cut of total rent
    mapping(address => bool) public isCardAffiliateApproved;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public nftMintingLimit;

    ///// OTHER /////
    /// @dev counts the total NFTs minted across all events
    /// @dev ... so the appropriate token id is used when upgrading to mainnet
    uint256 public totalNftMintCount;

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    /// @dev Treasury must be deployed before Factory
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise contract variable
        treasury = _treasuryAddress;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setminimumPriceIncreasePercent(10); // 10%
        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted
        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @dev include the owner as a governor
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - OWNER (SETUP)  ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier

    /// @notice where the NFTs live
    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but
    /// @dev ... keeping flexible in case returning to previous contract
    /// @param _newAddress the address to set
    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newAddress the address to set
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in basis points (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _mintLimit the limit to set
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    /// @notice if true, Cards in unapproved markets can't be upgraded
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    /// @notice market closing time must be no more than this many seconds in the future
    /// @param _newMaximumDuration the duration limit to set in seconds
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    /// @notice to fetch the owner of the contract
    /// @dev used to specifiy the Ownable contract instead of the interface
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    /// @notice check if an address is a governor
    /// @param _user the address to query
    /// @return boolean return if true or false
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    // EDIT GOVERNORS

    /// @notice add or remove an address from market creator whitelist
    /// @param _governor the address to change approval for
    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        // check it's an RC contract
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /// @notice artistAddress, passed in createMarket, must be approved
    /// @param _artist the artist address to change approval for
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    /// @notice affiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the affiliate address to change approval for
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    /// @notice cardAffiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the card affiliate address to change approval for
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    /// @notice change the reference contract for the contract logic
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice to change or renounce ownership of the uberOwner role
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        // affiliate
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        // check the number of NFTs to mint is within limits
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        // tell Treasury, Orderbook, and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        // update internals
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        // initialize the market
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        // create the NFTs
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        // increment totalNftMintCount
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",5732,635,"[M-05] RCFactory.createMarket() does not enforce _timestamps and _timestamps being larger than _timestamps, even though proper functioning requires them to be so
`RCFactory.createMarket()` does not enforce `_timestamps[1]` and `_timestamps[2]` being larger than _timestamps[0], even though proper functioning requires them to be so.
IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. (1)
The comments explicitly state that _incrementState() should be called ""thrice"" (2)
However, it is possible to create a market where these events do not occur sequentially.
You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.
This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0] (3)
This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. (4)
Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.
When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0] (5)",1,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";




contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    

    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    
    
    address public referenceContractAddress;
    
    uint256 public referenceContractVersion;
    
    
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    
    
    uint256[5] public potDistribution;
    
    uint256 public sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint32 public advancedWarning;
    
    uint32 public maximumDuration;
    
    mapping(address => bool) public governors;
    
    bool public marketCreationGovernorsOnly = true;
    
    bool public approvedAffilliatesOnly = true;
    
    bool public approvedArtistsOnly = true;
    
    bool public override trapIfUnapproved = true;
    
    address public uberOwner;
    
    uint256 public override maxRentIterations;
    
    address public arbitrator;
    
    uint32 public timeout;

    
    
    mapping(address => bool) public override isMarketApproved;
    
    mapping(address => bool) public isArtistApproved;
    
    mapping(address => bool) public isAffiliateApproved;
    
    mapping(address => bool) public isCardAffiliateApproved;
    
    uint256 public nftMintingLimit;

    
    
    
    uint256 public totalNftMintCount;

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    

    
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        uberOwner = msgSender();

        
        treasury = _treasuryAddress;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setminimumPriceIncreasePercent(10); 
        setNFTMintingLimit(60); 
        setMaxRentIterations(35); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    

    
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    
    

    
    
    
    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    
    
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    
    
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    

    
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    
    
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    
    
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    
    
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    
    
    
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    

    
    
    
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    
    

    
    
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    
    
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    
    
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    
    
    
    

    
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        
        
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    
}",3005,0,1,"Based on the comprehensive initial analysis, here's a structured audit task list for the RCFactory contract:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the security of the 'uberOwner' role and its privileged operations"",
        ""Audit the 'onlyGovernors' modifier for potential bypass vulnerabilities"",
        ""Review the multiple levels of access control (owner, governors, uberOwner)"",
        ""Validate the changeGovernorApproval and changeUberOwner function security"",
        ""Check for potential centralization risks in critical permission changes""
      ]
    },
    {
      ""Area"": ""Market Creation Security"",
      ""Tasks"": [
        ""Analyze the createMarket function for potential exploitation paths"",
        ""Verify sponsorship validation logic and minimum requirements"",
        ""Check timestamp validation for market creation parameters"",
        ""Review NFT minting limit enforcement mechanism"",
        ""Validate approval checks for artists, affiliates, and markets""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Audit interactions with IRCTreasury, IRCNftHubL2, IRCOrderbook, and IRealitio"",
        ""Verify initialization and market addition processes for external contracts"",
        ""Check for potential reentrancy vulnerabilities in external calls"",
        ""Review oracle integration and arbitration mechanism"",
        ""Validate sponsorship and token minting external function calls""
      ]
    },
    {
      ""Area"": ""Proxy Contract & Cloning Mechanism"",
      ""Tasks"": [
        ""Verify the security of the Clones.clone() implementation"",
        ""Check reference contract address setting and version increment logic"",
        ""Analyze potential risks in contract cloning process"",
        ""Validate initialization parameters for cloned markets"",
        ""Review the robustness of the referenceContractAddress mechanism""
      ]
    },
    {
      ""Area"": ""Meta-Transaction & Governance"",
      ""Tasks"": [
        ""Audit the NativeMetaTransaction implementation for standard compliance"",
        ""Verify meta-transaction signature validation"",
        ""Check potential replay attack vulnerabilities"",
        ""Review governance toggle functions for unexpected state changes"",
        ""Validate the msgSender() implementation for meta-transactions""
      ]
    },
    {
      ""Area"": ""Financial & Tokenomics Risk"",
      ""Tasks"": [
        ""Review pot distribution percentage calculations"",
        ""Verify the correctness of potDistribution mapping"",
        ""Check for potential rounding errors in financial calculations"",
        ""Analyze NFT minting and total count tracking mechanism"",
        ""Validate sponsorship and market creation economic model""
      ]
    },
    {
      ""Area"": ""Parameter Management & Configuration"",
      ""Tasks"": [
        ""Audit setter functions for critical system parameters"",
        ""Check boundary conditions and validation in configuration methods"",
        ""Review the impact of toggling flags like marketCreationGovernorsOnly"",
        ""Validate timeout, advanced warning, and maximum duration settings"",
        ""Analyze potential risks in dynamic system configuration""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in market creation process"",
        ""Review efficiency of mapping and array operations"",
        ""Check loop optimizations in createMarket function"",
        ""Validate the minimal proxy (Clone) pattern implementation"",
        ""Assess overall contract gas efficiency""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Review require statement coverage and error message clarity"",
        ""Identify potential unhandled edge cases in market creation"",
        ""Check for proper handling of zero-address scenarios"",
        ""Validate error handling in external contract interactions"",
        ""Analyze potential failure modes in complex operations""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the RCFactory contract, covering security, functionality, economic risks, and performance considerations. Each area is broken down into specific, actionable tasks that address the nuanced aspects of the contract's implementation.

The tasks are designed to systematically examine:
1. Security vulnerabilities
2. Access control mechanisms
3. External contract interactions
4. Proxy and cloning patterns
5. Governance and configuration risks
6. Economic and tokenomics considerations
7. Performance optimization opportunities
8. Error handling and edge case management

Would you like me to elaborate on any specific area or provide more detailed guidance for conducting the audit?","I've thoroughly analyzed the RCFactory smart contract. Here's my audit:

{
  ""ReviewingTheCode"": ""This is a factory contract for a Reality Cards platform, which appears to be a prediction market/NFT platform. The contract creates markets, manages governance, and handles various permissions for artists and affiliates. It also interacts with external contracts like treasury, NFT hub, and orderbook systems. It implements meta-transactions and has upgrade mechanisms through reference contract cloning."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCFactory"",
    ""Purpose"": ""A factory contract that creates and manages Reality Cards prediction markets, with governance controls over market creation, artist/affiliate approval, and system parameters."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""NativeMetaTransaction"", ""IRCFactory""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/proxy/Clones.sol"",
        ""hardhat/console.sol"",
        ""./interfaces/IRCFactory.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCNftHubL2.sol"",
        ""./interfaces/IRCOrderbook.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRealitio.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""treasury"",
        ""Type"": ""IRCTreasury"",
        ""Purpose"": ""Reference to the treasury contract for handling funds""
      },
      {
        ""Name"": ""nfthub"",
        ""Type"": ""IRCNftHubL2"",
        ""Purpose"": ""Reference to the NFT hub contract for minting tokens""
      },
      {
        ""Name"": ""orderbook"",
        ""Type"": ""IRCOrderbook"",
        ""Purpose"": ""Reference to the orderbook contract for market orders""
      },
      {
        ""Name"": ""realitio"",
        ""Type"": ""IRealitio"",
        ""Purpose"": ""Reference to oracle contract for reality questions""
      },
      {
        ""Name"": ""referenceContractAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of reference implementation for cloning new markets""
      },
      {
        ""Name"": ""referenceContractVersion"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Current version of the reference implementation""
      },
      {
        ""Name"": ""marketAddresses"",
        ""Type"": ""mapping(uint256 => address[])"",
        ""Purpose"": ""Stores market addresses by mode""
      },
      {
        ""Name"": ""mappingOfMarkets"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Verifies if an address is a valid market""
      },
      {
        ""Name"": ""potDistribution"",
        ""Type"": ""uint256[5]"",
        ""Purpose"": ""Distribution percentages for artists, winners, creators, affiliates""
      },
      {
        ""Name"": ""sponsorshipRequired"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum sponsorship required to create a market""
      },
      {
        ""Name"": ""minimumPriceIncreasePercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum percentage for price increases""
      },
      {
        ""Name"": ""advancedWarning"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Time required between market creation and opening""
      },
      {
        ""Name"": ""maximumDuration"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Maximum duration a market can run""
      },
      {
        ""Name"": ""governors"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Addresses with governor permissions""
      },
      {
        ""Name"": ""isMarketApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks approved markets""
      },
      {
        ""Name"": ""isArtistApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks approved artists""
      },
      {
        ""Name"": ""isAffiliateApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks approved affiliates""
      },
      {
        ""Name"": ""isCardAffiliateApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks approved card affiliates""
      },
      {
        ""Name"": ""nftMintingLimit"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum number of NFTs per market""
      },
      {
        ""Name"": ""totalNftMintCount"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Running total of NFTs minted across all markets""
      },
      {
        ""Name"": ""marketCreationGovernorsOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Restricts market creation to governors""
      },
      {
        ""Name"": ""approvedAffilliatesOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Restricts affiliates to approved ones""
      },
      {
        ""Name"": ""approvedArtistsOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Restricts artists to approved ones""
      },
      {
        ""Name"": ""trapIfUnapproved"",
        ""Type"": ""bool"",
        ""Purpose"": ""Whether to trap cards if market is unapproved""
      },
      {
        ""Name"": ""uberOwner"",
        ""Type"": ""address"",
        ""Purpose"": ""Super-admin with specific privileged operations""
      },
      {
        ""Name"": ""maxRentIterations"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum number of rent iterations""
      },
      {
        ""Name"": ""arbitrator"",
        ""Type"": ""address"",
        ""Purpose"": ""Address for reality.eth arbitration""
      },
      {
        ""Name"": ""timeout"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Timeout for reality.eth oracle questions""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with treasury, realitio, and arbitrator addresses"",
        ""Parameters"": [""IRCTreasury _treasuryAddress"", ""address _realitioAddress"", ""address _arbitratorAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMostRecentMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the most recent market for a given mode"",
        ""Parameters"": [""uint256 _mode""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getAllMarkets"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns all markets for a given mode"",
        ""Parameters"": [""uint256 _mode""],
        ""Returns"": [""address[] memory""]
      },
      {
        ""Name"": ""getPotDistribution"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the pot distribution percentages"",
        ""Parameters"": [],
        ""Returns"": [""uint256[5] memory""]
      },
      {
        ""Name"": ""onlyGovernors"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function calls to governors and owner"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setNftHubAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the NFT hub address and mint count"",
        ""Parameters"": [""IRCNftHubL2 _newAddress"", ""uint256 _newNftMintCount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setOrderbookAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the orderbook address"",
        ""Parameters"": [""IRCOrderbook _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPotDistribution"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the distribution percentages for the pot"",
        ""Parameters"": [""uint256 _artistCut"", ""uint256 _winnerCut"", ""uint256 _creatorCut"", ""uint256 _affiliateCut"", ""uint256 _cardAffiliateCut""],
        ""Returns"": []
      },
      {
        ""Name"": ""setminimumPriceIncreasePercent"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the minimum price increase percentage"",
        ""Parameters"": [""uint256 _percentIncrease""],
        ""Returns"": []
      },
      {
        ""Name"": ""setNFTMintingLimit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the NFT minting limit per market"",
        ""Parameters"": [""uint256 _mintLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxRentIterations"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the maximum number of rent iterations"",
        ""Parameters"": [""uint256 _rentLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRealitioAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the Realitio oracle address"",
        ""Parameters"": [""address _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""setArbitrator"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the arbitrator address"",
        ""Parameters"": [""address _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTimeout"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the timeout for reality.eth questions"",
        ""Parameters"": [""uint32 _newTimeout""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketCreationGovernorsOnly"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles whether only governors can create markets"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""changeApprovedArtistsOnly"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles whether only approved artists can be used"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""changeApprovedAffilliatesOnly"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles whether only approved affiliates can be used"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setSponsorshipRequired"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the required sponsorship amount for market creation"",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeTrapCardsIfUnapproved"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles trapping cards if market is unapproved"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setAdvancedWarning"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the advanced warning period for markets"",
        ""Parameters"": [""uint32 _newAdvancedWarning""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaximumDuration"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the maximum duration for markets"",
        ""Parameters"": [""uint32 _newMaximumDuration""],
        ""Returns"": []
      },
      {
        ""Name"": ""owner"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the contract owner, overriding from inherited contracts"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""isGovernor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Checks if an address is a governor"",
        ""Parameters"": [""address _user""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""changeGovernorApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles governor status for an address"",
        ""Parameters"": [""address _governor""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles approval for a market"",
        ""Parameters"": [""address _market""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeArtistApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles approval for an artist"",
        ""Parameters"": [""address _artist""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeAffiliateApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles approval for an affiliate"",
        ""Parameters"": [""address _affiliate""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeCardAffiliateApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles approval for a card affiliate"",
        ""Parameters"": [""address _affiliate""],
        ""Returns"": []
      },
      {
        ""Name"": ""setReferenceContractAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the reference contract for creating new markets"",
        ""Parameters"": [""address _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeUberOwner"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Changes the uber owner address"",
        ""Parameters"": [""address _newUberOwner""],
        ""Returns"": []
      },
      {
        ""Name"": ""createMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new market by cloning the reference contract"",
        ""Parameters"": [""uint32 _mode"", ""string memory _ipfsHash"", ""uint32[] memory _timestamps"", ""string[] memory _tokenURIs"", ""address _artistAddress"", ""address _affiliateAddress"", ""address[] memory _cardAffiliateAddresses"", ""string calldata _realitioQuestion"", ""uint256 _sponsorship""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getOracleSettings"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the oracle settings"",
        ""Parameters"": [],
        ""Returns"": [""IRealitio"", ""address"", ""uint32""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Interacts with IRCTreasury for funds management and market registration"",
    ""Interacts with IRCNftHubL2 for NFT minting and market registration"",
    ""Interacts with IRCOrderbook for market registration and configuration"",
    ""Interacts with IRealitio for oracle services"",
    ""Uses OpenZeppelin's Clones library to create new markets via minimal proxies"",
    ""Calls initialize() on newly created markets"",
    ""Calls sponsor() on newly created markets"",
    ""Calls mint() on the NFTHub contract""
  ],
  ""SpecialMechanisms"": [
    ""Uses Clone pattern (EIP-1167 minimal proxy) to create new markets efficiently"",
    ""Implements NativeMetaTransaction pattern to allow for gasless transactions"",
    ""Uses a multi-level governance model with owner, governors, and uberOwner"",
    ""Role-based access control for artists, affiliates, and market creation"",
    ""Version tracking for reference contracts with incrementing version numbers"",
    ""Token ID generation based on a global NFT counter to ensure uniqueness""
  ],
  ""Questions"": [
    ""What is the purpose of the 'mode' parameter in createMarket?"",
    ""How are the potDistribution percentages used in practice? Are they in basis points (out of 1000)?"",
    ""What's the difference between regular affiliates and card affiliates?"",
    ""What's the purpose of the trapIfUnapproved flag?"",
    ""What is the NativeMetaTransaction implementation doing? Does it follow a standard implementation?"",
    ""What events are emitted from NativeMetaTransaction?"",
    ""How are the _tokenURIs stored and used in the NFT contract?"",
    ""Is there a check to ensure cardAffiliateAddresses length matches tokenURIs length?"",
    ""What's the relationship between Market, Treasury, NFTHub and Orderbook contracts?"",
    ""How does the Reality.eth integration work for resolving markets?""
  ]
}

Additional audit observations:

1. Security concerns:
   - The `uberOwner` has special privileges with critical system operations like changing reference contracts, which introduces a centralization risk
   - There's no timelock mechanism for sensitive parameter changes
   - The contract allows multiple governor addresses with significant permissions
   - No slippage protection in market creation sponsorship functionality

2. Architecture observations:
   - Uses proxy pattern for gas-efficient market creation
   - Has role-based permissions with multiple levels (owner, governors, uber owner)
   - Implements meta-transactions for gasless operations
   - Manages a collection of NFTs through tokenID incrementing

3. Potential improvements:
   - Add more detailed validation in createMarket for timestamps and sponsorship amounts
   - Consider implementing a timelock for sensitive parameter changes
   - Implement a more standardized access control system like OpenZeppelin's AccessControl
   - Consider emitting more events for state changes to improve transparency and tracking","I've analyzed all the provided findings from various security reviews of the RCFactory contract. After consolidating similar issues, here's my structured output:

{
  ""Findings"": [
    {
      ""Issue"": ""Centralized Control with uberOwner Privileges"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract implements a highly centralized governance structure with a powerful 'uberOwner' role that has exclusive access to critical functions, bypassing the standard OpenZeppelin Ownable functionality. This role can change the reference implementation contract and control critical parameters without proper constraints or transparency. The 'Extremely Verboten' error message suggests this is intentionally designed as a super-admin role."",
      ""Impact"": ""If the uberOwner account is compromised, an attacker could change the reference implementation to a malicious version, manipulate economic parameters, or compromise the entire system of cloned markets. This represents a single point of failure in the architecture."",
      ""Location"": ""setReferenceContractAddress() and changeUberOwner() functions""
    },
    {
      ""Issue"": ""Insufficient Reference Contract Validation"",
      ""Severity"": ""High"",
      ""Description"": ""When setting or cloning the reference contract, validation is minimal - only checking that it implements isMarket() and returns true. There are no comprehensive checks for compatibility, security, or proper implementation of required interfaces. This follows a weak assertion pattern and could allow malicious or flawed implementation contracts to be deployed."",
      ""Impact"": ""A malicious actor who gains uberOwner rights could set a malicious reference contract that passes the basic check but isn't a proper market contract. This would affect all future markets created through the factory, potentially enabling theft of funds or introducing critical vulnerabilities."",
      ""Location"": ""setReferenceContractAddress() and createMarket() functions""
    },
    {
      ""Issue"": ""Missing Initialization Protection"",
      ""Severity"": ""High"",
      ""Description"": ""Newly cloned market contracts are initialized by calling initialize(), but there's no protection against calling this function multiple times or by unauthorized parties after deployment. The contract also initializes NativeMetaTransaction in the constructor with _initializeEIP712, without proper initialization guards."",
      ""Impact"": ""If the underlying market contract doesn't protect against re-initialization, an attacker could call initialize() again and reset the contract's state or set malicious parameters. Could also lead to broken meta-transaction functionality."",
      ""Location"": ""createMarket() function where it calls IRCMarket(_newAddress).initialize() and constructor""
    },
    {
      ""Issue"": ""Potential Reentrancy in createMarket"",
      ""Severity"": ""High"",
      ""Description"": ""The createMarket() function makes external calls to treasury.checkSponsorship(), nfthub.mint(), and other contracts before modifying its own state. This follows the pattern of 'checks-effects-interactions' incorrectly, creating potential reentrancy vulnerabilities."",
      ""Impact"": ""An attacker could potentially manipulate the contract state during market creation, resulting in unexpected behavior, duplicate markets, or theft of assets if the external contracts are malicious or compromised."",
      ""Location"": ""createMarket() function""
    },
    {
      ""Issue"": ""Unchecked External Call Results"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes several external calls without verifying their success, except for nfthub.mint(). For example, when calling treasury.addMarket(), nfthub.addMarket(), and orderbook.addMarket(), the contract doesn't check if these operations succeeded."",
      ""Impact"": ""If any of these external calls fail silently, it could lead to inconsistent state across the system. Markets might be partially initialized, leading to potential fund loss or functional issues."",
      ""Location"": ""createMarket() function, specifically calls to treasury.addMarket(), nfthub.addMarket(), and orderbook.addMarket()""
    },
    {
      ""Issue"": ""Insufficient Input Validation in createMarket"",
      ""Severity"": ""Medium"",
      ""Description"": ""The createMarket function has inconsistent validation of inputs. While it checks that _tokenURIs.length <= nftMintingLimit and validates some timestamp parameters, it doesn't ensure logical ordering of all timestamps, validate that _cardAffiliateAddresses length matches _tokenURIs length, or check token URI format/content."",
      ""Impact"": ""Could lead to markets with illogical time parameters, misalignment between card affiliates and tokens, or creation of NFTs with invalid or malicious metadata, causing unexpected behavior or usability issues."",
      ""Location"": ""createMarket() function""
    },
    {
      ""Issue"": ""Economic Parameter Centralization and Validation Issues"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical economic parameters like potDistribution (fee structure), minimumPriceIncreasePercent, and others can be modified unilaterally by the owner. The setPotDistribution() function checks that the sum of distributions doesn't exceed 1000, but doesn't enforce that it equals 1000 (100%) or validate individual values, allowing for scenarios where value could be lost."",
      ""Impact"": ""Could result in funds being locked in the contract if distribution percentages don't add up to 100%. The owner can also change economic incentives at will, potentially extracting more value from users or disrupting market operations."",
      ""Location"": ""setPotDistribution(), setminimumPriceIncreasePercent(), setSponsorshipRequired() functions""
    },
    {
      ""Issue"": ""Oracle-related Security Concerns"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses Realitio as an oracle system for market resolution but lacks comprehensive validation of oracle inputs and responses. The arbitrator settings (realitio address, arbitrator, timeout) can be changed by the owner without restrictions."",
      ""Impact"": ""If the oracle is compromised or manipulated, it could affect the outcome of markets and potentially lead to loss of funds for participants. The owner could potentially change oracle settings to influence market outcomes or delay/accelerate resolution in ways that benefit certain parties."",
      ""Location"": ""createMarket() function, getOracleSettings() function, setRealitioAddress(), setArbitrator(), setTimeout() functions""
    },
    {
      ""Issue"": ""Potential Block Gas Limit and Array Growth Issues"",
      ""Severity"": ""Medium"",
      ""Description"": ""The createMarket() function mints NFTs in a loop based on _tokenURIs.length. While there is a limit set via nftMintingLimit, if this limit is set too high, the transaction could exceed block gas limits. Additionally, the marketAddresses mapping stores arrays that can grow without bounds as markets are created."",
      ""Impact"": ""Transactions that exceed the block gas limit will fail, potentially preventing the creation of markets with many tokens. Functions like getAllMarkets might become unusable due to excessive gas costs if too many markets are created for a specific mode."",
      ""Location"": ""NFT minting loop in createMarket() function and getAllMarkets function""
    },
    {
      ""Issue"": ""Boolean Toggle Without Context"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like changeGovernorApproval, changeMarketApproval, etc. toggle boolean values without explicit setting to true/false or tracking state changes. This pattern can be error-prone as it's not immediately clear what the state will be after the function executes."",
      ""Impact"": ""Could lead to confusion about account status, accidental status changes, and potential mismanagement of permissions. A single call to these functions can both approve and unapprove an address."",
      ""Location"": ""changeGovernorApproval(), changeMarketApproval(), changeArtistApproval(), etc.""
    },
    {
      ""Issue"": ""Missing Events for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Several critical state-changing functions don't emit events, including setReferenceContractAddress(), changeUberOwner(), approval changes for artists and affiliates, and other parameter-setting functions. This reduces transparency and makes it difficult to track important changes."",
      ""Impact"": ""Off-chain monitoring tools would be unable to track critical changes to the contract's state, reducing security, transparency, and auditability. This complicates auditing and user awareness of important contract configuration changes."",
      ""Location"": ""setReferenceContractAddress(), changeUberOwner(), changeArtistApproval(), changeAffiliateApproval(), and various parameter-setting functions""
    },
    {
      ""Issue"": ""Hard-coded Time Values"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses hard-coded time values like (1 weeks) and 86400 (1 day in seconds) that could create inflexibility in market operations. While not immediately dangerous, this reduces flexibility and might cause issues if time-related logic needs to change."",
      ""Impact"": ""Limited flexibility for market parameters, potentially affecting usability in different scenarios and reducing adaptability to changing requirements for time-based operations."",
      ""Location"": ""createMarket() function, timestamp validation and setTimeout function""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 12
}",477.3818509578705,83104.0,32.0,"### **[M-05] RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0]**

**Report Description**:
The `RCFactory.createMarket()` function does not enforce that `_timestamps[1]` and `_timestamps[2]` are larger than `_timestamps[0]`, even though proper functioning requires them to be so. The `IRCMarket` defines a sequence of events that each market should progress through sequentially: CLOSED, OPEN, LOCKED, WITHDRAW. However, it is possible to create a market where these events do not occur sequentially. Specifically, `_timestamps[1]` (marketOpeningTime) and `_timestamps[2]` (marketLockingTime and oracleResolutionTime) can be set to values that are less than or equal to `_timestamps[0]`. This is because `RCFactory` only checks that `_timestamps[2]` is greater than `_timestamps[1]` but does not check the relationship between `_timestamps[1]` and `_timestamps[0]`. Additionally, while `_timestamps[0]` is checked to be equal to or greater than `block.timestamp`, there are no checks for minimum values or relative ordering between `_timestamps[1]` and `_timestamps[2]`. This oversight allows for the creation of markets with illogical time parameters, such as `marketLockingTime` and `oracleResolutionTime` occurring before `marketOpeningTime`.

**Match in Response List**:
Matches with the issue titled **""Insufficient Input Validation in createMarket""**.

**Validation**:
**Partially Correct**. The response identifies the issue of insufficient input validation in the `createMarket` function, which aligns with the reported issue. However, the response does not specifically address the critical detail of the missing validation for the relative ordering of `_timestamps[1]` and `_timestamps[2]` with respect to `_timestamps[0]`. While the response mentions ""logical ordering of all timestamps,"" it does not explicitly highlight the specific risk of creating markets with illogical event sequences, which is the core of the reported issue. Therefore, the response is partially correct but misses a critical aspect of the vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-05] RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0]**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
