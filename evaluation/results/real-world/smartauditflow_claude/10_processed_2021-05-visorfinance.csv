nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}

",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using timeLockERC721() with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using timeUnlockERC721().  This is possible because transferERC721() does all the timelock checks on expires/block.timestamp and recipient/msg.sender as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()).  [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval.  [H-03] Approval for NFT transfers is not removed after transfer

Submitted by cmichel, also found by gpersoon, and pauliax
The Visor.transferERC721 does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
 [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack
The function _removeNft uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time.  [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2.  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).  [M-03] timelockERC721Keys could exceed the block size limit
On line 504 of Visor.sol, looping through the timelockERC721Keys could exceed the block size limit
Recommend transfer by index instead of token ID

",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";




contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    

    
    
    
    
    
    
    
    
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    

    
    
    
    
    
    
    
    
    
    
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

    
    
    
    
    
    
    
    
    
    
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }

    
    
    
    
    
    
    
    
    
    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    
    
    
    
    
    
    
    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    
    
    
    
    
    
    
    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    
    
    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }

    
    
    
    
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    
    
    
    
    
    
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    
    
    
    
    
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    
    
    
    
    
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    
    
    
    
    
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,"{'task_list': [{'Area': 'Access Control and Ownership', 'Tasks': ['Verify that `OwnableERC721` is correctly initialized during contract deployment and that the NFT ownership is correctly established. Investigate the deployment process and how the NFT contract address is set in the `initialize` function when called via a proxy. Consider potential misconfigurations or vulnerabilities during initialization.', 'Analyze the intended use case of `OwnableERC721`. Confirm that all functions requiring ownership correctly utilize the `onlyOwner` modifier and that the owner is consistently derived from the NFT contract owner.', ""Evaluate the impact of NFT ownership changes on the vault's state. Determine if transferring the NFT owner has any unintended consequences on locked tokens, timelocks, or other vault functions."", 'Confirm that the owner can always recover assets from the contract, even in edge cases or unexpected states.', 'Check if the owner can bypass approvals in delegated transfers as intended via the `if(msg.sender != _getOwner())` check. Document the implications and confirm whether this is the desired behavior.']}, {'Area': 'EIP-712 Signature Verification', 'Tasks': ['Thoroughly examine the `onlyValidSignature` modifier and the underlying EIP-712 implementation (`EIP712.sol` and potentially `ERC1271.sol`). Confirm that signatures are correctly constructed and verified, preventing replay attacks or unauthorized access.', 'Verify that the domain separator is correctly initialized and used in the EIP-712 implementation.', 'Ensure that the `LOCK_TYPEHASH` and `UNLOCK_TYPEHASH` are correctly defined and used in generating the permission hash. Check for any potential vulnerabilities in the hash calculation that could lead to signature forgery.', 'Test the `lock` and `unlock` functions with various valid and invalid signatures to confirm that the signature verification mechanism is robust and reliable.', 'Analyze potential front-running vulnerabilities when using EIP-712 signatures. Explore mitigation strategies, such as using a commit-reveal scheme or increasing the signature validity window.']}, {'Area': 'ERC20 and ETH Transfer Security', 'Tasks': ['Verify that the `transferERC20` and `delegatedTransferERC20` functions correctly check for sufficient balance, considering locked and time-locked tokens. Ensure that these functions cannot be exploited to drain the contract.', ""Confirm that the `TransferHelper.safeTransfer` function is used correctly and prevents ERC20 transfer vulnerabilities (e.g., tokens that don't return a boolean success value)."", 'Analyze the potential for malicious ERC20 tokens to revert or misbehave during transfer, causing a denial-of-service or unexpected state changes. Consider implementing safeguards against malicious token behavior.', 'Audit the `transferETH` function to ensure it correctly handles ETH transfers and prevents loss of funds.', 'Review all calls to external token contracts for potential reentrancy vulnerabilities. Implement reentrancy guards if necessary.', 'Verify that `timeLockERC20Balances` is correctly updated in both `timeLockERC20` and `timeUnlockERC20` functions, and that the `transferERC20` and `delegatedTransferERC20` functions correctly consider this balance.']}, {'Area': 'ERC721 Transfer Security and NFT Management', 'Tasks': ['Audit the `transferERC721` function to ensure that it correctly handles NFT transfers and respects time-locks. Verify that only approved delegates or the owner can transfer NFTs.', 'Analyze the `onERC721Received` function to confirm that it correctly handles incoming NFTs and adds them to the `nfts` array. Check for potential vulnerabilities related to adding duplicate NFTs or handling malicious NFTs.', 'Review the `_addNft` and `_removeNft` functions for potential gas limit issues, especially when dealing with a large number of NFTs. Implement pagination or other optimization techniques if necessary.', 'Verify that the time-lock mechanism for ERC721 tokens correctly prevents unauthorized transfers before the expiry time.', 'Ensure that the `nftApprovals` mapping is correctly managed and that only approved delegates can transfer specific NFTs.', 'Verify that the `_removeNft` function works correctly, especially the case when `i != len - 1` where the current element is replaced with the last one, then the last one is popped. Double-check the logic.']}, {'Area': 'Time-Lock Functionality (ERC20 and ERC721)', 'Tasks': ['Audit the `timeLockERC20` and `timeUnlockERC20` functions to ensure that they correctly implement the time-lock mechanism for ERC20 tokens. Verify that only the owner can time-lock tokens and only the designated recipient can unlock them after the expiry time.', 'Review the `timeLockERC721` and `timeUnlockERC721` functions to ensure that they correctly implement the time-lock mechanism for ERC721 tokens. Verify that only the owner can time-lock tokens and only the designated recipient can unlock them after the expiry time.', 'Check the `require` statements in `timeLockERC20` and `timeLockERC721` to confirm the expires value is in the future and that the allowance is sufficient in the ERC20 case.', 'Assess the storage efficiency of `timelockERC20Keys` and `timelockERC721Keys`. Determine if there are more efficient ways to manage the keys for time-locked tokens, especially considering that the keys are not used for removal, only for iterating.']}, {'Area': 'Rage Quit Functionality', 'Tasks': ['Analyze the `rageQuit` function to confirm that it correctly removes locks and notifies the delegate contract (if applicable). Verify that only the owner can call this function.', 'Evaluate the gas limit (`RAGEQUIT_GAS`) for the external call to `IRageQuit(delegate).rageQuit`. Ensure that this gas limit is sufficient for most delegate contracts, while also preventing excessive gas consumption.', 'Assess the error handling in the `rageQuit` function. Determine if more robust error handling is needed, beyond simply returning an error string.', ""Consider the impact of a failed `rageQuit` call on the vault's state. Ensure that the lock is still removed even if the external call fails.""]}, {'Area': 'Gas Optimization', 'Tasks': ['Identify and address any gas inefficiencies in the contract, such as redundant calculations, unnecessary storage writes, or inefficient loop structures.', 'Optimize the `_addNft` and `_removeNft` functions to reduce gas consumption, especially when dealing with a large number of NFTs. Consider using more efficient data structures or algorithms.', 'Evaluate the gas cost of the `checkBalances` function and determine if it can be optimized. Consider limiting the number of locks that are checked in a single transaction.', 'Assess the gas cost of accessing storage variables, especially within loops. Consider caching values in memory if necessary.']}, {'Area': 'Contract Initialization and Upgradeability', 'Tasks': [""Review the initialization process of the contract, specifically the `initialize` and `initializeLock` functions. Verify that these functions are only called once and that they correctly initialize the contract's state."", 'Assess the upgradeability of the contract and identify any potential issues related to data migration or state management during upgrades.', ""Ensure that the contract's state variables are correctly initialized after an upgrade and that no data is lost or corrupted.""]}, {'Area': 'Potential Denial of Service', 'Tasks': ['Evaluate the potential for denial-of-service attacks on the contract, such as excessive gas consumption, storage exhaustion, or dependency on external contracts that could become unavailable.', 'Analyze the `rageQuit`, `transferERC20`, `transferERC721`, `timeLockERC20`, and `timeLockERC721` functions for potential denial-of-service vulnerabilities.', 'Implement safeguards to prevent denial-of-service attacks, such as limiting the number of operations that can be performed in a single transaction or using circuit breakers to halt the contract in case of an emergency.']}]}","{'ReviewingTheCode': 'The Visor contract acts as a multi-functional vault controlled by the owner of a specific NFT (via OwnableERC721). It can hold ETH, ERC20 tokens, and ERC721 NFTs. Key features include: EIP-712 based locking/unlocking of ERC20 tokens for delegates, owner-controlled and delegated transfers of assets, time-locking of ERC20s and ERC721s for specific recipients, and management of NFTs held within the vault. It utilizes OpenZeppelin libraries for safety and standards compliance and is designed to be upgradeable (Initializable).', 'IdentifyingKeyComponents': {'ContractName': 'Visor', 'Purpose': 'To serve as a secure and flexible vault for managing digital assets (ETH, ERC20, ERC721), allowing for delegated locking of funds (likely for DeFi integrations), time-locked releases, and NFT-based ownership control.', 'InheritanceAndImports': {'InheritsFrom': ['IUniversalVault', 'EIP712', 'ERC1271', 'OwnableERC721', 'Initializable', 'IERC721Receiver'], 'Imports': ['@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC721/IERC721.sol', '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol', '@openzeppelin/contracts/proxy/Initializable.sol', '@openzeppelin/contracts/utils/EnumerableSet.sol', '@openzeppelin/contracts/utils/Address.sol', '@uniswap/lib/contracts/libraries/TransferHelper.sol', './EIP712.sol', './ERC1271.sol', './OwnableERC721.sol', '../hypervisor/Hypervisor.sol (IRageQuit)', '../interfaces/IUniversalVault.sol', '../interfaces/IVisorService.sol']}, 'StateVariables': [{'Name': 'RAGEQUIT_GAS', 'Type': 'uint256 constant', 'Purpose': 'Gas limit allocated for the external call in the rageQuit function.'}, {'Name': 'LOCK_TYPEHASH', 'Type': 'bytes32 constant', 'Purpose': 'EIP-712 type hash for the Lock structure.'}, {'Name': 'UNLOCK_TYPEHASH', 'Type': 'bytes32 constant', 'Purpose': 'EIP-712 type hash for the Unlock structure.'}, {'Name': 'VERSION', 'Type': 'string constant', 'Purpose': 'Contract version identifier.'}, {'Name': '_nonce', 'Type': 'uint256', 'Purpose': 'Counter for EIP-712 signature replay protection.'}, {'Name': '_locks', 'Type': 'mapping(bytes32 => LockData)', 'Purpose': 'Stores details of ERC20 locks, keyed by a hash of delegate and token addresses.'}, {'Name': '_lockSet', 'Type': 'EnumerableSet.Bytes32Set', 'Purpose': 'Allows iteration over active lock IDs.'}, {'Name': 'uri', 'Type': 'string', 'Purpose': 'Metadata URI, potentially for the vault itself or related services.'}, {'Name': 'nfts', 'Type': 'Nft[]', 'Purpose': 'Array storing information about ERC721 tokens held by the contract.'}, {'Name': 'nftApprovals', 'Type': 'mapping(bytes32=>bool)', 'Purpose': 'Stores delegate approvals for transferring specific NFTs.'}, {'Name': 'erc20Approvals', 'Type': 'mapping(bytes32=>uint256)', 'Purpose': 'Stores delegate approvals (allowance) for transferring ERC20 tokens.'}, {'Name': 'timelockERC20s', 'Type': 'mapping(bytes32=>TimelockERC20)', 'Purpose': 'Stores details of time-locked ERC20 tokens.'}, {'Name': 'timelockERC20Keys', 'Type': 'mapping(address=>bytes32[])', 'Purpose': 'Stores keys for time-locked ERC20s, grouped by token address, for potential iteration (though not used for iteration in provided code).'}, {'Name': 'timelockERC20Balances', 'Type': 'mapping(address=>uint256)', 'Purpose': 'Tracks the total balance of each ERC20 token currently time-locked.'}, {'Name': 'timelockERC721s', 'Type': 'mapping(bytes32=>TimelockERC721)', 'Purpose': 'Stores details of time-locked ERC721 tokens.'}, {'Name': 'timelockERC721Keys', 'Type': 'mapping(address=>bytes32[])', 'Purpose': 'Stores keys for time-locked ERC721s, grouped by NFT contract address, for potential iteration (though not used for iteration in provided code).'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'external', 'Purpose': 'Initializes the contract, setting the NFT contract used for ownership. Meant to be called once via proxy.', 'Parameters': [], 'Returns': []}, {'Name': 'receive', 'Visibility': 'external payable', 'Purpose': 'Allows the contract to receive ETH.', 'Parameters': [], 'Returns': []}, {'Name': '_addNft / _removeNft', 'Visibility': 'internal', 'Purpose': 'Internal functions to manage the `nfts` array when ERC721 tokens are received or sent.', 'Parameters': ['address nftContract', 'uint256 tokenId'], 'Returns': []}, {'Name': 'owner', 'Visibility': 'public view', 'Purpose': 'Returns the owner address (derived from OwnableERC721).', 'Parameters': [], 'Returns': ['address']}, {'Name': 'lock', 'Visibility': 'external', 'Purpose': 'Allows a delegate to lock a specified amount of an ERC20 token within the vault, requiring a valid EIP-712 signature.', 'Parameters': ['address token', 'uint256 amount', 'bytes permission'], 'Returns': []}, {'Name': 'unlock', 'Visibility': 'external', 'Purpose': 'Allows a delegate to unlock (decrease the locked balance) a specified amount of an ERC20 token, requiring a valid EIP-712 signature.', 'Parameters': ['address token', 'uint256 amount', 'bytes permission'], 'Returns': []}, {'Name': 'rageQuit', 'Visibility': 'external', 'Purpose': 'Allows the owner to forcefully remove an ERC20 lock associated with a delegate, optionally notifying the delegate contract.', 'Parameters': ['address delegate', 'address token'], 'Returns': ['bool notified', 'string memory error']}, {'Name': 'transferERC20', 'Visibility': 'external', 'Purpose': 'Allows the owner to transfer ERC20 tokens out of the vault, respecting locked and time-locked balances.', 'Parameters': ['address token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'approveTransferERC20', 'Visibility': 'external', 'Purpose': 'Allows the owner to approve a delegate to transfer a specific amount of an ERC20 token.', 'Parameters': ['address token', 'address delegate', 'uint256 amount'], 'Returns': []}, {'Name': 'delegatedTransferERC20', 'Visibility': 'external', 'Purpose': 'Allows an approved delegate (or the owner) to transfer ERC20 tokens out of the vault, respecting locked and time-locked balances.', 'Parameters': ['address token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'transferETH', 'Visibility': 'external payable', 'Purpose': 'Allows the owner to transfer ETH out of the vault.', 'Parameters': ['address to', 'uint256 amount'], 'Returns': []}, {'Name': 'approveTransferERC721', 'Visibility': 'external', 'Purpose': 'Allows the owner to approve a delegate to transfer a specific ERC721 token.', 'Parameters': ['address delegate', 'address nftContract', 'uint256 tokenId'], 'Returns': []}, {'Name': 'transferERC721', 'Visibility': 'external', 'Purpose': 'Allows an approved delegate (or the owner) to transfer a specific ERC721 token out of the vault, respecting time-locks.', 'Parameters': ['address to', 'address nftContract', 'uint256 tokenId'], 'Returns': []}, {'Name': 'onERC721Received', 'Visibility': 'external', 'Purpose': 'ERC721 receiver hook to handle incoming NFTs and add them to the internal tracking array.', 'Parameters': ['address operator', 'address from', 'uint256 tokenId', 'bytes data'], 'Returns': ['bytes4']}, {'Name': 'timeLockERC721', 'Visibility': 'public', 'Purpose': 'Allows the owner to time-lock an ERC721 token (sent from the owner) for a specific recipient until an expiry time.', 'Parameters': ['address recipient', 'address nftContract', 'uint256 tokenId', 'uint256 expires'], 'Returns': []}, {'Name': 'timeUnlockERC721', 'Visibility': 'public', 'Purpose': 'Allows the designated recipient to withdraw a time-locked ERC721 token after its expiry.', 'Parameters': ['address recipient', 'address nftContract', 'uint256 tokenId', 'uint256 expires'], 'Returns': []}, {'Name': 'timeLockERC20', 'Visibility': 'public', 'Purpose': 'Allows the owner to time-lock an ERC20 token (transferred from the owner) for a specific recipient until an expiry time.', 'Parameters': ['address recipient', 'address token', 'uint256 amount', 'uint256 expires'], 'Returns': []}, {'Name': 'timeUnlockERC20', 'Visibility': 'public', 'Purpose': 'Allows the designated recipient to withdraw time-locked ERC20 tokens after their expiry.', 'Parameters': ['address recipient', 'address token', 'uint256 amount', 'uint256 expires'], 'Returns': []}, {'Name': 'onlyOwner', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the contract owner (derived from OwnableERC721).', 'Parameters': [], 'Returns': []}, {'Name': 'onlyValidSignature', 'Visibility': 'modifier', 'Purpose': 'Checks if a provided signature is valid for the given EIP-712 hash (internal mechanism likely within ERC1271/EIP712 base contracts).', 'Parameters': ['bytes32 hash', 'bytes signature'], 'Returns': []}, {'Name': 'initializer', 'Visibility': 'modifier', 'Purpose': 'Ensures a function can only be called once during initialization (from Initializable).', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IERC20: Calls `balanceOf`, `transfer`, `approve`, `allowance`, `transferFrom` on external ERC20 token contracts.', 'IERC721: Calls `safeTransferFrom` on external ERC721 token contracts.', ""IRageQuit: Calls `rageQuit` on an external delegate contract if it's a contract during the `rageQuit` process."", 'TransferHelper: Uses library for safe transfers of ERC20 tokens and ETH.', 'Owner NFT Contract (Implicit): Interacts with the NFT contract specified during initialization via `OwnableERC721` to determine the owner.', 'EIP712/ERC1271 Mechanisms: Relies on signature verification potentially involving checks against the owner (especially if the owner is a contract implementing ERC1271).'], 'SpecialMechanisms': ['Proxy Pattern (Upgradeable): Inherits from `Initializable`, indicating deployment behind a proxy.', 'NFT-Based Ownership: Uses `OwnableERC721` where ownership is tied to holding a specific NFT.', 'EIP-712 Signatures: Used for gasless permissioning of `lock` and `unlock` operations.', 'ERC1271 Signature Validation: Supports validating signatures from contract-based owners.', 'Delegated Locking: The `lock`/`unlock` mechanism allows external delegates to reserve funds within the vault.', 'Time-locking: Custom implementation for locking ERC20s and ERC721s until a specific timestamp.', 'EnumerableSet: Used for efficient iteration over active ERC20 locks.', 'Internal NFT Tracking: Maintains an array (`nfts`) of held ERC721s.'], 'Questions': ['What is the intended deployment process? How is the `OwnableERC721` NFT contract address set correctly in `initialize` when called via a proxy?', 'Is the owner intended to bypass the `erc20Approvals` and `nftApprovals` checks in `delegatedTransferERC20` and `transferERC721`? This seems implied by `if(msg.sender != _getOwner()) { ... }`.', 'Gas Limits: The `_removeNft` function uses a loop. Could this exceed gas limits if the vault holds a very large number of NFTs?', 'Gas Limits: The `checkBalances` function loops through all active locks. Could this become too expensive?', 'Reentrancy: Are there potential reentrancy risks, especially in `rageQuit` (calling external `rageQuit`) or transfer functions interacting with potentially malicious token contracts?', ""Timelock Key Management: `timelockERC20Keys` and `timelockERC721Keys` store keys but don't seem to be used for efficient removal upon unlock. Is removal handled elsewhere, or is this potentially inefficient?"", 'Unlock Event Consistency: The `rageQuit` function removes a lock but emits `RageQuit`, not `Unlocked`. Is this intended behavior?', 'IVisorService Interface: The `IVisorService` interface is imported but not used in the provided code snippet. What is its purpose in the broader system?', 'Error Handling: The `rageQuit` function catches errors from the external call but only returns them as strings. Are there scenarios where more robust error handling might be needed?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerabilities in Multiple Functions', 'Severity': 'High', 'Description': 'Multiple functions exhibit potential reentrancy vulnerabilities due to interactions with external contracts before state updates are finalized (violating the Checks-Effects-Interactions pattern) or missing `nonReentrant` modifiers. Specifically: `transferERC721` (during `safeTransferFrom` calls, potentially interacting with timelock logic), `timeUnlockERC20` and `timeUnlockERC721` (transferring tokens/NFTs *after* deleting timelock state), and `rageQuit` (calling an external `delegate` contract before internal state updates). These could allow malicious recipient/delegate contracts to re-enter the `Visor` contract, potentially leading to unauthorized token/NFT transfers, state manipulation, or bypassing intended logic.', 'Impact': 'An attacker could potentially drain ERC20 tokens or ERC721 NFTs, manipulate contract state, bypass timelocks, or cause other unexpected behavior by exploiting reentrancy during external calls.', 'Location': '`transferERC721`, `timeUnlockERC20`, `timeUnlockERC721`, `rageQuit` functions'}, {'Issue': 'Insufficient Balance/Logic Check in `timeUnlockERC20`', 'Severity': 'High', 'Description': 'The balance check in `timeUnlockERC20` (`require(IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount)...`) is potentially incorrect or insufficient. Reports suggest it might incorrectly factor in locked balances (leading to reverts when sufficient unlocked balance exists), or fail to account for the total timelocked balance (`timelockERC20Balances[token]`), potentially allowing unlocks that make later timelocks unretrievable or preventing legitimate unlocks.', 'Impact': ""Legitimate unlocks may fail (DoS), or the check might pass incorrectly, potentially leading to scenarios where timelocked tokens become permanently stuck if the contract's total balance becomes insufficient due to prior unlocks."", 'Location': '`timeUnlockERC20` function'}, {'Issue': 'Missing Check for ERC721 Ownership Before Timelocking in `timeLockERC721`', 'Severity': 'High', 'Description': 'The `timeLockERC721` function transfers an NFT from `msg.sender` to the contract but does not verify that `msg.sender` actually owns or has approval for the `tokenId` *before* initiating the `safeTransferFrom`. While the transfer itself will likely revert if `msg.sender` lacks rights, this allows for griefing attacks (wasting gas) and potential front-running scenarios where an attacker could manipulate ownership or approvals to cause denial of service or lock NFTs unexpectedly if the owner is tricked into calling the function.', 'Impact': 'Gas wastage, potential denial of service for the owner trying to manage NFTs, or locking NFTs under unexpected conditions if combined with approval manipulation or front-running.', 'Location': '`timeLockERC721` function'}, {'Issue': 'Flawed Access Control on `delegatedTransferERC20` and `transferERC721`', 'Severity': 'Medium', 'Description': ""The access control logic in `delegatedTransferERC20` and `transferERC721` is insufficient. The checks for `erc20Approvals` or `nftApprovals` are bypassed if `msg.sender == _getOwner()`, weakening the approval mechanism if the owner's key is compromised. Furthermore, reports suggest the checks when `msg.sender != _getOwner()` might be bypassable or insufficient on their own, potentially allowing unauthorized transfers if an attacker can satisfy approval/timelock conditions without being the intended delegate or recipient."", 'Impact': ""Unauthorized ERC20 token or ERC721 NFT transfers, leading to potential financial loss or loss of assets for the vault's owner, especially if the owner's account is compromised or approval logic is exploited."", 'Location': '`delegatedTransferERC20`, `transferERC721` functions'}, {'Issue': 'Potential Integer Overflow/Underflow in Approval Handling', 'Severity': 'Medium', 'Description': ""The `delegatedTransferERC20` function decrements `erc20Approvals`. While SafeMath's `.sub()` prevents underflow during the decrement itself *if* the initial check (`>= amount`) passes, there are edge cases. If the initial approval is zero, the check passes for `amount = 0`, but subsequent subtraction could underflow. If an approval is set near `MAX_UINT`, adding to it (if applicable elsewhere) or subtracting from it could theoretically wrap around, although direct underflow is mitigated by the `require` and SafeMath. This points to potential fragility in the approval logic."", 'Impact': 'Could lead to delegates having unexpectedly large approval amounts, potentially allowing unauthorized fund transfers if edge cases are triggered or logic is exploited.', 'Location': '`delegatedTransferERC20`, `approveTransferERC20` functions (related to `erc20Approvals` mapping)'}, {'Issue': 'Missing Input Validation for Critical Parameters (Zero Address, Expires)', 'Severity': 'Medium', 'Description': 'Several functions lack validation for critical parameters. `transferERC20`, `transferETH`, `timeLockERC20`, and `timeLockERC721` do not consistently check for zero addresses in `to` or `recipient` parameters, potentially leading to accidental burning of tokens/ETH or locking assets irrecoverably. Additionally, `timeLockERC20` and `timeLockERC721` do not validate the `expires` parameter against unreasonably large values, which could cause future issues or DoS.', 'Impact': 'Accidental loss of funds/NFTs by sending to the zero address. Potential DoS or unexpected behavior due to extremely large expiration timestamps.', 'Location': '`transferERC20`, `transferETH`, `timeLockERC20`, `timeLockERC721` functions'}, {'Issue': 'Potential Front-running/Griefing Vulnerability in Timelock Creation and Usage', 'Severity': 'Medium', 'Description': 'The timelock mechanism (`timeLockERC20`/`timeLockERC721`) uses predictable parameters (`recipient`, `token`, `amount`/`tokenId`, `expires`) to generate a storage key. An attacker monitoring the mempool could potentially front-run a legitimate `timeLock` transaction, creating a conflicting or identical timelock entry, possibly to steal the lock or cause confusion. Additionally, in `transferERC721`, if a timelock exists, an attacker could front-run a legitimate transfer by transferring the NFT *to* the vault, preventing the owner from moving it while allowing the timelock recipient potential control.', 'Impact': 'Potential theft of timelocked assets, denial of service for legitimate users trying to lock or transfer assets, or general disruption of the timelock mechanism.', 'Location': '`timeLockERC20`, `timeLockERC721`, `timeUnlockERC20`, `timeUnlockERC721`, `transferERC721` functions'}, {'Issue': 'Potential Denial of Service (DoS) due to Unbounded Loops', 'Severity': 'Medium', 'Description': 'Functions that iterate over arrays without guaranteed bounds can lead to DoS via gas exhaustion if the arrays grow large. This affects: `_removeNft` (iterating `nfts` array), `transferERC721` (iterating `timelockERC721Keys` for a specific `nftContract`), and potentially `getTimeLockCount`/`getTimeLockERC721Count` (iterating `timelockERC20Keys`/`timelockERC721Keys`). A large number of managed NFTs or timelocks could make these operations exceed the block gas limit.', 'Impact': 'Users may be unable to withdraw/manage NFTs or query timelock counts if the relevant arrays become too large, leading to locked assets or inability to interact with the contract.', 'Location': '`_removeNft`, `transferERC721`, `getTimeLockCount`, `getTimeLockERC721Count` functions'}, {'Issue': 'Potential Denial of Service (DoS) in `rageQuit`', 'Severity': 'Medium', 'Description': ""The `rageQuit` function attempts to notify a delegate contract. If the delegate contract's `rageQuit` function always reverts or consumes more gas than the hardcoded `RAGEQUIT_GAS` limit, the owner's `rageQuit` call will fail, preventing them from executing the rage quit."", 'Impact': 'Owner may be unable to perform the `rageQuit` action if the designated delegate contract is malicious or faulty.', 'Location': '`rageQuit` function'}, {'Issue': 'Missing Access Control on `timeUnlockERC20` and `timeUnlockERC721` after Expiry', 'Severity': 'Low', 'Description': ""The `timeUnlockERC20` and `timeUnlockERC721` functions check that the timelock has expired and `msg.sender` is the recipient. However, they don't restrict *who* can call the function once these conditions are met. Anyone knowing the parameters can call the function after expiry, potentially front-running the intended recipient."", 'Impact': 'A malicious actor could potentially front-run the intended recipient and claim the unlocked tokens/NFTs if they can predict the unlock parameters and timing.', 'Location': '`timeUnlockERC20`, `timeUnlockERC721` functions'}, {'Issue': 'Lack of Event Emission for Critical Actions', 'Severity': 'Low', 'Description': 'Certain state-changing operations lack corresponding event emissions. Specifically, `approveTransferERC20` and `approveTransferERC721` do not emit events upon changing approvals. Also, if the inherited `OwnableERC721` does not emit an `OwnershipTransferred` event, tracking ownership changes becomes difficult.', 'Impact': 'Reduced transparency and auditability. Off-chain systems and users cannot easily track approval changes or ownership transfers.', 'Location': '`approveTransferERC20`, `approveTransferERC721`, potentially inherited `OwnableERC721`'}, {'Issue': 'Missing Check for `expires` Parameter Consistency in TimeUnlock Functions', 'Severity': 'Low', 'Description': 'The `timeUnlockERC20` and `timeUnlockERC721` functions calculate the `key` using the `expires` parameter provided in the function call. They check if the stored timelock (using that key) has expired, but do not explicitly verify if the `expires` value *passed to the function* matches the `expires` value *stored* in the struct. While the recipient check adds security, this inconsistency could lead to confusion or unexpected behavior if incorrect expiry times are somehow used.', 'Impact': 'Potential for confusion or logic errors if the `expires` parameter mismatch is not handled correctly, though direct exploit seems unlikely due to other checks.', 'Location': '`timeUnlockERC20`, `timeUnlockERC721` functions'}, {'Issue': 'Potentially Unclear NFT Transfer Logic in `timeLockERC721`', 'Severity': 'Low', 'Description': ""The `timeLockERC721` function transfers the NFT using `safeTransferFrom(msg.sender, address(this), tokenId)`. This allows the owner (`msg.sender`) to initiate a transfer *from their own address* to the vault. While likely intended, it could be misinterpreted; ensuring the transfer originates specifically from the contract's owner (e.g., using `_getOwner()` if different from `msg.sender` context) might improve clarity."", 'Impact': 'Minor confusion regarding the source of the NFT transfer during timelocking; no direct security vulnerability identified.', 'Location': '`timeLockERC721` function'}, {'Issue': 'Lack of Input Validation on `setURI`', 'Severity': 'Low', 'Description': 'The `setURI` function does not validate the length or format of the provided `_uri` string. Extremely long URIs could lead to high gas costs for storage and potential issues for off-chain clients attempting to parse or display it.', 'Impact': 'Increased gas costs, potential client-side rendering issues or errors if the URI is excessively long or malformed.', 'Location': '`setURI` function'}, {'Issue': 'Missing Mechanism to Revoke NFT Approvals', 'Severity': 'Medium', 'Description': 'The contract provides `approveTransferERC721` to grant boolean approval for NFT transfers but lacks a corresponding function to explicitly revoke this approval. Once granted, an approval remains active indefinitely unless overwritten by setting it to `false` via another call to `approveTransferERC721`, which is less intuitive than a dedicated `revoke` function.', 'Impact': 'Approved delegates retain transfer rights permanently unless the owner actively overwrites the approval, potentially leading to unintended access if a delegate relationship changes.', 'Location': '`approveTransferERC721` function (lack of corresponding revoke mechanism)'}], 'IssueNumber': 64, 'OutputList': 15}",290.8541009426117,"### **Comparison and Evaluation**

---

#### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:  
If a timelocked NFT is transferred out of the vault using `transferERC721()` without explicitly unlocking it via `timeUnlockERC721()`, the `timelockERC721s[key]` entry for that NFT is not deleted. This oversight can cause the NFT to become permanently stuck in the vault if it is moved back in, as the timelock state remains active despite the NFT being transferred out.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of NFTs becoming permanently stuck due to incomplete cleanup of timelock state is not covered.

---

#### **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**

**Report Description**:  
NFT transfer approvals set in `approveTransferERC721()` are never reset or revoked. This lack of a revocation mechanism means that once an approval is granted, it remains active indefinitely, potentially leading to unauthorized transfers if the delegate relationship changes.

**Match in Response List**:  
Matches with the issue titled **""Missing Mechanism to Revoke NFT Approvals""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of a revocation mechanism for NFT transfer approvals, which aligns with the issue described in the report.

---

#### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:  
The `Visor.transferERC721` function does not reset the approval for the NFT after a transfer. This allows an approved delegate to move the NFT out of the contract multiple times, even if the NFT is deposited back into the vault by a new owner.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of approvals persisting after transfers is not covered.

---

#### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:  
The `_removeNft` function uses an unbounded loop to iterate through the `nfts` array. A malicious user could exploit this by repeatedly calling `onERC721Received` to grow the array, causing gas exhaustion and preventing legitimate users from removing NFTs.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service (DoS) due to Unbounded Loops""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of gas exhaustion due to unbounded loops, which aligns with the issue described in the report.

---

#### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:  
The `timeLockERC20()` function does not handle the return value of `transferFrom`. Some ERC20 implementations return `false` on failure instead of reverting, which could lead to silent failures and fund loss.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of unhandled return values in `transferFrom` is not covered.

---

#### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:  
The `transferERC721` function does not clean the `timelockERC721s` mapping after transferring a timelocked NFT. This could lead to stale timelock keys and incorrect administration of available NFTs.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of incomplete cleanup of timelock state in `transferERC721` is not covered.

---

#### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:  
The `timelockERC721Keys` array could grow large enough to exceed the block gas limit when iterated, causing transactions to fail.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service (DoS) due to Unbounded Loops""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of gas exhaustion due to unbounded loops, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**
- **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**
- **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**
- **[H-03] Approval for NFT transfers is not removed after transfer**
- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**
- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

--- 

The response list covers some critical issues but misses several others, particularly those related to incomplete cleanup of timelock state and unhandled return values. Addressing these gaps is essential for comprehensive security.","```
1. Missing Mechanism to Revoke NFT Approvals
2. Potential Denial of Service (DoS) due to Unbounded Loops
3. Potential Denial of Service (DoS) due to Unbounded Loops
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - The ranked list of predictions contains 15 items.
   - The true positives are:
     - ""Missing Mechanism to Revoke NFT Approvals"" (appears at rank 15)
     - ""Potential Denial of Service (DoS) due to Unbounded Loops"" (appears at rank 8)
     - ""Potential Denial of Service (DoS) due to Unbounded Loops"" (appears at rank 8)

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 8: \( P@8 = \frac{1}{8} = 0.125 \)
   - For rank 15: \( P@15 = \frac{2}{15} \approx 0.133 \)

3. **Average the precision values**:
   - AP = \( \frac{0.125 + 0.133}{2} \approx 0.129 \)

Thus, the **Average Precision (AP)** for the query is:

**0.129**"
