nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
FlashGovernanceArbiter.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";

///@title Flash Governance Arbiter
///@author Justin Goro
/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.
 * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.
 * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.
 * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed
 * By default, the asset is EYE.
 */
contract FlashGovernanceArbiter is Governable {
  /**
   * @param actor user making flash governance decision
   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.
   * @param amount is the amount of the deposit_asset to be put up as decision collateral.
   * @param target is the contract that will be affected by the flash governance decision.
   */
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.
    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov
  }

  //the current parameters determining the rules of flash governance
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules
   *without undermining the terms under which pending decisions were made.
   */
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config

  /**
   *@notice An attempt is made to withdraw the current deposit requirement.
   * For a given user, flash governance decisions can only happen one at a time
   *@param sender is the user making the flash governance decision
   *@param target is the contract that will be affected by the flash governance decision.
   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.
   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.
   */
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  /**
   *@param asset is the asset type put up as decision collateral. Must be burnable.
   *@param amount is the amount of the deposit_asset to be put up as decision collateral.
   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision
   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.
   */
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  /**
    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS
    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations
    @param changeTolerance is the amount by which a variable can be changed through flash governance.
    */
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  /**
    @notice LimboDAO proposals for burning flash governance collateral act through this function
    @param targetContract is the contract that is affected by the flash governance decision.
    @param user is the user who made the flash governance decision
    @param asset is the collateral asset to be burnt
    @param amount is the amount of the collateral to be burnt
    */
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  /**
   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset
   *@param targetContract is the contract that is affected by the flash governance decision.
   *@param asset is the collateral asset to be withdrawn
   */
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  /**
   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance
   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.
   * @param enforce for the given context, set whether variable movement limits are enforced or not.
   */
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  ///@dev for negative values, relative comparisons need to be calculated correctly.
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  ///@notice Allows functions to enforce maximum limits on a per variable basis
  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    //bonus points for readability
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1924,186,"[H-01] Lack of access control on assertGovernanceApproved can cause funds to be locked

Submitted by shw, also found by kirk-baird and pauliax
Lack of access control on the `assertGovernanceApproved` function of FlashGovernanceArbiter allows anyone to lock other users' funds in the contract as long as the users have approved the contract to transfer flashGovernanceConfig.amount of flashGovernanceConfig.asset from them.
Proof of Concept

Alice wants to execute a flash governance decision (e.g., disable to the protocol), so she first calls approve on the flashGovernanceConfig.asset to allow FlashGovernanceArbiter to transfer flashGovernanceConfig.amount of assets from her.
An attacker Bob, who listens to the mempool, notices Alice's approve transaction and decides to front-run it. He calls assertGovernanceApproved with sender being Alice, target being any address, and emergency being true.
As a result, Alice cannot execute her flash governance decision, and her funds are locked in the contract for the flashGovernanceConfig.unlockTime period.
Referenced code: DAO/FlashGovernanceArbiter.sol#L60-L81
  [H-04] Logic error in burnFlashGovernanceAsset can cause locked assets to be stolen

Submitted by shw
A logic error in the `burnFlashGovernanceAsset` function that resets a user's pendingFlashDecision allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.
Proof of Concept

An attacker Alice executes a malicious flash governance decision, and her assets are locked in the FlashGovernanceArbiter contract.
The community disagrees with Alice's flash governance decision and calls burnFlashGovernanceAsset to burn her locked assets. However, the burnFlashGovernanceAsset function resets Alice's pendingFlashDecision to the default config (see line 134).
A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.
Now, Alice calls withdrawGovernanceAsset to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's pendingFlashDecision is reset to the default, the unlockTime < block.timestamp condition is fulfilled, and the withdrawal succeeds.
  [H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request

Submitted by kirk-baird
Users who have not called `withdrawGovernanceAsset()` after they have locked their tokens from a previous proposal (i.e. assertGovernanceApproved), will lose their tokens if assertGovernanceApproved() is called again with the same target and sender.
The sender will lose pendingFlashDecision[target][sender].amount tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.
The impact of this is worsened by another vulnerability, that is assertGovernanceApproved() is a public function and may be called by any arbitrary user so long as the sender field has called approve() for FlashGovernanceArbiter on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary sender.

[M-01] Incorrect unlockTime can DOS withdrawGovernanceAsset

Submitted by csanuragjain
unlockTime is set incorrectly.
Proof of Concept

Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol
Observe the assertGovernanceApproved function ```
function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
...
pendingFlashDecision[target][sender].unlockTime += block.timestamp;
...
}
```  [M-02] Reentrancy on Flash Governance Proposal Withdrawal

Submitted by kirk-baird
The function withdrawGovernanceAsset() is vulnerable to reentrancy, which would allow the attacker to drain the balance of the flashGoverananceConfig.asset.
Note: this attack assumes the attacker may gain control of the execution flow in asset.tranfer() which is the case for many ERC20 tokens such as those that implement ERC777 but will depend on which asset is chosen in the configuration.
  [M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance

Submitted by kirk-baird
The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.
Proof of Concept

The function burnFlashGovernanceAsset() will simply overwrite the user's state with pendingFlashDecision[targetContract][user] = flashGovernanceConfig; as seen below.
function burnFlashGovernanceAsset(
  address targetContract,
  address user,
  address asset,
  uint256 amount
) public virtual onlySuccessfulProposal {
  if (pendingFlashDecision[targetContract][user].assetBurnable) {
    Burnable(asset).burn(amount);
  }

  pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
}
",6,,"pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";




contract FlashGovernanceArbiter is Governable {
  
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; 
    uint256 epochSize; 
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; 
  }

  
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; 

  
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  
  
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1017,3,3,"Based on the detailed initial analysis, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify ERC20 transfer mechanism in assertGovernanceApproved() for proper return value handling"",
        ""Audit transfer and burn functions for potential reentrancy risks"",
        ""Analyze potential integer overflow/underflow scenarios in calculation methods"",
        ""Validate input validation across all external and public functions""
      ]
    },
    {
      ""Area"": ""Access Control & Governance"",
      ""Tasks"": [
        ""Investigate inheritance and implementation of onlySuccessfulProposal modifier"",
        ""Review Governable contract for comprehensive access control mechanisms"",
        ""Verify governance configuration methods against potential centralization risks"",
        ""Analyze flash governance decision approval process for potential manipulation""
      ]
    },
    {
      ""Area"": ""Complex Logic Analysis"",
      ""Tasks"": [
        ""Thoroughly review enforceTolerance() percentage calculation logic"",
        ""Validate the epoch-based governance change limitation mechanism"",
        ""Audit the flash governance configuration and decision tracking system"",
        ""Analyze the interaction between SecurityParameters and FlashGovernanceConfig""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify safe interaction with external Burnable interface"",
        ""Check IERC20 token transfer and approval mechanisms"",
        ""Validate cross-contract method calls for potential vulnerabilities"",
        ""Ensure proper handling of external contract interactions""
      ]
    },
    {
      ""Area"": ""State Management"",
      ""Tasks"": [
        ""Investigate the use of 'configured' variable not defined in contract"",
        ""Review mapping and struct state update processes"",
        ""Analyze pendingFlashDecision state management for potential inconsistencies"",
        ""Verify state reset and deletion mechanisms in governance functions""
      ]
    },
    {
      ""Area"": ""Parameter Validation"",
      ""Tasks"": [
        ""Review input validation in configuration methods"",
        ""Verify tolerance and security parameter constraints"",
        ""Check for potential edge cases in parameter setting methods"",
        ""Validate range and type constraints for governance parameters""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in complex governance methods"",
        ""Review mapping and struct storage efficiency"",
        ""Identify potential optimization opportunities in calculation methods"",
        ""Evaluate computational complexity of enforcement functions""
      ]
    },
    {
      ""Area"": ""Risk Mitigation"",
      ""Tasks"": [
        ""Develop comprehensive test scenarios for edge cases"",
        ""Create threat model identifying potential attack vectors"",
        ""Implement additional safeguards for governance decision process"",
        ""Verify emergency stop and recovery mechanisms""
      ]
    }
  ]
}

This task list comprehensively addresses the key concerns identified in the initial analysis, providing a structured approach to auditing the FlashGovernanceArbiter contract. The tasks are designed to systematically examine security, functionality, and potential vulnerabilities across multiple dimensions of the smart contract.

The prioritization considers:
1. Critical security risks
2. Governance and access control
3. Complex logic and potential manipulation vectors
4. External interaction safety
5. State management integrity
6. Performance considerations

Each task is specific, actionable, and directly responds to the initial analysis findings, ensuring a thorough and methodical audit process.","After reviewing the FlashGovernanceArbiter contract, here's my detailed audit analysis:

{
  ""ReviewingTheCode"": ""The FlashGovernanceArbiter contract implements a flash governance mechanism that allows certain actions to be taken by users who lock tokens as collateral. It includes security parameters to limit governance changes and implements tolerance checks for parameter changes."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FlashGovernanceArbiter"",
    ""Purpose"": ""Provides a mechanism for temporary governance actions by requiring users to lock tokens, with configurable security parameters and tolerance enforcement for governance changes."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable""],
      ""Imports"": [
        ""Governable.sol"",
        ""hardhat/console.sol"",
        ""Burnable interface from ../facades/Burnable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""enforceLimitsActive"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks whether tolerance limits should be enforced for a particular address""
      },
      {
        ""Name"": ""flashGovernanceConfig"",
        ""Type"": ""FlashGovernanceConfig struct"",
        ""Purpose"": ""Global configuration for flash governance including required asset, amount, and unlock time""
      },
      {
        ""Name"": ""security"",
        ""Type"": ""SecurityParameters struct"",
        ""Purpose"": ""Defines security parameters like epoch size and change tolerance percentages""
      },
      {
        ""Name"": ""pendingFlashDecision"",
        ""Type"": ""mapping(address => mapping(address => FlashGovernanceConfig))"",
        ""Purpose"": ""Tracks pending flash governance decisions indexed by target contract and user address""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the DAO address by calling the parent Governable constructor"",
        ""Parameters"": [""address dao""],
        ""Returns"": []
      },
      {
        ""Name"": ""assertGovernanceApproved"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a sender is approved to govern a target contract, locks tokens, and records the decision"",
        ""Parameters"": [""address sender"", ""address target"", ""bool emergency""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureFlashGovernance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the flash governance configuration parameters"",
        ""Parameters"": [""address asset"", ""uint256 amount"", ""uint256 unlockTime"", ""bool assetBurnable""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSecurityParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the security parameters for governance changes"",
        ""Parameters"": [""uint8 maxGovernanceChangePerEpoch"", ""uint256 epochSize"", ""uint8 changeTolerance""],
        ""Returns"": []
      },
      {
        ""Name"": ""burnFlashGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns governance assets that were locked for a flash governance decision"",
        ""Parameters"": [""address targetContract"", ""address user"", ""address asset"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to withdraw their locked assets after the unlock time has passed"",
        ""Parameters"": [""address targetContract"", ""address asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setEnforcement"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a contract to set whether tolerance enforcement should be active for its address"",
        ""Parameters"": [""bool enforce""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceToleranceInt"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Enforces tolerance limits for signed integers"",
        ""Parameters"": [""int256 v1"", ""int256 v2""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceTolerance"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Enforces that changes between two values don't exceed the configured tolerance percentage"",
        ""Parameters"": [""uint256 v1"", ""uint256 v2""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 for token transfers (in assertGovernanceApproved and withdrawGovernanceAsset functions)"",
    ""Burnable interface for burning tokens in burnFlashGovernanceAsset"",
    ""Inherited Governable contract which likely handles governance permissions""
  ],
  
  ""SpecialMechanisms"": [
    ""Flash governance pattern requiring token collateral to make governance decisions"",
    ""Epoch-based security mechanism to limit the frequency of governance changes"",
    ""Change tolerance enforcement to prevent drastic parameter changes in governed contracts"",
    ""Time-locked governance decisions with configurable unlock times""
  ],
  
  ""Questions"": [
    ""The 'configured' variable is used in enforcement functions but isn't defined within this contract. Is it inherited from Governable?"",
    ""In assertGovernanceApproved(), the function doesn't check if the transfer returns true before proceeding with the rest of the logic - is this intentional?"",
    ""The enforceTolerance function's percentage calculation logic appears problematic. It's calculating (difference * 100) < tolerance * original value, which doesn't match a typical percentage calculation."",
    ""The onlySuccessfulProposal modifier is used but not defined in this contract - is it inherited from Governable?"",
    ""burnFlashGovernanceAsset() resets pendingFlashDecision to flashGovernanceConfig after burning. Is this intended, or should it clear the mapping entry?"",
    ""The contract doesn't explicitly check if flashGovernanceConfig is initialized before use in assertGovernanceApproved""
  ]
}

Based on my audit, several security concerns stand out:

1. The `assertGovernanceApproved` function doesn't properly handle the ERC20 transfer result, creating a potential vulnerability where execution continues even if the transfer fails.

2. The percentage calculation in `enforceTolerance` appears incorrect, which could allow larger changes than intended or block valid changes.

3. The contract relies on external state (`configured`) not defined in this contract.

4. There's inconsistent state management in functions like `burnFlashGovernanceAsset` which resets state to default values instead of clearing entries.

5. Missing validation for initialized configurations before using them in critical functions.

These issues should be addressed to ensure the contract functions correctly and securely.","I've processed and analyzed the multiple security assessments of the FlashGovernanceArbiter contract. After consolidating similar issues and removing redundancies, here is the comprehensive summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract's functions, especially withdrawGovernanceAsset and assertGovernanceApproved, perform external calls before updating state. This violates the checks-effects-interactions pattern, creating reentrancy vulnerabilities where attackers could reenter the contract before state updates occur."",
      ""Impact"": ""Attackers could potentially withdraw the same governance assets multiple times, draining the contract of funds, or manipulate governance decisions by reentering during token transfers."",
      ""Location"": ""withdrawGovernanceAsset and assertGovernanceApproved functions""
    },
    {
      ""Issue"": ""Missing Return Value Checks for ERC20 Operations"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses IERC20.transfer() and IERC20.transferFrom() without checking return values. Some ERC20 tokens (like USDT) return false instead of reverting on failure, which can lead to silent failures where the contract continues execution as if transfers succeeded."",
      ""Impact"": ""Users might lose governance assets if transfers fail silently, or unauthorized governance actions could proceed even when token requirements aren't met. The issue affects both deposits for governance decisions and withdrawals of locked assets."",
      ""Location"": ""assertGovernanceApproved function (transferFrom) and withdrawGovernanceAsset function (transfer)""
    },
    {
      ""Issue"": ""Lack of SafeERC20 Usage"",
      ""Severity"": ""High"",
      ""Description"": ""The contract directly uses IERC20 interface for token transfers without using the SafeERC20 library, which would handle non-standard token behaviors and provide proper return value checks."",
      ""Impact"": ""Could lead to locked tokens if transfers fail silently or if non-standard ERC20 tokens are used that don't properly implement the interface. In worst cases, funds could be permanently lost."",
      ""Location"": ""All functions performing token transfers, including assertGovernanceApproved and withdrawGovernanceAsset""
    },
    {
      ""Issue"": ""Unchecked External Calls in burnFlashGovernanceAsset"",
      ""Severity"": ""Medium"",
      ""Description"": ""The burnFlashGovernanceAsset function calls an external burn function without checking its return value or handling potential failures through try/catch mechanisms."",
      ""Impact"": ""If the burn operation fails, the function will continue execution as if it succeeded, potentially leaving inconsistent state and allowing users to withdraw tokens that should have been burned."",
      ""Location"": ""burnFlashGovernanceAsset function""
    },
    {
      ""Issue"": ""Missing Validation in configureFlashGovernance"",
      ""Severity"": ""Medium"",
      ""Description"": ""The configureFlashGovernance function sets important security parameters without validating their values, such as ensuring unlockTime is reasonable, amount is non-zero, or asset address is not the zero address."",
      ""Impact"": ""Misconfigured flash governance parameters could make the system unusable or insecure, either by setting too high deposit requirements or time locks that are too short/long, or by configuring with invalid token addresses."",
      ""Location"": ""configureFlashGovernance function""
    },
    {
      ""Issue"": ""Logical Error in Tolerance Enforcement Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the enforceTolerance function, the percentage calculation is incorrect. It computes ((v1 - v2) * 100) < security.changeTolerance * v1, which compares a percentage against an absolute value, not another percentage. The correct formula should be ((v1 - v2) * 100) / v1 < security.changeTolerance."",
      ""Impact"": ""The tolerance check will not work as expected, potentially allowing parameter changes beyond intended limits or blocking valid changes. The system might not enforce security guarantees as intended."",
      ""Location"": ""enforceTolerance and enforceToleranceInt functions""
    },
    {
      ""Issue"": ""Undefined 'configured' Variable"",
      ""Severity"": ""Medium"",
      ""Description"": ""Both enforceTolerance and enforceToleranceInt functions reference a 'configured' variable that isn't defined in the contract, suggesting incomplete implementation or inheritance issues."",
      ""Impact"": ""This could lead to unpredictable behavior when tolerance checks are performed, potentially allowing tolerance bypasses if the variable is not properly initialized or managed elsewhere."",
      ""Location"": ""enforceTolerance and enforceToleranceInt functions""
    },
    {
      ""Issue"": ""Uninitialized Security Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on security parameters that are only set through configureSecurityParameters, but there's no check to ensure these are initialized before being used in enforcement functions."",
      ""Impact"": ""If security parameters aren't set, the tolerance enforcement could behave unpredictably or allow changes that should be restricted, potentially undermining the entire security model."",
      ""Location"": ""enforceTolerance and enforceToleranceInt functions""
    },
    {
      ""Issue"": ""Lack of Access Control on setEnforcement"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setEnforcement function allows any address to set its enforcement status without any restrictions, allowing contracts to opt out of tolerance enforcement intended to protect the system."",
      ""Impact"": ""Malicious actors could disable critical security checks for their contracts, potentially circumventing governance safeguards and undermining the security measures intended by the governance system."",
      ""Location"": ""setEnforcement function""
    },
    {
      ""Issue"": ""Block Timestamp Manipulation Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on block.timestamp for time-based logic, which can be manipulated slightly by miners. This affects the security mechanisms around flash governance timing and unlocking of assets."",
      ""Impact"": ""Miners could manipulate timestamps to potentially bypass timing restrictions in flash governance, affecting the unlock time for governance assets."",
      ""Location"": ""Used throughout the contract, especially in assertGovernanceApproved and withdrawGovernanceAsset""
    },
    {
      ""Issue"": ""Incomplete Emergency Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The assertGovernanceApproved function has an 'emergency' parameter that bypasses epoch timing checks, but there's no validation or documentation on who can trigger emergency governance actions or what constitutes an emergency."",
      ""Impact"": ""The undefined emergency condition could be misused to bypass temporal security controls, potentially allowing more frequent governance changes than intended if the emergency parameter is controllable by unauthorized actors."",
      ""Location"": ""assertGovernanceApproved function""
    },
    {
      ""Issue"": ""Missing Event Emissions for Critical Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like configureFlashGovernance and configureSecurityParameters modify important state variables but don't emit events for off-chain monitoring and transparency."",
      ""Impact"": ""Reduced transparency and auditability of governance actions, making it difficult to track and respond to governance parameter changes off-chain."",
      ""Location"": ""configureFlashGovernance and configureSecurityParameters functions""
    },
    {
      ""Issue"": ""Unused Security Parameter"",
      ""Severity"": ""Low"",
      ""Description"": ""The maxGovernanceChangePerEpoch parameter is defined and set in configureSecurityParameters, but it's never used elsewhere in the contract code."",
      ""Impact"": ""This introduces unnecessary complexity, wastes gas on unused storage variables, and could lead to confusion about the actual security controls in place, particularly regarding limits on governance changes per epoch."",
      ""Location"": ""SecurityParameters struct and configureSecurityParameters function""
    }
  ],
  ""IssueNumber"": 51,
  ""OutputList"": 13
}",363.0121910572052,48032.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**

**Report Description**:  
The `assertGovernanceApproved` function in `FlashGovernanceArbiter` lacks access control, allowing anyone to lock other users' funds if the users have approved the contract to transfer `flashGovernanceConfig.amount` of `flashGovernanceConfig.asset`. An attacker can front-run a user's `approve` transaction and call `assertGovernanceApproved` with the user's address, locking their funds for the `flashGovernanceConfig.unlockTime` period.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the lack of access control on `assertGovernanceApproved`. This is a critical issue that allows unauthorized users to lock funds, but it is not covered in the response list.

---

#### **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**

**Report Description**:  
The `burnFlashGovernanceAsset` function resets a user's `pendingFlashDecision` to the default config, allowing them to withdraw other users' locked assets in future flash governance decisions. This enables attackers to steal funds even after their assets are burned.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in `burnFlashGovernanceAsset`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with unchecked external calls in `burnFlashGovernanceAsset` but misses the critical logic error that allows attackers to steal other users' assets. The response focuses on the burn operation's failure handling but does not address the state reset vulnerability.

---

#### **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**

**Report Description**:  
Users who do not call `withdrawGovernanceAsset` after locking their tokens in a previous proposal will lose their tokens if `assertGovernanceApproved` is called again with the same `target` and `sender`. The new amount overwrites the previous amount, making the tokens unaccounted for and locked in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of token loss due to overwriting `pendingFlashDecision` amounts. This is a significant oversight, as it allows attackers to lock users' tokens permanently.

---

#### **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**

**Report Description**:  
The `unlockTime` in `assertGovernanceApproved` is set incorrectly by adding `block.timestamp` to the existing `unlockTime`. This can cause `unlockTime` to exceed the maximum value, leading to a denial of service in `withdrawGovernanceAsset`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the incorrect calculation of `unlockTime`, which can lead to a denial of service. This is a medium-severity issue that is entirely missed.

---

#### **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**

**Report Description**:  
The `withdrawGovernanceAsset` function is vulnerable to reentrancy, allowing attackers to drain the balance of `flashGovernanceConfig.asset` if the asset implements ERC777 or similar standards.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in `withdrawGovernanceAsset` and explains the risks associated with external calls before state updates. This aligns with Solidity best practices for secure contract interactions.

---

#### **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Report Description**:  
The `burnFlashGovernanceAsset` function overwrites the user's state with `flashGovernanceConfig`, allowing users to withdraw their funds sooner instead of deducting their balance.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in `burnFlashGovernanceAsset`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with unchecked external calls in `burnFlashGovernanceAsset` but misses the critical logic error that allows users to withdraw funds instead of deducting their balance. The response focuses on the burn operation's failure handling but does not address the state reset vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**

**Partially Correct Matches**:

- **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**
- **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Missed Issues from Issue Report**:

- **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**
- **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**
- **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**

---

### **Conclusion**

The response list covers some issues, such as reentrancy and unchecked external calls, but misses critical vulnerabilities like access control flaws, token loss due to overwriting, and incorrect `unlockTime` calculations. Additionally, some responses are partially correct, identifying the issue but missing critical details. Overall, the response list needs improvement in coverage and accuracy to address all reported vulnerabilities effectively.","```
1. Reentrancy Vulnerability
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Reentrancy Vulnerability"".
   - In the ranked list of predictions, ""Reentrancy Vulnerability"" appears at rank 1.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
LimboDAO.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";

// import ""hardhat/console.sol"";

library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}

///@title Limbo DAO
///@author Justin Goro
/**@notice
 *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having
 *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain
 *of influence is confined to the local Dapp - Limbo in this case.
 * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured
 * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.
 * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.
 * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.
 * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,
 * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.
 */
///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.
contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; //check this for creating proposals
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  //rateCrate
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  /**@notice for staking EYE, we simply take the square root of staked amount.
   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.
   */
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; //lateDate

  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    // console.log('onlySuccessfulProposal');
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    //nextProposal();
  }

  ///@notice has a proposal successfully been approved?
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  ///@param limbo address of Limbo
  ///@param flan address of Flan
  ///@param eye address of EYE token
  ///@param proposalFactory authenticates and instantiates valid proposals for voting
  ///@param sushiFactory is the SushiSwap Factory contract
  ///@param uniFactory is the UniSwapV2 Factory contract
  ///@param flashGoverner oversees flash governance cryptoeconomics
  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right
  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking
  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  ///@notice allows Limbo to be governed by a new DAO
  ///@dev functions marked by onlyOwner are governed by MorgothDAO
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  ///@notice optional conversion rate of Fate to Flan
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  ///@notice caller spends their Fate to earn Flan
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.
   *  This is to encourage only lodging of proposals that are likely to succeed.
   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.
   */
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  ///@notice handles proposal voting logic.
  ///@param proposal contract to be voted on
  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      //check if voting has ended
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        //The following if statement checks if the vote is flipped by fate
        fate * currentFate < 0 && //sign different
        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate
      ) {
        //extend voting duration when vote flips decision. Suggestion made by community member
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  ///@notice pushes the decision to execute a successful proposal. For convenience only
  function executeCurrentProposal() public updateCurrentProposal {}

  ///@notice parameterizes the voting
  ///@param requiredFateStake the amount of Fate required to lodge a proposal
  ///@param votingDuration the duration of voting in seconds
  ///@param proposalFactory the address of the proposal factory
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  ///@notice Assets approved for earning Fate
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.
  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question
  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half
  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm
  ///@param asset the asset being staked
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    //verifying that rootEYE value is accurate within precision.
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    //EYE
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      //LP
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, //precision cap
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  /**
   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.
   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset
   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.
   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent
   * loss of EYE.
   *@param asset the asset to burn and can be EYE or EYE based assets
   *@param amount the amount of asset to burn
   */
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  ///@notice grants unlimited Flan minting power to an address.
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  ///@notice call this after initial config is complete.
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.
   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.
   */
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",4664,453,"[H-07] LP pricing formula is vulnerable to flashloan manipulation
 `burnAsset` function of `LimboDAO` 
Submitted by shw
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost.
With the large portion of fate he gets, he has more voting power to influence the system's decisions, or even he can convert his fate to Flan tokens for a direct profit.
  [M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted

LimboDAO.sol (`updateCurrentProposal() `modifier and makeProposal() function)

The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an UpdateMultipleSoulConfigProposal proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the vote function will revert), and the proposal can't be executed - the execute function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.
When trying to call the executeCurrentProposal() function that activates the updateCurrentProposal() modifier, the modifier will check the balance of fate, it will see that it's positive and will call currentProposalState.proposal.orchestrateExecute() to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with voting state).
When trying to call makeProposal() function to make a new proposal it will revert because the current proposal is not equal to address(0).
",2,,"pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";



library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}





contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; 
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; 

  
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; 

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    
  }

  
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  
  
  
  
  
  
  
  
  
  
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; 
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  
  
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  
  
  
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), 
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        
        fate * currentFate < 0 && 
        (fate + currentFate) * fate > 0 
      ) {
        
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  
  function executeCurrentProposal() public updateCurrentProposal {}

  
  
  
  
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  
  
  
  
  
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, 
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",3290,1,1,"Based on the comprehensive analysis of the LimboDAO contract, I'll create a detailed audit task list focusing on the most critical areas:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the integrity of onlyOwner and onlySuccessfulProposal modifiers"",
        ""Audit the killDAO function for potential centralization risks"",
        ""Analyze the ownership transfer mechanisms in transferOwnershipOfThing"",
        ""Confirm that makeLive function has adequate access controls""
      ]
    },
    {
      ""Area"": ""Governance Mechanism Security"",
      ""Tasks"": [
        ""Investigate potential exploits in the vote extension mechanism"",
        ""Analyze the vote counting logic for potential manipulation"",
        ""Review the proposal creation and execution flow for vulnerabilities"",
        ""Verify the stake requirements for proposal creation prevent spam"",
        ""Audit the successfulProposal function for potential bypass attempts""
      ]
    },
    {
      ""Area"": ""Token Economics & Fate Calculations"",
      ""Tasks"": [
        ""Verify the FATE generation calculations for mathematical precision"",
        ""Audit the setEYEBasedAssetStake function for potential rounding exploits"",
        ""Review the burnAsset mechanism for token generation fairness"",
        ""Analyze the conversion logic in convertFateToFlan"",
        ""Check the fateGrowthStrategy implementations for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""External Interactions & Reentrancy"",
      ""Tasks"": [
        ""Verify all external contract calls for reentrancy vulnerabilities"",
        ""Audit the TransferHelper library for safe token transfers"",
        ""Review interactions with Flan, Limbo, and other imported contracts"",
        ""Verify the safety of ERC20NetTransfer implementation"",
        ""Check for proper use of checks-effects-interactions pattern""
      ]
    },
    {
      ""Area"": ""Stake and Asset Management"",
      ""Tasks"": [
        ""Analyze the stakedUserAssetWeight mapping for potential manipulation"",
        ""Verify the asset approval mechanism in setApprovedAsset"",
        ""Review the staking invariants in setEYEBasedAssetStake"",
        ""Check the precision calculations for potential overflow/underflow"",
        ""Verify the asset burning mechanism for potential exploit vectors""
      ]
    },
    {
      ""Area"": ""Proposal Lifecycle & Execution"",
      ""Tasks"": [
        ""Audit the updateCurrentProposal modifier for execution logic"",
        ""Verify the proposal state transition mechanisms"",
        ""Review the conditions for proposal approval and rejection"",
        ""Check the time-based proposal mechanisms for potential gaming"",
        ""Analyze the proposal factory interaction for security""
      ]
    },
    {
      ""Area"": ""Emergency & Fallback Mechanisms"",
      ""Tasks"": [
        ""Verify the isLive modifier's effectiveness"",
        ""Review the emergency stop capabilities"",
        ""Audit the makeLive function for potential security holes"",
        ""Check the fallback mechanisms in case of unexpected scenarios""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of complex functions"",
        ""Review the incrementFate mechanism for efficiency"",
        ""Check loop implementations for potential gas risks"",
        ""Verify the use of storage vs memory in function calls""
      ]
    },
    {
      ""Area"": ""Compliance & Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC20 and ERC677 token interaction compliance"",
        ""Check OpenZeppelin contract inheritance implementations"",
        ""Review inheritance and interface implementations"",
        ""Verify event emissions for all critical state changes""
      ]
    }
  ],
  ""AuditPriorities"": [
    ""Governance Mechanism Security"",
    ""Access Control & Ownership"",
    ""External Interactions & Reentrancy"",
    ""Token Economics & Fate Calculations""
  ],
  ""KeyConcerns"": [
    ""Complex voting mechanism with time-based extensions"",
    ""Multiple token interaction and conversion logics"",
    ""Sophisticated FATE generation strategies"",
    ""Potential for governance attacks through proposal mechanisms""
  ]
}

The task list provides a comprehensive approach to auditing the LimboDAO contract, breaking down the analysis into specific, actionable tasks across multiple critical areas. The prioritization ensures that the most significant potential vulnerabilities are addressed first.

The audit should pay special attention to:
1. The unique voting mechanism with time-based extensions
2. The complex FATE generation and token conversion logics
3. Potential centralization risks in governance
4. External contract interactions and transfer mechanisms

Would you like me to elaborate on any specific area or provide more detailed recommendations for the audit approach?","I'll perform a thorough audit of the provided smart contract code.

{
  ""ReviewingTheCode"": ""The contract implements a DAO (Decentralized Autonomous Organization) named LimboDAO that governs the Flan and Limbo tokens. It manages asset approval, proposal voting, and fate growth mechanisms for users. The DAO uses a voting system where users can stake tokens (especially EYE tokens) to gain voting power (FATE) and participate in governance decisions."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LimboDAO"",
    ""Purpose"": ""A governance contract that manages proposals, voting, asset approval, and the relationship between FATE (governance power) and various tokens including EYE, Flan, and Limbo"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""../ERC677/ERC677.sol"",
        ""../Flan.sol"",
        ""./ProposalFactory.sol"",
        ""../facades/SwapFactoryLike.sol"",
        ""../facades/UniPairLike.sol"",
        ""./Governable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""domainConfig"",
        ""Type"": ""DomainConfig struct"",
        ""Purpose"": ""Stores addresses of core contracts like limbo, flan, eye tokens and configuration settings""
      },
      {
        ""Name"": ""proposalConfig"",
        ""Type"": ""ProposalConfig struct"",
        ""Purpose"": ""Stores configuration for proposals including voting duration, required stake, and factory address""
      },
      {
        ""Name"": ""currentProposalState"",
        ""Type"": ""ProposalState struct"",
        ""Purpose"": ""Stores the state of the current proposal being voted on""
      },
      {
        ""Name"": ""previousProposalState"",
        ""Type"": ""ProposalState struct"",
        ""Purpose"": ""Stores the state of the previous proposal""
      },
      {
        ""Name"": ""fateGrowthStrategy"",
        ""Type"": ""mapping(address => FateGrowthStrategy)"",
        ""Purpose"": ""Maps assets to their fate growth strategy""
      },
      {
        ""Name"": ""assetApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks which assets are approved for use in the DAO""
      },
      {
        ""Name"": ""fateState"",
        ""Type"": ""mapping(address => FateState)"",
        ""Purpose"": ""Tracks user fate balance, generation rate, and last adjustment time""
      },
      {
        ""Name"": ""stakedUserAssetWeight"",
        ""Type"": ""mapping(address => mapping(address => AssetClout))"",
        ""Purpose"": ""Tracks user's asset stakes and their corresponding fate weights""
      },
      {
        ""Name"": ""fateToFlan"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Conversion rate from FATE to Flan tokens""
      },
      {
        ""Name"": ""precision"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Precision factor for calculations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""isLive"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the DAO is active""
      },
      {
        ""Name"": ""onlySuccessfulProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function calls to only successful proposals""
      },
      {
        ""Name"": ""updateCurrentProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the state of the current proposal, executing it if the voting period has ended""
      },
      {
        ""Name"": ""incrementFate"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the caller's FATE balance before function execution""
      },
      {
        ""Name"": ""seed"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the DAO with core addresses and approved assets"",
        ""Parameters"": [""Multiple addresses and configuration parameters""],
        ""Returns"": []
      },
      {
        ""Name"": ""killDAO"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deactivates the DAO and transfers ownership to a new owner"",
        ""Parameters"": [""newOwner""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the conversion rate from FATE to Flan tokens"",
        ""Parameters"": [""rate""],
        ""Returns"": []
      },
      {
        ""Name"": ""convertFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts FATE to Flan tokens based on the set rate"",
        ""Parameters"": [""fate""],
        ""Returns"": [""flan""]
      },
      {
        ""Name"": ""makeProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates a new proposal and burns stake from proposer"",
        ""Parameters"": [""proposal"", ""proposer""],
        ""Returns"": []
      },
      {
        ""Name"": ""vote"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to vote on the current proposal using their FATE"",
        ""Parameters"": [""proposal"", ""fate""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeCurrentProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Triggers the update of the current proposal state"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setProposalConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates proposal configuration parameters"",
        ""Parameters"": [""votingDuration"", ""requiredFateStake"", ""proposalFactory""],
        ""Returns"": []
      },
      {
        ""Name"": ""setApprovedAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Approves or rejects an asset for use in the DAO"",
        ""Parameters"": [""asset"", ""approved""],
        ""Returns"": []
      },
      {
        ""Name"": ""setEYEBasedAssetStake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Stakes assets and calculates FATE generation based on EYE token equivalence"",
        ""Parameters"": [""finalAssetBalance"", ""finalEYEBalance"", ""rootEYE"", ""asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""burnAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns assets to generate FATE"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveFlanMintingPower"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Grants or revokes Flan minting ability to an address"",
        ""Parameters"": [""minter"", ""enabled""],
        ""Returns"": []
      },
      {
        ""Name"": ""makeLive"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Activates the DAO after ownership verification"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""transferOwnershipOfThing"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers ownership of a contract to a new address"",
        ""Parameters"": [""thing"", ""destination""],
        ""Returns"": []
      },
      {
        ""Name"": ""timeRemainingOnProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns time left for voting on the current proposal"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getFlashGoverner"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the address of the flash governer"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""ERC20 token transfers via TransferHelper library"",
    ""Proposal contract interactions for execution"",
    ""Flan contract for minting new tokens"",
    ""ERC677 for burning tokens"",
    ""Ownable for ownership management"",
    ""UniPairLike for interacting with liquidity pairs"",
    ""Governable for DAO authorization""
  ],
  
  ""SpecialMechanisms"": [
    ""FATE calculation system with different growth strategies based on asset types"",
    ""Proposal voting mechanism with automatic execution after voting period"",
    ""Dynamic voting period extension when close votes are flipped near the end"",
    ""EYE token burning mechanism that generates FATE"",
    ""Asset staking mechanism that generates FATE based on square root of EYE equivalent"",
    ""Stake verification using square root bounds (rootEYE²≤finalEYEBalance<(rootEYE+1)²)""
  ],
  
  ""Questions"": [
    ""How are Proposal contracts created and what's their interface?"",
    ""What's the relationship between FATE, Flan, Limbo, and EYE tokens?"",
    ""How does the vote extension mechanism work in practice - can it be exploited by constant vote flipping?"",
    ""Is there sufficient protection against flash loan attacks in the staking/voting mechanisms?"",
    ""How does the fate growth strategy 'indirectTwoRootEye' calculate fate exactly?"",
    ""What security measures prevent the DAO from being taken over through token manipulation?"",
    ""Could the precision calculations in setEYEBasedAssetStake lead to rounding exploits?"",
    ""Is there a risk in the makeProposal function where the stake is taken before any validation?"",
    ""What happens if the proposalConfig.proposalFactory is compromised?"",
    ""Are there any safeguards preventing a proposal from implementing malicious code once approved?""
  ]
}

After analyzing the LimboDAO contract, I can provide the following additional security observations:

1. The contract implements a complex governance system with multiple token interactions (EYE, Flan, Limbo) and voting mechanics based on FATE.

2. The voting system has interesting mechanisms like the 2-hour extension when a close vote is flipped in the last hour, which helps prevent last-minute vote sniping.

3. There are several critical trust points, particularly around proposal creation and execution, where malicious proposals could potentially cause harm if approved.

4. The FATE generation system uses square root calculations which appear to be designed to prevent large token holders from having disproportionate governance power.

5. The burn mechanism allows users to destroy assets to gain FATE, with different multipliers depending on whether it's direct EYE tokens or LP tokens containing EYE.

6. Several functions require successful proposal approval, forming the heart of the governance system where the community decides on parameter changes.

7. The contract has a ""kill switch"" (killDAO) that allows the owner to deactivate the DAO and transfer governance rights, which is both a security feature and a centralization risk.","I've analyzed the provided input data containing multiple security issue reports for the LimboDAO contract. After consolidating similar issues and organizing them by severity, here's my comprehensive summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect ERC20NetTransfer Implementation"",
      ""Severity"": ""Critical"",
      ""Description"": ""The TransferHelper library's ERC20NetTransfer function has significant flaws when handling negative amounts. It attempts to transfer tokens FROM the contract TO the user by calculating uint256(amount * (-1)), which could potentially overflow for large negative values near INT256_MIN. Additionally, the function doesn't properly handle non-standard ERC20 tokens that return false instead of reverting on failure."",
      ""Impact"": ""This could lead to incorrect token transfers, allowing users to withdraw more tokens than they should be able to or causing transaction failures. In rare edge cases involving large negative values, this will overflow because the absolute value of INT256_MIN is greater than INT256_MAX."",
      ""Location"": ""TransferHelper library, ERC20NetTransfer function""
    },
    {
      ""Issue"": ""Missing Return Value Check for ERC20 operations"",
      ""Severity"": ""Critical"",
      ""Description"": ""Several functions don't check return values from ERC20 operations, including burn() in burnAsset() and increaseMintAllowance() in approveFlanMintingPower(). This allows silent failures of critical operations that could lead to inconsistent state."",
      ""Impact"": ""If the burn operation fails silently, users would receive fate points without actually burning the asset, creating value out of nothing. Similarly, failed allowance increases could lead to a false sense of security and potential minting failures later."",
      ""Location"": ""burnAsset() function, approveFlanMintingPower() function""
    },
    {
      ""Issue"": ""Voting Extension Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The vote() function implements a mechanism to extend voting time by 2 hours if a vote flips the outcome during the last hour. This can be exploited by malicious actors to manipulate the voting timeline by strategically timing and sizing their votes to continuously extend the voting period, potentially indefinitely."",
      ""Impact"": ""An attacker can prevent proposals from ever concluding by strategically casting votes that flip the fate between positive and negative in the final hour, effectively allowing a denial of service attack on the governance mechanism."",
      ""Location"": ""vote() function, specifically the time extension logic""
    },
    {
      ""Issue"": ""Integer Underflow in Fate Balance"",
      ""Severity"": ""High"",
      ""Description"": ""The contract deducts fate balance in multiple functions including makeProposal(), vote(), and convertFateToFlan() without properly checking if the user has sufficient balance first. In the vote() function specifically, the fate balance is only decremented after the vote is cast."",
      ""Impact"": ""Users can cast votes with fake fate points or create proposals without actually having sufficient fate balance, potentially manipulating governance decisions without having the required stake."",
      ""Location"": ""makeProposal() function, vote() function, convertFateToFlan() function""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions make external calls to token contracts (via transferFrom, transfer, etc.) before updating internal state. This pattern is vulnerable to reentrancy attacks if any of those token contracts are malicious or compromised."",
      ""Impact"": ""An attacker could potentially vote multiple times with the same fate balance, manipulate proposal outcomes, drain fate balances, or manipulate governance before state changes take effect."",
      ""Location"": ""vote() function, setEYEBasedAssetStake() function, burnAsset() function""
    },
    {
      ""Issue"": ""Double Fate Stake in makeProposal"",
      ""Severity"": ""High"",
      ""Description"": ""In makeProposal(), the proposer's fate balance is reduced by requiredFateStake * 2, but only requiredFateStake is ever returned upon approval. This means proposers permanently lose half their staked amount even for successful proposals."",
      ""Impact"": ""Proposers lose half of their staked fate points even for successful proposals, discouraging participation in governance."",
      ""Location"": ""makeProposal() function""
    },
    {
      ""Issue"": ""Unlimited Minting Power in approveFlanMintingPower"",
      ""Severity"": ""High"",
      ""Description"": ""The approveFlanMintingPower() function sets the minting allowance to the maximum possible uint256 value (type(uint256).max) when enabling a minter, which is essentially unlimited minting power without any caps or restrictions."",
      ""Impact"": ""If a malicious or compromised address is approved as a minter, they could mint an unlimited amount of Flan tokens, potentially causing extreme inflation and devaluing the token."",
      ""Location"": ""approveFlanMintingPower() function""
    },
    {
      ""Issue"": ""Vote Double-counting Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The contract doesn't track which users have voted on which proposals, allowing users to vote multiple times on the same proposal as long as they have sufficient fate balance."",
      ""Impact"": ""A wealthy user could repeatedly vote on a proposal, magnifying their influence beyond what should be possible with their fate holdings."",
      ""Location"": ""vote() function""
    },
    {
      ""Issue"": ""Lack of Proposal Execution Delay"",
      ""Severity"": ""High"",
      ""Description"": ""The contract executes proposals immediately once the voting period ends, without any timelock or delay period. This prevents stakeholders from preparing for potentially malicious changes or exiting the system if a harmful proposal passes."",
      ""Impact"": ""Malicious proposals can be executed immediately after voting ends, not giving users time to react or exit the system. This could enable governance attacks that drain funds or compromise the system."",
      ""Location"": ""updateCurrentProposal() modifier""
    },
    {
      ""Issue"": ""Improper Access Control in incrementFateFor"",
      ""Severity"": ""Medium"",
      ""Description"": ""The incrementFateFor() function is public and can be called by anyone to increase another user's fate balance. While it appears to be designed for internal use, there's no access control limiting who can call it."",
      ""Impact"": ""Malicious actors could artificially inflate a user's fate balance, potentially giving them unearned governance power. While not directly exploitable for theft, this could be used to manipulate timing mechanics or force state changes at advantageous moments."",
      ""Location"": ""incrementFateFor() function""
    },
    {
      ""Issue"": ""Precision Loss in Mathematical Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calculations in the contract involve division operations that could lead to precision loss, particularly in the setEYEBasedAssetStake function and the burnAsset function where token amounts are calculated. The use of precision factors is inconsistent."",
      ""Impact"": ""Users might receive less fate weight than they should due to rounding errors in calculations, affecting the fairness of the governance system."",
      ""Location"": ""setEYEBasedAssetStake() function, burnAsset() function""
    },
    {
      ""Issue"": ""Unchecked Proposal Execution"",
      ""Severity"": ""Medium"",
      ""Description"": ""When a proposal is approved, orchestrateExecute() is called on the proposal contract without any try/catch mechanism or checking the return value. If this execution fails, it will revert the entire transaction, potentially blocking the DAO from moving to the next proposal."",
      ""Impact"": ""A maliciously crafted proposal that always reverts during execution could permanently block the governance mechanism, requiring external intervention."",
      ""Location"": ""updateCurrentProposal modifier""
    },
    {
      ""Issue"": ""Lack of Zero-Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple critical functions like seed(), setApprovedAsset(), and transferOwnershipOfThing() don't validate against zero addresses, which could lead to permanent loss of control or functionality."",
      ""Impact"": ""Setting critical addresses to zero could permanently break contract functionality or lead to loss of funds."",
      ""Location"": ""seed(), setApprovedAsset(), transferOwnershipOfThing() functions""
    },
    {
      ""Issue"": ""Insufficient Asset Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The validation for approved Sushi and Uni LPs during seed() function uses a simple EYE balance check (>1000) to determine if an LP should be approved. This is a weak validation mechanism that doesn't verify if the LP actually contains the intended token pairs."",
      ""Impact"": ""Could lead to approving invalid LPs as governance assets, potentially allowing manipulation of governance power."",
      ""Location"": ""seed() function""
    },
    {
      ""Issue"": ""No Slippage Protection in burnAsset"",
      ""Severity"": ""Medium"",
      ""Description"": ""The burnAsset function calculates the fate reward based on current eyePerUnit ratio without any slippage protection. This makes it vulnerable to sandwich attacks where attackers can manipulate the eyePerUnit ratio temporarily."",
      ""Impact"": ""Users could receive substantially less fate than expected for their burned assets if the transaction is sandwiched by an attacker."",
      ""Location"": ""burnAsset function""
    },
    {
      ""Issue"": ""Centralization Risk in seed and killDAO Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The seed() function allows the owner to set critical parameters and can only be called once. Similarly, the owner has the ability to kill the DAO through the killDAO function without any governance oversight. This creates a centralization risk where the initial setup and emergency control of the DAO is controlled by a single entity."",
      ""Impact"": ""If the owner account is compromised or acts maliciously, the entire DAO could be set up in a way that benefits certain parties at the expense of others, or the DAO could be killed inappropriately."",
      ""Location"": ""seed() function, killDAO() function""
    },
    {
      ""Issue"": ""Missing Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Several important state-changing functions like setFateToFlan(), convertFateToFlan(), makeLive(), and setProposalConfig() don't emit events, making it difficult to track changes off-chain."",
      ""Impact"": ""Reduced transparency and difficulty monitoring contract state changes, complicating integration with front-ends and other contracts."",
      ""Location"": ""setFateToFlan(), convertFateToFlan(), makeLive(), setProposalConfig() functions""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions lack proper input validation. For example, setProposalConfig() doesn't check if votingDuration is reasonable or if requiredFateStake is non-zero. The setFateToFlan() function does not validate the input rate."",
      ""Impact"": ""Malicious proposals could set extreme values that effectively break the governance mechanism or allow users to mint excessive amounts of Flan tokens."",
      ""Location"": ""setProposalConfig(), setFateToFlan() functions""
    },
    {
      ""Issue"": ""Unbounded Array Loop in seed Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The seed() function loops through arrays of Sushi and Uni LPs without any limit on array size, potentially exceeding block gas limits if too many LPs are provided."",
      ""Impact"": ""Could cause deployment or initialization to fail due to exceeding gas limits."",
      ""Location"": ""seed() function loops""
    }
  ],
  ""IssueNumber"": 70,
  ""OutputList"": 19
}",408.5622458457947,83320.0,32.0,"### **[H-07] LP pricing formula is vulnerable to flashloan manipulation**

**Report Description**:  
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. An attacker can swap a large number of EYE tokens into the underlying pool to artificially inflate the value of LP tokens. This allows the attacker to receive more `fate` tokens than they should, which can be used to gain disproportionate voting power or convert `fate` to `Flan` tokens for direct profit.

**Match in Response List**:  
Matches with the issue titled **""No Slippage Protection in burnAsset""**.

**Validation**:  
**Partially Correct**. The response identifies the vulnerability in the `burnAsset` function related to the lack of slippage protection, which aligns with the issue of flashloan manipulation. However, the response does not explicitly mention the specific risk of flashloan attacks or the broader impact on governance (e.g., gaining disproportionate voting power). While the core issue is addressed, critical details about the exploit mechanism and its governance implications are missing.

---

### **[M-04] The system can get to a ""stuck"" state if a bad proposal is accepted**

**Report Description**:  
The `LimboDAO` contract can enter a ""stuck"" state if a bad proposal (e.g., one that cannot be executed due to insufficient gas or tokens) is accepted. Once accepted, the proposal cannot be executed, and the system cannot register a new proposal because the `makeProposal` function requires the current proposal to be `address(0)`. This effectively halts the governance mechanism, requiring external intervention to resolve.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Proposal Execution""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked proposal execution in the `updateCurrentProposal` modifier. It correctly explains the risk of a proposal reverting during execution, which would block the system from moving to the next proposal. This aligns with the issue description and Solidity best practices for handling proposal execution.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-04] The system can get to a ""stuck"" state if a bad proposal is accepted**

**Partially Correct Matches**:  
- **[H-07] LP pricing formula is vulnerable to flashloan manipulation**

**Missed Issues from Issue Report**:  
- *None*

--- 

The response list effectively covers the core issues raised in the `issue` report, though some details in the flashloan manipulation case are not fully addressed. Overall, the responses align with Solidity security best practices and provide actionable insights for mitigating the identified vulnerabilities.","```
1. Unchecked Proposal Execution
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked Proposal Execution"".
   - In the ranked list of predictions, ""Unchecked Proposal Execution"" appears at rank 13.

2. **Calculate the precision at rank 13 (\( P@13 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 13, \( P@13 = \frac{1}{13} \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = P@13 = \frac{1}{13} \).

**Output**:
```
0.07692307692307693
```"
Limbo.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",7824,631,"[M-10] user won't be able to get his rewards in case of staking with amount = 0

Submitted by CertoraInc, also found by Randyyy
Limbo.sol (stake() function)

If a user has a pending reward and he calls the stake function with amount = 0, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)
That's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward
",1,,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";


enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, 
  perpetual 
}



struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; 
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; 
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; 
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; 
  uint256 initialCrossingBonus; 
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; 
  uint256 crossingMigrationDelay; 
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; 
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}





contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; 
  bool protocolEnabled = true;

  
  CrossingConfig public crossingConfig;

  
  
  mapping(address => mapping(uint256 => Soul)) public souls;

  
  mapping(address => uint256) public latestIndex;

  
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  
  
  
  
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor 
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  
  
  
  
  
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  
  
  
  
  
  
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  
  
  
  
  
  
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  
  
  
  
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; 
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  
  
  
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  
  
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  
  
  
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  
  
  
  
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  
  
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; 
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",3769,0,1,"Based on the comprehensive analysis of the Limbo contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Review all external contract calls for potential reentrancy vulnerabilities"",
        ""Analyze SafeERC20 implementation and verify token transfer safety"",
        ""Check for integer overflow/underflow risks in reward calculations"",
        ""Verify access control mechanisms in critical functions like migrate() and configureSoul()"",
        ""Examine unstakeApproval mapping for potential unauthorized access vulnerabilities""
      ]
    },
    {
      ""Area"": ""Access Control & Governance"",
      ""Tasks"": [
        ""Audit the Governable base contract for comprehensive access control"",
        ""Verify governance proposal mechanisms for configureSoul() and configureCrossingConfig()"",
        ""Analyze the flashGoverner tolerance enforcement for potential manipulation"",
        ""Review onlySoulUpdateProposal and governanceApproved modifiers for completeness"",
        ""Check emergency protocol disable/enable functions for potential abuse""
      ]
    },
    {
      ""Area"": ""Staking & Rewards Mechanism"",
      ""Tasks"": [
        ""Verify reward calculation logic in updateSoul() and getPending() functions"",
        ""Analyze bonus calculation in claimBonus() for potential economic exploits"",
        ""Check state transitions between Soul states for potential edge case vulnerabilities"",
        ""Validate the flanPerSecond and APY targeting mechanism"",
        ""Review cross-index staking and reward debt calculations for accuracy""
      ]
    },
    {
      ""Area"": ""Migration & Token Crossing"",
      ""Tasks"": [
        ""Thoroughly examine the migrate() function for potential token manipulation"",
        ""Analyze the Rectangle of Fairness mechanism for economic security"",
        ""Verify SCX token burning and minting limits during migration"",
        ""Check crossing threshold and state transition conditions"",
        ""Review morgothPower and Angband power execution for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate interactions with all imported facade interfaces"",
        ""Check AMMHelper integration for potential manipulation"",
        ""Verify BehodlerLike and FlanLike contract interactions"",
        ""Analyze cross-contract calls for potential security risks"",
        ""Review token balance management during migration and staking""
      ]
    },
    {
      ""Area"": ""Economic & Tokenomics Risks"",
      ""Tasks"": [
        ""Analyze the Flan token minting mechanism for potential inflation risks"",
        ""Review the crossingBonusDelta calculation for economic fairness"",
        ""Check secondary rewards claiming mechanism in claimSecondaryRewards()"",
        ""Verify the initial crossing bonus and its delta calculation"",
        ""Examine potential economic attack vectors in reward distribution""
      ]
    },
    {
      ""Area"": ""Gas Optimization & Performance"",
      ""Tasks"": [
        ""Review function gas costs, especially in complex functions like migrate()"",
        ""Analyze storage usage and potential optimizations"",
        ""Check loop and iteration efficiency in reward calculations"",
        ""Verify library function implementations for gas efficiency"",
        ""Examine mapping structures for potential gas optimization""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Review all require() statements for comprehensive error checking"",
        ""Analyze potential failure modes in token state transitions"",
        ""Check handling of zero-value stakes and rewards"",
        ""Verify behavior with different token decimal representations"",
        ""Examine potential race conditions in governance and staking functions""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the Limbo contract, covering critical areas of security, functionality, and economic design. Each area includes specific, actionable tasks that target potential vulnerabilities and design considerations identified in the initial code review.

The tasks are prioritized to address:
1. Direct security vulnerabilities
2. Access control and governance risks
3. Complex economic and staking mechanisms
4. External contract interactions
5. Performance and optimization opportunities
6. Error handling and edge case scenarios

Would you like me to elaborate on any specific area or provide more detailed insights into potential audit findings?","I've conducted a thorough audit of the provided smart contract code. Here's my analysis:

{
  ""ReviewingTheCode"": ""The code implements a staking and token migration system called 'Limbo' that manages 'souls' (token configurations) for staking, rewards distribution, and migration of tokens to the Behodler system. It handles different states a token can be in, manages reward calculation, and controls the crossing of tokens from Limbo to Behodler ecosystem."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Limbo"",
    ""Purpose"": ""A governance-controlled contract for staking tokens, distributing Flan rewards, and migrating tokens to the Behodler ecosystem through a process called 'crossing'"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable""],
      ""Imports"": [
        ""OpenZeppelin's Ownable, IERC20, SafeERC20"",
        ""Multiple facade interfaces (LimboDAOLike, Burnable, BehodlerLike, etc.)"",
        ""Libraries: SoulLib, MigrationLib, CrossingLib""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""protocolEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable/disable protocol functions""
      },
      {
        ""Name"": ""crossingConfig"",
        ""Type"": ""CrossingConfig struct"",
        ""Purpose"": ""Configuration for token migration/crossing""
      },
      {
        ""Name"": ""souls"",
        ""Type"": ""mapping(address => mapping(uint256 => Soul))"",
        ""Purpose"": ""Stores soul configurations for each token by index""
      },
      {
        ""Name"": ""latestIndex"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the latest soul index for each token""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => mapping(address => mapping(uint256 => User)))"",
        ""Purpose"": ""Stores user staking information by token, user address, and soul index""
      },
      {
        ""Name"": ""tokenCrossingParameters"",
        ""Type"": ""mapping(address => mapping(uint256 => CrossingParameters))"",
        ""Purpose"": ""Stores crossing configuration parameters for each token by index""
      },
      {
        ""Name"": ""unstakeApproval"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks approval for third parties to unstake on behalf of users""
      },
      {
        ""Name"": ""Flan"",
        ""Type"": ""FlanLike"",
        ""Purpose"": ""Interface to the Flan token contract for minting rewards""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""enabled"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures protocol is enabled before executing functions""
      },
      {
        ""Name"": ""updateSoul"",
        ""Visibility"": ""public/internal"",
        ""Purpose"": ""Updates soul reward state, calculating accumulated rewards"",
        ""Parameters"": [""token address"", ""(internal overload) soul storage reference""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures global crossing settings"",
        ""Parameters"": [""behodler"", ""angband"", ""ammHelper"", ""morgothPower"", ""migrationInvocationReward"", ""crossingMigrationDelay"", ""rectInflationFactor""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates or updates a soul configuration for a token"",
        ""Parameters"": [""token"", ""crossingThreshold"", ""soulType"", ""state"", ""index"", ""fps""],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to stake tokens, updates rewards, and possibly triggers state changes"",
        ""Parameters"": [""token"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake/unstakeFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to withdraw staked tokens and claim rewards"",
        ""Parameters"": [""token"", ""amount"", ""(unstakeFor only) holder""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims accumulated Flan rewards without unstaking"",
        ""Parameters"": [""token"", ""index""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimBonus"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims crossing bonus rewards for tokens that have crossed over"",
        ""Parameters"": [""token"", ""index""],
        ""Returns"": []
      },
      {
        ""Name"": ""migrate"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initiates token migration to Behodler when threshold is met"",
        ""Parameters"": [""token""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimSecondaryRewards"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims secondary rewards for tokens in calibration or crossedOver state"",
        ""Parameters"": [""token""],
        ""Returns"": []
      },
      {
        ""Name"": ""attemptToTargetAPY"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adjusts Flan per second rate to target a specific APY"",
        ""Parameters"": [""token"", ""desiredAPY"", ""daiThreshold""],
        ""Returns"": []
      },
      {
        ""Name"": ""adjustSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adjusts soul parameters with governance approval"",
        ""Parameters"": [""token"", ""initialCrossingBonus"", ""crossingBonusDelta"", ""fps""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets token-specific crossing parameters"",
        ""Parameters"": [""token"", ""initialCrossingBonus"", ""crossingBonusDelta"", ""burnable"", ""crossingThreshold""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 for token transfers"",
    ""FlanLike for minting rewards"",
    ""BehodlerLike for SCX token burning"",
    ""LimboAddTokenToBehodlerPowerLike for token migration"",
    ""AMMHelper for liquidity provision and APY calculations"",
    ""AngbandLike for executing powers"",
    ""FlashGovernanceArbiterLike for enforcing parameter change tolerance""
  ],
  ""SpecialMechanisms"": [
    ""State machine pattern for Soul states (calibration, staking, waitingToCross, crossedOver)"",
    ""Token migration mechanism that burns excess SCX to maintain ecosystem balance"",
    ""Rectangle of Fairness concept that limits SCX minting during migration"",
    ""Flash governance controls with tolerance checking"",
    ""Delegated unstaking system allowing approved third parties to unstake on behalf of users"",
    ""Dynamic reward rate calculation based on time and amount staked""
  ],
  ""Questions"": [
    ""What is the specific purpose of the 'Rectangle of Fairness' and how is the inflation factor intended to be used?"",
    ""How does the crossingBonusDelta affect the final bonus calculation over time?"",
    ""What security measures prevent a malicious token from exploiting the migration process?"",
    ""What happens to user funds if a soul transitions from staking to calibration state?"",
    ""How is the 'morgothPower' expected to parameterize the token during migration?"",
    ""What prevents a flash loan attack during migration to manipulate the crossing threshold?""
  ]
}

The Limbo contract is a sophisticated staking and migration system with governance-controlled parameters. It follows a state machine pattern for tokens, allowing them to move through different stages from calibration to crossing over to the Behodler ecosystem. The contract handles reward distribution in Flan tokens based on staking duration and amount, with additional bonuses available when tokens cross over.

Key security considerations include the governance controls, parameter tolerance enforcement through a flash governance arbiter, and the careful management of token state transitions. The migration mechanism includes safeguards like the ""Rectangle of Fairness"" concept that regulates how much SCX is minted during migration.

The code uses multiple mappings to track user stakes, token configurations, and approval delegations, creating a flexible but complex system that requires careful governance oversight to maintain security and proper functionality.","I've analyzed the provided issues and consolidated similar ones based on their descriptions and targeted functionality. Here's the structured output:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in unstake Function"",
      ""Severity"": ""High"",
      ""Description"": ""The _unstake function transfers tokens before updating state variables, following the pattern of external calls before state changes. While SafeERC20 is used, this can still create a potential reentrancy attack vector if the token has a hook that calls back into the contract. An attacker could potentially re-enter the contract between the token transfer and state update."",
      ""Impact"": ""An attacker could potentially drain more tokens than they originally staked, recursively call unstake before the state is updated, claim rewards multiple times for the same stake, or manipulate the contract state for malicious purposes."",
      ""Location"": ""_unstake function, where IERC20(token).safeTransfer(address(unstaker), amount) occurs before modifying user.stakedAmount""
    },
    {
      ""Issue"": ""Reentrancy Risk in stake Function"",
      ""Severity"": ""High"",
      ""Description"": ""The stake function follows a pattern where it updates state after external calls (Flan.mint and token transfers), potentially exposing it to reentrancy attacks. While SafeERC20 is used for transfers, the mint function call occurs before updating the user's state."",
      ""Impact"": ""An attacker could reenter the stake function through a malicious token or callback mechanism, potentially draining funds, manipulating reward calculations, or abusing the state update sequence."",
      ""Location"": ""stake function, where external calls are made before updating user.stakedAmount""
    },
    {
      ""Issue"": ""Missing Input Validation in unstakeFor Function"",
      ""Severity"": ""High"",
      ""Description"": ""The unstakeFor function decrements the approval amount but doesn't validate if the caller has sufficient approval before making the call. The function doesn't verify that the caller has sufficient unstake approval before attempting to deduct it, which could lead to an underflow in the unstakeApproval mapping."",
      ""Impact"": ""An attacker could call unstakeFor with an amount greater than their approved amount, causing an arithmetic underflow in the unstakeApproval mapping. This could result in the attacker gaining a very large approval amount, effectively allowing them to unstake all of a user's tokens or bypass approval restrictions."",
      ""Location"": ""unstakeFor function and _unstake internal function where unstakeApproval[token][holder][unstaker] -= amount is performed without sufficient checks""
    },
    {
      ""Issue"": ""Lack of Slippage Protection in Migration"",
      ""Severity"": ""High"",
      ""Description"": ""The migrate function in MigrationLib transfers tokens to morgothPower without any slippage protection or minimum output validation. This could enable sandwich attacks during the token listing process where malicious actors manipulate the price before and after the migration transaction."",
      ""Impact"": ""Users could receive significantly less tokens (SCX) than expected due to front-running attacks, effectively stealing value from the protocol and its users during migration or manipulation of the migration process for malicious purposes."",
      ""Location"": ""MigrationLib.migrate function and related implementation""
    },
    {
      ""Issue"": ""Flash Governance Attack Risk"",
      ""Severity"": ""High"",
      ""Description"": ""The governance approval system relies on a flashGoverner for tolerance checks, but the exact implementation is not visible. If this system allows rapid governance changes, it could be susceptible to flash governance attacks. The contract has significant governance controls through functions marked with modifiers like onlySuccessfulProposal and governanceApproved."",
      ""Impact"": ""An attacker could potentially gain control of governance functions temporarily, make malicious changes, and then revert to normal governance. Compromised governance could change critical parameters, disable the protocol, or manipulate token economics."",
      ""Location"": ""All functions with governanceApproved modifier and onlySuccessfulProposal modifier""
    },
    {
      ""Issue"": ""Parameter Validation Vulnerability in updateSoul"",
      ""Severity"": ""High"",
      ""Description"": ""The updateSoul function doesn't validate that finalTimeStamp > soul.lastRewardTimestamp before calculating rewards. If the stakingEndsTimestamp is set to a value lower than the lastRewardTimestamp, it can cause an arithmetic underflow in uint256 subtraction. The function is also public without access control, allowing anyone to update soul parameters."",
      ""Impact"": ""Could lead to large erroneous rewards being minted, potentially allowing an attacker to drain the system of tokens when calling stake/unstake functions that update the soul. Malicious actors could disrupt reward distribution by frequently calling this function."",
      ""Location"": ""updateSoul function, specifically the calculation: uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;""
    },
    {
      ""Issue"": ""Improper Validation in approveUnstake function"",
      ""Severity"": ""High"",
      ""Description"": ""The approveUnstake function allows a user to give permission to another address to unstake tokens on their behalf. However, it simply overwrites any existing approval without checks, which could lead to accidental or malicious overwriting of previous approvals. There's also no event emission when approvals change."",
      ""Impact"": ""Malicious actors could trick users into overwriting existing approvals. Users may also lose track of who has approval to unstake their tokens due to lack of events."",
      ""Location"": ""approveUnstake function""
    },
    {
      ""Issue"": ""Arithmetic Error in Bonus Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""The claimBonus function contains a problematic check: 'require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \""E6\"");' and may be susceptible to integer overflow. The bonus calculation performs multiplication before division, which could lead to integer overflow. The calculation in 'int256(user.stakedAmount) * finalFlanPerTeraToken' could exceed maximum integer size if both values are sufficiently large."",
      ""Impact"": ""Users could be incorrectly denied their bonuses or receive incorrect bonus amounts. Users might receive incorrect bonus amounts, potentially draining the system of more rewards than intended or causing the transaction to revert."",
      ""Location"": ""claimBonus function, calculation of flanBonus: uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA""
    },
    {
      ""Issue"": ""Integer Overflow in CrossingLib.set Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The CrossingLib.set function compares signed and unsigned integers without proper safeguards. When crossingBonusDelta is negative, converting it to a positive value for tolerance checks could lead to integer overflow despite built-in protection, due to the absolute value conversion logic. The function doesn't properly check for integer overflow when dealing with signed integers."",
      ""Impact"": ""Potential manipulation of crossing parameters, allowing malicious governance to set unauthorized values or calculation errors in crossing bonus values."",
      ""Location"": ""CrossingLib.set function""
    },
    {
      ""Issue"": ""Missing Input Validation in configureSoul and Other Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The configureSoul function accepts arbitrary values for soulType and state parameters without validating they are within the valid range for their respective enums. Similarly, functions like configureCrossingParameters and adjustSoul don't validate if the token address is valid or has been previously initialized. The configureSoul function doesn't validate the state transitions are valid."",
      ""Impact"": ""Could set invalid states that cause unexpected behavior in other functions that rely on the soul's state, potentially leading to broken contract invariants. Invalid token addresses could corrupt state or lead to unpredictable contract behavior."",
      ""Location"": ""configureSoul, adjustSoul, and configureCrossingParameters functions""
    },
    {
      ""Issue"": ""Flash Loan Attack Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The stake function may be susceptible to flash loan attacks because it updates the reward calculation based on the current balance after depositing tokens. An attacker could temporarily stake a large amount to manipulate the accumulatedFlanPerShare value. The contract's threshold-based mechanisms could be exploited using flash loans to temporarily push token balances over thresholds."",
      ""Impact"": ""Manipulation of reward distribution, potentially draining rewards unfairly. An attacker could manipulate the contract state by temporarily exceeding thresholds, potentially gaining undue rewards or affecting the migration process."",
      ""Location"": ""stake function where updateSoul is called and reward accrual is calculated""
    },
    {
      ""Issue"": ""Potential Deadlock After Token Migration"",
      ""Severity"": ""Medium"",
      ""Description"": ""After a token migrates successfully, all staked tokens are transferred to the morgothPower contract. However, there's no clear mechanism for existing stakers to recover their proportion of the value after migration. The migrate function might also fail due to the hardcoded requirement that the token must be migrated only after crossingMigrationDelay has passed."",
      ""Impact"": ""Users who staked tokens might lose access to their value if the system doesn't provide a mechanism to claim the migrated value. Token migration could be permanently blocked, locking user funds in the contract."",
      ""Location"": ""migrate function and MigrationLib.migrate function""
    },
    {
      ""Issue"": ""Unchecked Token Transfer Results"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the MigrationLib.migrate function, token transfers are performed without checking their success. Some tokens (like USDT) don't revert on failure but return a boolean that needs to be checked. Several token transfer operations don't check return values, assuming they always succeed."",
      ""Impact"": ""Failed transfers might not revert, leading to inconsistent state and incorrect balances. Failed token transfers might not be detected, potentially leading to broken migration processes and lost funds."",
      ""Location"": ""MigrationLib.migrate function and multiple other functions including token transfers""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes do not emit events, making it difficult to track changes off-chain. For example, configureCrossingConfig, configureCrossingParameters, disableProtocol, enableProtocol, and approveUnstake don't emit events. This reduces transparency and makes it difficult for users and interfaces to track state changes in the contract."",
      ""Impact"": ""Reduced transparency and difficulty in tracking important contract state changes. Lack of transparency and ability to monitor contract state changes off-chain."",
      ""Location"": ""configureCrossingConfig, configureCrossingParameters, disableProtocol, enableProtocol, approveUnstake functions""
    },
    {
      ""Issue"": ""No Check for Address Zero"",
      ""Severity"": ""Low"",
      ""Description"": ""Many functions like configureCrossingConfig, configureSoul, and configureCrossingParameters don't verify that provided addresses are not the zero address (0x0). Using zero addresses for critical components like 'flan', 'limboDAO', 'behodler', 'angband', 'ammHelper', or 'morgothPower' could lead to system failure."",
      ""Impact"": ""Configuration with zero addresses could cause functions to fail or behave unexpectedly when those addresses are later used. If zero addresses are passed, the contract may become unusable or funds may be lost permanently."",
      ""Location"": ""configureCrossingConfig, configureSoul, configureCrossingParameters functions and constructor""
    },
    {
      ""Issue"": ""Floating Pragma"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a fixed pragma version (0.8.4) which is good practice, but should be evaluated for known bugs in this specific compiler version."",
      ""Impact"": ""If there are known vulnerabilities in Solidity 0.8.4, the contract could be susceptible to those issues."",
      ""Location"": ""Contract header (pragma statement)""
    },
    {
      ""Issue"": ""Unbounded Loop Risk"",
      ""Severity"": ""Low"",
      ""Description"": ""If the latestIndex mapping grows too large for certain tokens, functions that operate on entire ranges of souls might consume excessive gas or exceed block gas limits. This could impact functions like migrate which might hit block gas limits if the token balance is very large or if the execution involves many operations."",
      ""Impact"": ""Functions might become unusable due to gas limitations if too many indices are created for a token. If the migration process requires too much gas, the transaction could fail, potentially locking tokens in the contract."",
      ""Location"": ""Functions that iterate over token indices and MigrationLib.migrate function""
    }
  ],
  ""IssueNumber"": 80,
  ""OutputList"": 16
}",409.4839017391205,88345.0,32.0,"### **[M-10] User Won't Be Able to Get His Rewards in Case of Staking with Amount = 0**

**Report Description**:  
In the `stake()` function of `Limbo.sol`, if a user has a pending reward and calls the `stake` function with `amount = 0`, they won't be able to claim their reward. This occurs because the reward calculation is only performed if the staked amount (provided as a parameter) is greater than 0. However, the reward debt is updated even if the amount is 0, effectively overwriting the pending reward without allowing the user to claim it. This behavior could lead to users losing their rightful rewards, especially if they attempt to stake with `amount = 0` to trigger reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The provided `response_list` does not address this specific issue. While the list covers various vulnerabilities such as reentrancy risks, arithmetic errors, and input validation issues, it does not mention the problem of reward calculation being skipped when `amount = 0` in the `stake()` function. This is a distinct issue that could lead to users losing their rewards, and it is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-10] User Won't Be Able to Get His Rewards in Case of Staking with Amount = 0**

---

### **Conclusion**  
The `response_list` does not address the specific issue of reward calculation being skipped when `amount = 0` in the `stake()` function. This is a significant oversight, as it could lead to users losing their rightful rewards. The response list should be updated to include this vulnerability and provide a solution, such as ensuring that reward calculations are performed regardless of the staked amount.","```
None.
```",0.0
UniswapHelper.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";
// import ""hardhat/console.sol"";
import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}

///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM
///@author Justin Goro
/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.
  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle
 */
contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; // behodler uses a binary search. The higher this number, the more precise
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. 
  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker
  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.
  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,
  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle
  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.
  */
  FlanQuote[2] public latestFlanQuotes; //0 is latest

  UniVARS VARS;

  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.
  uint256 constant EXA = 1e18;

  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.
  uint256 constant year = (1 days * 365);

  /*
    instead of relying on oracles, we simply require snapshots of important 
    prices to be taken at intervals far enough apart.
    If an attacker wishes to overstate or understate a price through market manipulation,
    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd
    have to time the manipulation to happen as the snapshots occur. As a miner,
    they could do this through transaction ordering but they'd have to win two blocks at precise moments
    which is statistically highly unlikely. 
    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost
    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,
    this is a cost worth bearing.
    */
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  ///@notice LP tokens minted during migration are discarded.
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  ///@notice Uniswap factory contract
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  ///@dev Only for testing: On mainnet Dai has a fixed address.
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  ///@notice main configuration function.
  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.
  ///@param _limbo Limbo contract
  ///@param FlanSCXPair The Uniswap flan/SCX pair
  ///@param behodler Behodler AMM
  ///@param flan The flan token
  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted 
  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration
  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.
  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally ""overshooting"" the price
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai
  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations
  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.
    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    //get DAI per scx
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.
    _zeroOutQuotes();
  }

  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic
  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold
  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler
  function minAPY_to_FPS(
    uint256 minAPY, //divide by 10000 to get percentage
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    // console.log(""DAI threshold %s"", daiThreshold);
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.
  ///@param inputToken The token used to buy Flan
  ///@param amount amount of input token used to buy Flan
  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly
  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; //save gas
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    // console.log(""dai balance divergence %s"", daiBalanceDivergence);
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",3665,289,"[M-07] Calling generateFLNQuote twice in every block prevents any migration

Submitted by camden, also found by GeekyLumberjack, kirk-baird, and shw
https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, generateFLNQuote is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a blockProduced value of the current block's number.
These quotes are used in the _ensurePriceStability function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285
   [M-11] You can grief migrations by sending SCX to the UniswapHelper

Submitted by camden, also found by robee
The attack here allows the attacker to prevent migrations.
The attack here is recoverable because we can just call buyFlanAndBurn (f it worked as expected) with SCX as the input token to buy Flan with the extra SCX, then run the migration again.
   [M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks

Submitted by hyh
Trades can happen at a manipulated price and end up receiving fewer Flan to be bought than current market price dictates.
For example, at the time a user decides to call buyFlanAndBurn Flan trades at 0.8 in the input token terms at the corresponding DEX pool. If the input token holdings are big enough to compensate for pool manipulation costs, the following can happen: Flan buy order will be seen by a malicious bot, that buys Flan, pushing it to 0.9 before UniswapHelper's order comes through, and selling it back right afterwards. This way, given a cumulative impact of the trades on Flan's market price, the input token will be overspent.
This yields direct loss for the system as input token market operations have lesser effect than expected at the expense of contract holdings.

",3,,"pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";

import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}




contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; 
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; 
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  
  FlanQuote[2] public latestFlanQuotes; 

  UniVARS VARS;

  
  uint256 constant EXA = 1e18;

  
  uint256 constant year = (1 days * 365);

  
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  
  
  
  
  
  
  
  
  
  
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  
  
  
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    
    
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    
    _zeroOutQuotes();
  }

  
  
  
  function minAPY_to_FPS(
    uint256 minAPY, 
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  
  
  
  
  
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; 
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",2373,0,3,"Based on the comprehensive analysis, here's the detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in external contract calls (BehodlerLike, UniPairLike)"",
        ""Check for integer overflow/underflow risks in mathematical operations, especially in getAmountOut and getAmountIn functions"",
        ""Validate input validation and sanitization across all external and public functions"",
        ""Review transfer and mint operations for potential unauthorized token generation""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Thoroughly analyze the onlyLimbo and onlySuccessfulProposal modifiers for comprehensive access restrictions"",
        ""Verify governance mechanisms in the Governable inheritance"",
        ""Check potential centralization risks in configuration and admin functions"",
        ""Validate the scope and limitations of the configure() function""
      ]
    },
    {
      ""Area"": ""External Interactions & Oracle Integrity"",
      ""Tasks"": [
        ""Verify price quote generation mechanism for manipulation resistance"",
        ""Analyze the _ensurePriceStability() method for potential pricing attack vectors"",
        ""Review Behodler and Uniswap interaction logic for potential flash loan vulnerabilities"",
        ""Check divergence tolerance calculations for potential exploit paths""
      ]
    },
    {
      ""Area"": ""Liquidity Pool & AMM Risks"",
      ""Tasks"": [
        ""Analyze stabilizeFlan() method for potential price manipulation"",
        ""Review LP token minting and burning mechanisms"",
        ""Validate the BlackHole contract's role in LP token management"",
        ""Check Flan token minting logic during liquidity operations""
      ]
    },
    {
      ""Area"": ""Token Economics & Burning Mechanism"",
      ""Tasks"": [
        ""Verify buyFlanAndBurn() function for correct token burning proportions"",
        ""Analyze reward calculation in token burning process"",
        ""Check potential economic attack vectors in burning mechanism"",
        ""Review token supply control and inflationary risks""
      ]
    },
    {
      ""Area"": ""Configuration & Initialization"",
      ""Tasks"": [
        ""Fix precision assignment logic in configure() method"",
        ""Review hardcoded address handling for mainnet vs other networks"",
        ""Validate input validation in configuration functions"",
        ""Check potential risks in dynamic address configuration""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Review computational complexity of price stability checks"",
        ""Analyze memory vs storage usage in quote management"",
        ""Check potential gas optimization opportunities in mathematical operations"",
        ""Validate efficiency of external contract interactions""
      ]
    },
    {
      ""Area"": ""Error Handling & Emergency Mechanisms"",
      ""Tasks"": [
        ""Replace cryptic error codes with descriptive error messages"",
        ""Verify error handling in critical financial operations"",
        ""Check emergency stop or circuit breaker mechanisms"",
        ""Review potential failure modes in external contract interactions""
      ]
    }
  ]
}

Key Observations and Recommendations:

1. The task list comprehensively covers potential vulnerabilities across multiple dimensions.
2. Special attention is given to the unique mechanisms like BlackHole, price stability checks, and token burning.
3. The list prioritizes security, economic integrity, and operational reliability.
4. Each task is designed to probe specific potential weaknesses identified in the initial analysis.

Recommended Next Steps:
- Conduct a detailed line-by-line code review
- Perform static analysis using tools like Slither
- Consider formal verification of complex mathematical operations
- Implement comprehensive test cases covering edge scenarios

The audit tasks provide a structured approach to thoroughly examining the UniswapHelper contract's security, functionality, and economic design.","After carefully reviewing the code, here's my audit:

{
  ""ReviewingTheCode"": ""This is a contract that integrates with Uniswap and appears to be part of a larger system involving tokens called Flan and SCX. The contract mainly handles price stabilization mechanisms, liquidity provision, and token burning operations."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""UniswapHelper"",
    ""Purpose"": ""Facilitates interactions between Limbo, Behodler, and Uniswap, focusing on price stabilization for Flan token, liquidity provision, and token burning operations."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable"", ""AMMHelper""],
      ""Imports"": [
        ""UniPairLike.sol"",
        ""BehodlerLike.sol"",
        ""Governable.sol"",
        ""ERC20Burnable.sol"",
        ""FlanLike.sol"",
        ""IUniswapV2Factory.sol"",
        ""AMMHelper.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""limbo"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Limbo contract""
      },
      {
        ""Name"": ""VARS"",
        ""Type"": ""UniVARS struct"",
        ""Purpose"": ""Stores configuration variables for the contract""
      },
      {
        ""Name"": ""latestFlanQuotes"",
        ""Type"": ""FlanQuote[2]"",
        ""Purpose"": ""Stores the two most recent Flan price quotes for price stability verification""
      },
      {
        ""Name"": ""EXA"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Decimal precision constant (10^18)""
      },
      {
        ""Name"": ""year"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Number of seconds in a year for APY calculations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""ensurePriceStability"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures price stability by checking price divergence between quotes""
      },
      {
        ""Name"": ""onlyLimbo"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to only the Limbo contract""
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with limbo address, creates a BlackHole contract, and sets hardcoded addresses"",
        ""Parameters"": [""_limbo: address"", ""limboDAO: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""blackHole"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the BlackHole contract"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""setFactory"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the Uniswap factory address (only for non-mainnet)"",
        ""Parameters"": [""factory: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDAI"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the DAI token address (only for non-mainnet)"",
        ""Parameters"": [""dai: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""configure"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures multiple contract parameters at once"",
        ""Parameters"": [""_limbo: address"", ""FlanSCXPair: address"", ""behodler: address"", ""flan: address"", ""divergenceTolerance: uint256"", ""minQuoteWaitDuration: uint256"", ""precision: uint8"", ""priceBoostOvershoot: uint8""],
        ""Returns"": []
      },
      {
        ""Name"": ""generateFLNQuote"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the price quotes array with latest price data"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getLatestFLNQuote"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates current price of SCX in terms of DAI"",
        ""Parameters"": [],
        ""Returns"": [""dai_scx: uint256"", ""daiBalanceOnBehodler: uint256""]
      },
      {
        ""Name"": ""stabilizeFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to maintain Flan's price stability"",
        ""Parameters"": [""rectangleOfFairness: uint256""],
        ""Returns"": [""lpMinted: uint256""]
      },
      {
        ""Name"": ""minAPY_to_FPS"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Converts minimum APY to required Flan Per Second rate"",
        ""Parameters"": [""minAPY: uint256"", ""daiThreshold: uint256""],
        ""Returns"": [""fps: uint256""]
      },
      {
        ""Name"": ""buyFlanAndBurn"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Swaps input tokens for Flan, rewards caller, and burns remaining Flan"",
        ""Parameters"": [""inputToken: address"", ""amount: uint256"", ""recipient: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountOut"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates output amount for a swap based on Uniswap formula"",
        ""Parameters"": [""amountIn: uint256"", ""reserveIn: uint256"", ""reserveOut: uint256""],
        ""Returns"": [""amountOut: uint256""]
      },
      {
        ""Name"": ""getAmountIn"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates input amount needed for a desired output based on Uniswap formula"",
        ""Parameters"": [""amountOut: uint256"", ""reserveIn: uint256"", ""reserveOut: uint256""],
        ""Returns"": [""amountIn: uint256""]
      },
      {
        ""Name"": ""_zeroOutQuotes"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Resets the stored price quotes"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_ensurePriceStability"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Verifies price stability by checking divergence between quotes"",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Interacts with Behodler contract to get SCX price information"",
    ""Interacts with Uniswap V2 Factory and pairs"",
    ""Interacts with Flan token for minting operations"",
    ""Interacts with ERC20 tokens for transfers and balance checks"",
    ""Interacts with BlackHole contract as a recipient for LP tokens""
  ],
  ""SpecialMechanisms"": [
    ""BlackHole pattern - a contract created to permanently hold LP tokens"",
    ""Price stability checking mechanism using sequential quotes"",
    ""LP token creation and management for Flan-SCX pair"",
    ""Token burning mechanism that rewards callers with a small percentage""
  ],
  ""Questions"": [
    ""What is the relationship between Limbo, Behodler, and this contract?"",
    ""Why is the BlackHole contract used instead of burning LP tokens directly?"",
    ""In stabilizeFlan(), the require check for rectangleOfFairness seems to always set it to localSCXBalance regardless of input. What's the purpose?"",
    ""The precision check in configure() has a logical issue: 'precision = precision == 0 ? precision : precision' which doesn't change the value"",
    ""Is there a potential risk in the hardcoded mainnet addresses for non-mainnet environments?"",
    ""The function minAPY_to_FPS() references 'Flan Per Second' but doesn't seem connected to any actual emission mechanism"",
    ""Why does the contract need a two-quote system with waiting period for price stabilization instead of checking current market conditions?""
  ]
}

Based on my analysis, there are also several potential issues worth noting:

1. The precision assignment in configure() has a logical error: `VARS.precision = precision == 0 ? precision : precision` doesn't actually change anything.

2. There's an unusual check in stabilizeFlan(): `require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");` followed by immediately overriding the input parameter with `rectangleOfFairness = localSCXBalance`.

3. The contract has hardcoded addresses for mainnet (Uniswap factory, DAI) but allows them to be changed on other networks, which could create inconsistencies in behavior across environments.

4. The contract creates a BlackHole instance but doesn't have any mechanisms to replace it if needed.

5. The error messages use short codes (""EM"", ""EG"", ""EH"") which might make debugging difficult.

These issues should be addressed to improve the contract's maintainability and correctness.","I'll process the lists of issues to identify and consolidate similar vulnerabilities, ordered by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Arithmetic Error in rectangleOfFairness Validation"",
      ""Severity"": ""Critical"",
      ""Description"": ""The stabilizeFlan function contains a critically flawed require statement: `require((localSCXBalance * 100) / rectangleOfFairness == 98, 'EM')`. This check attempts to enforce that localSCXBalance is 98% of rectangleOfFairness. However, immediately after this check, the code overwrites rectangleOfFairness with localSCXBalance, making the validation completely ineffective. Additionally, due to integer division rounding, this check can be easily manipulated by carefully selecting input values."",
      ""Impact"": ""This vulnerability allows attackers to bypass a critical security check meant to ensure the correct relationship between parameters. The validation can be manipulated to allow arbitrary values, potentially enabling economic attacks on the protocol's pricing mechanism or draining funds from the system."",
      ""Location"": ""stabilizeFlan() function""
    },
    {
      ""Issue"": ""Reentrancy Risk in External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The stabilizeFlan function makes external calls to IERC20 transfer and Uniswap mint functions without following the checks-effects-interactions pattern. The contract transfers SCX to the pair and then calls mint without updating internal state first. Additionally, the function doesn't check return values from these external calls, which is especially problematic for tokens that don't revert on failure but return a boolean."",
      ""Impact"": ""This could allow a malicious contract to reenter and potentially drain funds if any of the tokens or Uniswap pair implementations have reentrancy vulnerabilities. Failed transfers might not revert the transaction, leading to loss of funds or incorrect state updates."",
      ""Location"": ""stabilizeFlan function - IERC20 transfer calls and LP token minting""
    },
    {
      ""Issue"": ""Inadequate Price Oracle Security"",
      ""Severity"": ""High"",
      ""Description"": ""The _ensurePriceStability function relies on just two price quotes to determine price stability, and the generateFLNQuote function is public with no access control. The block number comparison logic is also flawed, as it assumes quotes are generated in a specific order. Additionally, the waiting period is determined by block numbers, which can be unreliable across different networks with varying block times."",
      ""Impact"": ""An attacker can manipulate the price feeds to pass the price stability check by calling generateFLNQuote at strategic times. This could allow exploitation of the stabilizeFlan function for profit, particularly through flash loan attacks or other market manipulation techniques."",
      ""Location"": ""_ensurePriceStability function and its relationship with generateFLNQuote()""
    },
    {
      ""Issue"": ""LP Token Accounting Issues"",
      ""Severity"": ""High"",
      ""Description"": ""In stabilizeFlan(), LP tokens are minted to a blackHole address, permanently removing them from circulation. While this may be intentional, it means that liquidity added to the pair cannot be reclaimed. Additionally, there are questionable calculations for determining the amount of Flan to mint when adding liquidity, especially in the else branch where minFlan is calculated by dividing existingFlanOnLP by total supply and arbitrarily adding 2."",
      ""Impact"": ""Permanent loss of liquidity control and value that could otherwise be reused or managed. Continuous burning of LP tokens can lead to price manipulation vulnerabilities as the remaining LP tokens gain more control over the pool's price discovery mechanism. The arbitrary minFlan calculation might lead to economically unfair LP token minting."",
      ""Location"": ""stabilizeFlan function minting to VARS.blackHole""
    },
    {
      ""Issue"": ""Potential Price Manipulation in stabilizeFlan"",
      ""Severity"": ""High"",
      ""Description"": ""The stabilizeFlan function adds liquidity to a Uniswap pair in a way that explicitly allows manipulating the price by using priceBoostOvershoot. When adding liquidity, if existingFlanOnLP < DesiredFinalFlanOnLP, the function mints a reduced amount of FLN tokens by subtracting the priceBoostOvershoot percentage. However, when existingFlanOnLP >= DesiredFinalFlanOnLP, it mints only a minimal amount of Flan."",
      ""Impact"": ""Artificially boosting prices can create arbitrage opportunities that hurt long-term holders and destabilize the system. This inconsistency can lead to price manipulation opportunities or inefficient use of funds when adding liquidity, potentially causing losses to the protocol."",
      ""Location"": ""stabilizeFlan function (lines 166-180)""
    },
    {
      ""Issue"": ""No Slippage Protection in buyFlanAndBurn"",
      ""Severity"": ""Medium"",
      ""Description"": ""The buyFlanAndBurn function calculates the expected output amount but doesn't include any slippage protection or validate return values from token operations. This creates vulnerability to sandwich attacks, front-running, and failed transactions that don't revert."",
      ""Impact"": ""Users could receive significantly fewer tokens than expected due to market manipulation, leading to financial loss. Front-running attacks could extract value from users calling this function by manipulating the price just before and after the transaction."",
      ""Location"": ""buyFlanAndBurn function""
    },
    {
      ""Issue"": ""Lack of Zero Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The configure() function accepts multiple address parameters but doesn't validate against zero addresses, which could lead to contract state corruption if critical components like behodler, flan, or FlanSCXPair are set to address(0)."",
      ""Impact"": ""Setting critical components to zero addresses would break core functionality and potentially lock funds. Accidentally setting a critical contract address to zero could require a costly contract redeployment."",
      ""Location"": ""configure() function""
    },
    {
      ""Issue"": ""Inconsistent Quote Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In _ensurePriceStability(), the function copies latestFlanQuotes to memory but doesn't check if the quotes are empty or uninitialized before performing price stability calculations. Functions with ensurePriceStability modifier could fail if called before quotes are properly initialized."",
      ""Impact"": ""May lead to division by zero errors if quotes haven't been properly initialized. Could cause transactions to revert unexpectedly due to division by zero when quotes aren't properly initialized."",
      ""Location"": ""_ensurePriceStability() function""
    },
    {
      ""Issue"": ""Precision Issues in Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple precision issues exist throughout the contract: 1) The minAPY_to_FPS function performs divisions that can lead to truncation due to integer division, potentially returning 0 for small APY values. 2) In the configure function, there's a logic error: `VARS.precision = precision == 0 ? precision : precision;`, which always sets precision to itself regardless of its value, making the check pointless. 3) The contract uses block numbers for time measurement in _ensurePriceStability, assuming consistent block times."",
      ""Impact"": ""Functions may return 0 fps (frames per second) when small APY values are provided, potentially breaking mechanisms relying on non-zero results. The precision validation is ineffective, allowing zero as a valid value which could cause issues in calculations that rely on precision. On networks with variable block times, the waiting period between quotes could be shorter or longer than intended."",
      ""Location"": ""minAPY_to_FPS() function, configure() function, _ensurePriceStability function""
    },
    {
      ""Issue"": ""Unprotected Configuration Settings"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setFactory() and setDAI() functions are public but not protected by onlySuccessfulProposal modifier nor onlyGovernance. They only check that the chain is not mainnet. Additionally, the contract has hard-coded Ethereum mainnet addresses for DAI and Uniswap factory, with special handling for non-mainnet chains."",
      ""Impact"": ""On testnets or non-mainnet chains, anyone can change these critical parameters, potentially disrupting testing. If the hard-coded addresses become obsolete (e.g., due to token upgrades or protocol changes), the contract would need to be redeployed on mainnet."",
      ""Location"": ""setFactory() and setDAI() functions""
    },
    {
      ""Issue"": ""Centralization Risk in Governance"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical configuration functions like configure() are only callable by successful governance proposals, and stabilizeFlan() is only callable by the limbo contract. If these controlling entities are compromised, the entire system could be manipulated."",
      ""Impact"": ""If the governance mechanism is compromised or centralized, attackers could modify critical parameters like divergenceTolerance or configure the contract with malicious values, potentially leading to system-wide failure."",
      ""Location"": ""configure() function with onlySuccessfulProposal modifier, stabilizeFlan() function with onlyLimbo modifier""
    },
    {
      ""Issue"": ""Unbounded Loops and Gas Limitations"",
      ""Severity"": ""Low"",
      ""Description"": ""The design of the system where LP tokens are continuously minted and sent to a black hole address could eventually lead to extremely high gas costs for operations involving the LP token, as its total supply grows without bound."",
      ""Impact"": ""Over time, operations involving the LP token could become prohibitively expensive or exceed block gas limits, rendering parts of the contract unusable."",
      ""Location"": ""stabilizeFlan function's approach to LP token management""
    },
    {
      ""Issue"": ""Unclear Error Messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses abbreviated error messages like 'EM', 'EG', and 'EH' which are not descriptive and make debugging difficult."",
      ""Impact"": ""Reduced contract maintainability and harder debugging for developers and users."",
      ""Location"": ""Throughout the contract, especially in require statements""
    }
  ],
  ""IssueNumber"": 59,
  ""OutputList"": 13
}",379.9627981185913,66096.0,32.0,"### **[M-07] Calling generateFLNQuote twice in every block prevents any migration**

**Report Description**:
The `generateFLNQuote` function in the UniswapHelper contract is public, allowing any user to generate the latest quote. If this function is called twice in the same block, both quotes will have the same `blockProduced` value. These quotes are used in the `_ensurePriceStability` function, which relies on the `blockProduced` value to ensure price stability. The last require statement in `_ensurePriceStability` checks if the `blockProduced` values of the two latest quotes are different. If they are the same, the migration process is blocked, effectively preventing any migration.

**Match in Response List**:
Matches with the issue titled **""Inadequate Price Oracle Security""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `generateFLNQuote` function being public and the flawed block number comparison logic in `_ensurePriceStability`. It correctly explains the risks associated with manipulating the price feeds by calling `generateFLNQuote` at strategic times, which aligns with the issue described in the report.

---

### **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

**Report Description**:
An attacker can prevent migrations by sending SCX tokens to the UniswapHelper contract. This attack is recoverable by calling `buyFlanAndBurn` with SCX as the input token to buy Flan with the extra SCX, and then running the migration again. However, the attack can still disrupt the migration process temporarily.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The issue involves a griefing attack by sending SCX to the UniswapHelper, which is not covered in the response list.

---

### **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Report Description**:
The `buyFlanAndBurn` function is vulnerable to sandwich attacks, where a malicious bot can manipulate the price of Flan before and after the transaction. For example, if Flan is trading at 0.8 in the input token terms, the bot can buy Flan, pushing the price to 0.9 before the `buyFlanAndBurn` transaction, and then sell it back afterward. This results in the input token being overspent, leading to direct losses for the system.

**Match in Response List**:
Matches with the issue titled **""No Slippage Protection in buyFlanAndBurn""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the lack of slippage protection in the `buyFlanAndBurn` function, which makes it vulnerable to sandwich attacks. The response correctly explains the risks associated with market manipulation and front-running, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-07] Calling generateFLNQuote twice in every block prevents any migration**
- **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

---","```
1. Inadequate Price Oracle Security
2. No Slippage Protection in buyFlanAndBurn
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Inadequate Price Oracle Security"" appears at rank 3.
   - ""No Slippage Protection in buyFlanAndBurn"" appears at rank 6.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 6: \( P@6 = \frac{2}{6} \approx 0.333 \)

3. **Average the precision values**:
   - \( AP = \frac{0.333 + 0.333}{2} = 0.333 \)

**Output**:
```
0.333
```"
