nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
HolyPaladinToken.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",12522,1437,"[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases
In the function `_updateDropPerSecond()`, when current time is `lastDropUpdate + (2*MONTH-1)`:
`nbMonthEllapsed` will be round down to 1, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.
In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to 1 * `dropDecreasePerMonth` for the decrease of emission rate.
At the very edge case, if all the updates happened just like the scenario above. by the end of the dropDecreaseDuration, it will drop only 12 * dropDecreasePerMonth in total, while it's expected to be 24 * dropDecreasePerMonth.
So only half of (startDropPerSecond - endDropPerSecond) is actually decreased. And the last time updateDropPerSecond is called, DropPerSecond will suddenly drop to endDropPerSecond.   [H-02] System could be wrapped and made useless without contract whitelisting
Anyone could create a contract or a contract factory ""PAL Locker"" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.
  [M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern
In HolyPaladinToken.sol it imports ERC20.sol with some changes from the original Open Zeppelin standard. One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates, followed by the external call to prevent reentrancy attacks. Currently the `transferFrom()` function in ERC20.sol used by HolyPaladinToken.sol calls _transfer() first and then updates the sender allowance which is highly unsafe. The openZeppelin ER20.sol contract which is the industry standard first updates the sender allowance before calling _transfer. The external call should always be done last to avoid any double spending bugs or reentrancy attacks.
  [M-02] Incorrect number of seconds in `ONE_YEAR` variable
In HolyPaladinToken.sol the ONE_YEAR variable claims that there are 31557600 seconds in a year when this is incorrect. The ONE_YEAR variable is used in the `getCurrentVotes()` function as well as the getPastVotes() function so it is vital that the correct time in seconds be used as it can effect users negatively.
  [M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens.
In the `_getNewReceiverCooldown` function, `_senderCooldown` is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5.   [M-04] cooldown is set to 0 when the user sends all tokens to himself
In the `_beforeTokenTransfer` function, cooldowns will be set to 0 when the user transfers all tokens to himself.   [M-05] Past state query results are susceptible to manipulation due to multiple states with same block number   [M-09] Function `cooldown()` is not protected when protocol in emergency mode Its behavior is not consistent with the other major functions defined.
  [M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`

[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards
Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged.",10,,"pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";



contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    
    uint256 public constant WEEK = 604800;
    
    uint256 public constant MONTH = 2629800;
    
    uint256 public constant UNIT = 1e18;
    
    uint256 public constant MAX_BPS = 10000;
    
    uint256 public constant ONE_YEAR = 31557600;

    
    uint256 public constant COOLDOWN_PERIOD = 864000; 
    
    uint256 public constant UNSTAKE_PERIOD = 432000; 

    
    uint256 public constant UNLOCK_DELAY = 1209600; 

    
    uint256 public constant MIN_LOCK_DURATION = 7889400; 
    
    uint256 public constant MAX_LOCK_DURATION = 63115200; 

    
    IERC20 public immutable pal;

    
    struct UserLock {
        
        uint128 amount; 
        
        uint48 startTimestamp;
        
        uint48 duration;
        
        uint32 fromBlock; 
    }

    
    mapping(address => UserLock[]) public userLocks;

    
    struct TotalLock {
        
        uint224 total;
        
        uint32 fromBlock;
    }

    
    uint256 public currentTotalLocked;
    
    TotalLock[] public totalLocks;

    
    mapping(address => uint256) public cooldowns;

    
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    
    mapping(address => address) public delegates;

    
    mapping(address => Checkpoint[]) public checkpoints;

    
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    
    uint256 public kickRatioPerWeek = 1000;

    
    uint256 public bonusLockVoteRatio = 0.5e18;

    
    bool public emergency = false;

    
    address public immutable rewardsVault;

    
    uint256 public rewardIndex;
    
    uint256 public lastRewardUpdate;

    
    uint256 public immutable startDropPerSecond;
    
    uint256 public endDropPerSecond;
    
    uint256 public currentDropPerSecond;
    
    uint256 public lastDropUpdate;
    
    uint256 public immutable dropDecreaseDuration;
    
    uint256 public immutable startDropTimestamp;

    
    mapping(address => uint256) public userRewardIndex;
    
    mapping(address => uint256) public claimableRewards;
    
    mapping(address => uint256) public rewardsLastUpdate;

    
    uint256 public immutable baseLockBonusRatio;
    
    uint256 public immutable minLockBonusRatio;
    
    uint256 public immutable maxLockBonusRatio;

    
    mapping(address => uint256) public userCurrentBonusRatio;
    
    mapping(address => uint256) public userBonusRatioDecrease;

    
    error EmergencyBlock(); 

    

    
    event Stake(address indexed user, uint256 amount);
    
    event Unstake(address indexed user, uint256 amount);
    
    event Cooldown(address indexed user);
    
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    
    event ClaimRewards(address indexed user, uint256 amount);
    
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        
        startDropTimestamp = block.timestamp;
    }


    
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        
        
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        
        
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    

    
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    
    function getUserLock(address user) external view returns(UserLock memory) {
        
        
        
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); 
        return totalLocks[totalLocks.length - 1];
    }

    
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        
        
        
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        
        
        
        
        
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    
    function estimateClaimableRewards(address user) external view returns(uint256) {
        
        
        if(emergency || user == address(0)) return 0;
        
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        
        uint256 estimatedClaimableRewards = claimableRewards[user];
        
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; 

        uint256 nbCheckpoints = checkpoints[user].length;
        
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        
        uint256 votes = _getPastVotes(user, blockNumber);


        
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    

    
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    
    function _updateDropPerSecond() internal returns (uint256){
        
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            
            
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; 

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        
        
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        
        uint256 currentTotalSupply = totalSupply();
        
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        
        
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; 

        
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                
                
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            
                            
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                
                                
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                
                                
                                
                            }

                            
                            
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    
    function _updateUserRewards(address user) internal {
        
        uint256 newIndex = _updateRewardState();

        
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; 

        
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        
        userCurrentBonusRatio[user] = newBonusRatio;
        
        
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { 
            
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; 

        if(from != to) {
            
            _updateUserRewards(to);
            
            

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        
        

        _mint(user, amount); 

        
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        

        
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        
        _burn(user, burnAmount);

        

        
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    
    
    
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        
        if(receiverCooldown < minValidCooldown) return 0;

        
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); 
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                
                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                
                
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            
            if(action != LockAction.INCREASE_AMOUNT){
                
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); 
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",8463,2,8,"Based on the comprehensive analysis of the HolyPaladinToken contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze reentrancy risks in stake, unstake, lock, and claim functions"",
        ""Verify comprehensive integer overflow/underflow protection"",
        ""Check for potential arithmetic precision issues in reward calculations"",
        ""Evaluate emergency mode implementation for potential centralization risks"",
        ""Verify SafeERC20 library usage prevents unexpected token transfer behaviors""
      ]
    },
    {
      ""Area"": ""Access Control & Governance"",
      ""Tasks"": [
        ""Review onlyOwner modifier implementations and potential privilege escalation"",
        ""Analyze delegation mechanism for potential vote manipulation"",
        ""Verify checkpoint tracking system's integrity and resistance to attacks"",
        ""Validate emergency withdraw and trigger mechanisms"",
        ""Check role separation and administrative controls""
      ]
    },
    {
      ""Area"": ""Reward Distribution & Tokenomics"",
      ""Tasks"": [
        ""Conduct thorough review of reward calculation logic"",
        ""Verify time-based reward emission decay mechanism"",
        ""Check for potential reward accumulation exploits"",
        ""Analyze bonus ratio calculations and potential gaming vectors"",
        ""Validate rewardsVault interactions and potential fund drainage risks""
      ]
    },
    {
      ""Area"": ""Staking & Locking Mechanisms"",
      ""Tasks"": [
        ""Analyze lock duration constraints and potential circumvention"",
        ""Review kick mechanism for potential manipulation"",
        ""Verify cooldown and unstaking period implementations"",
        ""Check for potential flash loan or economic attacks on locking system"",
        ""Validate penalty calculations for kicked locks""
      ]
    },
    {
      ""Area"": ""External Interactions & Integrations"",
      ""Tasks"": [
        ""Verify safe interactions with underlying PAL token"",
        ""Check transfer hooks and potential external contract interactions"",
        ""Analyze potential oracle or price feed dependencies"",
        ""Validate cross-contract call security"",
        ""Review import and inheritance security""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of complex functions"",
        ""Review checkpoint and lock array management strategies"",
        ""Check for potential DoS vectors through array manipulations"",
        ""Evaluate computational complexity of reward calculations"",
        ""Assess storage optimization techniques""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Review custom error implementations"",
        ""Validate handling of zero-value transactions"",
        ""Check boundary condition handling in lock and reward calculations"",
        ""Analyze error propagation and user experience in failure scenarios"",
        ""Verify fallback and emergency mechanism robustness""
      ]
    },
    {
      ""Area"": ""Compliance & Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC20 standard compliance"",
        ""Check governance mechanism against best practices"",
        ""Validate token transfer and delegation standards"",
        ""Review event emission comprehensiveness"",
        ""Ensure proper interface implementations""
      ]
    }
  ]
}

Key Audit Focus Areas:
- Complex reward calculation logic
- Delegation and voting mechanisms
- Lock and unstake functionality security
- Emergency mode implementation
- Potential economic attack vectors

Recommended Approach:
1. Systematic review of each task area
2. Detailed documentation of findings
3. Provide concrete recommendations for improvements
4. Prioritize critical security vulnerabilities
5. Offer optimization suggestions

The task list provides a comprehensive framework for an in-depth security audit, addressing technical, economic, and governance aspects of the HolyPaladinToken contract.","I've carefully reviewed the HolyPaladinToken smart contract. Here's my analysis:

{
  ""ReviewingTheCode"": ""The HolyPaladinToken (hPAL) is a complex staking, locking, and delegation contract that extends ERC20 functionality. It allows users to stake PAL tokens, lock them for periods, and participate in a governance system through voting delegation. The contract includes mechanisms for rewards distribution, time-locked staking with bonuses, and penalties for late unlocking."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""HolyPaladinToken"",
    ""Purpose"": ""A governance and staking token contract for PAL token holders, providing locking mechanisms with vote amplification, token delegation, and reward distribution systems"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ERC20"", ""Ownable""],
      ""Imports"": [
        ""ERC20.sol"",
        ""Ownable.sol"",
        ""IERC20.sol"",
        ""SafeERC20.sol"",
        ""Math.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WEEK, MONTH, UNIT, MAX_BPS, ONE_YEAR"",
        ""Type"": ""uint256 constants"",
        ""Purpose"": ""Time and calculation constants""
      },
      {
        ""Name"": ""COOLDOWN_PERIOD, UNSTAKE_PERIOD"",
        ""Type"": ""uint256 constants"",
        ""Purpose"": ""Timing parameters for the unstaking process""
      },
      {
        ""Name"": ""UNLOCK_DELAY"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Grace period after lock expiry before kickable""
      },
      {
        ""Name"": ""MIN_LOCK_DURATION, MAX_LOCK_DURATION"",
        ""Type"": ""uint256 constants"",
        ""Purpose"": ""Define the allowed range for token lock durations""
      },
      {
        ""Name"": ""pal"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""Reference to the underlying PAL token""
      },
      {
        ""Name"": ""userLocks"",
        ""Type"": ""mapping(address => UserLock[])"",
        ""Purpose"": ""Track all locks created by each user""
      },
      {
        ""Name"": ""currentTotalLocked"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Current total amount of locked tokens""
      },
      {
        ""Name"": ""totalLocks"",
        ""Type"": ""TotalLock[]"",
        ""Purpose"": ""History of total locked amounts""
      },
      {
        ""Name"": ""cooldowns"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Track cooldown periods for each user""
      },
      {
        ""Name"": ""delegates, checkpoints, delegateCheckpoints"",
        ""Type"": ""mappings"",
        ""Purpose"": ""Support vote delegation and historical vote accounting""
      },
      {
        ""Name"": ""kickRatioPerWeek"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Penalty ratio for kicking expired locks""
      },
      {
        ""Name"": ""bonusLockVoteRatio"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Vote amplification ratio for long-term locks""
      },
      {
        ""Name"": ""rewardsVault, rewardIndex, lastRewardUpdate"",
        ""Type"": ""address and uint256"",
        ""Purpose"": ""Controls reward distribution mechanism""
      },
      {
        ""Name"": ""startDropPerSecond, endDropPerSecond, currentDropPerSecond"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Reward emission rate parameters""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initialize the contract with required parameters"",
        ""Parameters"": [""palToken"", ""admin"", ""rewardsVault"", ""startDropPerSecond"", ""endDropPerSecond"", ""dropDecreaseDuration"", ""baseLockBonusRatio"", ""minLockBonusRatio"", ""maxLockBonusRatio""],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to stake PAL tokens for hPAL tokens"",
        ""Parameters"": [""amount""],
        ""Returns"": [""uint256 - amount staked""]
      },
      {
        ""Name"": ""cooldown"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates cooldown period before unstaking"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to unstake after cooldown period"",
        ""Parameters"": [""amount"", ""receiver""],
        ""Returns"": [""uint256 - amount unstaked""]
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Lock hPAL tokens for a specific duration"",
        ""Parameters"": [""amount"", ""duration""],
        ""Returns"": []
      },
      {
        ""Name"": ""unlock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlock previously locked tokens after lock period"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""kick"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Force unlock another user's expired locks with a penalty"",
        ""Parameters"": [""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""delegate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Delegate voting power to another address"",
        ""Parameters"": [""delegatee""],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claim accumulated rewards"",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateRewardState"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Update global reward state"",
        ""Parameters"": [],
        ""Returns"": [""uint256 - new reward index""]
      },
      {
        ""Name"": ""_updateUserRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Update rewards for a specific user"",
        ""Parameters"": [""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allow users to withdraw in emergency mode"",
        ""Parameters"": [""amount"", ""receiver""],
        ""Returns"": [""uint256 - amount withdrawn""]
      },
      {
        ""Name"": ""triggerEmergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggle emergency mode"",
        ""Parameters"": [""trigger""],
        ""Returns"": [],
        ""Modifier"": ""onlyOwner""
      },
      {
        ""Name"": ""setKickRatio"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Update the kick penalty ratio"",
        ""Parameters"": [""newKickRatioPerWeek""],
        ""Returns"": [],
        ""Modifier"": ""onlyOwner""
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""PAL token (IERC20) for staking and unstaking operations"",
    ""Rewards vault for distributing rewards"",
    ""SafeERC20 library for secure token transfers""
  ],
  
  ""SpecialMechanisms"": [
    ""Time-based locking mechanism with variable duration bonuses"",
    ""Governance through delegation with vote tracking via checkpoints"",
    ""Historical state tracking using block-indexed arrays"",
    ""Time-decaying reward emission system"",
    ""Lock bonus ratio that decreases over time"",
    ""Cooldown and unstake window mechanics for withdrawal"",
    ""Kick mechanism allowing forced unlocks of expired locks with penalties""
  ],
  
  ""VulnerabilitiesAndRisks"": [
    ""Block timestamp dependence for lock durations, rewards, and cooldowns"",
    ""Complicated reward calculations that could be subject to rounding errors"",
    ""Risk of errors in checkpoint-based historical vote tracking"",
    ""No explicit protection against flash loans or MEV attacks in the staking/unstaking process"",
    ""The emergency mode gives significant power to the contract owner"",
    ""Lack of slippage protection for token transfers""
  ],
  
  ""Questions"": [
    ""Is there a mechanism to recover incorrect tokens sent to the contract?"",
    ""How does the contract handle rounding errors in reward calculations?"",
    ""What happens if the rewardsVault becomes depleted?"",
    ""Is there a limit to the number of checkpoints that can be created for an address?"",
    ""How is front-running mitigated in the kick functionality?"",
    ""What security measures are in place to prevent an owner from abusing emergency mode?""
  ]
}

Additional Observations:

1. **Reward System Complexity**: The reward distribution system is highly complex, with time-varying emission rates and user-specific bonus ratios. This complexity increases the risk of calculation errors or unexpected behavior.

2. **Gas Optimization Concerns**: Heavy use of arrays for locks and checkpoints could lead to high gas costs as these data structures grow, especially for users who interact with the contract frequently.

3. **Precision Handling**: The contract uses various ratios and time-based calculations where precision issues could occur. While UNIT (1e18) is used to maintain precision in calculations, edge cases should be carefully examined.

4. **Emergency Functionality**: The emergency mode is a double-edged sword - while it provides a safety mechanism, it also introduces a centralized point of control that could be abused.

5. **Delegation System**: The delegation system uses a complex checkpoint mechanism to track historical votes, which is similar to Compound's governance but requires careful implementation to avoid vulnerabilities.

The contract appears sophisticated and well-structured but would benefit from thorough testing, particularly around the reward calculation and lock manipulation functionality.","I've analyzed the provided findings from multiple security analyses of the HolyPaladinToken contract. After consolidating similar issues and structuring the output as requested, here is the result:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerabilities in token transfers"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions like claim(), _unstake(), and emergencyWithdraw() make external calls to transfer tokens after changing contract state. While SafeERC20 is used, which mitigates some concerns, these functions could still be vulnerable to reentrancy attacks if the PAL token has hooks or callbacks that could be exploited."",
      ""Impact"": ""An attacker could potentially claim the same rewards multiple times, drain funds from the contract, or create inconsistent state conditions by exploiting reentrancy during token transfers."",
      ""Location"": ""Functions claim(), _unstake(), emergencyWithdraw() and other functions making external token transfers""
    },
    {
      ""Issue"": ""Vulnerable to flash loan attacks in delegation system"",
      ""Severity"": ""High"",
      ""Description"": ""The delegation system allows users to instantly gain voting power by acquiring tokens. This enables potential flash loan attacks to manipulate governance decisions, as voting power is determined by token balance at the time of voting without any time-lock mechanism."",
      ""Impact"": ""Governance manipulation, allowing attackers to potentially pass malicious proposals without actually having long-term stake in the system by borrowing a large amount of tokens via a flash loan, delegating voting power, executing a proposal, and returning tokens in one transaction."",
      ""Location"": ""_delegate() and _moveDelegates() functions""
    },
    {
      ""Issue"": ""Insufficient validation in lock management"",
      ""Severity"": ""High"",
      ""Description"": ""In the _lock() function, the contract validates that the amount is less than or equal to the user's balance, but it doesn't properly validate available balance when increasing lock amounts. Additionally, when a user increases their lock duration, the function doesn't consider the time already passed in the original lock when calculating the new userBonusRatioDecrease."",
      ""Impact"": ""Users might be able to lock more tokens than they should, potentially breaking the token economy or exploiting the reward system. Users who extend lock durations will receive incorrect rewards as the decay rate would be calculated based on the full new duration rather than accounting for elapsed time."",
      ""Location"": ""_lock() function, particularly when handling LockAction.INCREASE_DURATION""
    },
    {
      ""Issue"": ""Emergency flag can permanently disable core functionality"",
      ""Severity"": ""High"",
      ""Description"": ""When the emergency flag is set to true by the owner, most of the contract's functionality is permanently disabled unless explicitly reset. This creates a significant centralization risk without timelock or governance oversight."",
      ""Impact"": ""If the emergency flag is triggered, users may lose access to normal functionality or be forced to use the emergencyWithdraw function, potentially at unfavorable terms, disrupting the platform's operations."",
      ""Location"": ""Function triggerEmergencyWithdraw() and emergency checks throughout the contract""
    },
    {
      ""Issue"": ""Incorrect tracking of user locks"",
      ""Severity"": ""High"",
      ""Description"": ""The contract continuously adds to the userLocks array without a mechanism to prune old entries. This could lead to excessive gas costs and potential DoS conditions when reading or managing locks for users who have had many lock operations."",
      ""Impact"": ""Operations involving user locks could become prohibitively expensive or impossible after many lock operations, potentially preventing users from managing their positions."",
      ""Location"": ""userLocks mapping and related functions like _lock() and _unlock()""
    },
    {
      ""Issue"": ""Centralized control over critical parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The owner has significant privileges, including the ability to trigger emergency withdrawals and modify key parameters like kickRatioPerWeek and endDropPerSecond without timelock mechanisms or multi-signature requirements. This creates a centralization risk where a malicious or compromised owner could disrupt the system."",
      ""Impact"": ""If the owner account is compromised, malicious actors could manipulate parameters to drain funds or disrupt the protocol's functionality. Users have no opportunity to exit positions before potentially adverse parameter changes take effect."",
      ""Location"": ""Functions setKickRatio(), triggerEmergencyWithdraw(), and setEndDropPerSecond() with onlyOwner modifier""
    },
    {
      ""Issue"": ""Precision loss in reward calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses fixed-point arithmetic with division operations in multiple reward calculations. These complex calculations involving multiple division operations can lead to precision loss, especially when dealing with small token amounts or short durations. The calculation of vars.periodBonusRatio may not accurately represent the average bonus over the period."",
      ""Impact"": ""Users may receive slightly fewer rewards than they should be entitled to due to rounding down in integer division. Small stakeholders might be more significantly affected by these precision issues."",
      ""Location"": ""Multiple locations, including _getUserAccruedRewards(), _getNewIndex(), _lock(), and ratio calculations throughout the contract""
    },
    {
      ""Issue"": ""Gas limit concerns with unbounded arrays"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions operate on unbounded arrays (checkpoints, delegateCheckpoints, userLocks, totalLocks), which could grow indefinitely as users interact with the contract. As these arrays grow over time, gas costs will increase and operations could eventually hit block gas limits."",
      ""Impact"": ""Historical voting data might become inaccessible, potentially breaking dependent governance systems. Long-term users of the protocol might find their transactions failing due to excessive gas costs, especially for operations involving delegation or lock management."",
      ""Location"": ""_writeCheckpoint(), _getPastVotes(), getPastTotalLock(), _moveDelegates(), and other checkpoint-related functions""
    },
    {
      ""Issue"": ""No validation for vault address in reward transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract assumes that the rewardsVault has pre-approved PAL tokens for the contract to transfer. There's no check to ensure the vault has sufficient balance or has approved the transfers. Additionally, the constructor sets the rewardsVault address but doesn't validate that it's not the zero address."",
      ""Impact"": ""If the rewardsVault is misconfigured or runs out of tokens, users may be unable to claim rewards even if the contract shows they have claimable rewards, essentially breaking the reward mechanism."",
      ""Location"": ""claim() function and constructor""
    },
    {
      ""Issue"": ""Front-running vulnerability in delegation system"",
      ""Severity"": ""Medium"",
      ""Description"": ""The delegate system allows users to change their delegation at any time without protection against front-running. This could be exploited by attackers monitoring the mempool to change their own delegations to manipulate voting outcomes just before a proposal snapshot."",
      ""Impact"": ""Potential manipulation of voting results through front-running attacks, where users could observe pending delegation transactions and submit their own with higher gas to execute first."",
      ""Location"": ""delegate() function""
    },
    {
      ""Issue"": ""Kickable locks create potential for abuse"",
      ""Severity"": ""Medium"",
      ""Description"": ""The kick mechanism allows any user to kick another user and claim a percentage of their locked tokens if they haven't unlocked after expiration plus the UNLOCK_DELAY. This creates a race condition where multiple users might compete to kick the same target."",
      ""Impact"": ""This could lead to front-running attacks where users monitor the chain for kickable locks and attempt to front-run each other's transactions to claim the penalty."",
      ""Location"": ""_kick() function""
    },
    {
      ""Issue"": ""Missing slippage protection in staking functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The staking and unstaking functions don't implement slippage protection or deadline parameters. This exposes users to potential sandwich attacks or front-running, especially in a system where the value of staked tokens can fluctuate based on protocol events."",
      ""Impact"": ""Users may receive less value than expected when staking or unstaking, as transactions could be delayed and executed at unfavorable rates."",
      ""Location"": ""Functions _stake() and _unstake()""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using Solidity 0.8.x which has built-in overflow protection, parts of the contract perform complex calculations that might exceed uint256 limits or lead to unexpected behaviors, particularly in the reward calculations and voting power arithmetic operations."",
      ""Impact"": ""Could lead to incorrect reward distribution, voting power miscalculations, or transaction failures, especially when dealing with very large token amounts."",
      ""Location"": ""_getUserAccruedRewards() function, _getNewReceiverCooldown(), and other calculation-heavy functions""
    },
    {
      ""Issue"": ""Lack of input validation in administrative functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Some administrative functions and the constructor lack comprehensive input validation. For example, setEndDropPerSecond() only checks if the decrease duration is over but doesn't validate that the new value is reasonable. The constructor only checks if palToken and _admin are non-zero addresses, but doesn't validate other critical parameters."",
      ""Impact"": ""Could potentially lead to setting extreme values that break the token economy or reward system. If parameters are incorrectly set during deployment, the contract could behave unexpectedly with no way to correct them later."",
      ""Location"": ""setEndDropPerSecond(), setKickRatio() functions, and constructor""
    },
    {
      ""Issue"": ""Vulnerability to block re-orgs in voting mechanisms"",
      ""Severity"": ""Low"",
      ""Description"": ""The voting power is determined based on block numbers. In the event of a blockchain reorganization, this could lead to inconsistent voting results if proposals are evaluated near the time of a re-org."",
      ""Impact"": ""Potential temporary inconsistencies in governance vote counting during chain reorganizations."",
      ""Location"": ""getPastVotes() and related voting functions""
    },
    {
      ""Issue"": ""Time-based dependencies"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies heavily on block.timestamp for critical timing functions. This introduces potential vulnerabilities as miners have some flexibility in manipulating timestamps."",
      ""Impact"": ""Minor manipulation of timestamps by miners could affect locking periods, cooldowns, and reward calculations, potentially allowing users to game the system."",
      ""Location"": ""Throughout the contract, especially in functions using block.timestamp for timing logic""
    },
    {
      ""Issue"": ""Lack of grace period for lock extension"",
      ""Severity"": ""Low"",
      ""Description"": ""When increasing lock duration, the contract requires the new duration to be longer than the current one, but there's no grace period for users who might want to extend a lock that has just expired."",
      ""Impact"": ""Users with expired locks must create entirely new locks rather than extending existing ones, which may be less gas efficient and less user-friendly."",
      ""Location"": ""_lock() function""
    },
    {
      ""Issue"": ""Insufficient events for critical actions"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical parameter changes do not emit events, making it difficult to track important changes to the contract state off-chain. For example, when endDropPerSecond or kickRatio is updated, no event is emitted."",
      ""Impact"": ""Reduced transparency and difficulty in monitoring contract state changes, which could affect user trust and complicate integration with external systems."",
      ""Location"": ""Functions setKickRatio() and setEndDropPerSecond()""
    },
    {
      ""Issue"": ""Complex delegation mechanism with potential for confusion"",
      ""Severity"": ""Low"",
      ""Description"": ""The delegation system involves multiple checkpoints and calculations, including bonus votes for locks. This complexity makes it difficult to predict voting power and could lead to confusion for users trying to calculate expected voting outcomes."",
      ""Impact"": ""Users might misunderstand their voting power or the expected outcome of governance actions, potentially leading to unexpected governance results."",
      ""Location"": ""Delegation functions and voting power calculations""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 18
}",420.0012385845184,154307.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**

**Report Description**:  
The function `_updateDropPerSecond()` suffers from precision loss when calculating the number of months elapsed. Specifically, when the current time is `lastDropUpdate + (2*MONTH-1)`, `nbMonthEllapsed` is rounded down to 1, even though 1.99 months have passed. This results in `DropPerSecond` decreasing by only 1 * `dropDecreasePerMonth` instead of the expected 2 * `dropDecreasePerMonth`. Over time, this discrepancy can lead to a significant shortfall in the total decrease of emission rate, potentially causing the system to emit up to double the expected rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The precision loss in `_updateDropPerSecond()` and its impact on reward emissions are not covered in any of the findings.

---

#### **[H-02] System could be wrapped and made useless without contract whitelisting**

**Report Description**:  
Anyone can create a contract or contract factory (""PAL Locker"") to deposit PAL tokens, lock them, and delegate voting power to the contract owner. The ownership of this contract can then be sold, effectively making locked hPAL tokens liquid and transferable again. This undermines the core system of hPAL, which relies on locking tokens to gain non-liquid, boosted voting power and rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The potential for wrapping the system and making locked tokens liquid is not mentioned in any of the findings.

---

#### **[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**

**Report Description**:  
The `transferFrom()` function in `HolyPaladinToken.sol` does not follow the Checks-Effects-Interactions pattern. Specifically, it calls `_transfer()` before updating the sender's allowance, which is highly unsafe and opens the door to reentrancy attacks. The OpenZeppelin standard updates the allowance before calling `_transfer`, ensuring safety.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy vulnerabilities in token transfers""**.

**Validation**:  
**Partially Correct**. The response identifies reentrancy vulnerabilities in token transfers but does not specifically address the unsafe pattern in `transferFrom()` or the deviation from the OpenZeppelin standard. The core issue is partially covered but lacks critical details.

---

#### **[M-02] Incorrect number of seconds in `ONE_YEAR` variable**

**Report Description**:  
The `ONE_YEAR` variable in `HolyPaladinToken.sol` is set to 31557600 seconds, which is incorrect. This variable is used in functions like `getCurrentVotes()` and `getPastVotes()`, and the incorrect value can negatively impact users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect value of `ONE_YEAR` and its potential impact are not covered in any of the findings.

---

#### **[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**

**Report Description**:  
In the `_getNewReceiverCooldown` function, if `_senderCooldown` is Day 15 and `receiverCooldown` is Day 0, the latest cooldown of user A is calculated as (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5. This behavior allows users to assist others in unstaking tokens, potentially bypassing intended restrictions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The behavior of `_getNewReceiverCooldown` and its implications are not covered in any of the findings.

---

#### **[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**

**Report Description**:  
In the `_beforeTokenTransfer` function, `cooldown` is set to 0 when a user transfers all tokens to themselves. This behavior may not align with the intended design of the cooldown mechanism.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The behavior of `_beforeTokenTransfer` and its implications are not covered in any of the findings.

---

#### **[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**

**Report Description**:  
Past state query results can be manipulated because multiple states can share the same block number. This vulnerability could be exploited to alter historical data.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The susceptibility of past state queries to manipulation is not covered in any of the findings.

---

#### **[M-09] Function `cooldown()` is not protected when protocol is in emergency mode**

**Report Description**:  
The `cooldown()` function is not protected when the protocol is in emergency mode, making its behavior inconsistent with other major functions.

**Match in Response List**:  
Matches with the issue titled **""Emergency flag can permanently disable core functionality""**.

**Validation**:  
**Partially Correct**. The response identifies the emergency flag's impact on core functionality but does not specifically address the lack of protection for the `cooldown()` function. The core issue is partially covered but lacks critical details.

---

#### **[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**

**Report Description**:  
Users can bypass emergency restrictions on the `updateUserRewardState()` function, potentially allowing unauthorized actions during an emergency.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The bypass of emergency restrictions in `updateUserRewardState()` is not covered in any of the findings.

---

#### **[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**

**Report Description**:  
Increasing the lock amount on an expired lock can cause users to miss out on rewards. The protocol should only increase the total locked amount without altering the associated bonus ratios, as the duration remains unchanged.

**Match in Response List**:  
Matches with the issue titled **""Insufficient validation in lock management""**.

**Validation**:  
**Partially Correct**. The response identifies issues with lock management but does not specifically address the impact of increasing the lock amount on expired locks. The core issue is partially covered but lacks critical details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**  
- **[M-09] Function `cooldown()` is not protected when protocol is in emergency mode**  
- **[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**

**Missed Issues from Issue Report**:  
- **[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**  
- **[H-02] System could be wrapped and made useless without contract whitelisting**  
- **[M-02] Incorrect number of seconds in `ONE_YEAR` variable**  
- **[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**  
- **[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**  
- **[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**  
- **[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**

--- 

The response list covers some issues but misses or partially addresses many critical vulnerabilities and risks identified in the issue report. Significant gaps remain in the coverage of precision loss, system wrapping, incorrect constants, and bypassing emergency restrictions.","```
None.
```",0.0
PaladinRewardReserve.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";

/** @title Paladin Reward Reserve contract  */
/// @author Paladin
contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    /** @notice Addresses allowed to transfer tokens from this contract */
    mapping(address => bool) public approvedSpenders;

    /** @notice Emitted when a new spender is approved*/
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when the allowance of a spander is updated */
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when a spender allowance is removed */
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",494,56,"[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards
  [M-08] Add a timelock to PaladinRewardReserve functions
The owner of PaladinRewardReserve can approve and transfer any amount of tokens with no limits on any account. This is not good for investors. To give more trust to users: these functions should be put behind a timelock.
",2,,"pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";



contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    
    mapping(address => bool) public approvedSpenders;

    
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",423,0,2,"Based on the detailed analysis of the PaladinRewardReserve smart contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the integrity of the onlyOwner modifier and ownership transfer mechanism"",
        ""Confirm that all sensitive functions are properly protected by onlyOwner modifier"",
        ""Assess the potential risks of single-point-of-failure with admin/owner model"",
        ""Validate the constructor's ownership transfer logic""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct thorough reentrancy attack vector analysis"",
        ""Verify the effectiveness of the ReentrancyGuard implementation"",
        ""Check for potential integer overflow/underflow risks in allowance and transfer functions"",
        ""Examine the safeApprove and safeTransfer implementations for potential edge cases"",
        ""Validate the zero-address check for critical input parameters""
      ]
    },
    {
      ""Area"": ""Token Approval Mechanism"",
      ""Tasks"": [
        ""Analyze the spender approval process for potential logical flaws"",
        ""Verify the reset and update of token approvals in updateSpenderAllowance"",
        ""Check the limitations of the approvedSpenders mapping"",
        ""Investigate potential risks in the token approval workflow"",
        ""Confirm the handling of different ERC20 token implementations""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify the safety of external token interactions using SafeERC20"",
        ""Check the robustness of token transfer and approval mechanisms"",
        ""Validate error handling for failed token interactions"",
        ""Assess potential risks from interacting with untrusted token contracts""
      ]
    },
    {
      ""Area"": ""Event Logging & Transparency"",
      ""Tasks"": [
        ""Verify the comprehensiveness of event emissions"",
        ""Ensure all critical state changes are properly logged"",
        ""Check the accuracy and completeness of event parameters"",
        ""Validate the indexing of event topics for efficient filtering""
      ]
    },
    {
      ""Area"": ""Potential Improvement Opportunities"",
      ""Tasks"": [
        ""Identify potential gas optimization strategies"",
        ""Suggest additional input validation mechanisms"",
        ""Recommend potential emergency stop or circuit breaker functionality"",
        ""Evaluate the need for more granular access control"",
        ""Propose additional safeguards for token management""
      ]
    },
    {
      ""Area"": ""Compliance & Best Practices"",
      ""Tasks"": [
        ""Verify compliance with OpenZeppelin library best practices"",
        ""Check adherence to Solidity security recommendations"",
        ""Validate the contract's compatibility with standard ERC20 interactions"",
        ""Ensure proper use of SafeERC20 library functions""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list comprehensively covers the potential risks and areas of concern identified in the initial contract review.
2. Tasks are specifically tailored to the unique characteristics of the PaladinRewardReserve contract.
3. The breakdown provides a structured approach to auditing, covering security, functionality, and potential improvements.
4. Each area includes multiple specific, actionable tasks to ensure thorough examination.

The prioritization focuses on:
- Critical security vulnerabilities
- Access control integrity
- Token interaction safety
- Comprehensive error handling
- Potential improvements and best practices

This approach ensures a methodical and thorough audit of the smart contract, addressing both immediate security concerns and potential future optimizations.","After carefully reviewing the provided smart contract code, here's my audit:

{
  ""ReviewingTheCode"": ""The contract 'PaladinRewardReserve' appears to be a token management contract that allows an admin to approve specific spenders for ERC20 tokens stored in the contract. It inherits from Ownable and ReentrancyGuard, making use of OpenZeppelin's security patterns. The contract provides functionality to manage spender allowances and transfer tokens to recipients."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PaladinRewardReserve"",
    ""Purpose"": ""Manage token allowances and transfers for a set of approved spenders, acting as a token reserve with controlled spending permissions"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard""],
      ""Imports"": [
        ""open-zeppelin/utils/Ownable.sol"",
        ""open-zeppelin/utils/ReentrancyGuard.sol"",
        ""open-zeppelin/interfaces/IERC20.sol"",
        ""open-zeppelin/libraries/SafeERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""approvedSpenders"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks addresses that have been approved as spenders for tokens held by this contract""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by transferring ownership to the specified admin"",
        ""Parameters"": [""_admin: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setNewSpender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new approved spender and grants them an allowance for a specific token"",
        ""Parameters"": [""token: address"", ""spender: address"", ""amount: uint256""],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""updateSpenderAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the allowance for an existing approved spender for a specific token"",
        ""Parameters"": [""token: address"", ""spender: address"", ""amount: uint256""],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""removeSpender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes a spender from the approved list and revokes their token allowance"",
        ""Parameters"": [""token: address"", ""spender: address""],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""transferToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers a specific amount of tokens to a receiver"",
        ""Parameters"": [""token: address"", ""receiver: address"", ""amount: uint256""],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner"", ""nonReentrant""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""Interacts with ERC20 tokens through the IERC20 interface"",
    ""Uses SafeERC20 library for safe token operations (safeApprove, safeTransfer)""
  ],
  
  ""SpecialMechanisms"": [
    ""Uses OpenZeppelin's Ownable pattern for access control"",
    ""Implements ReentrancyGuard to prevent reentrancy attacks on token transfers"",
    ""Uses SafeERC20 to safely interact with ERC20 tokens that might not return booleans""
  ],
  
  ""Questions"": [
    ""The contract manages approvals for multiple tokens, but the approvedSpenders mapping doesn't track which token each spender is approved for. Is this intentional?"",
    ""There's no function to recover accidentally sent ETH. Is this intentional?"",
    ""The contract doesn't verify that token addresses are valid ERC20 contracts before interacting with them. Should there be additional validation?"",
    ""Some ERC20 tokens don't work well with approve(0) followed by approve(amount). Has this edge case been considered?"",
    ""The contract doesn't limit the types of tokens that can be managed. Is it intended to handle any ERC20 token?""
  ]
}","I've analyzed the provided list of issues identified by different reviewers. After consolidating similar findings and organizing by severity, here's the final structured report:

{
  ""Findings"": [
    {
      ""Issue"": ""Race Condition in ERC20 Approvals"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses the pattern of setting approval to 0 before setting it to a new value in updateSpenderAllowance. While this is generally recommended for ERC20 tokens, calling safeApprove twice in the same transaction can cause issues with certain ERC20 implementations that have approval race condition protections. Some tokens revert when trying to change an existing non-zero approval."",
      ""Impact"": ""Function calls may revert unexpectedly when interacting with certain ERC20 tokens, potentially causing the contract to become unable to update allowances for specific tokens. This can lead to failed transactions with certain ERC20 implementations."",
      ""Location"": ""updateSpenderAllowance function (lines 35-41)""
    },
    {
      ""Issue"": ""Lack of Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not validate that token, spender, or receiver addresses are non-zero or valid contract addresses. This applies to setNewSpender(), updateSpenderAllowance(), removeSpender(), and transferToken() functions. Additionally, token addresses are not verified to be valid ERC20 contracts before operations are attempted."",
      ""Impact"": ""This could lead to irreversible loss of tokens if operations are accidentally performed with the zero address. Transactions might fail in unexpected ways if invalid addresses are provided, potentially leading to confusion or denial of service."",
      ""Location"": ""setNewSpender(), updateSpenderAllowance(), removeSpender(), and transferToken() functions""
    },
    {
      ""Issue"": ""Unlimited Token Approvals"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract allows the owner to approve arbitrary amounts of any ERC20 token to any address marked as a spender, including the maximum uint256 value which effectively gives unlimited spending authority. This creates a significant risk surface."",
      ""Impact"": ""If the owner's private key is compromised, an attacker could set approvals for all tokens in the contract to malicious addresses, potentially draining all funds. If a spender contract becomes compromised, all tokens of a specific type could be drained."",
      ""Location"": ""setNewSpender() and updateSpenderAllowance() functions""
    },
    {
      ""Issue"": ""Insufficient Spender Tracking"",
      ""Severity"": ""Medium"",
      ""Description"": ""The approvedSpenders mapping only tracks whether an address is approved as a spender but doesn't track which tokens they can spend or what amounts. There's no spender-to-token tracking mechanism, meaning a spender approved for one token is considered approved for all tokens, which may not be the intended behavior."",
      ""Impact"": ""This design makes it hard to track which spenders have which permissions, potentially leading to operational confusion and security gaps. When removing a spender, the owner has to manually identify all tokens that spender has approvals for. Missing any would leave lingering approvals that could be exploited."",
      ""Location"": ""approvedSpenders mapping and all related functions""
    },
    {
      ""Issue"": ""Missing Ownership Transfer Safety"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses Ownable which implements a single-step ownership transfer. If the owner address is input incorrectly during the transfer, ownership could be permanently lost or transferred to an unintended address."",
      ""Impact"": ""Potential loss of contract ownership leading to the inability to perform administrative functions, effectively locking the contract's functionality."",
      ""Location"": ""constructor(), which uses transferOwnership()""
    },
    {
      ""Issue"": ""No Emergency Pause Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a pause mechanism that would allow the owner to halt operations in case of an emergency or discovered vulnerability."",
      ""Impact"": ""If a vulnerability is discovered, the owner has no way to quickly prevent further exploitation while a fix is being developed."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Centralized Control"",
      ""Severity"": ""Low"",
      ""Description"": ""All administrative functions are restricted to the owner, creating a single point of failure or control. There are no time-locks, multi-signature requirements, or other governance mechanisms to protect against malicious or erroneous actions by the owner."",
      ""Impact"": ""Risk of unauthorized token transfers if the owner account is compromised, with no time-lock or multi-signature protections."",
      ""Location"": ""All functions with onlyOwner modifier""
    },
    {
      ""Issue"": ""Missing Events for Token Transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""The transferToken function doesn't emit an event when tokens are transferred, making it difficult to track token movements off-chain."",
      ""Impact"": ""Reduced transparency and auditability of token movements from the reserve contract. More difficult accounting/reconciliation of token movements."",
      ""Location"": ""transferToken function (lines 47-49)""
    },
    {
      ""Issue"": ""No Approval Expiration or Time-based Controls"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract provides indefinite approvals with no mechanism to automatically expire them. This creates a long-term security risk if spenders are compromised."",
      ""Impact"": ""If a spender is compromised long after approval, they may still have access to the contract's tokens."",
      ""Location"": ""setNewSpender and updateSpenderAllowance functions (lines 26-40)""
    },
    {
      ""Issue"": ""Redundant ReentrancyGuard on transferToken"",
      ""Severity"": ""Informational"",
      ""Description"": ""The transferToken function uses the nonReentrant modifier, but since it's using SafeERC20's safeTransfer, which should already be safe against reentrancy, this guard may be redundant."",
      ""Impact"": ""Minimal impact; slight increase in gas costs due to unnecessary checks."",
      ""Location"": ""transferToken() function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 10
}",281.7753999233246,28750.0,30.0,"### **[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**

**Report Description**:
The `PaladinRewardReserve.sol` contract may encounter potential bugs if it uses new tokens as rewards. This could lead to unexpected behavior, especially if the new tokens have different implementations or behaviors compared to standard ERC20 tokens. The contract might not handle edge cases or specific token behaviors correctly, leading to vulnerabilities or operational failures.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of potential bugs arising from using new tokens as rewards. This is a missed issue, as the response list does not cover the risks associated with integrating new or non-standard tokens into the reward mechanism.

---

### **[M-08] Add a timelock to PaladinRewardReserve functions**

**Report Description**:
The owner of `PaladinRewardReserve` can approve and transfer any amount of tokens with no limits on any account. This lack of restrictions is not ideal for investors. To enhance trust and security, these functions should be put behind a timelock. A timelock would introduce a delay before critical actions are executed, allowing users to react or intervene if necessary.

**Match in Response List**:
Matches with the issue titled **""Centralized Control""**.

**Validation**:
**Partially Correct**. The response identifies the issue of centralized control, where all administrative functions are restricted to the owner, creating a single point of failure. However, it does not specifically address the need for a timelock mechanism to mitigate the risks associated with immediate token approvals and transfers. While the response highlights the risks of centralized control, it misses the specific solution (timelock) proposed in the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-08] Add a timelock to PaladinRewardReserve functions**

**Missed Issues from Issue Report**:
- **[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**

---

### **Conclusion**
The response list partially addresses one of the issues ([M-08]) but misses the other ([M-06]) entirely. The response to [M-08] is partially correct as it identifies the broader issue of centralized control but does not specifically mention the need for a timelock. The issue [M-06] is completely missed, indicating a gap in the response list's coverage of potential bugs related to new token integrations.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is zero."
