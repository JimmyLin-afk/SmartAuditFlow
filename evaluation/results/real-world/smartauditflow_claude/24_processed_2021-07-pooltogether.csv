nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}

",3524,331,"[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source

The function `swapYieldSource` SwappableYieldSource.sol` L307
Can be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check
However, if either the owner or the assetManager have malicious intent, this function allows them to instantly rug all funds
Create a contract that implements the function depositToken() external returns (address)
Be the Owner or AssetManager
Call setYieldSource while pointing at your malicious contract
Profit
 [H-02] redeemToken can fail for certain tokens
The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the ERC20.transferFrom(address(this), msg.sender, redeemableBalance) function for this. Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.  [H-03] setYieldSource leads to temporary wrong results
 The use of `setYieldSource` leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.
The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.
More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).
  [H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()
 `transferFunds()` will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  [M-01] Single-step process for critical ownership transfer/renounce is risky
 The `SwappableYieldSource` allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.
Given that AssetManager is derived from Ownable, the ownership management of this contract defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  [M-02] Use of `safeApprove` will always cause `approveMax` to revert

Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.
The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.

[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens

The supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212  [M-04] Old yield source still has infinite approval
 After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).

",8,,"pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";





contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  
  
  
  
  
  
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  
  
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  
  
  
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  
  
  
  
  
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  
  IYieldSource public yieldSource;

  
  function freeze() public initializer {
    
  }

  
  
  
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  
  
  
  
  
  
  
  
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  
  
  
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  
  
  
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  
  
  
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  
  
  
  
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  
  
  
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  
  
  
  
  
  
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  
  
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  
  
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  
  
  
  
  
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  
  
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  
  
  
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  
  
  
  
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  
  
  
  
  
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  
  
  
  
  
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  
  
  
  
  
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  
  
  
  
  
  
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",1938,4,4,"Based on the detailed code review and initial analysis, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the _requireYieldSource function for potential bypass mechanisms"",
        ""Review reentrancy protection in supplyTokenTo and redeemToken functions"",
        ""Validate integer overflow/underflow protection in share and token conversion methods"",
        ""Inspect staticcall implementation in _requireYieldSource for potential call manipulation"",
        ""Examine potential edge cases in _tokenToShares and _sharesToToken calculations""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the exact implementation of onlyOwnerOrAssetManager modifier"",
        ""Audit the ownership transfer and initialization process"",
        ""Validate restrictions on setYieldSource and swapYieldSource functions"",
        ""Check for potential privilege escalation vulnerabilities"",
        ""Review asset manager role and its permissions comprehensively""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze interactions with IYieldSource interface for potential external call vulnerabilities"",
        ""Review safeApprove and safeIncreaseAllowance implementations"",
        ""Validate deposit token validation logic across different yield sources"",
        ""Check for potential oracle or price manipulation risks"",
        ""Ensure proper error handling in external contract interactions""
      ]
    },
    {
      ""Area"": ""Token Economics & Shares"",
      ""Tasks"": [
        ""Thoroughly test share-to-token conversion mechanisms under various scenarios"",
        ""Validate share minting and burning logic for precision and accuracy"",
        ""Analyze potential rounding errors in token/share conversions"",
        ""Review economic implications of yield source swapping"",
        ""Check for potential share dilution or manipulation scenarios""
      ]
    },
    {
      ""Area"": ""Yield Source Swapping"",
      ""Tasks"": [
        ""Analyze the swapYieldSource function for potential fund loss risks"",
        ""Validate deposit token consistency across yield sources"",
        ""Test yield source swapping under different balance and market conditions"",
        ""Review transfer funds mechanism for potential interruption vulnerabilities"",
        ""Verify that fund transfers maintain user stake proportions""
      ]
    },
    {
      ""Area"": ""Upgradability & Initialization"",
      ""Tasks"": [
        ""Review the freeze() method for potential initialization bypass"",
        ""Validate initializer function access controls"",
        ""Check for potential reinitialize vulnerabilities"",
        ""Verify proxy contract upgrade path security"",
        ""Ensure proper contract state initialization""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Test contract behavior with zero-value transactions"",
        ""Validate error message clarity and specificity"",
        ""Check handling of unexpected token transfer behaviors"",
        ""Review require statement implementations for comprehensive validation"",
        ""Test contract under extreme input scenarios""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in share conversion methods"",
        ""Review repeated external calls for potential optimization"",
        ""Check storage variable usage and minimization strategies"",
        ""Evaluate function modifiers' gas impact"",
        ""Identify potential gas-efficient refactoring opportunities""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, functional, and economic aspects of the contract.
2. Each area targets specific potential vulnerabilities identified in the initial analysis.
3. Tasks are designed to be specific, actionable, and focused on critical contract mechanisms.
4. The approach considers both technical implementation details and broader economic implications.

Recommended Next Steps:
- Conduct a systematic audit following this task list
- Use formal verification tools for mathematical precision
- Perform extensive scenario-based testing
- Consider professional third-party security audits

Would you like me to elaborate on any specific area or provide more detailed guidance for the audit process?","I've conducted a thorough audit of the provided smart contract. Here's my analysis in the requested JSON format:

{
  ""ReviewingTheCode"": ""The code presents a SwappableYieldSource contract, which is an upgradeable ERC20 token that acts as a wrapper around another yield source. It allows users to deposit tokens and receive shares representing their stake in the underlying yield source. The contract also provides functionality to swap the underlying yield source without users needing to withdraw their funds."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SwappableYieldSource"",
    ""Purpose"": ""Serves as a wrapper around a yield source that can be swapped for another yield source without requiring users to manually withdraw and redeposit their funds."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ERC20Upgradeable"",
        ""IYieldSource"",
        ""AssetManager"",
        ""ReentrancyGuardUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"",
        ""@pooltogether/fixed-point/contracts/FixedPoint.sol"",
        ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"",
        ""./access/AssetManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""yieldSource"",
        ""Type"": ""IYieldSource"",
        ""Purpose"": ""Reference to the current underlying yield source contract""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""freeze"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Empty initializer function to prevent reinitialization"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireYieldSource"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Validates that a yield source address is not zero and is a valid implementation"",
        ""Parameters"": [""IYieldSource _yieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with a yield source, decimal places, symbol, name, and owner"",
        ""Parameters"": [""IYieldSource _yieldSource"", ""uint8 _decimals"", ""string _symbol"", ""string _name"", ""address _owner""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""approveMaxAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves the yield source to spend the maximum amount of deposit tokens"",
        ""Parameters"": [],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tokenToShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts token amounts to share amounts"",
        ""Parameters"": [""uint256 tokens""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_sharesToToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts share amounts to token amounts"",
        ""Parameters"": [""uint256 shares""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_mintShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and mints shares based on token amount"",
        ""Parameters"": [""uint256 mintAmount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burnShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and burns shares based on token amount"",
        ""Parameters"": [""uint256 burnAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""supplyTokenTo"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers tokens from sender to contract, supplies to yield source, and mints shares"",
        ""Parameters"": [""uint256 amount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositToken"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the deposit token from the yield source"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""balanceOfToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Converts a user's share balance to token amount"",
        ""Parameters"": [""address addr""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""redeemToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns shares and transfers redeemed tokens to user"",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_requireDifferentYieldSource"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Ensures a new yield source is different from the current one"",
        ""Parameters"": [""IYieldSource _yieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setYieldSource"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the yield source reference"",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""setYieldSource"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner or asset manager to change the yield source"",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_transferFunds"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers funds from one yield source to another"",
        ""Parameters"": [""IYieldSource _yieldSource"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""transferFunds"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner or asset manager to transfer funds between yield sources"",
        ""Parameters"": [""IYieldSource _yieldSource"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""swapYieldSource"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Changes the yield source and transfers all funds to the new source"",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""transferERC20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner or asset manager to transfer arbitrary ERC20 tokens from the contract"",
        ""Parameters"": [""IERC20Upgradeable erc20Token"", ""address to"", ""uint256 amount""],
        ""Returns"": [""bool""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IYieldSource - The contract interacts with an external yield source contract to deposit and redeem tokens"",
    ""IERC20Upgradeable - Interacts with ERC20 tokens for transfers, approvals, and balance checks"",
    ""FixedPoint - Used for mathematical calculations related to share-to-token conversion""
  ],
  
  ""SpecialMechanisms"": [
    ""Proxy Pattern - The contract is built to be upgradeable using the OpenZeppelin upgradeable contracts pattern"",
    ""Share-based Accounting - Uses an internal share system to represent proportional ownership of the yield pool"",
    ""Yield Source Swapping - Allows the underlying yield source to be changed without users having to move their funds"",
    ""Asset Management - Implements access control for certain operations through the AssetManager contract"",
    ""Reentrancy Protection - Uses ReentrancyGuard to prevent reentrancy attacks in key external functions""
  ],
  
  ""Questions"": [
    ""What is the exact implementation of AssetManager? The onlyOwnerOrAssetManager modifier isn't directly visible in the code."",
    ""The _requireYieldSource function uses a strange check with `isInvalidYieldSource = depositTokenAddress != address(0)` but then requires isInvalidYieldSource to be true. This seems to imply that a valid yield source must have a non-zero deposit token, but the logic is convoluted."",
    ""Is there a risk of fund loss if the swap process is interrupted? The contract first sets the new yield source and then transfers funds, which could be problematic if the latter fails."",
    ""How are the economics of share-to-token conversion affected during yield source changes, especially if the new yield source has different yield characteristics?"",
    ""In the transferERC20 function, it checks that the erc20Token isn't the yieldSource, but should be checking against the yieldSource's depositToken instead."",
    ""The approveMaxAmount function might be vulnerable to approval race conditions when a token doesn't support SafeERC20's safeIncreaseAllowance method.""
  ]
}

Based on my analysis, this contract appears to be a sophisticated wrapper around yield-generating protocols that allows for seamless transitions between different yield sources. While the core functionality seems well-designed, there are some potential issues with the validation logic and error handling, particularly around the yield source swapping process, that warrant further investigation.","I've analyzed the input data and combined similar issues. Here's the consolidated report:

{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect validation logic in _requireYieldSource"",
      ""Severity"": ""Critical"",
      ""Description"": ""The _requireYieldSource function contains a logical error in the validation of yield sources. The function incorrectly sets isInvalidYieldSource to true when depositTokenAddress != address(0), and then requires isInvalidYieldSource to be true. This inverts the intended validation - it considers a yield source valid only if its deposit token is NOT the zero address, which is the opposite of what should happen."",
      ""Impact"": ""This will reject valid yield sources and potentially accept invalid ones, leading to initialization failures or acceptance of malicious/incorrect yield sources. This could cause fund loss, contract dysfunction, or make the contract unusable."",
      ""Location"": ""Function _requireYieldSource (lines 83-110)""
    },
    {
      ""Issue"": ""Incorrect token transfer in redeemToken"",
      ""Severity"": ""Critical"",
      ""Description"": ""In the redeemToken function, tokens are transferred using safeTransferFrom instead of safeTransfer when sending tokens back to the user. This assumes the contract has previously been approved by itself to spend its own tokens, which is an unusual pattern and incorrect implementation."",
      ""Impact"": ""The redeemToken function will consistently fail due to lack of self-approval, preventing users from withdrawing their funds from the contract. This effectively locks user funds in the contract."",
      ""Location"": ""redeemToken function (lines 207-223)""
    },
    {
      ""Issue"": ""Reentrancy vulnerability in redeemToken"",
      ""Severity"": ""High"",
      ""Description"": ""While the redeemToken function is marked with nonReentrant modifier, there's a problematic operation sequence: it burns shares before calling external yieldSource.redeemToken and transferring tokens. This order of operations creates a potential attack vector if the external yield source is malicious or compromised."",
      ""Impact"": ""If the external yield source is compromised, it could potentially execute a reentrancy attack during the token redemption process, allowing an attacker to drain funds from the contract or manipulate contract state."",
      ""Location"": ""redeemToken function (lines 196-225)""
    },
    {
      ""Issue"": ""Vulnerable to price manipulation attacks"",
      ""Severity"": ""High"",
      ""Description"": ""The _tokenToShares and _sharesToToken functions calculate exchange rates based on current balances, which could be manipulated by an attacker through flash loans or large deposits/withdrawals right before legitimate users interact with the contract."",
      ""Impact"": ""An attacker could extract value from other users by manipulating the exchange rate, effectively stealing a portion of other users' funds. Users might receive fewer shares or tokens than expected."",
      ""Location"": ""Functions _tokenToShares (lines 110-157) and _sharesToToken (lines 127-175)""
    },
    {
      ""Issue"": ""Unlimited token approvals to yield sources"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract approves maximum uint256 amounts to external yield sources in multiple places (initialize, _setYieldSource, and approveMaxAmount functions). While this saves gas by not requiring reapprovals, it's generally discouraged as a security best practice."",
      ""Impact"": ""If the yield source contract is compromised or has vulnerabilities, an attacker could drain all tokens that have been approved to the maximum amount."",
      ""Location"": ""initialize function (line 104-140), _setYieldSource function (line 228-261), approveMaxAmount function (lines 137-144)""
    },
    {
      ""Issue"": ""Missing validation in transferFunds and swapYieldSource"",
      ""Severity"": ""Medium"",
      ""Description"": ""The transferFunds function doesn't validate if the provided _yieldSource is a valid yield source implementation or that it uses the same deposit token as the current yield source. Similarly, swapYieldSource has weak validation that only checks the new yield source is different from the current one."",
      ""Impact"": ""Could allow transferring funds to an incompatible or malicious yield source, potentially causing loss of funds or contract failure."",
      ""Location"": ""transferFunds function (lines 250-299), swapYieldSource function (lines 240-267)""
    },
    {
      ""Issue"": ""Lack of reentrancy protection in critical functions"",
      ""Severity"": ""Medium"", 
      ""Description"": ""Functions like setYieldSource, transferFunds, and swapYieldSource are not protected against reentrancy. Although the contract inherits from ReentrancyGuardUpgradeable, the nonReentrant modifier is not used on these functions that interact with external contracts."",
      ""Impact"": ""External calls to yield sources could potentially lead to reentrancy attacks if the yield sources are malicious or compromised."",
      ""Location"": ""Functions setYieldSource, transferFunds, swapYieldSource, and _transferFunds""
    },
    {
      ""Issue"": ""No slippage protection in token conversion"",
      ""Severity"": ""Medium"",
      ""Description"": ""When converting between tokens and shares in _tokenToShares and _sharesToToken, there's no slippage protection or minimum return values. This means users could receive fewer shares or tokens than expected if the exchange rate changes between transaction submission and execution."",
      ""Impact"": ""Users might experience unexpected losses during deposit or withdrawal operations, especially in volatile market conditions or when the contract is being manipulated."",
      ""Location"": ""Functions _tokenToShares and _sharesToToken""
    },
    {
      ""Issue"": ""Missing validation in transferERC20"",
      ""Severity"": ""Medium"",
      ""Description"": ""The transferERC20 function only prevents transfers of the yield source token, but does not prevent transfers of the underlying deposit token. Additionally, it doesn't verify that the 'to' address is not zero, which could lead to tokens being accidentally burned."",
      ""Impact"": ""The owner or asset manager could mistakenly drain the contract of its deposit tokens, essentially stealing from all users. Irreversible loss of tokens could occur if transferred to address(0)."",
      ""Location"": ""transferERC20 function (lines 271-286)""
    },
    {
      ""Issue"": ""Potential division by zero in _sharesToToken"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _sharesToToken function, there's a potential division by zero in the FixedPoint.calculateMantissa call if the totalSupply is non-zero but the yield source balance is zero. The function checks if totalSupply is zero but not if the yield source balance is zero."",
      ""Impact"": ""Could cause transactions to revert unexpectedly, potentially locking user funds temporarily."",
      ""Location"": ""Function _sharesToToken (lines 162-175)""
    },
    {
      ""Issue"": ""Missing or unchecked return values from external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not consistently check the return values of external calls to the yield source. For example, in supplyTokenTo and other functions that make external calls, the return values are not validated."",
      ""Impact"": ""If an external call fails silently, the contract may proceed with operations under incorrect assumptions, potentially leading to accounting errors or frozen funds."",
      ""Location"": ""Multiple locations including supplyTokenTo and external calls to yield source methods""
    },
    {
      ""Issue"": ""Potential DoS in swapYieldSource"",
      ""Severity"": ""Medium"",
      ""Description"": ""The swapYieldSource function transfers the entire balance from the old yield source to the new one in one transaction. For large balances, this might exceed gas limits or cause the transaction to fail."",
      ""Impact"": ""Could make it impossible to change the yield source if the balance is too large, effectively locking the contract to the current yield source."",
      ""Location"": ""swapYieldSource function""
    },
    {
      ""Issue"": ""Inappropriate freeze function implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""The freeze function is empty but marked as initializer, which is confusing and potentially misleading. It doesn't actually freeze anything despite its name and appears to be intended to prevent re-initialization but doesn't actually perform any checks or actions."",
      ""Impact"": ""While not directly exploitable, this could lead to confusion about the contract's functionality and potentially result in misuse or implementation errors."",
      ""Location"": ""freeze function (lines 78-88)""
    },
    {
      ""Issue"": ""Missing event emissions for critical actions"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important functions like supplyTokenTo, redeemToken, and approveMaxAmount don't emit events when performing critical actions, which makes it difficult to track important state changes off-chain."",
      ""Impact"": ""Reduces transparency and auditability of the contract operations, making it difficult to monitor contract activity."",
      ""Location"": ""Functions supplyTokenTo, redeemToken, and approveMaxAmount""
    }
  ],
  ""IssueNumber"": 57,
  ""OutputList"": 14
}",354.07290291786194,60031.0,32.0,"### **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**

**Report Description**:
The `swapYieldSource` function in `SwappableYieldSource.sol` can be called by the owner or Asset Manager. This function transfers all funds from the old Yield Source to the new one. If either the owner or Asset Manager has malicious intent, they can exploit this function to rug-pull all funds by setting a malicious Yield Source contract that implements `depositToken()`.

**Match in Response List**:
Matches with the issue titled **""Missing validation in transferFunds and swapYieldSource""**.

**Validation**:
**Partially Correct**. The response identifies the lack of validation in `swapYieldSource`, but it does not explicitly address the rug-pull risk posed by malicious owners or Asset Managers. The response focuses on the potential for transferring funds to an incompatible or malicious yield source, which is related but does not fully capture the severity of the issue.

---

### **[H-02] redeemToken can fail for certain tokens**

**Report Description**:
The `redeemToken` function in `SwappableYieldSource` uses `ERC20.transferFrom` to transfer tokens back to the sender. However, some token implementations may fail because `transferFrom` checks if the contract has approved itself for the `redeemableBalance`. This could prevent users from withdrawing their funds.

**Match in Response List**:
Matches with the issue titled **""Incorrect token transfer in redeemToken""**.

**Validation**:
**Correct**. The response accurately identifies the issue with using `safeTransferFrom` instead of `safeTransfer` in the `redeemToken` function. It correctly explains that this implementation will fail due to the lack of self-approval, which aligns with the issue described in the report.

---

### **[H-03] setYieldSource leads to temporary wrong results**

**Report Description**:
The `setYieldSource` function changes the underlying yield source but does not immediately transfer the underlying balances. This leaves the contract in an inconsistent state, causing `balanceOfToken` and `supplyTokenTo` to return incorrect results. Users may receive more shares than appropriate, leading to potential fund draining.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The inconsistency in contract state and the potential for users to receive incorrect shares is a significant vulnerability that is not covered in the response list.

---

### **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**

**Report Description**:
The `transferFunds()` function transfers funds from a specified yield source to the current yield source but fails to check if the deposit tokens are the same. If the specified yield source's assets are of higher valuation, a malicious owner or Asset Manager could exploit this to pocket the difference.

**Match in Response List**:
Matches with the issue titled **""Missing validation in transferFunds and swapYieldSource""**.

**Validation**:
**Partially Correct**. The response identifies the lack of validation in `transferFunds`, but it does not explicitly mention the risk of exploiting differences in deposit token valuations. The response is related but does not fully capture the severity of the issue.

---

### **[M-01] Single-step process for critical ownership transfer/renounce is risky**

**Report Description**:
The `SwappableYieldSource` contract uses `Ownable`'s `transferOwnership()` and `renounceOwnership()` methods, which are single-step processes. This is risky because any mistakes in transferring or renouncing ownership are irrecoverable, and ownership plays a critical role in the protocol.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the risk associated with single-step ownership transfer or renouncement. This is a significant issue that is not covered in the response list.

---

### **[M-02] Use of safeApprove will always cause approveMax to revert**

**Report Description**:
The `mStableYieldSource` uses OpenZeppelin’s `safeApprove()`, which is deprecated and will revert if the current allowance is not zero. This prevents the function from increasing the allowance once it is reduced, making it impossible to use as intended.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue with `safeApprove` and its potential to revert. This is a significant issue that is not covered in the response list.

---

### **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

**Report Description**:
The `supplyTokenTo` function assumes that the full `amount` of `_depositToken` is transferred to itself after calling `safeTransferFrom`. However, if the token is transfer-on-fee or deflationary, the received amount may be less than the accounted amount, leading to inconsistencies.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue with transfer-on-fee or deflationary tokens. This is a significant issue that is not covered in the response list.

---

### **[M-04] Old yield source still has infinite approval**

**Report Description**:
After swapping a yield source, the old yield source still has infinite approval. This could be exploited if the old yield source is not perfectly safe, as seen in previous attacks like Furucombo.

**Match in Response List**:
Matches with the issue titled **""Unlimited token approvals to yield sources""**.

**Validation**:
**Correct**. The response accurately identifies the issue with unlimited token approvals to yield sources, including the risk of old yield sources retaining infinite approval. This aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-02] redeemToken can fail for certain tokens**
- **[M-04] Old yield source still has infinite approval**

**Partially Correct Matches**:
- **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**
- **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**

**Missed Issues from Issue Report**:
- **[H-03] setYieldSource leads to temporary wrong results**
- **[M-01] Single-step process for critical ownership transfer/renounce is risky**
- **[M-02] Use of safeApprove will always cause approveMax to revert**
- **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

---

The response list covers some issues correctly or partially but misses several critical vulnerabilities, particularly those related to contract state inconsistencies, ownership management, and token handling. These gaps indicate a need for a more comprehensive review of the contract's security posture.","```
1. Incorrect token transfer in redeemToken
2. Unlimited token approvals to yield sources
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Incorrect token transfer in redeemToken"" appears at rank 2.
   - ""Unlimited token approvals to yield sources"" appears at rank 5.

2. **Calculate the precision at each rank**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Compute the Average Precision (AP)**:
   - AP = \( \frac{0.5 + 0.4}{2} = 0.45 \)

**Output**:
```
0.45
```"
