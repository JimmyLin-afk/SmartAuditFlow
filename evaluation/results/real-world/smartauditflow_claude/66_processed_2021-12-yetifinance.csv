nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,Match,Partially,Not Match,LLM-generated,matchList,MAP,Score
StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12382.0,1177.0,"[H-01] receiveCollateral() can be called by anyone

Submitted by jayjonah8, also found by dalgarim and kenzo
Impact

In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments, but anyone can call it passing in _tokens and _amounts args to update stability pool balances.",1.0,,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";



contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    
    ISortedTroves internal sortedTroves;

    
    uint256 internal totalYUSDDeposits;

    
    
    
    newColls internal totalColl;

    

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; 

    
    mapping(address => Snapshots) public depositSnapshots; 

    mapping(address => FrontEnd) public frontEnds; 
    mapping(address => uint256) public frontEndStakes; 
    mapping(address => Snapshots) public frontEndSnapshots; 

    
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    
    uint128 public currentScale;

    
    uint128 public currentEpoch;

    
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    
    uint256 public lastYETIError;
    
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    

    
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    

    
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        
        
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    

    
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); 
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    


    
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    

    
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    
    
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    
    
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    

    
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    
    
    
    
    
    
    
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            
            compoundedStake = 0;
        }

        
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    

    
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    

    
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    
    
    
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",7250.0,1.0,0.0,"Based on the comprehensive analysis of the StabilityPool contract, I'll create a detailed task list focusing on key audit areas:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in external calls, especially in provideToSP and withdrawFromSP methods"",
        ""Check for potential integer overflow/underflow in mathematical operations, despite SafeMath usage"",
        ""Validate input validation and sanitization in all external and public methods"",
        ""Verify that critical state changes are properly protected against unauthorized modifications""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyOwner modifier usage and ownership transfer mechanisms"",
        ""Review permission checks in critical methods like setAddresses, offset, and receiveCollateral"",
        ""Verify front-end registration and kickback rate implementation for potential exploitation"",
        ""Check the implementation of _requireCallerIs* methods for comprehensive access control""
      ]
    },
    {
      ""Area"": ""Complex Calculation Mechanisms"",
      ""Tasks"": [
        ""Thoroughly review _computeRewardsPerUnitStaked method for potential precision loss or manipulation"",
        ""Verify the error correction mechanisms in reward calculations (lastYETIError, lastAssetError_Offset)"",
        ""Audit the epoch and scale tracking system for potential edge cases"",
        ""Validate the compounding logic in _getCompoundedStakeFromSnapshots method""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify safe interaction with all imported interfaces (ICommunityIssuance, IWhitelist, etc.)"",
        ""Check for proper validation of external contract addresses in setAddresses method"",
        ""Audit the collateral receiving and sending mechanisms for potential vulnerabilities"",
        ""Verify that wrapped asset handling (IWAsset) is secure and doesn't introduce additional risks""
      ]
    },
    {
      ""Area"": ""Reward Distribution"",
      ""Tasks"": [
        ""Analyze the YETI reward distribution mechanism for fairness and potential manipulation"",
        ""Verify the front-end kickback rate implementation"",
        ""Check the precision and accuracy of reward calculations across different scenarios"",
        ""Validate the handling of edge cases in reward distribution (zero deposits, partial withdrawals)""
      ]
    },
    {
      ""Area"": ""Economic Attack Vectors"",
      ""Tasks"": [
        ""Identify potential flash loan attack surfaces in deposit and withdrawal mechanisms"",
        ""Check for possible economic manipulation through front-running or sandwich attacks"",
        ""Verify the robustness of liquidation offset mechanisms"",
        ""Analyze potential ways to game the reward distribution system""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Review the efficiency of complex mapping and array operations"",
        ""Analyze the gas cost of reward calculation methods"",
        ""Check for potential optimizations in loop structures"",
        ""Verify that error tracking mechanisms don't introduce unnecessary gas overhead""
      ]
    },
    {
      ""Area"": ""Error Handling and Recovery"",
      ""Tasks"": [
        ""Verify comprehensive error handling in critical methods"",
        ""Check the robustness of error correction mechanisms"",
        ""Validate emergency stop or pause functionality"",
        ""Review error messaging for clarity and potential information leakage""
      ]
    },
    {
      ""Area"": ""Collateral Management"",
      ""Tasks"": [
        ""Audit the addCollateralType method for potential security risks"",
        ""Verify the whitelist integration and collateral validation processes"",
        ""Check the handling of multiple collateral types in reward and offset calculations"",
        ""Validate the total collateral tracking mechanism""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The contract has complex reward calculation mechanisms that require meticulous verification.
2. Multiple external interactions necessitate thorough interface and interaction checks.
3. The multi-collateral nature adds complexity to reward distribution and tracking.
4. Error correction and precision maintenance are critical areas of focus.

The task list provides a comprehensive approach to auditing the StabilityPool contract, addressing potential vulnerabilities, complex logic, and economic risks. Each task is designed to systematically examine different aspects of the contract's implementation.

Recommended Next Steps:
1. Conduct a detailed line-by-line code review
2. Develop comprehensive test cases covering edge cases
3. Perform static and dynamic analysis
4. Consider formal verification of complex mathematical operations

Would you like me to elaborate on any specific area or provide more detailed guidance on approaching these audit tasks?","After reviewing the StabilityPool contract, I'll provide a detailed analysis of its components and functionality.

{
  ""ReviewingTheCode"": ""The StabilityPool contract is part of a larger DeFi protocol similar to Liquity. It manages a pool where users can deposit YUSD (a stablecoin) to earn collateral from liquidated troves and YETI rewards. The contract handles complex accounting for deposits, rewards, and liquidation processes."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""StabilityPool"",
    ""Purpose"": ""Manages a stability pool that allows users to deposit YUSD tokens and earn collateral from liquidated troves and YETI rewards. It also provides a mechanism for offsetting debt during liquidations in the protocol."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""LiquityBase"", ""Ownable"", ""CheckContract"", ""IStabilityPool""],
      ""Imports"": [
        ""IBorrowerOperations"", ""IStabilityPool"", ""ITroveManager"", ""IYUSDToken"", 
        ""ISortedTroves"", ""ICommunityIssuance"", ""IWhitelist"", ""IERC20"", ""IWAsset"", 
        ""LiquityBase"", ""SafeMath"", ""LiquitySafeMath128"", ""Ownable"", ""CheckContract"", ""SafeERC20""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Identifier for the contract""
      },
      {
        ""Name"": ""troveManagerLiquidationsAddress"",
        ""Type"": ""address internal"",
        ""Purpose"": ""Address of the trove manager liquidations contract""
      },
      {
        ""Name"": ""whitelistAddress"",
        ""Type"": ""address internal"",
        ""Purpose"": ""Address of the whitelist contract""
      },
      {
        ""Name"": ""totalYUSDDeposits"",
        ""Type"": ""uint256 internal"",
        ""Purpose"": ""Total amount of YUSD deposited in the stability pool""
      },
      {
        ""Name"": ""totalColl"",
        ""Type"": ""newColls internal"",
        ""Purpose"": ""Tracking the total collateral in the pool (with arrays for token addresses and amounts)""
      },
      {
        ""Name"": ""P"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Product of terms used to track compounded deposits""
      },
      {
        ""Name"": ""currentScale"",
        ""Type"": ""uint128 public"",
        ""Purpose"": ""Current scale factor for reward calculations""
      },
      {
        ""Name"": ""currentEpoch"",
        ""Type"": ""uint128 public"",
        ""Purpose"": ""Current epoch for reward calculations""
      },
      {
        ""Name"": ""deposits"",
        ""Type"": ""mapping(address => Deposit)"",
        ""Purpose"": ""Maps depositor addresses to their deposit information""
      },
      {
        ""Name"": ""depositSnapshots"",
        ""Type"": ""mapping(address => Snapshots)"",
        ""Purpose"": ""Maps depositor addresses to their reward snapshots""
      },
      {
        ""Name"": ""frontEnds"",
        ""Type"": ""mapping(address => FrontEnd)"",
        ""Purpose"": ""Maps front-end addresses to their information""
      },
      {
        ""Name"": ""frontEndStakes"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maps front-end addresses to their staked amounts""
      },
      {
        ""Name"": ""frontEndSnapshots"",
        ""Type"": ""mapping(address => Snapshots)"",
        ""Purpose"": ""Maps front-end addresses to their reward snapshots""
      },
      {
        ""Name"": ""epochToScaleToSum"",
        ""Type"": ""mapping(address => mapping(uint128 => mapping(uint128 => uint256)))"",
        ""Purpose"": ""Maps collateral, epoch, and scale to cumulative reward sums""
      },
      {
        ""Name"": ""epochToScaleToG"",
        ""Type"": ""mapping(uint128 => mapping(uint128 => uint256))"",
        ""Purpose"": ""Maps epoch and scale to cumulative YETI reward sums""
      },
      {
        ""Name"": ""lastYETIError"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Tracks accumulated error in YETI reward calculations""
      },
      {
        ""Name"": ""lastAssetError_Offset"",
        ""Type"": ""uint256[] public"",
        ""Purpose"": ""Tracks accumulated errors in collateral reward calculations""
      },
      {
        ""Name"": ""lastYUSDLossError_Offset"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Tracks accumulated error in YUSD loss calculations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initialize contract addresses and renounce ownership"",
        ""Parameters"": [""Multiple address parameters for protocol components""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideToSP"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allow users to deposit YUSD into the stability pool"",
        ""Parameters"": [""_amount: amount to deposit"", ""_frontEndTag: front-end address to tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFromSP"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allow users to withdraw YUSD from the stability pool"",
        ""Parameters"": [""_amount: amount to withdraw""],
        ""Returns"": []
      },
      {
        ""Name"": ""offset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Handle liquidation offsets when troves are liquidated"",
        ""Parameters"": [""_debtToOffset: debt amount"", ""_tokens: collateral tokens"", ""_amountsAdded: collateral amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""getDepositorGains"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculate collateral gains for a depositor"",
        ""Parameters"": [""_depositor: user address""],
        ""Returns"": [""address[]: collateral tokens"", ""uint256[]: collateral amounts""]
      },
      {
        ""Name"": ""getDepositorYETIGain"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculate YETI token rewards for a depositor"",
        ""Parameters"": [""_depositor: user address""],
        ""Returns"": [""uint256: YETI reward amount""]
      },
      {
        ""Name"": ""getCompoundedYUSDDeposit"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculate a depositor's compounded YUSD deposit after applying loss"",
        ""Parameters"": [""_depositor: user address""],
        ""Returns"": [""uint256: compounded deposit amount""]
      },
      {
        ""Name"": ""registerFrontEnd"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Register an address as a front-end with a kickback rate"",
        ""Parameters"": [""_kickbackRate: percentage of YETI rewards to give to depositors""],
        ""Returns"": []
      },
      {
        ""Name"": ""_triggerYETIIssuance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Trigger YETI token issuance from community issuance contract"",
        ""Parameters"": [""_communityIssuance: community issuance contract""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateG"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Update the G variable for YETI reward calculations"",
        ""Parameters"": [""_YETIIssuance: amount of YETI to distribute""],
        ""Returns"": []
      },
      {
        ""Name"": ""_computeRewardsPerUnitStaked"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate collateral gains and YUSD losses per unit staked during offset"",
        ""Parameters"": [""_tokens, _amountsAdded, _debtToOffset, _totalYUSDDeposits""],
        ""Returns"": [""AssetGainPerUnitStaked, YUSDLossPerUnitStaked""]
      },
      {
        ""Name"": ""_updateRewardSumAndProduct"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Update reward sums and product factors during offset"",
        ""Parameters"": [""_assets, _AssetGainPerUnitStaked, _YUSDLossPerUnitStaked""],
        ""Returns"": []
      },
      {
        ""Name"": ""receiveCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Receive collateral from the active pool"",
        ""Parameters"": [""_tokens: collateral tokens"", ""_amounts: collateral amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralType"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Add a new collateral type to the stability pool"",
        ""Parameters"": [""_collateral: new collateral address""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IBorrowerOperations - For borrower operations in the protocol"",
    ""ITroveManager - For managing troves (loans)"",
    ""IYUSDToken - The stablecoin token contract"",
    ""ISortedTroves - For accessing sorted list of troves"",
    ""ICommunityIssuance - For YETI token rewards distribution"",
    ""IWhitelist - For checking valid collateral types"",
    ""IERC20 - For interacting with ERC20 tokens"",
    ""IWAsset - For handling wrapped assets"",
    ""IActivePool - For accessing the active pool of the protocol""
  ],
  
  ""SpecialMechanisms"": [
    ""Compounding mechanism that tracks user deposits through epochs and scales"",
    ""Complex multi-collateral reward accounting system that handles proportional distribution"",
    ""Front-end kickback system allowing UI providers to earn a portion of rewards"",
    ""Error correction system that captures and reapplies rounding errors in calculations"",
    ""Scale and epoch mechanisms to handle edge cases in deposit compounding""
  ],
  
  ""Questions"": [
    ""How is the protocol ensuring that the system can't be manipulated through flash loans or similar attacks?"",
    ""What happens if all troves are under-collateralized at the same time?"",
    ""How is the precision loss handled in the reward calculation mechanisms?"",
    ""What happens to the rewards accrued if a user's compounded deposit drops to zero due to liquidations?"",
    ""Could the complexity of the reward tracking system cause gas inefficiencies for users with small deposits?"",
    ""How does the whitelist verification work and what safeguards prevent adding malicious tokens?""
  ]
}

Based on my analysis, this StabilityPool contract is part of a multi-collateral lending protocol similar to Liquity. It allows users to deposit the system's stablecoin (YUSD) to earn rewards from liquidated troves and YETI token incentives. 

The contract implements complex accounting mechanisms including:
1. A deposit tracking system that handles compounding through epochs and scales
2. Multi-collateral reward distribution based on proportional contributions
3. Front-end registration and kickback system for UI providers
4. Error correction for rounding imprecisions in calculations

The security aspects are well-considered with multiple access controls, validation requirements, and precision maintenance mechanisms. However, the complexity of the calculations and state tracking could potentially lead to edge cases or gas inefficiencies that would require further testing.","I'll analyze the provided findings and consolidate similar issues into a comprehensive report, sorted by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions in the StabilityPool contract violate the checks-effects-interactions pattern by making external calls before updating internal state. This occurs in provideToSP, withdrawFromSP, and _sendGainsToDepositor functions where the contract sends rewards/tokens to users before updating its state. An attacker could potentially reenter the contract through malicious token implementations."",
      ""Impact"": ""An attacker could potentially reenter the contract through a malicious token's transfer function and manipulate the state before the original function completes, potentially draining funds from the stability pool or corrupting its state."",
      ""Location"": ""provideToSP function (lines 324-371), withdrawFromSP function (lines 374-416), and _sendGainsToDepositor function (lines 740-767)""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Risks"",
      ""Severity"": ""High"",
      ""Description"": ""Despite using SafeMath for many operations, there are instances where arithmetic operations don't use SafeMath, particularly in reward calculations such as YUSDLossPerUnitStaked calculation with '.add(1)'. In _updateRewardSumAndProduct, when calculating the new P value, overflow could occur when multiplying by SCALE_FACTOR (1e9)."",
      ""Impact"": ""Integer overflow could cause incorrect reward calculations, potentially allowing users to extract more collateral than they're entitled to or leading to locked funds."",
      ""Location"": ""_computeRewardsPerUnitStaked function (lines 419-454), _updateRewardSumAndProduct function (lines 474-564)""
    },
    {
      ""Issue"": ""Missing Input Validation for Arrays"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions that accept arrays as parameters (offset, receiveCollateral) don't validate that the arrays match expected lengths or structures. Specifically, the contract does not validate that _tokens and _amountsAdded arrays have the same length before processing them, which could lead to inconsistent state updates."",
      ""Impact"": ""If arrays with mismatched lengths are passed, it could lead to out-of-bounds access, incomplete collateral handling, token theft, or incorrect accounting, potentially corrupting the pool's state."",
      ""Location"": ""offset function (lines 391-498), receiveCollateral function (lines 942-954)""
    },
    {
      ""Issue"": ""Unbounded Operations in Loops"",
      ""Severity"": ""High"",
      ""Description"": ""The contract performs operations on arrays whose length is determined by the number of collateral tokens, without bounds checking. If the whitelist contains too many tokens, functions could hit block gas limits and fail. This affects all functions that iterate through totalColl.tokens."",
      ""Impact"": ""If too many collateral types are added to the whitelist, core functions like withdrawFromSP() could become unusable due to out-of-gas errors, effectively locking user funds."",
      ""Location"": ""getDepositorGains(), _calculateGains(), _updateDepositAndSnapshots(), and other functions iterating through all collateral types""
    },
    {
      ""Issue"": ""Flash Loan Attack Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The offset function, which is called during liquidations, updates rewards based on the current state. This could be manipulated in combination with flash loans to extract more value than entitled to."",
      ""Impact"": ""An attacker could use flash loans to manipulate the reward distribution in their favor, extracting excess value from the protocol."",
      ""Location"": ""offset function (lines 486-498)""
    },
    {
      ""Issue"": ""Missing Initialization Check in setAddresses"",
      ""Severity"": ""High"",
      ""Description"": ""The setAddresses function doesn't check if the contract has already been initialized. Although it has the onlyOwner modifier, this could still be problematic if ownership isn't immediately relinquished after initialization."",
      ""Impact"": ""If the owner doesn't call _renounceOwnership(), they could potentially call setAddresses again and redirect the contract to interact with malicious contracts."",
      ""Location"": ""setAddresses function (lines 126-213)""
    },
    {
      ""Issue"": ""Uninitialized Array Length Issues"",
      ""Severity"": ""High"",
      ""Description"": ""The lastAssetError_Offset array must be properly initialized when new collateral types are added. If addCollateralType() is not called before using a new collateral type, array access could be out of bounds. This array is used in offset() and _computeRewardsPerUnitStaked()."",
      ""Impact"": ""This could lead to out-of-bounds array access, causing the transaction to revert, or potentially corrupt data if the array length doesn't match the number of collateral types."",
      ""Location"": ""offset() function, _computeRewardsPerUnitStaked() function, and lastAssetError_Offset state variable""
    },
    {
      ""Issue"": ""Withdrawal under Low ICR Conditions"",
      ""Severity"": ""Medium"",
      ""Description"": ""In withdrawFromSP(), the check _requireNoUnderCollateralizedTroves() is bypassed when _amount is 0, allowing users to withdraw rewards even when some troves are undercollateralized. This could lead to potential gaming of the system by malicious users."",
      ""Impact"": ""Users could potentially extract collateral gains without restrictions when troves are undercollateralized, which might destabilize the system during market stress."",
      ""Location"": ""withdrawFromSP() function""
    },
    {
      ""Issue"": ""Scale Overflow and Handling Limitations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has issues with scale factor handling: 1) In _updateRewardSumAndProduct(), when the scale is incremented, there's no check to prevent uint128 overflow. 2) In _getCompoundedStakeFromSnapshots, scaling is limited to handling only one scale change (scaleDiff <= 1). If scaleDiff > 1, the function returns 0, which could lead to users losing their stake."",
      ""Impact"": ""An overflow in the scale value would reset it to 0, disrupting reward distribution. Users who haven't interacted with the contract for a long time could lose their entire stake if multiple scale changes happen."",
      ""Location"": ""_updateRewardSumAndProduct() where currentScale is incremented and _getCompoundedStakeFromSnapshots() function (lines 603-738)""
    },
    {
      ""Issue"": ""Precision Loss in Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several instances of division-before-multiplication operations are present in the contract, which can lead to significant precision loss. For example, in _getGainFromSnapshots and _getYETIGainFromSnapshots, the functions divide before multiplying, which may result in truncation. The YUSDLossPerUnitStaked calculation has a hardcoded +1 addition that could lead to rounding errors."",
      ""Impact"": ""Users may receive fewer rewards than they should due to rounding errors, and these errors could accumulate over time, leading to systematic value extraction from users."",
      ""Location"": ""_getGainFromSnapshots (lines 500-626), _getYETIGainFromSnapshots (lines 679-693), _computeYETIPerUnitStaked, and _computeRewardsPerUnitStaked functions""
    },
    {
      ""Issue"": ""Potential Division by Zero"",
      ""Severity"": ""Medium"",
      ""Description"": ""In several places, such as _computeRewardsPerUnitStaked(), there are division operations where the divisor could potentially be zero, e.g., when _totalYUSDDeposits is very small due to withdrawals."",
      ""Impact"": ""Although there are some checks, edge cases might still lead to division by zero errors, causing transactions to revert and potentially locking functionality."",
      ""Location"": ""_computeRewardsPerUnitStaked(), _getCompoundedStakeFromSnapshots(), and similar calculation functions""
    },
    {
      ""Issue"": ""Centralization Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has centralization risks in two main areas: 1) The whitelist contract controls valid collateral tokens. 2) Critical contract addresses are set by the owner in setAddresses. While ownership is renounced after setup, there are still dependencies on other centrally controlled contracts."",
      ""Impact"": ""If the whitelist contract is compromised or manipulated, it could lead to invalid tokens being accepted as collateral. If the owner sets incorrect addresses before renouncing ownership, the entire system could become unusable."",
      ""Location"": ""addCollateralType() function, setAddresses() function, and references to whitelist throughout the contract""
    },
    {
      ""Issue"": ""Frontend Kickback Rate Manipulation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Frontend operators can register with a specific kickback rate but there's no mechanism to prevent them from changing this rate after users have deposited funds with their tag. This could be exploited by operators who initially offer high kickback rates to attract deposits and then reduce rates to increase their own profits."",
      ""Impact"": ""Depositors may receive less YETI rewards than expected based on the kickback rate advertised when they made their deposit."",
      ""Location"": ""registerFrontEnd function and lack of constraints on changing kickback rates after registration""
    },
    {
      ""Issue"": ""Lack of Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The offset function and provideToSP/withdrawFromSP functions don't include any slippage protection. The StabilityPool accepts whatever amounts of collateral are provided without any verification that these amounts are fair or match expected values."",
      ""Impact"": ""In case of front-running attacks or market manipulation, users might receive significantly less than expected if market conditions change between transaction submission and execution."",
      ""Location"": ""offset function, provideToSP and withdrawFromSP functions""
    },
    {
      ""Issue"": ""Lack of Zero Address Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate that address parameters are not the zero address in several functions, particularly when setting front end tags or in the setAddresses function."",
      ""Impact"": ""If zero addresses are used, it could lead to unexpected behavior or locked funds."",
      ""Location"": ""setAddresses function and _setFrontEndTag function""
    },
    {
      ""Issue"": ""Incorrect Error Handling in Offset Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The error offset tracking mechanism in _computeRewardsPerUnitStaked has flawed logic where lastYUSDLossError_Offset is calculated by subtracting the numerator from the product rather than the other way around, potentially leading to incorrect tracking of accumulated errors."",
      ""Impact"": ""Over time, this could result in increasingly inaccurate calculations of rewards and losses, disadvantaging either the protocol or its users."",
      ""Location"": ""_computeRewardsPerUnitStaked() function (lines 436-440)""
    },
    {
      ""Issue"": ""Inconsistent State Updates in receiveCollateral"",
      ""Severity"": ""Medium"",
      ""Description"": ""The receiveCollateral function updates totalColl.amounts but does not verify that the _tokens array matches the existing tokens in totalColl. This could lead to inconsistencies between the tokens and amounts arrays in the totalColl structure."",
      ""Impact"": ""Misalignment between token addresses and their corresponding amounts could cause incorrect accounting and potentially loss of funds during withdrawals or liquidations."",
      ""Location"": ""receiveCollateral() function (lines 942-947)""
    },
    {
      ""Issue"": ""Front-running Vulnerability in provideToSP"",
      ""Severity"": ""Low"",
      ""Description"": ""The provideToSP function and registerFrontEnd function are vulnerable to front-running, where MEV extractors could observe pending transactions and insert their own transactions to manipulate rewards distribution or register popular front end addresses before legitimate owners."",
      ""Impact"": ""Users might receive fewer rewards than expected due to front-running manipulation, and legitimate front ends could lose their expected position and rewards to attackers."",
      ""Location"": ""provideToSP() function (lines 222-269) and registerFrontEnd function""
    },
    {
      ""Issue"": ""Missing Return Value Check for ERC20 Transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract uses SafeERC20 for some token operations, in the _sendGainsToDepositor function it directly calls transfer on the asset token without checking return values. Some tokens don't revert on failed transfers but return false instead."",
      ""Impact"": ""Failed transfers might not be detected, leading to accounting inconsistencies where users are recorded as having received tokens they never actually got."",
      ""Location"": ""_sendGainsToDepositor() function (line 762)""
    },
    {
      ""Issue"": ""Insufficient Event Emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes are not accompanied by events, particularly in addCollateralType function and when updating error offset variables. This makes it difficult to track the contract's state off-chain."",
      ""Impact"": ""This makes monitoring the contract more difficult and could hide subtle bugs or attacks."",
      ""Location"": ""Throughout the contract, particularly in state-changing functions like addCollateralType""
    },
    {
      ""Issue"": ""Missing Decimals Normalization"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't normalize for different token decimals when handling multiple collateral types. This assumes all tokens have the same decimal precision, which isn't always true for ERC20 tokens."",
      ""Impact"": ""Tokens with different decimals would be treated inconsistently, potentially undervaluing or overvaluing certain collateral types and creating imbalances in the system."",
      ""Location"": ""Throughout the contract's collateral handling logic""
    },
    {
      ""Issue"": ""Inefficient Data Structure for Collateral Tracking"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses multiple arrays to track different collateral types, which requires loops through all assets for many operations. This becomes increasingly inefficient as more collateral types are added."",
      ""Impact"": ""Gas costs for operations increase linearly with the number of collateral types, potentially making the contract unusable if too many collateral types are supported."",
      ""Location"": ""Throughout the contract, particularly in functions that iterate through all collateral types""
    }
  ],
  ""IssueNumber"": 85,
  ""OutputList"": 21
}",434.421817064285,133746.0,32.0,"### **[H-01] receiveCollateral() can be called by anyone**

**Report Description**:  
In `StabilityPool.sol`, the `receiveCollateral()` function is intended to be called exclusively by `ActivePool`, as indicated by the comments. However, the function lacks access control, allowing anyone to call it by passing `_tokens` and `_amounts` arguments. This oversight enables unauthorized users to update stability pool balances, potentially leading to incorrect accounting, manipulation of the pool's state, or even loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent State Updates in receiveCollateral""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `receiveCollateral()` and correctly notes that the function does not verify whether the `_tokens` array matches the existing tokens in `totalColl`, leading to potential inconsistencies. However, the response misses the critical detail that the function lacks access control, which is the primary vulnerability reported in the issue. While the response partially addresses the problem, it does not fully capture the severity or the core issue of unauthorized access.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-01] receiveCollateral() can be called by anyone**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis**  
The response partially addresses the issue by identifying inconsistencies in state updates but fails to highlight the lack of access control, which is the primary vulnerability. This oversight reduces the sufficiency of the response. To fully address the issue, the response should explicitly mention the access control flaw and its potential impact on the contract's security.",1,0,0,21,"```
None.
```",0.0,0.0625
sYetiToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; // Underflow is checked
                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3595.0,338.0,"[H-02] Yeti token rebase checks the additional token amount incorrectly

function `rebuse`, `effectiveYetiTokenBalance`
`yetiToken.balance - effectiveYetiTokenBalance`â€¨
The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added toÂ effectiveYetiTokenBalanceÂ during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.
The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total usersâ€™ claims. In other words, the contract will be in default if enough users claim after that.

[M-01] WrongÂ lastBuyBackPrice

Submitted by cmichel
TheÂ sYETIToken.lastBuyBackPriceÂ is set inÂ buyBackÂ and hardcoded as:
function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {
    require(YUSDToSell > 0, ""Zero amount"");
    require(lastBuybackTime + 69 hours < block.timestamp, ""Must have 69 hours pass before another buyBack"");
    yusdToken.approve(routerAddress, YUSDToSell);
    uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);
    lastBuybackTime = block.timestamp;
    // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
    // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)
    lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
    emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]);
}

It divides the first and second returnÂ amountsÂ of the swap, however, these amounts depend on the swapÂ pathÂ parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).",2.0,,"pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}












contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    
    
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    
    mapping(address => User) public users;
    
    mapping(address => mapping(address => uint256)) public override allowance;
    
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                users[to].balance = toUser.balance + shares128; 
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    
    
    
    
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    
    
    
    
    
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    
    
    
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    
    
    
    
    
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    
    
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        
        
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        
        

        
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        
        
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    
    
    
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",2343.0,1.0,1.0,"Based on the comprehensive initial analysis, here's a structured task list for auditing the sYETIToken contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze potential reentrancy risks in mint(), burn(), and _buyBack() functions"",
        ""Review transfer and transferFrom methods for integer overflow/underflow vulnerabilities"",
        ""Verify safe division implementation in div() function"",
        ""Check for potential unprotected external calls in mint and burn methods"",
        ""Validate input validation and boundary checks across all external functions""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify ownership mechanisms inherited from BoringOwnable"",
        ""Review addValidRouter and removeValidRouter for potential centralization risks"",
        ""Assess the single point of failure risks with owner-only functions"",
        ""Validate the addressesSet mechanism for preventing multiple address configurations""
      ]
    },
    {
      ""Area"": ""Staking & Rewards Mechanism"",
      ""Tasks"": [
        ""Analyze the rebasing mechanism for potential economic exploits"",
        ""Review the transfer ratio implementation and its potential manipulation"",
        ""Validate the time-lock mechanism (LOCK_TIME) for staked tokens"",
        ""Assess the shares calculation logic in mint() and burn() functions"",
        ""Check the calculation of effectiveYetiTokenBalance for accuracy""
      ]
    },
    {
      ""Area"": ""Token Economics"",
      ""Tasks"": [
        ""Evaluate the buyback mechanism for potential price manipulation"",
        ""Review the lastBuybackPrice calculation and its usage"",
        ""Verify the _getValueOfContract method for potential economic vulnerabilities"",
        ""Assess the impact of transfer ratio on long-term token economics""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify safe interactions with YETI, YUSD, and router contracts"",
        ""Check allowance and approval mechanisms for external contract interactions"",
        ""Review permit implementation for potential signature replay attacks"",
        ""Validate router whitelist mechanism for preventing unauthorized swaps""
      ]
    },
    {
      ""Area"": ""Compliance & Standards"",
      ""Tasks"": [
        ""Verify full ERC20 standard compliance"",
        ""Review EIP-2612 permit implementation for standard adherence"",
        ""Check decimal handling and total supply management"",
        ""Validate event emissions for key state changes""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of key functions"",
        ""Review use of BoringMath libraries for gas efficiency"",
        ""Check storage variable packing and optimization"",
        ""Evaluate computational complexity of rebasing and buyback mechanisms""
      ]
    },
    {
      ""Area"": ""Emergency & Edge Cases"",
      ""Tasks"": [
        ""Identify potential scenarios where contract could become stuck"",
        ""Review handling of zero-value or dust transactions"",
        ""Check error handling and revert conditions"",
        ""Verify behavior with extreme input values"",
        ""Assess contract's resilience to potential economic attacks""
      ]
    },
    {
      ""Area"": ""Cryptographic Operations"",
      ""Tasks"": [
        ""Review permit signature verification logic"",
        ""Validate domain separator implementation"",
        ""Check nonce management for preventing signature replay"",
        ""Verify ecrecover usage in permit method""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the sYETIToken contract, covering critical areas of security, functionality, and economic design. Each task is specific, actionable, and directly addresses potential risks identified in the initial analysis.

The tasks are prioritized to first address critical security vulnerabilities, then move through access control, economic mechanisms, external interactions, and finally performance and edge cases.

Would you like me to elaborate on any specific area or provide more detailed guidance for any of these audit tasks?","After a careful analysis of the provided smart contract code, here is my audit report:

{
  ""ReviewingTheCode"": ""The contract implements a staked token (sYETI) system for the YETI token. It allows users to stake YETI tokens and receive sYETI tokens, with staking rewards through rebasing. The contract includes features for burning tokens, buying back tokens through a router, and implementing a time-lock mechanism."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""sYETIToken"",
    ""Purpose"": ""Implements a staking mechanism for YETI tokens, allowing users to earn rewards through rebasing and buybacks"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IERC20"", ""Domain"", ""BoringOwnable""],
      ""Imports"": [
        ""BoringMath"", 
        ""BoringERC20"", 
        ""Domain"", 
        ""ERC20"", 
        ""IERC20"", 
        ""BoringOwnable"",
        ""IsYETIRouter""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""symbol"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Symbol for the staked token (sYETI)""
      },
      {
        ""Name"": ""name"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Name for the staked token (Staked YETI Tokens)""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""uint8 constant"",
        ""Purpose"": ""Decimal precision for the token (18)""
      },
      {
        ""Name"": ""totalSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total supply of sYETI tokens""
      },
      {
        ""Name"": ""LOCK_TIME"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Time period for locking staked tokens (69 hours)""
      },
      {
        ""Name"": ""effectiveYetiTokenBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the total YETI tokens effectively backing sYETI""
      },
      {
        ""Name"": ""lastBuybackTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last buyback operation""
      },
      {
        ""Name"": ""lastBuybackPrice"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Price from the last buyback operation""
      },
      {
        ""Name"": ""lastRebaseTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last rebase operation""
      },
      {
        ""Name"": ""transferRatio"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Ratio for determining how much YETI to add during rebase""
      },
      {
        ""Name"": ""yetiToken"",
        ""Type"": ""IYETIToken"",
        ""Purpose"": ""Reference to the YETI token contract""
      },
      {
        ""Name"": ""yusdToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""Reference to the YUSD token contract""
      },
      {
        ""Name"": ""addressesSet"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to prevent multiple calls to setAddresses""
      },
      {
        ""Name"": ""validRouters"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Whitelist of valid router addresses for buyback operations""
      },
      {
        ""Name"": ""users"",
        ""Type"": ""mapping(address => User)"",
        ""Purpose"": ""Stores user balance and lock time information""
      },
      {
        ""Name"": ""allowance"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks token allowances for ERC20 standard""
      },
      {
        ""Name"": ""nonces"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Used for permit functionality to prevent replay attacks""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the sYETI balance of a user"",
        ""Parameters"": [""address user""],
        ""Returns"": [""uint256 (balance)""]
      },
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the YETI and YUSD token addresses (can only be called once)"",
        ""Parameters"": [""IYETIToken _yeti"", ""IERC20 _yusd""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle token transfers with lock check"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""_useAllowance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Validates and updates allowances for transferFrom"",
        ""Parameters"": [""address from"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""public"",
        ""Purpose"": ""ERC20 transfer implementation"",
        ""Parameters"": [""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""ERC20 transferFrom implementation"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""public"",
        ""Purpose"": ""ERC20 approve implementation"",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""increaseAllowance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increases the allowance for a spender"",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the domain separator for EIP-712"",
        ""Parameters"": [],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""permit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""EIP-2612 permit implementation for gasless approvals"",
        ""Parameters"": [""address owner_"", ""address spender"", ""uint256 value"", ""uint256 deadline"", ""uint8 v"", ""bytes32 r"", ""bytes32 s""],
        ""Returns"": []
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Stakes YETI tokens and mints sYETI tokens"",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_burn"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to burn sYETI and return YETI tokens"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""burn"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns sYETI tokens and returns YETI"",
        ""Parameters"": [""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""burnFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns sYETI tokens from another address with allowance"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""buyBack"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to perform a buyback with YUSD"",
        ""Parameters"": [""address _routerAddress"", ""uint256 _YUSDToSell"", ""uint256 _YETIOutMin""],
        ""Returns"": []
      },
      {
        ""Name"": ""publicBuyBack"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Public function to execute buybacks with time restrictions"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_buyBack"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function that executes the actual buyback"",
        ""Parameters"": [""address _routerAddress"", ""uint256 _YUSDToSell"", ""uint256 _YETIOutMin""],
        ""Returns"": []
      },
      {
        ""Name"": ""rebase"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the effective YETI token balance to distribute rewards"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_getValueOfContract"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the value of the contract in YETI equivalent"",
        ""Parameters"": [""uint _adjustedYetiTokenBalance""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""setTransferRatio"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to set the transfer ratio for rebasing"",
        ""Parameters"": [""uint256 newTransferRatio""],
        ""Returns"": []
      },
      {
        ""Name"": ""addValidRouter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to whitelist a router address"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeValidRouter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to remove a router from whitelist"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""div"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Safe division function that checks for division by zero"",
        ""Parameters"": [""uint256 a"", ""uint256 b""],
        ""Returns"": [""uint256 c""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IYETIToken contract - for staking YETI tokens and interacting with the YETI token"",
    ""IERC20 contract - for YUSD token interactions"",
    ""IsYETIRouter interface - for executing swaps during buybacks"",
    ""BoringCrypto libraries - for safe math operations and other utility functions""
  ],
  
  ""SpecialMechanisms"": [
    ""ERC20 Implementation - Standard token functionality with extensions"",
    ""EIP-2612 Permit - Allows gasless approvals"",
    ""Time-locking mechanism - Locks staked tokens for 69 hours"",
    ""Rebasing mechanism - Distributes rewards by increasing the backing YETI per sYETI"",
    ""Buyback system - Uses YUSD to buy back YETI tokens through whitelisted routers"",
    ""Dynamic exchange rate - sYETI to YETI ratio changes based on rewards distributed""
  ],
  
  ""Questions"": [
    ""Is there a function to withdraw the YUSD accumulated in the contract other than through buybacks?"",
    ""How is the transferRatio initially set? There's a setter function but no initialization in the contract."",
    ""What protection mechanisms exist against price manipulation during buybacks?"",
    ""Is there any way to pause the contract in case of emergency?"",
    ""The rebase function has time checks but no access controls - is this intentional?"",
    ""What happens if the lastBuybackPrice is zero? Could this cause a division by zero in _getValueOfContract?"",
    ""Are there any potential reentrancy risks in the mint/burn functions with external calls?""
  ]
}","I've analyzed the provided smart contract security issues and consolidated similar findings. Here's my summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerabilities in mint and _burn functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract modifies state variables before making external calls in both mint and _burn functions. In mint, it modifies user balances and totalSupply before calling yetiToken.sendToSYETI(). In _burn, it decreases the user's balance and totalSupply before making an external call to yetiToken.transfer. This creates potential reentrancy vulnerabilities if the yetiToken contract is malicious or compromised."",
      ""Impact"": ""An attacker could potentially re-enter the contract during the token transfer and perform additional operations with already spent shares, potentially draining funds from the contract or manipulating token balances through multiple mints or burns with the same tokens."",
      ""Location"": ""mint and _burn functions""
    },
    {
      ""Issue"": ""Lack of slippage protection in publicBuyBack"",
      ""Severity"": ""High"",
      ""Description"": ""The publicBuyBack function calls _buyBack with _YETIOutMin set to 0, which means there's no minimum amount of YETI tokens that must be received in the swap. This makes the function vulnerable to MEV attacks, sandwich attacks, and extreme slippage without any protection."",
      ""Impact"": ""Malicious actors could extract value from the swap transaction by front-running publicBuyBack transactions, manipulating the exchange rate, potentially leading to significant loss of funds to the protocol."",
      ""Location"": ""publicBuyBack function where it calls _buyBack with _YETIOutMin set to 0""
    },
    {
      ""Issue"": ""Manipulation of lastBuybackPrice affecting rebase mechanism"",
      ""Severity"": ""High"",
      ""Description"": ""The rebase function relies on lastBuybackPrice for calculating the value of the contract. If an attacker can influence this price through market manipulation, flash loans, or other means during buybacks, they can affect how tokens are distributed during rebases. Additionally, there's no validation that lastBuybackPrice has been set before the first rebase."",
      ""Impact"": ""Malicious actors could manipulate the lastBuybackPrice to gain unfair advantages during rebases, potentially extracting value from honest users or causing incorrect token distributions."",
      ""Location"": ""_buyBack, rebase, and _getValueOfContract functions""
    },
    {
      ""Issue"": ""Lack of input validation in _burn function"",
      ""Severity"": ""High"", 
      ""Description"": ""The _burn function doesn't validate if the 'shares' parameter is less than or equal to the user's balance before attempting to subtract from it. Though there is a check in the BoringMath.sub function (as indicated by usage pattern), relying solely on that is unsafe as it would revert with a potentially unclear error message."",
      ""Impact"": ""This could lead to transaction reverts with unclear error messages, affecting user experience. In worst case, if BoringMath.sub doesn't properly check for underflow, it could lead to balance manipulation."",
      ""Location"": ""In the _burn function""
    },
    {
      ""Issue"": ""Division by zero risk in _getValueOfContract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _getValueOfContract function divides by lastBuybackPrice without checking if it's zero. This could occur if rebase is called before any buyback happens (lastBuybackPrice defaults to zero). Additionally, there's no validation for the case where the swap in _buyBack returns zero YETI tokens, which would set lastBuybackPrice to zero."",
      ""Impact"": ""Division by zero would cause the rebase function to revert, preventing the normal operation of the contract until a successful buyback is executed."",
      ""Location"": ""_getValueOfContract function and its usage in rebase""
    },
    {
      ""Issue"": ""Uninitialized transferRatio state variable"",
      ""Severity"": ""Medium"",
      ""Description"": ""The transferRatio variable is used in the rebase function for calculations but there's no initialization in the constructor. If setTransferRatio is not called before the first rebase, transferRatio will be 0, which could cause unexpected behavior."",
      ""Impact"": ""The first rebase would set amountYetiToRebase to 0, effectively doing nothing. This could lead to confusion or loss of potential value growth for early investors."",
      ""Location"": ""Contract initialization, rebase function, and setTransferRatio function""
    },
    {
      ""Issue"": ""Unsafe arithmetic operations and inconsistent math library usage"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite importing BoringMath, several mathematical operations aren't properly protected. The contract inconsistently uses BoringMath library versus direct arithmetic operations (e.g., totalSupply += shares and totalSupply -= shares). The contract also uses a custom div function that checks for division by zero but not for overflow."",
      ""Impact"": ""Could lead to integer overflows or underflows which might allow attackers to manipulate token balances. This inconsistency could also lead to maintenance issues and potential bugs in future updates."",
      ""Location"": ""Various functions including mint, _burn, _buyBack, and _getValueOfContract""
    },
    {
      ""Issue"": ""Centralization risk with owner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several critical functions like setAddresses, buyBack, setTransferRatio, and router management are restricted to the owner, creating a centralization risk. The owner has extensive control, including the ability to add/remove routers, set transfer ratios, and execute privileged buybacks."",
      ""Impact"": ""If the owner account is compromised or acts maliciously, they could modify critical parameters, manipulate the protocol's operations, potentially leading to loss of user funds."",
      ""Location"": ""setAddresses, buyBack, setTransferRatio, addValidRouter, removeValidRouter functions""
    },
    {
      ""Issue"": ""Potential price manipulation in buyBack and rebase"",
      ""Severity"": ""Medium"",
      ""Description"": ""The buyBack functionality does not properly validate the returned swap amounts beyond the _YETIOutMin parameter. Additionally, the owner can call buyBack without time restrictions, unlike publicBuyBack which has a timelock of 169 hours. This inconsistency gives the owner additional privileges that could be abused."",
      ""Impact"": ""The owner could repeatedly call buyBack to manipulate the lastBuybackPrice and subsequently affect the rebase calculations, leading to potential manipulation of token distribution."",
      ""Location"": ""buyBack function and rebase mechanism""
    },
    {
      ""Issue"": ""Lack of router validation beyond existence check"",
      ""Severity"": ""Medium"",
      ""Description"": ""When adding a valid router, the only check is that the address is not zero. There's no verification that the address actually implements the expected IsYETIRouter interface correctly or is a legitimate router."",
      ""Impact"": ""The owner could accidentally add an invalid router, which could lead to failed buybacks or, worse, loss of funds if the router implementation is malicious."",
      ""Location"": ""addValidRouter function""
    },
    {
      ""Issue"": ""Precision loss in share calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The calculations for determining shares in mint and amount in _burn involve division operations that could lead to precision loss, especially with small amounts. In several calculations, the contract divides before multiplying which can lead to precision loss."",
      ""Impact"": ""Users might receive slightly fewer tokens than expected due to rounding errors in the calculations, which can accumulate over time and lead to value loss."",
      ""Location"": ""mint and _burn functions, _getValueOfContract calculations""
    },
    {
      ""Issue"": ""No access control for rebase function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The rebase function can be called by anyone after the time constraint is satisfied. While there's a time constraint of 8 hours, there's no additional access control, allowing any external actor to trigger potentially significant changes to the token economy."",
      ""Impact"": ""Malicious actors could trigger rebases at suboptimal times, potentially manipulating the market or causing disruption in token economics."",
      ""Location"": ""rebase function""
    },
    {
      ""Issue"": ""Missing initialization checks for critical parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several critical parameters including transferRatio and lastBuybackPrice aren't properly initialized in the constructor, but are used in calculations. The functions that use these values don't check if they've been properly set."",
      ""Impact"": ""Could lead to unexpected behavior, incorrect calculations, or reverted transactions when the contract is first deployed."",
      ""Location"": ""Contract state variables and their usage in various functions""
    },
    {
      ""Issue"": ""Potential DOS in publicBuyBack due to fixed timeframe"",
      ""Severity"": ""Low"",
      ""Description"": ""The publicBuyBack function can only be called every 169 hours, which could be manipulated by a malicious actor to prevent legitimate users from executing the function by front-running with a minimal transaction."",
      ""Impact"": ""The buyback mechanism could be effectively blocked by an attacker, preventing the contract from functioning as intended."",
      ""Location"": ""publicBuyBack function""
    },
    {
      ""Issue"": ""No incentive mechanism for publicBuyBack"",
      ""Severity"": ""Low"",
      ""Description"": ""The publicBuyBack function allows anyone to trigger a buyback after 169 hours, but there's no incentive for users to call this function and pay the gas fees."",
      ""Impact"": ""The publicBuyBack function may rarely be used, limiting its effectiveness as a backup mechanism if the owner is inactive."",
      ""Location"": ""publicBuyBack function""
    },
    {
      ""Issue"": ""Missing events for critical state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like setAddresses, setTransferRatio, addValidRouter, and removeValidRouter change important contract parameters but don't emit events to notify users or external systems of these changes."",
      ""Impact"": ""This makes it harder to track changes to the contract's configuration off-chain, reducing transparency and potentially complicating integrations."",
      ""Location"": ""setAddresses, setTransferRatio, addValidRouter, removeValidRouter functions""
    },
    {
      ""Issue"": ""No transfer ownership functionality"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits from BoringOwnable but there's no visible implementation of a secure ownership transfer function in the provided code. This appears to be a single-step ownership transfer which is risky."",
      ""Impact"": ""If the owner needs to be changed, there might not be a secure way to do so, potentially leading to loss of admin control or requiring a new contract deployment. If ownership is transferred to an incorrect address, control of the contract could be lost permanently."",
      ""Location"": ""Missing functionality in contract""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 17
}",404.168725013733,68924.0,32.0,"### **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Report Description**:
The `rebase` function in the contract incorrectly calculates the additional token amount by using `yetiToken.balance - effectiveYetiTokenBalance`. This calculation does not account for the actual amount of Yeti tokens bought back from the market, leading to an overestimation of the token balance. As a result, the `effectiveYetiTokenBalance` can exceed the actual amount of Yeti tokens owned by the contract. This discrepancy can lead to a deficit in the contract's net worth, especially if the price of Yeti tokens increases. If enough users attempt to withdraw their tokens, the contract may default because it cannot fulfill the total claims.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of incorrect token amount calculation in the `rebase` function. The closest related issue in the response list is ""Manipulation of lastBuybackPrice affecting rebase mechanism,"" but this does not cover the core problem of incorrect token balance calculation. Therefore, the response list fails to identify or address this vulnerability.

---

### **[M-01] Wrong lastBuyBackPrice**

**Report Description**:
The `lastBuyBackPrice` is incorrectly calculated in the `buyBack` function. The function hardcodes the calculation as `amounts[0] / amounts[1]`, where `amounts[0]` is the amount of YUSD sold and `amounts[1]` is the amount of YETI gained. This calculation assumes a swap path of length 2 and that all routers sort pairs the same way. If a swap path of length 3 is used, this calculation is incorrect, leading to an inaccurate `lastBuyBackPrice`. This inaccuracy can affect the rebase mechanism and the overall token economy.

**Match in Response List**:
Matches with the issue titled **""Manipulation of lastBuybackPrice affecting rebase mechanism""**.

**Validation**:
**Partially Correct**. The response identifies the issue of `lastBuyBackPrice` manipulation and its impact on the rebase mechanism. However, it does not specifically address the incorrect calculation of `lastBuyBackPrice` when using a swap path of length 3. The response focuses on the potential for price manipulation but misses the critical detail of the calculation error in the `buyBack` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-01] Wrong lastBuyBackPrice**

**Missed Issues from Issue Report**:
- **[H-02] Yeti token rebase checks the additional token amount incorrectly**

---

The response list partially addresses one of the issues but completely misses the critical vulnerability in the `rebase` function. This indicates a significant gap in the coverage of the provided response list.",1,0,1,17,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and the average of these values is also zero.",0.333
PriceFeed.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7613.0,799.0,"[M-02] Should check return data from Chainlink aggregators

Function `_getCurrentChainlinkResponse`, no checks on lastRoundData

The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.
Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.",1.0,,"pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";



contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  
    ITellorCaller public tellorCaller;  

    
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    
    uint constant public TIMEOUT = 14400;  

    
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; 

    
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; 

    
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        
        status = Status.chainlinkWorking;

        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    

    
    function fetchPrice() external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                
                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            
            return _storeChainlinkPrice(chainlinkResponse);
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    

    
    function fetchPrice_v() view external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) { 
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
         if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    

    
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.roundId == 0) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        
        try priceAggregator.decimals() returns (uint8 decimals) {
            
            chainlinkResponse.decimals = decimals;
        } catch {
            
            return chainlinkResponse;
        }

        
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        

        
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            
            return prevChainlinkResponse;
        }
    }
}",4598.0,0.0,1.0,"Based on the comprehensive analysis of the PriceFeed contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Oracle Security and Integrity"",
      ""Tasks"": [
        ""Verify the robustness of oracle failover mechanism between Chainlink and Tellor"",
        ""Analyze price scaling logic for potential precision loss or manipulation"",
        ""Validate oracle response validation checks for comprehensive error handling"",
        ""Assess the effectiveness of status change logic in different oracle failure scenarios"",
        ""Review the timeout and price deviation threshold constants for appropriate security margins""
      ]
    },
    {
      ""Area"": ""Smart Contract Vulnerabilities"",
      ""Tasks"": [
        ""Perform a comprehensive reentrancy attack vector analysis"",
        ""Check for potential integer overflow/underflow risks in mathematical operations"",
        ""Verify SafeMath library usage across all arithmetic operations"",
        ""Validate input parameter validation and sanitization"",
        ""Assess potential manipulation of price feed through external calls""
      ]
    },
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Review the ownership renunciation mechanism in setAddresses()"",
        ""Verify the security implications of one-time address initialization"",
        ""Check for potential centralization risks in owner-only functions"",
        ""Analyze the impact of removing owner access after contract initialization""
      ]
    },
    {
      ""Area"": ""External Interaction Security"",
      ""Tasks"": [
        ""Audit try-catch error handling for Chainlink and Tellor external calls"",
        ""Verify the completeness of error scenarios covered in external interactions"",
        ""Assess the fallback mechanism when both oracles are unavailable"",
        ""Review interface implementations for AggregatorV3Interface and ITellorCaller""
      ]
    },
    {
      ""Area"": ""Price Feed Logic and State Management"",
      ""Tasks"": [
        ""Analyze the state machine logic in fetchPrice() method"",
        ""Review the multiple status scenarios and transition conditions"",
        ""Verify the correctness of price storage and scaling mechanisms"",
        ""Check the implementation of _bothOraclesSimilarPrice() for potential manipulation"",
        ""Assess the lastGoodPrice storage and usage strategy""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of complex oracle verification methods"",
        ""Review the efficiency of multiple price validation checks"",
        ""Assess the performance impact of decimal scaling operations"",
        ""Evaluate the gas costs of status changes and price storage""
      ]
    },
    {
      ""Area"": ""Compliance and Best Practices"",
      ""Tasks"": [
        ""Verify adherence to Solidity 0.6.11 best practices"",
        ""Check alignment with oracle integration security standards"",
        ""Review event emission for comprehensive system state tracking"",
        ""Assess the implementation against known oracle manipulation techniques""
      ]
    },
    {
      ""Area"": ""Unused and Potential Dead Code"",
      ""Tasks"": [
        ""Investigate the purpose of unused state variables (borrowerOperationsAddress, troveManagerAddress)"",
        ""Analyze the rationale behind the view fetchPrice_v() method"",
        ""Verify if any implemented methods are redundant or unnecessary""
      ]
    },
    {
      ""Area"": ""Emergency and Failure Scenarios"",
      ""Tasks"": [
        ""Simulate comprehensive oracle failure scenarios"",
        ""Verify the contract's behavior under extreme price volatility"",
        ""Test the recovery mechanisms when oracles become untrusted"",
        ""Assess the system's resilience to prolonged oracle unavailability""
      ]
    }
  ]
}

Key Observations and Recommendations:
1. The contract demonstrates a sophisticated multi-oracle approach with intelligent failover.
2. Complex state management requires thorough testing across all possible scenarios.
3. The one-time initialization and ownership renunciation pattern needs careful security review.
4. Decimal scaling and price validation logic are critical points for potential vulnerabilities.

The task list provides a comprehensive framework for a deep, methodical audit of the PriceFeed contract, covering security, functionality, and performance aspects.","After thoroughly reviewing the provided smart contract code, here's my detailed analysis:

{
  ""ReviewingTheCode"": ""The contract is a price feed oracle implementation that uses both Chainlink and Tellor as price sources for ETH/USD. It has a sophisticated failover mechanism that switches between oracles based on their reliability, freshness, and price consistency. The contract aims to provide resilient price data even if one oracle fails or becomes untrusted."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PriceFeed"",
    ""Purpose"": ""A dual-oracle system that provides ETH/USD price data for the Liquity protocol by retrieving prices from Chainlink and Tellor oracles with intelligent fallback mechanisms when one source becomes unreliable"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""CheckContract"", ""BaseMath"", ""IPriceFeed""],
      ""Imports"": [
        ""IPriceFeed.sol"",
        ""ITellorCaller.sol"",
        ""AggregatorV3Interface.sol"",
        ""SafeMath.sol"",
        ""Ownable.sol"",
        ""CheckContract.sol"",
        ""BaseMath.sol"",
        ""LiquityMath.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""string constant public"",
        ""Purpose"": ""Name identifier for the contract""
      },
      {
        ""Name"": ""priceAggregator"",
        ""Type"": ""AggregatorV3Interface public"",
        ""Purpose"": ""Interface to the Chainlink price aggregator""
      },
      {
        ""Name"": ""tellorCaller"",
        ""Type"": ""ITellorCaller public"",
        ""Purpose"": ""Interface to the Tellor oracle caller""
      },
      {
        ""Name"": ""borrowerOperationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address for borrower operations contract""
      },
      {
        ""Name"": ""troveManagerAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address for trove manager contract""
      },
      {
        ""Name"": ""ETHUSD_TELLOR_REQ_ID"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Tellor request ID for ETH/USD price""
      },
      {
        ""Name"": ""TARGET_DIGITS"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Target decimal precision (18)""
      },
      {
        ""Name"": ""TELLOR_DIGITS"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Tellor decimal precision (6)""
      },
      {
        ""Name"": ""TIMEOUT"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Time after which oracle data is considered stale (14400 seconds = 4 hours)""
      },
      {
        ""Name"": ""MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Maximum allowed price deviation between consecutive Chainlink rounds (50%)""
      },
      {
        ""Name"": ""MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES"",
        ""Type"": ""uint constant public"",
        ""Purpose"": ""Maximum allowed price difference between Chainlink and Tellor (5%)""
      },
      {
        ""Name"": ""lastGoodPrice"",
        ""Type"": ""uint public"",
        ""Purpose"": ""Last valid price that was accepted by the system""
      },
      {
        ""Name"": ""status"",
        ""Type"": ""Status public"",
        ""Purpose"": ""Current status of the price feed system, determines which oracle to use""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with oracle addresses and sets initial status"",
        ""Parameters"": [""_priceAggregatorAddress"", ""_tellorCallerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""fetchPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Main function to get the current ETH/USD price with fallback logic between oracles"",
        ""Parameters"": [],
        ""Returns"": [""uint (price)""]
      },
      {
        ""Name"": ""fetchPrice_v"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""View-only version of fetchPrice that doesn't modify state but follows the same logic"",
        ""Parameters"": [],
        ""Returns"": [""uint (price)""]
      },
      {
        ""Name"": ""_chainlinkIsBroken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if Chainlink oracle is providing invalid data"",
        ""Parameters"": [""_currentResponse"", ""_prevResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_badChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Validates a single Chainlink response"",
        ""Parameters"": [""_response""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_chainlinkIsFrozen"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if Chainlink data is stale (older than TIMEOUT)"",
        ""Parameters"": [""_response""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_chainlinkPriceChangeAboveMax"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if price change between consecutive Chainlink rounds exceeds maximum allowed deviation"",
        ""Parameters"": [""_currentResponse"", ""_prevResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tellorIsBroken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if Tellor oracle is providing invalid data"",
        ""Parameters"": [""_response""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tellorIsFrozen"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if Tellor data is stale (older than TIMEOUT)"",
        ""Parameters"": [""_tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_bothOraclesLiveAndUnbrokenAndSimilarPrice"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if both oracles are working and reporting similar prices"",
        ""Parameters"": [""_chainlinkResponse"", ""_prevChainlinkResponse"", ""_tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_bothOraclesSimilarPrice"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if prices from both oracles are within allowed deviation range"",
        ""Parameters"": [""_chainlinkResponse"", ""_tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_scaleChainlinkPriceByDigits"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Scales Chainlink price to target decimal precision"",
        ""Parameters"": [""_price"", ""_answerDigits""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_scaleTellorPriceByDigits"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Scales Tellor price to target decimal precision"",
        ""Parameters"": [""_price""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_changeStatus"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the oracle system status and emits an event"",
        ""Parameters"": [""_status""],
        ""Returns"": []
      },
      {
        ""Name"": ""_storePrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates lastGoodPrice and emits an event"",
        ""Parameters"": [""_currentPrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""_storeTellorPrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Scales and stores Tellor price"",
        ""Parameters"": [""_tellorResponse""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_storeChainlinkPrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Scales and stores Chainlink price"",
        ""Parameters"": [""_chainlinkResponse""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_getCurrentTellorResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Fetches current price from Tellor oracle"",
        ""Parameters"": [],
        ""Returns"": [""TellorResponse memory""]
      },
      {
        ""Name"": ""_getCurrentChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Fetches current price from Chainlink oracle"",
        ""Parameters"": [],
        ""Returns"": [""ChainlinkResponse memory""]
      },
      {
        ""Name"": ""_getPrevChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Fetches previous round price from Chainlink oracle"",
        ""Parameters"": [""_currentRoundId"", ""_currentDecimals""],
        ""Returns"": [""ChainlinkResponse memory""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""AggregatorV3Interface (Chainlink price feed)"",
    ""ITellorCaller (Interface to interact with Tellor oracle)"",
    ""SafeMath library for arithmetic operations"",
    ""LiquityMath library for min/max operations""
  ],
  
  ""SpecialMechanisms"": [
    ""State machine pattern using an enum (Status) to manage oracle failover logic"",
    ""Try/catch error handling for external oracle calls to prevent system-wide failures"",
    ""Price validation with multiple criteria (frozen check, deviation check, cross-oracle comparison)"",
    ""Decimal precision normalization between different oracle systems"",
    ""Owner-renouncing pattern in setAddresses to make the contract immutable after initialization""
  ],
  
  ""Questions"": [
    ""What happens if both oracles are permanently broken? Is there a recovery mechanism?"",
    ""The borrowerOperationsAddress and troveManagerAddress are declared but never used in the contract - what's their purpose?"",
    ""In setAddresses, _renounceOwnership() is called, making the contract immutable after initialization. Is there a backup plan if oracle addresses need to be updated?"",
    ""Why does fetchPrice_v() mirror fetchPrice() logic exactly but without state changes? Is it used for gas-free price queries?"",
    ""The contract seems to favor Chainlink over Tellor when both are working. Is this intentional for security reasons?""
  ]
}","After analyzing the provided findings, I've consolidated similar issues and organized them by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Oracle Manipulation and Failure Risk"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies heavily on two oracles (Chainlink and Tellor) for price feeds. If both oracles fail simultaneously or provide manipulated data, the system falls back to the last good price, which could be stale. The MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES threshold (5%) may be exploitable during volatile markets, allowing an attacker to manipulate one oracle within this threshold to influence the price feed. In flash loan attacks, if an attacker can influence prices temporarily through market manipulation, they could affect the contract's pricing mechanism."",
      ""Impact"": ""In scenarios where both oracles fail or provide corrupt data, the system would use outdated price information, potentially leading to undercollateralized positions, improper liquidations, or enabling attackers to profit through price-sensitive operations. During extreme market volatility, the system might continue operating with distorted price data."",
      ""Location"": ""fetchPrice() and fetchPrice_v() functions, Status.bothOraclesUntrusted handling, _bothOraclesSimilarPrice() function""
    },
    {
      ""Issue"": ""Lack of Circuit Breaker Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a formal circuit breaker or emergency shutdown mechanism that could halt operations in case of extreme market conditions, oracle manipulation, or when suspicious price activity is detected. While the contract has logic to fall back to the last good price in case of oracle failure, it doesn't have a way to pause operations entirely if needed."",
      ""Impact"": ""In case of severe market volatility, oracle attacks, or black swan events, the system will continue operating based on potentially unreliable price data, which could lead to systemic failure, mass liquidations, or exploitation."",
      ""Location"": ""Throughout the contract; no emergency pause functionality exists""
    },
    {
      ""Issue"": ""Ownership Renounced In Constructor"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calls _renounceOwnership() in the setAddresses function, permanently removing the ability to update the oracle addresses or make other owner-required changes. While this prevents centralization risks, it also means if the oracle addresses need to be changed due to deprecated services or discovered vulnerabilities, it would be impossible without deploying a new contract."",
      ""Impact"": ""If either Chainlink or Tellor services change their interfaces, are compromised, or become deprecated, there is no way to update the contract to use alternative data sources or improved implementations. If vulnerabilities are discovered, the entire contract would need to be redeployed."",
      ""Location"": ""setAddresses() function where _renounceOwnership() is called""
    },
    {
      ""Issue"": ""Fixed Deviation Thresholds and Timeout Values"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses hardcoded constants for MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND (50%), MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES (5%), and TIMEOUT (14400 seconds = 4 hours). These static values cannot be adjusted after deployment and may not be appropriate for all market conditions, especially during high volatility periods. If oracles change their update frequency or if network congestion delays updates beyond this window, the system will consider valid oracles as frozen."",
      ""Impact"": ""During periods of extreme market volatility, these fixed thresholds might be too restrictive or too permissive, potentially leading to incorrect price determinations, unnecessary oracle switching, or the system might reject legitimate price updates, relying on potentially outdated prices."",
      ""Location"": ""Constants defined at lines 40-43 and logic in _chainlinkPriceChangeAboveMax() and _bothOraclesSimilarPrice() functions, TIMEOUT constant at line 36""
    },
    {
      ""Issue"": ""Centralization Risk in Oracle Selection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract sets the initial status to 'chainlinkWorking' and prioritizes Chainlink data over Tellor in most scenarios. The initial oracle addresses are set by a single entity (owner) during contract initialization. While ownership is renounced after setup, the initial selection of oracle sources represents a centralization risk and creates trust assumptions."",
      ""Impact"": ""Over-reliance on a single oracle increases systemic risk if that oracle experiences manipulation, technical issues, or operator error. If compromised oracle addresses are set during initialization, the entire system could be vulnerable to price manipulation."",
      ""Location"": ""setAddresses() function and overall oracle prioritization logic""
    },
    {
      ""Issue"": ""No Validation of Oracle Price Ranges"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract checks for relative price changes and differentials between oracles, it does not enforce absolute boundaries on prices or have strong validation for whether returned prices are reasonable. An oracle reporting extremely high or low prices could still be accepted if it passes the relative checks."",
      ""Impact"": ""Extreme pricing errors from oracles could be propagated to the system if they don't trigger the relative change thresholds, potentially causing significant harm to the protocol's financial operations including incorrect liquidations or allowing mispriced borrowing."",
      ""Location"": ""Price validation logic in fetchPrice and fetchPrice_v, _badChainlinkResponse() and _tellorIsBroken() functions""
    },
    {
      ""Issue"": ""Inconsistent Function Return Behavior"",
      ""Severity"": ""Medium"",
      ""Description"": ""The fetchPrice() and fetchPrice_v() functions have nearly identical logic but are implemented separately as duplicated code. This creates a maintenance burden and increases the risk of divergent behavior if one function is updated but not the other. The view function fetchPrice_v() appears to be a duplicate with slight modifications that don't change state."",
      ""Impact"": ""Code duplication increases maintenance complexity and the risk of bugs. If the functions diverge in their logic due to updates to one but not the other, it could lead to inconsistent price reporting depending on which function is called. If one function is updated but the other isn't, or if there are subtle differences in logic, the contract could behave inconsistently."",
      ""Location"": ""fetchPrice() and fetchPrice_v() functions""
    },
    {
      ""Issue"": ""Potential Precision Loss in Price Scaling"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract scales prices from different oracles to match TARGET_DIGITS (18), but when scaling down (dividing), there's potential for precision loss. The functions _scaleChainlinkPriceByDigits and _scaleTellorPriceByDigits perform division and multiplication to standardize price decimals, which can introduce rounding errors, especially when dealing with large numbers or low-value assets."",
      ""Impact"": ""For very low-value assets or in cases where oracle decimals are much higher than TARGET_DIGITS, the scaling could lead to precision loss and slightly inaccurate prices. Small but consistent rounding errors could accumulate over time, potentially leading to price inaccuracies that might affect the protocol's financial calculations."",
      ""Location"": ""_scaleChainlinkPriceByDigits() and _scaleTellorPriceByDigits() functions""
    },
    {
      ""Issue"": ""Excessive Gas Usage in Oracle Calls"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract makes multiple external calls to oracles in a single transaction, both in fetchPrice() and fetchPrice_v(). These include calls to get current and previous Chainlink responses and Tellor responses, which can consume significant gas, especially if the oracles' responses require complex computation."",
      ""Impact"": ""High gas costs for calls to the fetchPrice functions could make certain operations prohibitively expensive during times of network congestion, potentially preventing important system updates."",
      ""Location"": ""_getCurrentChainlinkResponse(), _getPrevChainlinkResponse(), and _getCurrentTellorResponse() functions""
    },
    {
      ""Issue"": ""Missing Event Emissions for Status Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract emits events for status changes via the _changeStatus function, it doesn't emit events for all important state changes, such as when temporary oracle failures are detected but don't result in status changes. The contract also lacks specific events when oracle queries fail, making it difficult to monitor oracle health off-chain."",
      ""Impact"": ""Limited event emissions make it difficult to track and debug the contract's behavior off-chain, particularly when trying to understand why certain price decisions were made. Reduced observability of oracle failures could delay operational responses to deteriorating oracle conditions."",
      ""Location"": ""Various oracle validation functions like _chainlinkIsBroken(), _tellorIsBroken(), setAddresses() function which lacks event emissions""
    },
    {
      ""Issue"": ""Unused State Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract declares borrowerOperationsAddress and troveManagerAddress state variables that are never used in the contract logic. These variables consume storage unnecessarily."",
      ""Impact"": ""Unnecessary gas costs for deploying and maintaining unused state variables. May also confuse developers about the contract's intended functionality."",
      ""Location"": ""State variable declarations""
    },
    {
      ""Issue"": ""Potential Block Timestamp Manipulation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses block.timestamp for determining if price feeds are frozen (via TIMEOUT). Miners can manipulate block.timestamp to a certain degree, which could potentially be used to force the contract to consider a valid oracle as frozen."",
      ""Impact"": ""In edge cases, a miner could manipulate the timestamp to make the contract think the oracle is frozen when it isn't, potentially forcing a switch to a different oracle or to use lastGoodPrice."",
      ""Location"": ""_chainlinkIsFrozen() and _tellorIsFrozen() functions using block.timestamp""
    },
    {
      ""Issue"": ""Insufficient Comment Documentation"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract has some comments, important concepts like the rationale behind the threshold values (MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND, MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES) and the detailed state transition logic are not well documented."",
      ""Impact"": ""Lack of comprehensive documentation makes the contract harder to audit, maintain, and understand, increasing the likelihood of bugs during future updates."",
      ""Location"": ""Throughout the contract, particularly around constant definitions and state transition logic""
    }
  ],
  ""IssueNumber"": 54,
  ""OutputList"": 13
}",414.422066926956,101380.0,32.0,"---

**[M-02] Should check return data from Chainlink aggregators**

**Report Description**:
The function `_getCurrentChainlinkResponse` in `PriceFeed.sol` fetches the asset price from a Chainlink aggregator using the `latestRoundData` function. However, it does not validate the `roundID` or other return values. According to Chainlink's documentation, `latestRoundData` may return stale or incorrect data (e.g., `0`) if no valid answer is available. This oversight could lead to the use of outdated or incorrect prices, which may result in financial risks such as undercollateralized positions, improper liquidations, or exploitation by attackers. The reliance on external oracles introduces inherent risks, including the possibility of the oracle failing or providing outdated data.

**Match in Response List**:
Matches with the issue titled **""Oracle Manipulation and Failure Risk""**.

**Validation**:
**Partially Correct**. The response identifies the general risks associated with oracle reliance, including the potential for manipulated or stale data. However, it does not specifically address the lack of validation for `roundID` or other return values from `latestRoundData`, which is the core issue in the report. While the response highlights the broader risks of oracle failure, it misses the critical detail of validating Chainlink's return data, which is essential for ensuring accurate price feeds. This partial alignment with the issue makes the response **partially correct**.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-02] Should check return data from Chainlink aggregators**

**Missed Issues from Issue Report**:
- *None*

---",1,0,0,13,"```
None.
```",0.0,1.0
ActivePool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716.0,304.0,"[M-03] Unwhitelisted token can cause disaster

Submitted by csanuragjain
Impact

Contract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)
Proof of Concept

Navigate to contract atÂ https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol
Assume sendCollaterals function is called by one of allowed contract with a non whitelisted token and amount as 1
```â€¨function sendCollaterals(address _to, address[] memory _tokens, uint[] memory _amounts) external override returns (bool) {
    _requireCallerIsBOorTroveMorTMLorSP();
    require(_tokens.length == _amounts.length);
    for (uint i = 0; i < _tokens.length; i++) {
        _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
    }

    if (_needsUpdateCollateral(_to)) {
        ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
    }
    
    return true;
}â€¨```â€¨â€¨[M-04] Out of gas.

Submitted by Jujic, also found by gzeon
There is no upper limit onÂ poolColl.tokens[], it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.
Impact

For every callÂ getVC()Â function which computed contain the VC value of a given collateralAddress is listed inÂ poolColl.tokens[]Â array, the gas consumption can be more expensive each time that a new collateral address is appended to the array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.",2.0,,"pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";


contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    
    newColls internal poolColl;

    
    uint256 internal YUSDDebt;

    

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    

    

    
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    

    
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); 
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    
    
    
    
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); 
            }
        }
        return true;
    }

    
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); 
        return true;
    }

    
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); 
        }
        return true;
    }

    
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2101.0,0.0,2.0,"Based on the comprehensive analysis of the ActivePool smart contract, here's a detailed audit task list focusing on critical areas:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control Security"",
      ""Tasks"": [
        ""Verify integrity of _requireCallerIs* functions for comprehensive access control"",
        ""Audit the completeness of allowed caller checks in sensitive functions"",
        ""Confirm that renounceOwnership() effectively removes owner privileges after initialization"",
        ""Validate that all critical functions have appropriate access restrictions""
      ]
    },
    {
      ""Area"": ""Collateral Management Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the newColls struct for potential overflow or underflow risks"",
        ""Review _sendCollateral and sendCollaterals methods for secure token transfer mechanisms"",
        ""Verify the correctness of collateral balance tracking and updates"",
        ""Check unwrapping logic in sendCollateralsUnwrap for potential attack vectors"",
        ""Validate the addCollateralType function against potential whitelist manipulation""
      ]
    },
    {
      ""Area"": ""Debt Accounting Integrity"",
      ""Tasks"": [
        ""Validate increaseYUSDDebt and decreaseYUSDDebt functions for arithmetic safety"",
        ""Verify that YUSDDebt cannot be manipulated through unauthorized calls"",
        ""Check SafeMath usage for preventing potential integer overflow/underflow"",
        ""Confirm consistency of debt tracking across different system components""
      ]
    },
    {
      ""Area"": ""External Interactions and Interfaces"",
      ""Tasks"": [
        ""Audit interactions with IWhitelist for secure value calculations"",
        ""Review callback mechanisms in receiveCollateral function"",
        ""Verify safe integration with IERC20 and IWAsset interfaces"",
        ""Check for potential reentrancy risks in external contract calls"",
        ""Validate address validation in setAddresses method""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in collateral transfer and tracking methods"",
        ""Review loop implementations for potential optimization"",
        ""Check array manipulation efficiency in multi-token operations"",
        ""Verify minimal state changes and event emissions""
      ]
    },
    {
      ""Area"": ""Error Handling and Revert Mechanisms"",
      ""Tasks"": [
        ""Review _revertWrongFuncCaller for comprehensive error messaging"",
        ""Validate error handling in all external and internal functions"",
        ""Check require statements for precise and informative revert conditions"",
        ""Ensure no silent failures or unexpected state changes""
      ]
    },
    {
      ""Area"": ""Advanced Security Considerations"",
      ""Tasks"": [
        ""Analyze contract's resilience against potential front-running attacks"",
        ""Verify protection against sandwich attacks in collateral transfers"",
        ""Check for potential economic manipulation through collateral value calculations"",
        ""Review whitelist integration for potential centralization risks""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Confirm compliance with ERC-20 token transfer standards"",
        ""Verify proper implementation of SafeERC20 library methods"",
        ""Check consistent event emissions for critical state changes"",
        ""Validate naming and interface adherence to best practices""
      ]
    }
  ]
}

Key Audit Focus Points:
1. The contract has multiple complex interactions between different system components
2. Access control is critical and implemented through multiple internal verification methods
3. Collateral management involves sophisticated tracking of multiple token types
4. External interactions with whitelist and other contracts require careful scrutiny
5. Debt accounting needs precise validation to prevent manipulation

Recommended Next Steps:
- Obtain and review the implementations of imported interfaces and base contracts
- Create comprehensive test scenarios covering edge cases
- Perform thorough static and dynamic analysis
- Consider formal verification for critical mathematical operations

The task list provides a structured approach to comprehensively audit the ActivePool contract, addressing security, efficiency, and reliability concerns.","I'll conduct a thorough audit of the provided smart contract code. Let me analyze it step by step.

{
  ""ReviewingTheCode"": ""The code represents an 'ActivePool' contract for a DeFi protocol, likely part of a system similar to Liquity/MakerDAO. It manages collateral assets and YUSD debt for the protocol. The contract handles operations like receiving, sending, and tracking various types of collateral assets along with debt accounting. It implements access controls to ensure only authorized contracts can call sensitive functions."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ActivePool"",
    ""Purpose"": ""Manages and tracks collateral assets and YUSD debt in the protocol. Acts as a store of collateral and accounting system for troves/loans in the system."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""CheckContract"", ""IActivePool"", ""YetiCustomBase""],
      ""Imports"": [
        ""IActivePool"", 
        ""IWhitelist"", 
        ""IERC20"", 
        ""IWAsset"", 
        ""SafeMath"", 
        ""Ownable"", 
        ""CheckContract"", 
        ""YetiCustomBase"", 
        ""SafeERC20""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""bytes32 constant"",
        ""Purpose"": ""Identifier for the contract""
      },
      {
        ""Name"": ""borrowerOperationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the BorrowerOperations contract""
      },
      {
        ""Name"": ""troveManagerAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManager contract""
      },
      {
        ""Name"": ""stabilityPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StabilityPool contract""
      },
      {
        ""Name"": ""defaultPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the DefaultPool contract""
      },
      {
        ""Name"": ""troveManagerLiquidationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManagerLiquidations contract""
      },
      {
        ""Name"": ""troveManagerRedemptionsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManagerRedemptions contract""
      },
      {
        ""Name"": ""collSurplusPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the CollSurplusPool contract""
      },
      {
        ""Name"": ""poolColl"",
        ""Type"": ""newColls"",
        ""Purpose"": ""Tracks the collateral balances held by this pool""
      },
      {
        ""Name"": ""YUSDDebt"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the total YUSD debt in the system""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes contract with required addresses for the system components"",
        ""Parameters"": [""Multiple address parameters for system contracts""],
        ""Returns"": []
      },
      {
        ""Name"": ""getCollateral"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the balance of a specific collateral token"",
        ""Parameters"": [""address _collateral""],
        ""Returns"": [""uint - amount of specific collateral""]
      },
      {
        ""Name"": ""getAllCollateral"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns all collateral tokens and their balances"",
        ""Parameters"": [],
        ""Returns"": [""address[] - tokens"", ""uint256[] - amounts""]
      },
      {
        ""Name"": ""getCollateralVC"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Gets the value contribution (VC) of a specific collateral"",
        ""Parameters"": [""address _collateral""],
        ""Returns"": [""uint - VC value""]
      },
      {
        ""Name"": ""getVC"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the total value contribution of all collaterals"",
        ""Parameters"": [],
        ""Returns"": [""uint totalVC""]
      },
      {
        ""Name"": ""getYUSDDebt"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total YUSD debt"",
        ""Parameters"": [],
        ""Returns"": [""uint - debt amount""]
      },
      {
        ""Name"": ""_sendCollateral"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Helper to send collateral to an address"",
        ""Parameters"": [""address _to"", ""address _collateral"", ""uint _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendCollaterals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends multiple collaterals to an address"",
        ""Parameters"": [""address _to"", ""address[] _tokens"", ""uint[] _amounts""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendCollateralsUnwrap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends multiple collaterals, unwrapping any wrapped tokens"",
        ""Parameters"": [""address _from"", ""address _to"", ""address[] _tokens"", ""uint[] _amounts""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendSingleCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends a single collateral token"",
        ""Parameters"": [""address _to"", ""address _token"", ""uint256 _amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendSingleCollateralUnwrap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends a single collateral token, unwrapping if needed"",
        ""Parameters"": [""address _from"", ""address _to"", ""address _token"", ""uint256 _amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_needsUpdateCollateral"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a contract needs collateral updates"",
        ""Parameters"": [""address _contractAddress""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""increaseYUSDDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the YUSD debt counter"",
        ""Parameters"": [""uint _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseYUSDDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Decreases the YUSD debt counter"",
        ""Parameters"": [""uint _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""receiveCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Receives collateral tokens into the pool"",
        ""Parameters"": [""address[] _tokens"", ""uint[] _amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralType"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new collateral type to the system"",
        ""Parameters"": [""address _collateral""],
        ""Returns"": []
      },
      {
        ""Name"": ""Multiple _requireCallerIs* functions"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Access control modifiers to restrict function access"",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IWhitelist - Used to validate collateral tokens and get value calculations"",
    ""IERC20 - Used for token transfers"",
    ""IWAsset - Interface for wrapped assets that can be unwrapped"",
    ""ICollateralReceiver - Callback interface for contracts receiving collateral""
  ],
  ""SpecialMechanisms"": [
    ""Access control pattern using _requireCallerIs* functions to restrict function access to specific contract addresses"",
    ""Support for wrapped assets with unwrapping functionality when transferring collateral"",
    ""Collateral value calculation mechanism using a whitelist contract"",
    ""Renouncing ownership after initialization for immutability"",
    ""Safe ERC20 transfer pattern using SafeERC20 library"",
    ""Multi-collateral support system with dynamic tracking of different token types""
  ],
  ""Questions"": [
    ""What is the structure of newColls and what does _leftSumColls function do?"",
    ""How does the whitelist contract determine collateral value?"",
    ""Is there a separate mechanism to add collaterals to the whitelist before they can be added to the ActivePool?"",
    ""How are the access control events (like StabilityPoolAddressChanged) defined, as they're emitted but not declared in the contract?"",
    ""What is the YetiCustomBase contract and what functionality does it provide?"",
    ""How are wrapped assets registered and managed in the whitelist?""
  ]
}

Upon analyzing this contract, I've identified several key points:

1. This is part of a DeFi lending system, likely similar to Liquity or MakerDAO
2. The ActivePool manages collateral assets and debt accounting for the entire system
3. It supports multiple collateral types and has integration with wrapped assets
4. The contract implements strict access controls to ensure only authorized system components can perform sensitive operations
5. The contract appears to be designed for a one-time initialization followed by operation without an owner (it renounces ownership after setup)

The code generally follows good practices like using SafeMath for arithmetic operations, SafeERC20 for token transfers, and comprehensive access controls. However, without seeing the related contracts (particularly the YetiCustomBase and the structures like newColls), a complete security assessment would require additional context.","I've analyzed the provided findings and consolidated similar issues while preserving critical security information. Here's the processed result:

{
  ""Findings"": [
    {
      ""Issue"": ""Missing reentrancy protection in external token transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses external token transfers without adequate reentrancy protection, particularly in functions like _sendCollateral(), sendCollaterals(), sendCollateralsUnwrap(), and sendSingleCollateralUnwrap(). While SafeERC20 is used for standard token transfers, the contract doesn't follow the checks-effects-interactions pattern consistently, especially when unwrapping assets or making calls to ICollateralReceiver."",
      ""Impact"": ""If a malicious wrapped token or receiver is added to the whitelist, it could exploit reentrancy to drain funds from the ActivePool or manipulate token balances, enabling double spending or other fund theft methods."",
      ""Location"": ""_sendCollateral(), sendCollaterals(), sendCollateralsUnwrap(), and sendSingleCollateralUnwrap() functions""
    },
    {
      ""Issue"": ""Missing input validation in receiveCollateral"",
      ""Severity"": ""High"",
      ""Description"": ""The receiveCollateral() function accepts arrays of tokens and amounts but doesn't properly validate that the tokens match the existing poolColl.tokens in both content and order, nor that they exist in the poolColl structure before updating amounts. Additionally, the function relies on _leftSumColls helper without verifying that token transfers actually happened."",
      ""Impact"": ""Could lead to accounting errors, manipulation of token balances, potential fund loss, or corruption of the collateral accounting system if arrays mismatch or if malicious inputs are provided."",
      ""Location"": ""receiveCollateral() function""
    },
    {
      ""Issue"": ""Incorrect accounting with wrapped tokens"",
      ""Severity"": ""High"",
      ""Description"": ""When unwrapping tokens in sendCollateralsUnwrap and sendSingleCollateralUnwrap, the contract calls IWAsset(_tokens[i]).unwrapFor() but doesn't appear to decrement the corresponding amounts from poolColl.amounts like it does with regular tokens in _sendCollateral."",
      ""Impact"": ""This could lead to accounting errors where the ActivePool believes it holds more collateral than it actually does, potentially allowing users to extract more value than they should be able to."",
      ""Location"": ""sendCollateralsUnwrap and sendSingleCollateralUnwrap functions""
    },
    {
      ""Issue"": ""Lack of validation for token address in addCollateralType"",
      ""Severity"": ""Medium"",
      ""Description"": ""The addCollateralType function adds a new collateral type without validating if the address is a valid ERC20 token, checking if it already exists in the pool collection, or emitting events for tracking. This could lead to duplicate entries and inconsistent accounting."",
      ""Impact"": ""Could add invalid tokens or duplicate entries to the collateral list, leading to accounting errors, potential exploits, or breaking functions that iterate through all collaterals."",
      ""Location"": ""addCollateralType function""
    },
    {
      ""Issue"": ""Unsafe use of index in getCollateral"",
      ""Severity"": ""Medium"",
      ""Description"": ""The getCollateral function retrieves the index of a collateral token from the whitelist and uses it to access the amounts array without validating if that index exists in the array or is within bounds."",
      ""Impact"": ""If the whitelist returns an invalid or out-of-bounds index, this could cause the transaction to revert or return incorrect collateral amounts, especially if the whitelist and poolColl arrays become out of sync."",
      ""Location"": ""getCollateral function""
    },
    {
      ""Issue"": ""Missing zero address checks in setAddresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""Although the setAddresses() function performs contract validation using checkContract(), it doesn't explicitly verify that addresses aren't zero addresses before storing them."",
      ""Impact"": ""If the checkContract() function doesn't include zero address validation, critical contract addresses could be set to zero, breaking core functionality and potentially causing irreversible loss of functionality."",
      ""Location"": ""setAddresses() function""
    },
    {
      ""Issue"": ""Centralized control and permanent ownership renunciation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has a centralized control model where the owner can set all critical addresses in setAddresses(). This function calls _renounceOwnership() at the end, which permanently gives up control of the contract, making future upgrades or fixes impossible if issues are discovered later."",
      ""Impact"": ""Makes the contract immutable after initialization, preventing any updates to address configurations if vulnerabilities are discovered or integrations need to change. A malicious or compromised owner could set malicious contract addresses before renouncing ownership."",
      ""Location"": ""setAddresses() function""
    },
    {
      ""Issue"": ""Unbounded loops in multiple functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like getVC(), getAllCollateral(), and sendCollaterals() iterate over all collateral tokens without any upper bound on the loop size. If the number of collateral types grows significantly, this could lead to excessive gas consumption."",
      ""Impact"": ""Operations requiring iteration through all collateral types could become prohibitively expensive or fail entirely due to block gas limits as the number of supported collateral types increases."",
      ""Location"": ""getVC(), getAllCollateral(), and sendCollaterals() functions""
    },
    {
      ""Issue"": ""No synchronization with whitelist removals"",
      ""Severity"": ""Medium"",
      ""Description"": ""While there is a function to add a collateral type when the whitelist adds it, there appears to be no mechanism to handle collateral removal if a token is removed from the whitelist."",
      ""Impact"": ""If a token is removed from the whitelist but still exists in the ActivePool's poolColl, it could lead to accounting discrepancies and functions like getCollateral() could fail since whitelist.getIndex() might revert for non-whitelisted tokens."",
      ""Location"": ""Throughout the contract (missing functionality)""
    },
    {
      ""Issue"": ""Tight coupling with external contracts"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract depends heavily on external contracts like IWhitelist and IWAsset, assuming specific behavior when interacting with them. This creates tight coupling that could break if those contracts have issues or change behavior."",
      ""Impact"": ""Changes in external contract behavior could break ActivePool functionality, potentially leading to stuck funds or incorrect accounting."",
      ""Location"": ""Throughout the contract, especially in functions interacting with whitelist and token wrapping""
    },
    {
      ""Issue"": ""Missing events for important operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The setAddresses() function emits events for some address changes but not all (missing events for troveManagerLiquidationsAddress, troveManagerRedemptionsAddress, and collSurplusPoolAddress). Additionally, addCollateralType() doesn't emit an event when a new collateral type is added."",
      ""Impact"": ""Reduced transparency, difficulty tracking changes to important contract configurations, and challenges for off-chain systems monitoring the protocol's state."",
      ""Location"": ""setAddresses() and addCollateralType() functions""
    },
    {
      ""Issue"": ""Inconsistent array length validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract checks that _tokens.length == _amounts.length in some functions but not in others, like receiveCollateral(). This inconsistency could lead to errors if arrays of different lengths are passed."",
      ""Impact"": ""Potential for array out-of-bounds access if mismatched array lengths are provided to functions missing validation."",
      ""Location"": ""receiveCollateral() function and others handling token arrays""
    },
    {
      ""Issue"": ""Inappropriate error messages"",
      ""Severity"": ""Low"",
      ""Description"": ""Error messages like 'AP:Lengths' are not descriptive enough to help users understand what went wrong, which is against best practices."",
      ""Impact"": ""Makes debugging and error handling more difficult for users and developers interacting with the contract."",
      ""Location"": ""Require statements using messages like 'AP:Lengths'""
    }
  ],
  ""IssueNumber"": 61,
  ""OutputList"": 13
}",373.052016019821,58982.0,33.0,"### **[M-03] Unwhitelisted token can cause disaster**

**Report Description**:
The issue highlights that the `sendCollaterals` function in the `ActivePool.sol` contract does not validate whether the tokens being sent are whitelisted. If an allowed contract calls `sendCollaterals` with a non-whitelisted token (potentially due to user input), it could lead to contract instability and financial loss. The function only checks that the caller is authorized and that the lengths of the `_tokens` and `_amounts` arrays match, but it does not verify the whitelist status of the tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unwhitelisted tokens being used in the `sendCollaterals` function. While some responses discuss missing input validation and tight coupling with external contracts, none explicitly mention the risk of non-whitelisted tokens causing instability or financial loss. This is a critical oversight, as the issue directly impacts the security and stability of the contract.

---

### **[M-04] Out of gas**

**Report Description**:
The issue points out that the `poolColl.tokens[]` array in the contract has no upper limit, and its size increases each time a new collateral is added. This can lead to excessive gas consumption in functions like `getVC()`, which iterate over the array. As the number of collateral types grows, the gas cost of these operations increases, potentially causing ""Out of Gas"" errors or exceeding the block gas limit.

**Match in Response List**:
Matches with the issue titled **""Unbounded loops in multiple functions""**.

**Validation**:
**Correct**. The response accurately identifies the problem of unbounded loops in functions like `getVC()`, `getAllCollateral()`, and `sendCollaterals()`. It correctly explains the risk of excessive gas consumption as the number of collateral types increases, which aligns with the issue report. The response also highlights the potential for operations to fail due to block gas limits, which is consistent with the reported impact.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] Out of gas**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-03] Unwhitelisted token can cause disaster**

---

### **Conclusion**

The response list effectively addresses the issue of unbounded loops and gas consumption but fails to cover the critical risk posed by unwhitelisted tokens in the `sendCollaterals` function. This gap highlights the need for more comprehensive validation of token whitelist status in the contract's functions.",1,0,1,13,"```
1. Unbounded loops in multiple functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unbounded loops in multiple functions"".
   - This issue appears at rank 8 in the ranked list of predictions.

2. **Calculate the precision at rank 8**:
   - Precision at rank 8 (\( P@8 \)) is the number of true positives up to rank 8 divided by 8.
   - Since there is only one true positive up to rank 8, \( P@8 = \frac{1}{8} = 0.125 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.125 \).

**Output**:
```
0.125
```",0.07692
BorrowerOperations.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, etc. 
 */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        // transfer collateral into ActivePool
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called _after_ collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist and no duplicates
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }


        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // Use the unmodified _YUSDChange here, as we don't send the fee to the user
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        // transfer withdrawn collateral to msg.sender from ActivePool
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     */
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    /* Checks that:
     * 1. _colls contains no duplicates
     * 2. All elements of _colls are active collateral on the whitelist
     */
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    // requires that avax indices are in order
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",9859.0,1116.0,"[M-05] Reentrancy in contracts/BorrowerOperations.sol

Submitted by heiho1, also found by jayjonah8
Impact

There are several potential re-entrant functions in contracts/BorrowerOperations.sol:
=> Function addColl() on line 346 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _adjustTrove() which potentially impacts user debt, collateral top-ups or withdrawals.
Same applies to
-- withdrawColl() on line 373 -- withdrawYUSD() on line 389 -- repayYUSD() on line 406 -- adjustTrove() on line 420
=> Function openTrove() on line 207 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _openTroveInternal() which potentially impacts trove creation, YUSD withdrawals and YUSD gas compensation.
=> Function closeTrove() on line 628 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes troveManagerCached.r",1.0,,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";



contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    
    
    
    
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, 
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); 

        _requireAtLeastMinNetDebt(vars.netDebt);
        
        
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); 
            _requireNewTCRisAboveCCR(newTCR);
        }

        
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    
    
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    
    
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); 
        _requireNoDuplicateColls(_collsOut);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, 
                params._maxFeePercentage
            );
            
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); 
        }


        
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); 
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        
        
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    
    function claimCollateral() external override {
        
        collSurplusPool.claimColl(msg.sender);
    }

    

    
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); 
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    
    
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); 
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { 
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { 
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    
    
    
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    

    
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    

    
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",8265.0,0.0,1.0,"Based on the thorough analysis of the BorrowerOperations contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in external contract calls, especially in _transferCollateralsIntoActivePool and collateral transfer methods"",
        ""Check for potential integer overflow/underflow in mathematical operations, particularly in fee calculations and VC computations"",
        ""Audit all external function entry points for proper access control and parameter validation"",
        ""Review _adjustTrove and _openTroveInternal methods for potential manipulation vectors""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the onlyOwner modifier implementation and ownership transfer mechanism"",
        ""Validate the setAddresses function's one-time initialization and security"",
        ""Check that _renounceOwnership() is correctly implemented and doesn't introduce vulnerabilities"",
        ""Ensure no critical functions remain accessible after ownership renunciation""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze all external contract interactions for potential call injection or unexpected behavior"",
        ""Verify whitelist contract integration and ensure robust collateral validation"",
        ""Review interactions with TroveManager, ActivePool, and other core protocol contracts"",
        ""Check for proper error handling in cross-contract method calls""
      ]
    },
    {
      ""Area"": ""Multi-Collateral Mechanism"",
      ""Tasks"": [
        ""Thoroughly test _getNewPortfolio method for edge cases with multiple collateral types"",
        ""Verify _getTotalVariableDepositFee calculation across different collateral scenarios"",
        ""Check handling of dust amounts and minimum collateral requirements"",
        ""Validate collateral value calculation (VC) across different token types""
      ]
    },
    {
      ""Area"": ""Fee Mechanisms"",
      ""Tasks"": [
        ""Audit _triggerBorrowingFee and _getTotalVariableDepositFee for potential manipulation"",
        ""Verify fee calculation logic during bootstrap period"",
        ""Check fee distribution to sYETIAddress for potential economic exploits"",
        ""Validate max fee percentage constraints in different system states""
      ]
    },
    {
      ""Area"": ""Recovery Mode Logic"",
      ""Tasks"": [
        ""Comprehensively test recovery mode transitions and restrictions"",
        ""Verify ICR and TCR calculations during recovery mode"",
        ""Check constraints on trove modifications during recovery mode"",
        ""Ensure proper handling of collateral withdrawals and debt changes""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in complex methods like _adjustTrove and _openTroveInternal"",
        ""Review array manipulation methods for potential optimization"",
        ""Check loop structures for potential gas-intensive operations"",
        ""Verify efficiency of multiple collateral handling mechanisms""
      ]
    },
    {
      ""Area"": ""Liquidation and Risk Management"",
      ""Tasks"": [
        ""Verify minimum debt and collateralization ratio requirements"",
        ""Check interaction with liquidation mechanisms in TroveManager"",
        ""Validate gas compensation and surplus collateral handling"",
        ""Audit risk parameters like MCR (Minimum Collateral Ratio) and CCR (Critical Collateral Ratio)""
      ]
    },
    {
      ""Area"": ""Token Interactions"",
      ""Tasks"": [
        ""Verify ERC20 token transfer and approval mechanisms"",
        ""Check handling of non-standard ERC20 tokens"",
        ""Validate YUSD token minting and burning processes"",
        ""Review collateral transfer security in _transferCollateralsIntoActivePool""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test boundary conditions in all public methods"",
        ""Verify proper error message generation"",
        ""Check handling of zero-value and dust amount transactions"",
        ""Validate hint mechanism for sorted troves under various scenarios""
      ]
    }
  ]
}

This task list provides a comprehensive, structured approach to auditing the BorrowerOperations contract. It covers critical areas including security, access control, external interactions, and complex protocol-specific mechanisms. 

The tasks are designed to:
- Identify potential vulnerabilities
- Verify correct implementation of complex logic
- Ensure robust handling of multi-collateral scenarios
- Check economic and security mechanisms
- Validate interactions with other protocol contracts

Recommended next steps:
1. Execute each task methodically
2. Document findings and potential improvements
3. Perform both static analysis and dynamic testing
4. Consider formal verification for critical methods

Would you like me to elaborate on any specific area or provide more detailed guidance for conducting the audit?","I've performed a thorough audit of the BorrowerOperations smart contract. Here are my findings:

{
  ""ReviewingTheCode"": ""The BorrowerOperations contract is a key component of a collateralized debt protocol (Yeti Finance) that handles all borrower operations including opening troves (collateralized debt positions), adjusting troves (add/remove collateral, borrow/repay debt), and closing troves. It interacts with multiple other contracts like TroveManager, ActivePool, and StabilityPool to maintain the system's stability and track borrower positions. The contract employs a multi-collateral system where users can deposit various whitelisted tokens as collateral to borrow YUSD stablecoin."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BorrowerOperations"",
    ""Purpose"": ""Manages borrower interactions with the Yeti Finance protocol, including creating, modifying, and closing debt positions (troves) with multiple collateral types"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""LiquityBase"", ""Ownable"", ""CheckContract"", ""IBorrowerOperations""],
      ""Imports"": [
        ""IBorrowerOperations"", ""ITroveManager"", ""IYUSDToken"", ""ICollSurplusPool"", 
        ""ISortedTroves"", ""ISYETI"", ""IWhitelist"", ""IYetiRouter"", 
        ""LiquityBase"", ""Ownable"", ""CheckContract"", ""IERC20""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Contract identifier""
      },
      {
        ""Name"": ""troveManager"",
        ""Type"": ""ITroveManager"",
        ""Purpose"": ""Interface to the TroveManager contract""
      },
      {
        ""Name"": ""stabilityPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StabilityPool contract""
      },
      {
        ""Name"": ""gasPoolAddress"",
        ""Type"": ""address"", 
        ""Purpose"": ""Address of the GasPool contract""
      },
      {
        ""Name"": ""collSurplusPool"",
        ""Type"": ""ICollSurplusPool"",
        ""Purpose"": ""Interface to the CollSurplusPool contract""
      },
      {
        ""Name"": ""sYETI"",
        ""Type"": ""ISYETI"",
        ""Purpose"": ""Interface to the sYETI contract (staking/governance token)""
      },
      {
        ""Name"": ""sYETIAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the sYETI contract""
      },
      {
        ""Name"": ""yusdToken"",
        ""Type"": ""IYUSDToken"",
        ""Purpose"": ""Interface to the YUSD stablecoin token contract""
      },
      {
        ""Name"": ""BOOTSTRAP_PERIOD"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Period after deployment during which fees are capped (14 days)""
      },
      {
        ""Name"": ""deploymentTime"",
        ""Type"": ""uint"",
        ""Purpose"": ""Timestamp when contract was deployed""
      },
      {
        ""Name"": ""sortedTroves"",
        ""Type"": ""ISortedTroves"",
        ""Purpose"": ""Interface to sortedTroves contract that maintains trove ordering by ICR""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""One-time initialization of contract dependencies"",
        ""Parameters"": [""Various contract addresses""],
        ""Returns"": []
      },
      {
        ""Name"": ""openTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new trove with multiple collateral types and borrows YUSD"",
        ""Parameters"": [""max fee percentage"", ""YUSD amount"", ""hints for sorted list"", ""collateral addresses"", ""collateral amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""_openTroveInternal"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of openTrove logic"",
        ""Parameters"": [""trove owner"", ""max fee percentage"", ""YUSD amount"", ""hints"", ""collateral addresses"", ""collateral amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addColl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds collateral to an existing trove"",
        ""Parameters"": [""collaterals in"", ""amounts in"", ""hints"", ""max fee percentage""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawColl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws collateral from an existing trove"",
        ""Parameters"": [""collaterals out"", ""amounts out"", ""hints""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawYUSD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Borrows more YUSD from an existing trove"",
        ""Parameters"": [""max fee percentage"", ""YUSD amount"", ""hints""],
        ""Returns"": []
      },
      {
        ""Name"": ""repayYUSD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Repays YUSD debt for an existing trove"",
        ""Parameters"": [""YUSD amount"", ""hints""],
        ""Returns"": []
      },
      {
        ""Name"": ""adjustTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Comprehensive function to adjust collateral and debt in one transaction"",
        ""Parameters"": [""collaterals in"", ""amounts in"", ""collaterals out"", ""amounts out"", ""YUSD change"", ""is debt increase"", ""hints"", ""max fee percentage""],
        ""Returns"": []
      },
      {
        ""Name"": ""_adjustTrove"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of trove adjustment logic"",
        ""Parameters"": [""Adjustment parameters struct""],
        ""Returns"": []
      },
      {
        ""Name"": ""closeTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes a trove by repaying all debt and withdrawing all collateral"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""claimCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims collateral from CollSurplusPool after liquidation"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_getTotalVariableDepositFee"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates variable deposit fees for collateral tokens"",
        ""Parameters"": [""tokens in"", ""amounts in"", ""VC values"", ""fee percentage factor"", ""max fee percentage"", ""contracts cache""],
        ""Returns"": [""YUSD fee""]
      },
      {
        ""Name"": ""_transferCollateralsIntoActivePool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers collateral tokens from user to ActivePool"",
        ""Parameters"": [""from address"", ""collateral addresses"", ""amounts""],
        ""Returns"": [""success boolean""]
      },
      {
        ""Name"": ""_triggerBorrowingFee"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and applies borrowing fee"",
        ""Parameters"": [""trove manager"", ""YUSD token"", ""YUSD amount"", ""max fee percentage factor"", ""max fee percentage""],
        ""Returns"": [""YUSD fee""]
      },
      {
        ""Name"": ""getCompositeDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Public wrapper for calculating composite debt (including gas compensation)"",
        ""Parameters"": [""debt amount""],
        ""Returns"": [""composite debt""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""TroveManager - manages trove state, calculates fees, applies rewards"",
    ""ActivePool - holds active collateral and manages YUSD debt"",
    ""DefaultPool - holds defaulted collateral"",
    ""CollSurplusPool - holds surplus collateral from liquidations"",
    ""StabilityPool - used for liquidations"",
    ""SortedTroves - maintains sorted list of troves by ICR"",
    ""YUSDToken - the protocol's stablecoin"",
    ""sYETI - the protocol's staking/governance token"",
    ""Whitelist - manages which collateral tokens are accepted"",
    ""ERC20 tokens - the collateral tokens themselves""
  ],
  ""SpecialMechanisms"": [
    ""Multi-collateral system - allows multiple different tokens as collateral in a single trove"",
    ""Variable deposit fee - fees based on collateral type and system state"",
    ""Recovery mode - special operational state when system TCR falls below CCR"",
    ""Value calculation (VC) - standardized way to measure different collateral values"",
    ""Interest-free borrowing - system uses fees instead of interest rates"",
    ""Bootstrap period - initial period where fees are capped to promote adoption"",
    ""ICR and TCR tracking - Individual Collateral Ratio and Total Collateral Ratio for risk management""
  ],
  ""Questions"": [
    ""How is the whitelist.getValueVC() function implemented? It seems to calculate the value of collateral in terms of a standardized unit."",
    ""What are the specific requirements in '_requireValidDepositCollateral'? The function checks for duplicates and whitelist status."",
    ""How does the system handle liquidations? This contract handles borrower operations but liquidation logic seems to be elsewhere."",
    ""What is the source of price data for collateral valuation? Is there an oracle implementation not shown in this code?"",
    ""How does the routing mechanism work for collateral conversions? The IYetiRouter interface suggests there's some AMM integration."",
    ""What constraints exist on the collateral types that can be accepted? The whitelist seems to control this."",
    ""How are 'hints' (_upperHint and _lowerHint) determined for the sorted list operations?"",
    ""What happens to fees collected in the system? They appear to be sent to the sYETI address.""
  ]
}

After thorough analysis, I've identified potential security considerations in this contract:

1. **Complex multi-collateral handling**: The system manages multiple collaterals with varying risk profiles which increases complexity and potential edge cases.

2. **Centralized whitelist control**: The whitelist contract determines which collaterals are accepted and their parameters, representing a centralization point.

3. **Dependency on external price feeds**: While not explicitly shown in this code, the system relies on price oracles for collateral valuation which could be manipulated.

4. **Potential for flash loan attacks**: The contract doesn't appear to have specific protections against flash loan manipulation of collateral prices.

5. **Recovery mode implementation**: The code includes special behavior during ""recovery mode"" when system collateralization falls below critical levels, but transitions between modes could create edge cases.

6. **YUSD fee handling**: Fees are sent to sYETIAddress which suggests a governance mechanism, but the details of fee distribution aren't clear from this code alone.

7. **Function visibility**: Most state-changing functions are properly externalized, but some complex internal functions might benefit from additional validation.

The contract demonstrates solid architecture with separation of concerns, but the multi-collateral system introduces significant complexity that requires careful testing of all possible interaction paths.","I've analyzed the provided smart contract audit findings for the BorrowerOperations contract. Let me consolidate similar issues and organize them according to their severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in collateral operations"",
      ""Severity"": ""High"",
      ""Description"": ""The contract performs external calls to ERC20 tokens before updating internal state in several functions. The _transferCollateralsIntoActivePool function transfers multiple ERC20 tokens from the user to the active pool without following the checks-effects-interactions pattern. If any collateral tokens have malicious implementations with callbacks, they could potentially re-enter the contract during the transfer operation."",
      ""Impact"": ""A malicious token could reenter the contract during transfer operations, potentially allowing double-spending of collateral, manipulation of system state, or draining funds from the protocol."",
      ""Location"": ""_transferCollateralsIntoActivePool function, openTrove, adjustTrove, and other functions making external token transfers""
    },
    {
      ""Issue"": ""Unchecked return values in ERC20 operations"",
      ""Severity"": ""High"",
      ""Description"": ""The contract checks the return value from transferFrom when moving collateral into the ActivePool, but doesn't uniformly check return values for all ERC20 operations. Several external calls to contracts like yusdToken.mint(), activePool.sendCollateralsUnwrap(), etc., don't check return values. This inconsistency could lead to silent failures with non-standard tokens."",
      ""Impact"": ""Failed token transfers might go undetected, leading to accounting errors where the contract thinks it has received tokens that were never actually transferred, potentially resulting in fund loss or inconsistent state."",
      ""Location"": ""_transferCollateralsIntoActivePool, _withdrawYUSD, _repayYUSD, and other functions making external calls to token contracts""
    },
    {
      ""Issue"": ""Reliance on external price feeds without validation"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies on external price feeds to calculate collateral values without implementing adequate sanity checks. The _getVC function (called from multiple places) uses prices that could potentially be manipulated if the price oracle system fails."",
      ""Impact"": ""Flash loan attacks or oracle manipulation could potentially allow attackers to temporarily affect system valuation and extract value through rapid borrowing and repayment operations."",
      ""Location"": ""_getVC function usage in openTrove, adjustTrove, and related valuation functions""
    },
    {
      ""Issue"": ""Lack of access control in _openTroveInternal"",
      ""Severity"": ""High"",
      ""Description"": ""The _openTroveInternal function can be called by any external function without proper access control. This function handles critical operations including creating new troves and minting YUSD tokens. While it's currently only called by legitimate functions like openTrove, future modifications could potentially add vulnerable entry points."",
      ""Impact"": ""If exploited, an attacker could bypass the intended flow and controls in the wrapper functions, potentially creating malicious troves or minting unauthorized tokens."",
      ""Location"": ""Function _openTroveInternal(address _troveOwner, uint256 _maxFeePercentage, uint256 _YUSDAmount, address _upperHint, address _lowerHint, address[] memory _colls, uint256[] memory _amounts)""
    },
    {
      ""Issue"": ""Inadequate validation in collateral operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple validation issues exist in the collateral handling: 1) The _requireNoDuplicateColls check is applied inconsistently, 2) The contract doesn't validate if token addresses are zero addresses or if they are legitimate ERC20 tokens beyond whitelist checking, 3) Token ordering is not enforced which could lead to manipulation, and 4) The contract doesn't verify that all collaterals in _collsOut already exist in the user's trove during adjustTrove."",
      ""Impact"": ""These validation issues could lead to accounting errors, manipulation of collateral calculations, failed transactions, or inconsistent state when adding or withdrawing collateral."",
      ""Location"": ""_requireNoDuplicateColls, _requireValidDepositCollateral, adjustTrove, and other collateral handling functions""
    },
    {
      ""Issue"": ""Precision loss in fee calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""In several fee calculation functions (like _getTotalVariableDepositFee and _triggerBorrowingFee), there are multiple division operations that could lead to precision loss, especially when dealing with small amounts. Various fee calculations involve division operations after multiplication, which can lead to precision loss, particularly when calculating whitelistFee and collateralYUSDFee."",
      ""Impact"": ""Users might pay slightly different fees than intended due to rounding errors, potentially benefiting or harming either users or the protocol. Accumulated precision losses could lead to unfair fee distributions over time."",
      ""Location"": ""_getTotalVariableDepositFee, _triggerBorrowingFee, _getNewICRFromTroveChange functions and other math operations""
    },
    {
      ""Issue"": ""Potential integer overflow/underflow in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs various mathematical operations for calculating value, collateral ratios, and fees without thoroughly checking for potential overflows/underflows in all cases. While Solidity 0.6.11 doesn't have built-in overflow protection, not all arithmetic operations use SafeMath."",
      ""Impact"": ""Extreme collateral values, debt positions, or fee parameters could potentially lead to incorrect calculations, resulting in system instability, incorrect fee charges, or incorrect liquidation conditions."",
      ""Location"": ""_getNewICRFromTroveChange, _getNewTCRFromTroveChange, _triggerBorrowingFee, and related calculation functions""
    },
    {
      ""Issue"": ""Unbounded loops in collateral processing"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions process arrays of collateral tokens without limiting the array size, including _transferCollateralsIntoActivePool, _getTotalVariableDepositFee, _getNewPortfolio, and others. This could potentially lead to denial of service if extremely large arrays are provided, causing transactions to exceed block gas limits."",
      ""Impact"": ""Transactions with many collateral types might fail due to excessive gas consumption, potentially locking user funds or preventing critical operations."",
      ""Location"": ""_getNewPortfolio, _transferCollateralsIntoActivePool, _getTotalVariableDepositFee, and other functions processing collateral arrays""
    },
    {
      ""Issue"": ""Inconsistent fee handling logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several inconsistencies exist in the fee handling: 1) The mechanism for applying _maxFeePercentage to variable deposit fees is complex and might not be intuitive, 2) MaxFeePercentage is adjusted after calculating borrowing fee but before calculating variable deposit fee, 3) During Recovery Mode, borrowing fees are waived but variable deposit fees are still charged, and 4) There's no explicit cap on fees after the bootstrap period ends."",
      ""Impact"": ""Users might pay more in fees than they authorized or expected, particularly after maxFeePercentage adjustments or when the bootstrap period ends. This could lead to transaction failures or unexpected costs."",
      ""Location"": ""_openTroveInternal, _adjustTrove, _getTotalVariableDepositFee functions""
    },
    {
      ""Issue"": ""No slippage protection in collateral operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""When users add or withdraw collateral directly (not through routers), there's no slippage protection mechanism. Additionally, while the contract includes parameters for minimum swap amounts in router operations, the enforcement mechanism for these minimums isn't comprehensive. The _requireValidRouterParams function only checks array lengths without verifying the actual values are reasonable."",
      ""Impact"": ""Users could receive less value than expected when adding or withdrawing collateral or when their collateral is routed through multiple exchanges, potentially leading to capital loss or unexpected liquidations."",
      ""Location"": ""addColl, withdrawColl, adjustTrove, and _requireValidRouterParams functions""
    },
    {
      ""Issue"": ""Front-running vulnerability in fee calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The variable deposit fee calculation in _getTotalVariableDepositFee depends on the current state of the pool. This creates opportunities for front-running where users might monitor pending transactions to execute their own transactions first when fees are lower. Additionally, during the bootstrap period, the fee is capped at 1%, which could be exploited by timing transactions strategically."",
      ""Impact"": ""Users might pay higher fees than necessary, and sophisticated actors could gain advantages by front-running others' transactions or timing them to take advantage of the bootstrap period cap."",
      ""Location"": ""_getTotalVariableDepositFee function, particularly the bootstrap period logic""
    },
    {
      ""Issue"": ""Insufficient validation in initialization and configuration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setAddresses function doesn't validate that the provided addresses are not zero addresses. While it uses checkContract to ensure they have code, it doesn't ensure they're the correct contracts. This creates centralization risk during the initialization process where the owner has significant control."",
      ""Impact"": ""If the owner sets malicious contract addresses during initialization, the entire system could be compromised before ownership is renounced. Incorrect contract initialization could lead to system-wide issues and potential loss of funds."",
      ""Location"": ""setAddresses function""
    },
    {
      ""Issue"": ""Centralization risks in system dependencies"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies heavily on external contracts like the whitelist to determine valid collateral types, their values, and fees. This creates centralization points where changes to these external contracts could significantly impact the system. If the whitelist contract is compromised or misconfigured, it could have severe effects on the entire system."",
      ""Impact"": ""If the whitelist or other dependent contracts are compromised or maliciously updated, it could allow worthless tokens to be used as valuable collateral, block legitimate collateral, or cause users to pay excessive fees."",
      ""Location"": ""Throughout the contract, particularly in _requireValidDepositCollateral and _getTotalVariableDepositFee""
    },
    {
      ""Issue"": ""Timestamp dependency for fee bootstrap period"",
      ""Severity"": ""Low"",
      ""Description"": ""The _isBeforeFeeBootstrapPeriod function relies on block.timestamp to determine if the system is in the bootstrap period where fees are capped. Miners can manipulate timestamps within certain bounds, potentially allowing exploitation of this period. Additionally, there's no graceful handling of the transition when this period ends."",
      ""Impact"": ""A malicious validator could manipulate the timestamp to extend the bootstrap period, resulting in artificially lower fees. Users might also face unexpectedly higher fees immediately after the bootstrap period ends."",
      ""Location"": ""_isBeforeFeeBootstrapPeriod function and related fee capping in _getTotalVariableDepositFee""
    },
    {
      ""Issue"": ""Missing events for important operations"",
      ""Severity"": ""Low"",
      ""Description"": ""While there is an event YUSDBorrowingFeePaid for borrowing fees, there's no equivalent event for variable deposit fees. This makes it harder to track and audit these fees and other important operations."",
      ""Impact"": ""Reduced transparency and difficulty in auditing variable deposit fees through events, which could complicate monitoring and analysis of the system."",
      ""Location"": ""Throughout the contract, specifically in functions that trigger variable deposit fees""
    },
    {
      ""Issue"": ""Hardcoded gas compensation values"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a hardcoded YUSD_GAS_COMPENSATION constant for gas compensation. This approach doesn't adjust for varying gas prices or complexity of different operations, which could lead to inadequate compensation during network congestion."",
      ""Impact"": ""During periods of high network activity, the gas compensation might be insufficient to cover the actual gas costs, potentially leading to liquidations being economically unviable. Alternatively, if gas prices decrease, the hardcoded value could become excessive."",
      ""Location"": ""Throughout the contract where YUSD_GAS_COMPENSATION is used, including closeTrove function""
    },
    {
      ""Issue"": ""Inefficient overlapping collateral detection"",
      ""Severity"": ""Low"",
      ""Description"": ""The _requireNoOverlapColls function uses nested loops to detect overlapping collaterals, resulting in O(nÂ²) complexity. For large collateral arrays, this could lead to excessive gas consumption."",
      ""Impact"": ""Users attempting to adjust troves with many collateral types could experience high gas costs or transaction failures if the gas limit is exceeded."",
      ""Location"": ""_requireNoOverlapColls function""
    }
  ],
  ""IssueNumber"": 70,
  ""OutputList"": 17
}",436.530758142471,146696.0,32.0,"---

**[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Report Description**:
The issue report identifies several functions in `BorrowerOperations.sol` that are potentially re-entrant due to the lack of reentrancy guards. These functions include `addColl()`, `withdrawColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`. Each of these functions is external and interacts with other internal functions or external contracts, which could lead to reentrancy attacks. The impact of such vulnerabilities includes manipulation of user debt, collateral top-ups or withdrawals, and potential exploitation of trove creation and YUSD gas compensation.

**Match in Response List**:
Matches with the issue titled **""Reentrancy vulnerability in collateral operations""**.

**Validation**:
**Partially Correct**. The response identifies the reentrancy vulnerability in collateral operations and correctly highlights the risks associated with external calls to ERC20 tokens before updating internal state. However, the response focuses primarily on the `_transferCollateralsIntoActivePool` function and does not explicitly address all the functions mentioned in the issue report (`addColl()`, `withdrawColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`). While the core issue of reentrancy is acknowledged, the response misses critical details about the specific functions at risk and their potential impacts.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Missed Issues from Issue Report**:
- *None*

---",1,0,0,17,"```
None.
```","Since there are no true positives in the provided list, the **Average Precision (AP)** for the query is:

**0.0**",1.0
ThreePieceWiseLinearPriceCurve.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";

/** 
 * This contract is used to calculate the variable fee for an input of tokens. 
 * Uses three linear piecewise functions to calculate the fee, and the average 
 * of the system collateralization by that asset before and after the tx. 
 */
contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    /** 
     * f1 = m1 * x + b1
     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2
     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3
     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages
     * Decimal precision = 1e18
     */

    /** 
     * Function for setting slopes and intercepts of linear functions used for fee calculations. 
     */
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.
        decayTime = 5 days;
    }

    // Set the whitelist address so that the fee can only be updated by whitelistAddress
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    // Set the decay time in seconds
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     * @param _collateralVCInput is how much collateral is being input by the user into the system
     * @param _totalCollateralVCBalance is how much collateral is in the system
     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)
     */
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    // Called only by whitelist. Updates the last fee time and last fee percent
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     */
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        // percent of all VC backed by this collateral * 1e18
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { // use function 1
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { // use function 2
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
        } else { // use function 3
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",2218.0,197.0,"[M-07] Cannot use most piecewise linear functions with current implementation

TheÂ ThreePieceWiseLinearPriceCurve.adjustParamsÂ function uses three functionsÂ f1, f2, f3Â whereÂ y_i = f_i(x_i). It computes the y-axis intersect (b2 = f_2(0), b3 = f_3(0)) for each of these but usesÂ unsigned integersÂ for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.
â€¨
[M-08] Wrong comment inÂ getFee

TheÂ ThreePieceWiseLinearPriceCurve.getFeeÂ comment states that the total + the input must be less than the cap:
If dollarCap == 0, then it is not capped. Otherwise,Â then the total + the total inputÂ must be less than the cap.
The code only checks if the input is less than the cap:
// @param _collateralVCInput is how much collateral is being input by the user into the system
if (dollarCap != 0) {
    require(_collateralVCInput <= dollarCap, ""Collateral input exceeds cap"");
}
â€¨â€¨â€¨[M-09] Fee not decayed if pastÂ decayTime

TheÂ ThreePieceWiseLinearPriceCurve.calculateDecayedFeeÂ function is supposed to decay theÂ lastFeePercentÂ over time. This is correctly done in theÂ decay > 0 && decay < decayTimeÂ case, but for theÂ decay > decayTimeÂ case it does not decay at all but should set it to 0 instead..
if (decay > 0 && decay < decayTime) {
    // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.
    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));
} else {
    fee = lastFeePercent;
}",3.0,,"pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";


contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    

    
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; 
        decayTime = 5 days;
    }

    
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    
    
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { 
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { 
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            
        } else { 
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",1536.0,0.0,3.0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the integrity of the onlyOwner modifier implementation"",
        ""Audit the setAddresses function for potential security risks"",
        ""Confirm that addressesSet prevents multiple address configurations"",
        ""Examine the whitelistAddress mechanism and its authorization checks""
      ]
    },
    {
      ""Area"": ""Mathematical Precision & SafeMath"",
      ""Tasks"": [
        ""Validate all mathematical calculations for potential overflow/underflow risks"",
        ""Review the use of 1e18 for decimal precision in calculations"",
        ""Check the _getFeePoint function for edge case handling"",
        ""Verify the correctness of fee calculation logic across different segments""
      ]
    },
    {
      ""Area"": ""Fee Calculation Mechanism"",
      ""Tasks"": [
        ""Analyze the three-piece linear curve implementation for potential manipulation"",
        ""Review the calculateDecayedFee logic for time-based fee reduction"",
        ""Verify the getFee and getFeeAndUpdate functions for consistency"",
        ""Check the maximum fee capping mechanism (limited to 1e18)""
      ]
    },
    {
      ""Area"": ""External Interactions & Whitelist"",
      ""Tasks"": [
        ""Audit the whitelist address interactions for potential security vulnerabilities"",
        ""Verify the setFeeCapAndTime function access controls"",
        ""Ensure that only the whitelist can update critical fee parameters"",
        ""Check for potential front-running risks in fee updates""
      ]
    },
    {
      ""Area"": ""Parameter Configuration"",
      ""Tasks"": [
        ""Review the adjustParams function for parameter validation"",
        ""Verify the constraints on cutoff values and fee parameters"",
        ""Check the dollarCap implementation for potential bypass methods"",
        ""Analyze the dynamic fee parameter calculation logic""
      ]
    },
    {
      ""Area"": ""Gas Optimization & Efficiency"",
      ""Tasks"": [
        ""Evaluate the efficiency of internal view functions"",
        ""Review the use of storage vs. memory in function parameters"",
        ""Check for redundant calculations or unnecessary storage operations"",
        ""Analyze the computational complexity of fee calculations""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Verify error handling for zero total VC balance scenarios"",
        ""Check boundary condition handling in fee calculations"",
        ""Review require statements for comprehensive input validation"",
        ""Test extreme input values for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""Contract Interactions & Interface Compliance"",
      ""Tasks"": [
        ""Verify full compliance with IPriceCurve interface"",
        ""Check implementation of all required override functions"",
        ""Ensure consistent return types and parameter handling"",
        ""Review any potential interface interaction vulnerabilities""
      ]
    }
  ],

  ""KeyAuditPriorities"": [
    ""The complex fee calculation mechanism with three linear segments"",
    ""Access control and whitelist interactions"",
    ""Mathematical precision and potential overflow risks"",
    ""Parameter configuration and validation"",
    ""Time-based fee decay implementation""
  ],

  ""RecommendedNextSteps"": [
    ""Conduct a detailed line-by-line code review"",
    ""Develop comprehensive test cases covering various scenarios"",
    ""Perform static analysis using security tools"",
    ""Consider formal verification of mathematical calculations"",
    ""Create detailed documentation explaining the fee calculation mechanism""
  ],

  ""PotentialConcerns"": [
    ""Complexity of the fee calculation logic"",
    ""Reliance on external whitelist address"",
    ""Precision of mathematical calculations"",
    ""Potential for manipulation through parameter configuration""
  ]
}
","{
  ""ReviewingTheCode"": ""This contract implements a three-piece-wise linear price curve that determines fees based on collateral ratios. It's designed to calculate dynamic fees based on the relationship between collateral value and total value, with three different linear curves applying at different percentage ranges. The fee system also includes a decay mechanism where fees decrease over time."",

  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ThreePieceWiseLinearPriceCurve"",
    ""Purpose"": ""Implements a price curve with three linear segments to calculate dynamic fees based on collateral ratios, with a time-based decay feature"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IPriceCurve"", ""Ownable""],
      ""Imports"": [
        ""../Interfaces/IPriceCurve.sol"",
        ""../Dependencies/SafeMath.sol"",
        ""../Dependencies/Ownable.sol""
      ]
    },
    ""StateVariables"": [
      {""Name"": ""name"", ""Type"": ""string"", ""Purpose"": ""Identifier for the price curve configuration""},
      {""Name"": ""m1, m2, m3"", ""Type"": ""uint256"", ""Purpose"": ""Slope parameters for the three linear segments""},
      {""Name"": ""b1, b2, b3"", ""Type"": ""uint256"", ""Purpose"": ""Intercept parameters for linear segments""},
      {""Name"": ""b2Negative, b3Negative"", ""Type"": ""bool"", ""Purpose"": ""Subtract/add flags for intercepts in calculations""},
      {""Name"": ""cutoff1, cutoff2"", ""Type"": ""uint256"", ""Purpose"": ""Thresholds to switch between linear segments""},
      {""Name"": ""decayTime"", ""Type"": ""uint256"", ""Purpose"": ""Period for fee decay to zero, default 5 days""},
      {""Name"": ""lastFeeTime"", ""Type"": ""uint"", ""Purpose"": ""Timestamp of last fee calculation""},
      {""Name"": ""lastFeePercent"", ""Type"": ""uint"", ""Purpose"": ""Last calculated fee percentage""},
      {""Name"": ""dollarCap"", ""Type"": ""uint"", ""Purpose"": ""Maximum collateral value limit""},
      {""Name"": ""whitelistAddress"", ""Type"": ""address"", ""Purpose"": ""Authorized address for updating fees""},
      {""Name"": ""addressesSet"", ""Type"": ""bool"", ""Purpose"": ""Prevents multiple address configurations""}
    ],
    ""FunctionsAndModifiers"": [
      {""Name"": ""adjustParams"", ""Visibility"": ""external"", ""Purpose"": ""Configure price curve parameters"", ""Parameters"": [""_name"", ""_m1"", ""_b1"", ""_m2"", ""_cutoff1"", ""_m3"", ""_cutoff2"", ""_dollarCap""], ""Returns"": []},
      {""Name"": ""setAddresses"", ""Visibility"": ""external"", ""Purpose"": ""Sets whitelisted address"", ""Parameters"": [""_whitelistAddress""], ""Returns"": []},
      {""Name"": ""setDecayTime"", ""Visibility"": ""external"", ""Purpose"": ""Modify fee decay time"", ""Parameters"": [""_decayTime""], ""Returns"": []},
      {""Name"": ""getFeeCapAndTime"", ""Visibility"": ""external view"", ""Purpose"": ""Returns last fee percent and timestamp"", ""Parameters"": [], ""Returns"": [""lastFeePercent"", ""lastFeeTime""]},
      {""Name"": ""setFeeCapAndTime"", ""Visibility"": ""external"", ""Purpose"": ""Sets last fee percent and timestamp"", ""Parameters"": [""_lastFeePercent"", ""_lastFeeTime""], ""Returns"": []},
      {""Name"": ""getFee"", ""Visibility"": ""external view"", ""Purpose"": ""Calculates fee without state update"", ""Parameters"": [""_collateralVCInput"", ""_totalCollateralVCBalance"", ""_totalVCBalancePre"", ""_totalVCBalancePost""], ""Returns"": [""fee""]},
      {""Name"": ""getFeeAndUpdate"", ""Visibility"": ""external"", ""Purpose"": ""Calculates and updates fee state"", ""Parameters"": [""_collateralVCInput"", ""_totalCollateralVCBalance"", ""_totalVCBalancePre"", ""_totalVCBalancePost""], ""Returns"": [""feeCalculated""]},
      {""Name"": ""_getFeePoint"", ""Visibility"": ""internal view"", ""Purpose"": ""Fee at collateral ratio point"", ""Parameters"": [""_collateralVCBalance"", ""_totalVCBalance""], ""Returns"": [""fee""]},
      {""Name"": ""calculateDecayedFee"", ""Visibility"": ""public view"", ""Purpose"": ""Time-decayed fee calculation"", ""Parameters"": [], ""Returns"": [""fee""]},
      {""Name"": ""_min"", ""Visibility"": ""internal pure"", ""Purpose"": ""Utility min value"", ""Parameters"": [""a"", ""b""], ""Returns"": [""minimum value""]},
      {""Name"": ""_max"", ""Visibility"": ""internal pure"", ""Purpose"": ""Utility max value"", ""Parameters"": [""a"", ""b""], ""Returns"": [""maximum value""]}
    ]
  },

  ""ExternalInteractions"": [
    ""Inherits IPriceCurve interface for function definition"",
    ""Ownable inheritance for access control"",
    ""SafeMath library for secure math operations"",
    ""Interaction with external whitelisted address for fee updates""
  ],

  ""SpecialMechanisms"": [
    ""Three-segment linear fee calculation"",
    ""Linear time-based fee decay"",
    ""Two-state averaging fee calculation"",
    ""Dollar cap on total collateral"",
    ""Fee floor to prevent excessive reduction""
  ],

  ""Questions"": [
    ""Meaning of 'VC' in parameter names?"",
    ""Role of whitelistAddress in broader system?"",
    ""Initial determination of slope and intercept parameters?"",
    ""Reason for using precision divisor (1e18)?"",
    ""Business rationale behind three-segment curve?"",
    ""Use case for dollarCap parameter?""
  ]
}
","{
  ""Findings"": [
    {
      ""Issue"": ""Unrestricted Parameter Adjustment by Owner"",
      ""Severity"": ""High"",
      ""Description"": ""The owner can arbitrarily change critical economic parameters, including the fee calculation slopes (m1, m2, m3), intercepts, and dollar cap, without governance or timelock protections."",
      ""Impact"": ""This centralization risk could lead to economic manipulation, extraction of excessive fees, or economic disruption by a compromised or malicious owner."",
      ""Location"": ""adjustParams function""
    },
    {
      ""Issue"": ""Integer Overflow and Precision Loss in Fee Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""Complex arithmetic involving multiplication followed by division in fee calculation logic could overflow or lose precision, especially when dealing with large values."",
      ""Impact"": ""Incorrect fee calculations could lead to financial losses or gains for users, disrupting the protocol's economic integrity."",
      ""Location"": ""_getFeePoint function, getFee and getFeeAndUpdate functions""
    },
    {
      ""Issue"": ""Lack of Comprehensive Input Validation in adjustParams"",
      ""Severity"": ""Medium"",
      ""Description"": ""The adjustParams function only minimally checks parameters (e.g., _cutoff1 <= _cutoff2) but fails to validate other critical parameters (m1, m2, m3, b1), potentially resulting in illogical fee curves."",
      ""Impact"": ""Improper parameter settings could result in economically nonsensical or exploitative fee structures."",
      ""Location"": ""adjustParams function""
    },
    {
      ""Issue"": ""Immutable Whitelist Address Setting"",
      ""Severity"": ""Medium"",
      ""Description"": ""Once the whitelistAddress is set via setAddresses, it cannot be changed, creating a potential single point of failure if the whitelist needs updating or if compromised."",
      ""Impact"": ""Inability to update or recover the whitelistAddress without redeploying the entire contract, causing operational disruption."",
      ""Location"": ""setAddresses function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""Fee calculation and updates dependent on external states can be front-run, allowing sophisticated users to execute transactions at more favorable rates."",
      ""Impact"": ""Consistent exploitation could lead to revenue loss for the protocol."",
      ""Location"": ""getFeeAndUpdate function""
    },
    {
      ""Issue"": ""Centralization Risk Due to Owner Controls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Significant functions, including parameter adjustments and decay time changes, rely solely on the owner, posing centralization risks."",
      ""Impact"": ""Single point of control susceptible to malicious manipulation."",
      ""Location"": ""adjustParams, setDecayTime functions""
    },
    {
      ""Issue"": ""Lack of Event Emissions for Critical Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state changes, such as parameter adjustments or fee updates, lack corresponding events, reducing transparency."",
      ""Impact"": ""Reduced off-chain monitoring capability, complicating audits and user trust."",
      ""Location"": ""adjustParams, setAddresses, setDecayTime, getFeeAndUpdate functions""
    },
    {
      ""Issue"": ""Timestamp Manipulation Risk"",
      ""Severity"": ""Low"",
      ""Description"": ""Use of block.timestamp for fee decay calculations can be slightly manipulated by miners."",
      ""Impact"": ""Marginal manipulation of fee calculation outcomes, though impact limited by the scale of decay periods."",
      ""Location"": ""calculateDecayedFee function, getFeeAndUpdate function""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 8
}",1083.36878204346,121744.0,102.0,"### **[M-07] Cannot use most piecewise linear functions with current implementation**

**Report Description**:
The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue highlights a limitation in the implementation of piecewise linear functions due to the use of unsigned integers, which prevents the use of functions with negative y-intercepts. This specific concern is not addressed in the `response_list`, which focuses on other vulnerabilities like parameter adjustment, integer overflow, and input validation. The response list does not cover the mathematical limitations imposed by the use of unsigned integers in this context.

---

### **[M-08] Wrong comment in getFee**

**Report Description**:
The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap: ""If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap."" However, the code only checks if the input is less than the cap: `if (dollarCap != 0) { require(_collateralVCInput <= dollarCap, ""Collateral input exceeds cap""); }`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue points out a discrepancy between the comment and the actual code logic, which could mislead developers or auditors. The `response_list` does not address this specific issue, as it focuses on other vulnerabilities like integer overflow, front-running, and centralization risks. The mismatch between the comment and the code is not covered in the responses.

---

### **[M-09] Fee not decayed if past decayTime**

**Report Description**:
The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case, it does not decay at all but should set it to 0 instead.

**Match in Response List**:
Matches with the issue titled **""Timestamp Manipulation Risk""**.

**Validation**:
**Partially Correct**. The response identifies the use of `block.timestamp` for fee decay calculations and mentions the risk of miner manipulation. However, it does not address the specific issue where the fee is not decayed to 0 when `decay > decayTime`. While the response touches on the broader context of timestamp usage, it misses the critical detail of the incorrect decay logic in the `decay > decayTime` case.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-09] Fee not decayed if past decayTime**

**Missed Issues from Issue Report**:
- **[M-07] Cannot use most piecewise linear functions with current implementation**
- **[M-08] Wrong comment in getFee**

---

The `response_list` does not adequately cover the specific issues raised in the `issue` report, particularly the limitations of unsigned integers in piecewise linear functions and the discrepancy between the comment and code in the `getFee` function. The response for the fee decay issue is partially correct but misses the critical detail of the incorrect decay logic.",0,0,3,0,"```
None.
```",0.0,0.0
,,,,,,,,,,,,,,3145.96416521073,631472.0,263.0,,5,0,5,81,,,2.47242
