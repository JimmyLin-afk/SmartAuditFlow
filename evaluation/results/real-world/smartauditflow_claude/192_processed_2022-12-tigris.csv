nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Lock.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",1088,145,"[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
There are two functions that allow to lock some amount of assets. The first function is Lock.lock which creates a new bond. The second function is the function `extendLock`. This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.
The issue is that the `extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `release` is called.
Therefore only the amount of assets deposited via `lock` can be released again. The amount of assets deposited using `extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.
  [M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract
When calling the function `claimGovFees()`, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in the function `bondNFT.distribute`.
  [M-02] Must approve 0 first
Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved in function `claimGovFees()`.  Recommend: Add an approve(0) before approving",3,"pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",790,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct a thorough reentrancy analysis on external contract calls in claim(), claimDebt(), and lock() functions"",
        ""Verify input validation and sanitization in all public and external functions"",
        ""Check for potential integer overflow/underflow risks in mathematical operations"",
        ""Validate that token transfers are using safe transfer methods"",
        ""Analyze the potential for unexpected state changes in claimGovFees() function""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the scope and implementation of onlyOwner() modifier in editAsset() and sendNFTs() functions"",
        ""Ensure no critical functions can be called by unauthorized addresses"",
        ""Check for potential privilege escalation vulnerabilities"",
        ""Review the ownership transfer mechanism and potential centralization risks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interactions with IBondNFT and IGovNFT interfaces for potential external call vulnerabilities"",
        ""Verify the correctness of token approvals in claimGovFees() function"",
        ""Check the handling of failed token transfers or approval calls"",
        ""Validate the integrity of cross-contract method calls"",
        ""Ensure proper error handling for external contract interactions""
      ]
    },
    {
      ""Area"": ""Token Locking Mechanism"",
      ""Tasks"": [
        ""Verify the correctness of lock period constraints (minPeriod and maxPeriod)"",
        ""Analyze the token locking and releasing logic in lock(), extendLock(), and release() functions"",
        ""Check the accuracy of totalLocked mapping updates"",
        ""Validate the token transfer and accounting mechanisms"",
        ""Ensure proper handling of locked tokens across different scenarios""
      ]
    },
    {
      ""Area"": ""Fee Distribution"",
      ""Tasks"": [
        ""Audit the claimGovFees() function for potential manipulation"",
        ""Verify the correctness of governance fee claiming and distribution"",
        ""Check for any potential inconsistencies in fee allocation"",
        ""Validate the approve mechanism with type(uint256).max"",
        ""Ensure transparent and fair fee distribution process""
      ]
    },
    {
      ""Area"": ""Asset Management"",
      ""Tasks"": [
        ""Review the implementation of editAsset() function for potential asset manipulation"",
        ""Verify the allowedAssets mapping's role in preventing unauthorized token locks"",
        ""Check for potential denial of service through asset management"",
        ""Validate the process of adding or removing allowed assets""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in complex functions like claimGovFees()"",
        ""Check for potential gas optimization opportunities"",
        ""Verify the efficiency of loop operations in claimGovFees()"",
        ""Review the use of storage variables and their gas implications""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test behavior with zero-value transfers"",
        ""Verify handling of tokens with different decimal precisions"",
        ""Check edge cases in lock period calculations"",
        ""Validate error handling for failed token transfers"",
        ""Ensure robust handling of unexpected contract states""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The Lock contract implements a token locking mechanism with NFT representation. It allows users to lock ERC20 tokens for a specified period, receiving bond NFTs in return. The contract facilitates claiming rewards, extending lock periods, and releasing locked tokens. It also handles the distribution of governance fees to bondholders."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Lock"",
    ""Purpose"": ""Manages a token locking system where users can lock approved ERC20 tokens and receive bond NFTs in return. Includes functionality for claiming rewards, extending locks, and releasing tokens after lock periods end."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""hardhat/console.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/IBondNFT.sol"",
        ""./interfaces/IGovNFT.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""minPeriod"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Minimum lock period (7 days)""
      },
      {
        ""Name"": ""maxPeriod"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Maximum lock period (365 days)""
      },
      {
        ""Name"": ""bondNFT"",
        ""Type"": ""IBondNFT immutable"",
        ""Purpose"": ""Interface to the Bond NFT contract that represents locked positions""
      },
      {
        ""Name"": ""govNFT"",
        ""Type"": ""IGovNFT immutable"",
        ""Purpose"": ""Interface to the Governance NFT contract for claiming fees""
      },
      {
        ""Name"": ""allowedAssets"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks which ERC20 tokens are allowed to be locked""
      },
      {
        ""Name"": ""totalLocked"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Tracks the total amount of each token that is locked""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with addresses for bondNFT and govNFT"",
        ""Parameters"": [""address _bondNFTAddress"", ""address _govNFT""],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims rewards for a specific bond NFT and transfers them to the caller"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""address (the asset address)""]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims accumulated debt rewards for a specific asset"",
        ""Parameters"": [""address _tigAsset""],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Locks tokens for a specified period, creating a bond NFT"",
        ""Parameters"": [""address _asset"", ""uint _amount"", ""uint _period""],
        ""Returns"": []
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Extends an existing lock by adding more tokens or time"",
        ""Parameters"": [""uint _id"", ""uint _amount"", ""uint _period""],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Releases locked tokens when the lock period has expired"",
        ""Parameters"": [""uint _id""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimGovFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims governance fees for all assets and distributes them to bond holders"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""editAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to enable or disable specific assets for locking"",
        ""Parameters"": [""address _tigAsset"", ""bool _isAllowed""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendNFTs"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to transfer governance NFTs to the owner"",
        ""Parameters"": [""uint[] memory _ids""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IBondNFT - Creates, extends, and releases locks represented as NFTs"",
    ""IGovNFT - Claims fees and transfers NFTs"",
    ""IERC20 - Handles token transfers, approvals, and balances""
  ],
  
  ""SpecialMechanisms"": [
    ""NFT-based token locking system where locked tokens are represented as NFTs"",
    ""Fee distribution mechanism that claims governance fees and distributes them to bondholders"",
    ""Token approval and transfer mechanism to handle user deposits and withdrawals""
  ],
  
  ""Questions"": [
    ""What's the relationship between bondNFT and govNFT? How do these two NFT systems interact?"",
    ""How are debt rewards calculated in the bondNFT contract?"",
    ""What security measures exist to prevent unauthorized claiming or releasing of bonds?"",
    ""How does the distribute function in bondNFT allocate fees to bondholders?"",
    ""What happens if a token that was previously allowed becomes disallowed?"",
    ""Is there any mechanism to handle situations where token transfers fail?"",
    ""What happens to locked tokens if the contract is upgraded or replaced?"",
    ""Is there a limit to how many assets can be supported by the system?""
  ]
}","{
""Findings"": [
{
""Issue"": ""Missing Return Value Validation for Token Transfers"",
""Severity"": ""High"",
""Description"": ""The contract does not validate return values from ERC20 transfer and transferFrom operations across multiple functions. Some ERC20 tokens (like USDT) return false instead of reverting on failure, which could lead to silent failures where tokens appear to be transferred but actually aren't."",
""Impact"": ""Silent failures in token transfers could result in loss of funds, locked assets, or inconsistent contract state where accounting records indicate tokens were moved when they weren't actually transferred."",
""Location"": ""claim(), claimDebt(), lock(), release() functions - all IERC20 transfer and transferFrom calls""
},
{
""Issue"": ""Reentrancy Vulnerabilities"",
""Severity"": ""High"",
""Description"": ""Multiple functions make external calls to other contracts before updating state variables, creating potential re-entrancy attack vectors. The contract doesn't follow the checks-effects-interactions pattern consistently, particularly in functions involving token transfers and external contract calls."",
""Impact"": ""Malicious contracts could re-enter the Lock contract during external calls, potentially executing functions multiple times and draining tokens or manipulating contract state."",
""Location"": ""claim(), release(), and other functions making external calls before state updates""
},
{
""Issue"": ""Unlimited Token Approvals"",
""Severity"": ""Medium"",
""Description"": ""The claimGovFees() function approves bondNFT to spend the maximum possible amount (type(uint256).max) of each token. This unlimited approval persists across function calls and creates an unnecessary security risk."",
""Impact"": ""If the bondNFT contract is compromised or contains vulnerabilities, an attacker could drain all tokens from the Lock contract up to the maximum value."",
""Location"": ""claimGovFees() function - IERC20(assets[i]).approve() call""
},
{
""Issue"": ""Centralization Risks"",
""Severity"": ""Medium"",
""Description"": ""The contract gives significant control to the owner through functions like editAsset() and sendNFTs(). The owner can arbitrarily enable/disable assets and withdraw NFTs from the contract without restrictions or timelock mechanisms."",
""Impact"": ""Users have to trust the owner not to suddenly disallow assets they've locked or to not extract valuable NFTs from the contract. If the owner's private key is compromised, an attacker could manipulate allowed assets or steal NFTs."",
""Location"": ""editAsset() and sendNFTs() functions with onlyOwner modifier""
},
{
""Issue"": ""Unbounded Loop in claimGovFees"",
""Severity"": ""Medium"",
""Description"": ""The claimGovFees() function iterates through all assets returned by bondNFT.getAssets() without any limit. If the number of assets grows very large, this could lead to gas limit issues."",
""Impact"": ""If the number of assets grows too large, transactions calling claimGovFees() (including lock(), claim(), and release()) could fail due to exceeding block gas limits, causing a denial of service."",
""Location"": ""claimGovFees() function - the for loop iterating through assets""
},
{
""Issue"": ""Missing Events and Input Validation"",
""Severity"": ""Low"",
""Description"": ""The contract lacks event emissions for critical operations and proper input validation for constructor parameters and function inputs. Address parameters aren't validated to be non-zero, and amounts aren't checked to be greater than zero."",
""Impact"": ""Reduced transparency and auditability of contract operations, potential deployment with invalid addresses, and possibility of zero-value operations consuming gas unnecessarily."",
""Location"": ""Throughout the contract, particularly in constructor and state-changing functions""
}
],
""IssueNumber"": 45,
""OutputList"": 6
}",317.0,40677.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Report Description**:  
The `extendLock` function in `Lock.sol` allows users to extend the lock period or increase the locked amount. However, it fails to update the `totalLocked[_asset]` state variable. This omission means that when the `release` function is called, it will attempt to reduce `totalLocked[_asset]` by the full locked amount, including the additional amount deposited via `extendLock`. This will cause an underflow revert, making it impossible to release the additional assets deposited via `extendLock`. As a result, these assets are effectively lost.

**Match in Response List**:  
**No match found**.  

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is not related to return value validation, reentrancy, or token approvals. It is a critical accounting error in state variable management, which is not covered in the response list.

---

#### **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Report Description**:  
The `claimGovFees` function calls `bondNFT.distribute` to distribute assets. However, if the assets are not allowed or have no shares in the `BondNFT` contract, the function will silently fail. This could result in assets being stuck in the `Lock` contract, as the function does not handle such cases explicitly.

**Match in Response List**:  
Partially matches with the issue titled **""Unbounded Loop in claimGovFees""**.  

**Validation**:  
**Partially Correct**. The response identifies the `claimGovFees` function but focuses on the unbounded loop issue rather than the silent failure caused by invalid assets or missing shares. While the response highlights a related problem, it does not address the core issue of assets being stuck due to silent failures.

---

#### **[M-02] Must approve 0 first**

**Report Description**:  
Some tokens (e.g., USDT) require setting the allowance to zero before approving a new value. The `claimGovFees` function does not follow this practice, which could lead to failures when interacting with such tokens. The recommendation is to add an `approve(0)` call before setting the actual allowance.

**Match in Response List**:  
Matches with the issue titled **""Unlimited Token Approvals""**.  

**Validation**:  
**Correct**. The response accurately identifies the issue with token approvals in the `claimGovFees` function. While the response focuses on unlimited approvals, it implicitly covers the need for proper approval handling, including setting the allowance to zero for tokens like USDT. This aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Must approve 0 first**

**Partially Correct Matches**:

- **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Missed Issues from Issue Report**:

- **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

---

### **Analysis of Gaps**

1. **High Severity Issue Missed**:  
   The response list fails to address the critical accounting error in the `extendLock` function, which leads to asset loss. This is a high-severity issue that should have been included in the response list.

2. **Partial Coverage of Medium Severity Issues**:  
   While the response list partially covers the `claimGovFees` function, it misses the specific issue of silent failures due to invalid assets or missing shares. This indicates a gap in the response list's coverage of medium-severity issues.

3. **Focus on Broader Issues**:  
   The response list tends to focus on broader issues like reentrancy, unbounded loops, and unlimited approvals but misses specific vulnerabilities like the `extendLock` accounting error. This suggests a need for more granular analysis in the response list.

---

### **Recommendations**

1. **Expand Coverage of Accounting Errors**:  
   The response list should include issues related to state variable management and accounting errors, such as the `extendLock` issue.

2. **Address Silent Failures Explicitly**:  
   The response list should explicitly cover silent failures in functions like `claimGovFees`, especially when interacting with external contracts or handling invalid inputs.

3. **Include Token-Specific Handling**:  
   The response list should include recommendations for handling token-specific behaviors, such as setting allowances to zero before approving new values for tokens like USDT.

By addressing these gaps, the response list can provide more comprehensive coverage of the vulnerabilities identified in the issue report.","```
1. Must approve 0 first
```",0.0
BondNFT.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",3270,384,"[H-05] Malicious user can steal all assets in BondNFT
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
When calling `claim()` for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.
  [M-06] BondNFTs can revert when transferred
In the function `_transfer`, `BondNFTs` should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against.
  [M-14] BondNFT.sol#claim() needs to correct all the missing epochs
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.
 
[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch
Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function Lock.lock() first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.
  [M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT
After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.   [M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called
Calling the following `Trading._handleOpenFees` function does not approve the GovNFT contract for spending any of the Trading contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`.",6,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; 
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; 

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             
                address(0),     
                _asset,         
                _amount,        
                epoch[_asset],  
                block.timestamp,
                expireEpoch,    
                0,              
                shares,         
                _period,        
                false           
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",2608,1,5,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Privilege Management"",
      ""Tasks"": [
        ""Verify the onlyManager modifier implementation and potential centralization risks"",
        ""Audit the setManager function for potential ownership transfer vulnerabilities"",
        ""Assess the scope and implications of manager-only function access"",
        ""Evaluate potential single point of failure risks with manager role""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct thorough reentrancy analysis, especially in transfer and claim methods"",
        ""Review unchecked arithmetic operations for potential integer overflow/underflow"",
        ""Validate input validation across all external and public functions"",
        ""Analyze transfer mechanisms for potential token manipulation"",
        ""Check for potential front-running risks in distribute and createLock functions""
      ]
    },
    {
      ""Area"": ""Reward Distribution Mechanism"",
      ""Tasks"": [
        ""Verify accuracy of share-based reward calculation logic"",
        ""Audit epoch-based reward tracking for potential manipulation"",
        ""Review pending rewards calculation in idToBond method"",
        ""Evaluate reward distribution fairness and precision"",
        ""Check handling of edge cases in reward distribution (zero shares, rounding)""
      ]
    },
    {
      ""Area"": ""Token Transfer and Bond Management"",
      ""Tasks"": [
        ""Analyze bond transfer logic, particularly in _transfer method"",
        ""Review userDebt tracking mechanism during token transfers"",
        ""Verify bond extension constraints and validation"",
        ""Check multi-transfer functions (safeTransferMany, safeTransferFromMany) for potential risks"",
        ""Validate bond release and claim mechanisms""
      ]
    },
    {
      ""Area"": ""Asset and Liquidity Management"",
      ""Tasks"": [
        ""Review asset addition and allowance management processes"",
        ""Verify constraints on supported assets"",
        ""Check handling of different ERC20 token types (standard, non-standard, rebasing)"",
        ""Evaluate potential risks in distribute function"",
        ""Validate asset index tracking mechanism""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze loop structures for potential gas optimization"",
        ""Review unchecked blocks and their efficiency"",
        ""Evaluate memory vs storage usage in complex functions"",
        ""Check array and mapping operations for gas consumption"",
        ""Assess the impact of epoch tracking on contract performance""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC721 and ERC721Enumerable standard compliance"",
        ""Check metadata and URI generation mechanisms"",
        ""Review NFT minting, burning, and transfer processes"",
        ""Validate contract's interaction with external ERC20 tokens""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Identify and document potential failure scenarios"",
        ""Test boundary conditions in lock creation and extension"",
        ""Verify error message clarity and specificity"",
        ""Check handling of zero-value or dust amount transactions"",
        ""Evaluate contract behavior under extreme market conditions""
      ]
    },
    {
      ""Area"": ""Governance and Emergency Controls"",
      ""Tasks"": [
        ""Review owner-only functions for potential misuse"",
        ""Verify emergency stop or pause mechanisms"",
        ""Assess potential upgrade or migration paths"",
        ""Check for comprehensive access control across critical functions""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""This contract is a bond management system implemented as an NFT (ERC721). It allows users to lock assets for a specified period, earning rewards proportional to the lock amount and duration. The contract handles bond creation, extension, reward distribution, and release of locked assets."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BondNFT"",
    ""Purpose"": ""Manages assets locked in bonds represented as NFTs, with reward distribution for holders based on lock amount and duration."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ERC721Enumerable"", ""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"", 
        ""@openzeppelin/contracts/access/Ownable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DAY"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Time constant representing seconds in a day (24 hours)""
      },
      {
        ""Name"": ""Bond"",
        ""Type"": ""struct"",
        ""Purpose"": ""Represents a bond with details like ID, owner, asset type, amount, mint time, expiry, rewards, and status""
      },
      {
        ""Name"": ""epoch"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the current epoch (day) for each asset""
      },
      {
        ""Name"": ""totalBonds"",
        ""Type"": ""uint private"",
        ""Purpose"": ""Counter for total bonds created""
      },
      {
        ""Name"": ""baseURI"",
        ""Type"": ""string public"",
        ""Purpose"": ""Base URI for token metadata""
      },
      {
        ""Name"": ""manager"",
        ""Type"": ""address public"",
        ""Purpose"": ""Address with privileged access to manage bond operations""
      },
      {
        ""Name"": ""assets"",
        ""Type"": ""address[] public"",
        ""Purpose"": ""List of supported asset contract addresses""
      },
      {
        ""Name"": ""allowedAsset"",
        ""Type"": ""mapping(address => bool) public"",
        ""Purpose"": ""Tracks which assets are allowed in the system""
      },
      {
        ""Name"": ""assetsIndex"",
        ""Type"": ""mapping(address => uint) private"",
        ""Purpose"": ""Maps asset addresses to their index in the assets array""
      },
      {
        ""Name"": ""bondPaid"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256)) private"",
        ""Purpose"": ""Tracks rewards already paid for each bond and asset""
      },
      {
        ""Name"": ""accRewardsPerShare"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256)) private"",
        ""Purpose"": ""Accumulated rewards per share for each asset at each epoch""
      },
      {
        ""Name"": ""_idToBond"",
        ""Type"": ""mapping(uint => Bond) private"",
        ""Purpose"": ""Maps bond IDs to Bond structs""
      },
      {
        ""Name"": ""totalShares"",
        ""Type"": ""mapping(address => uint) public"",
        ""Purpose"": ""Total shares for each asset across all bonds""
      },
      {
        ""Name"": ""userDebt"",
        ""Type"": ""mapping(address => mapping(address => uint)) public"",
        ""Purpose"": ""Tracks pending rewards owed to users when transferring bonds""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""createLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new bond by locking assets for a period"",
        ""Parameters"": [""_asset"", ""_amount"", ""_period"", ""_owner""],
        ""Returns"": [""id (uint)""]
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Extends an existing bond's lock period and/or amount"",
        ""Parameters"": [""_id"", ""_asset"", ""_amount"", ""_period"", ""_sender""],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Releases an expired bond, returning assets to owner"",
        ""Parameters"": [""_id"", ""_releaser""],
        ""Returns"": [""amount"", ""lockAmount"", ""asset"", ""_owner""]
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims pending rewards for a bond"",
        ""Parameters"": [""_id"", ""_claimer""],
        ""Returns"": [""amount"", ""tigAsset""]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims accumulated debt for a user after bond transfers"",
        ""Parameters"": [""_user"", ""_tigAsset""],
        ""Returns"": [""amount""]
      },
      {
        ""Name"": ""distribute"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes rewards to all active bonds of a specific asset"",
        ""Parameters"": [""_tigAsset"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""idToBond"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Retrieves bond details with updated pending rewards"",
        ""Parameters"": [""_id""],
        ""Returns"": [""bond struct""]
      },
      {
        ""Name"": ""isExpired"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a bond is expired"",
        ""Parameters"": [""_id""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""pending"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns pending rewards for a bond"",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""totalAssets"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the number of supported assets"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getAssets"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns array of supported asset addresses"",
        ""Parameters"": [],
        ""Returns"": [""address[] memory""]
      },
      {
        ""Name"": ""_baseURI"",
        ""Visibility"": ""internal override view"",
        ""Purpose"": ""Returns the base URI for token metadata"",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""safeTransferMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers multiple bonds at once"",
        ""Parameters"": [""_to"", ""_ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""safeTransferFromMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers multiple bonds from a specified address"",
        ""Parameters"": [""_from"", ""_to"", ""_ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves multiple tokens at once"",
        ""Parameters"": [""_to"", ""_ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints a new bond NFT with initialized payment tracking"",
        ""Parameters"": [""to"", ""bond""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burn"",
        ""Visibility"": ""internal override"",
        ""Purpose"": ""Burns a bond NFT and cleans up bond data"",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal override"",
        ""Purpose"": ""Transfers a bond with special handling of pending rewards"",
        ""Parameters"": [""from"", ""to"", ""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""balanceIds"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns array of bond IDs owned by an address"",
        ""Parameters"": [""_user""],
        ""Returns"": [""uint[] memory""]
      },
      {
        ""Name"": ""addAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new supported asset"",
        ""Parameters"": [""_asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables or disables an asset"",
        ""Parameters"": [""_asset"", ""_bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBaseURI"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the base URI for token metadata"",
        ""Parameters"": [""_newBaseURI""],
        ""Returns"": []
      },
      {
        ""Name"": ""setManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the manager address"",
        ""Parameters"": [""_manager""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyManager"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the manager only"",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 token transfers for claiming rewards and distributing to bonds"",
    ""ERC721Enumerable functionality for NFT operations"",
    ""External calls from/to the manager address that has privileged access""
  ],
  
  ""SpecialMechanisms"": [
    ""Share-based reward distribution system scaled by lock duration"",
    ""Epoch-based tracking for rewards accumulation and bond expiration"",
    ""NFT representation of financial positions (bonds)"",
    ""Reward accounting that handles both active and expired bonds"",
    ""Transfer mechanism that tracks unclaimed rewards as debt""
  ],
  
  ""Questions"": [
    ""What happens if there's an error in the epoch calculation or someone manipulates the clock?"",
    ""Is there any slashing mechanism for early withdrawal, or is it simply not possible?"",
    ""How are rewards secured against potential reentrancy attacks?"",
    ""Is there a limit on the number of supported assets to prevent gas issues?"",
    ""Can the contract handle rebasing tokens or tokens with transfer fees properly?"",
    ""What happens if the manager address is compromised?""
  ]
}","{
""Findings"": [
{
""Issue"": ""Critical Reentrancy Vulnerabilities"",
""Severity"": ""Critical"",
""Description"": ""Multiple functions (claim, release, claimDebt) perform external token transfers after state changes but before completing all internal accounting. These functions lack reentrancy protection, allowing malicious contracts to re-enter and potentially execute multiple withdrawals."",
""Impact"": ""Attackers could drain funds through repeated claims or manipulate contract state before updates are finalized, leading to significant financial losses."",
""Location"": ""claim(), release(), claimDebt() functions, specifically in token transfer operations""
},
{
""Issue"": ""Unchecked Arithmetic Operations"",
""Severity"": ""High"",
""Description"": ""Extensive use of unchecked blocks for arithmetic operations throughout the contract, bypassing Solidity's built-in overflow protection. Critical calculations affecting shares, rewards, and token balances are particularly vulnerable."",
""Impact"": ""Potential overflow/underflow leading to incorrect calculations of shares, rewards, or token amounts, possibly resulting in financial loss or reward manipulation."",
""Location"": ""createLock(), extendLock(), release(), claim(), distribute() functions""
},
{
""Issue"": ""Improper Access Control and Centralization Risk"",
""Severity"": ""High"",
""Description"": ""The contract gives extensive privileges to manager and owner roles without proper safeguards, timelocks, or multi-signature requirements. Critical functions can be executed by single privileged accounts."",
""Impact"": ""If privileged accounts are compromised, an attacker could manipulate bonds, drain funds, or disrupt the entire system's operation."",
""Location"": ""All functions with onlyManager and onlyOwner modifiers""
},
{
""Issue"": ""Insufficient Input Validation"",
""Severity"": ""Medium"",
""Description"": ""Multiple functions lack proper input validation, including zero-address checks, amount validation, and period verification. This includes createLock, extendLock, and setManager functions."",
""Impact"": ""Could lead to creation of invalid bonds, locked funds, or permanent loss of contract functionality if critical addresses are set to zero."",
""Location"": ""createLock(), extendLock(), setManager() functions""
},
{
""Issue"": ""Time-based Manipulation Vulnerability"",
""Severity"": ""Medium"",
""Description"": ""Heavy reliance on block.timestamp for epoch calculations and time-based constraints. Miners can manipulate timestamps within certain bounds, affecting critical timing operations."",
""Impact"": ""Potential manipulation of bond expiration, transfer windows, and reward calculations through timestamp exploitation."",
""Location"": ""Throughout contract, especially in epoch calculations and transfer restrictions""
},
{
""Issue"": ""Unbounded Operations Risk"",
""Severity"": ""Medium"",
""Description"": ""Functions containing loops (distribute, safeTransferMany) or operations without size limits could hit gas limits if processing large arrays or significant time gaps between operations."",
""Impact"": ""Potential denial of service if operations become too gas-intensive to execute within block limits."",
""Location"": ""distribute() function, safeTransferMany(), safeTransferFromMany()""
},
{
""Issue"": ""Missing Event Emissions"",
""Severity"": ""Low"",
""Description"": ""Critical state changes and administrative actions lack event emissions, making it difficult to track changes off-chain and reducing contract transparency."",
""Impact"": ""Reduced ability to monitor contract administration and track important changes, affecting auditability."",
""Location"": ""setManager(), addAsset(), setAllowedAsset() functions""
}
],
""IssueNumber"": 47,
""OutputList"": 7
}",44.029799938201904,0.0,5.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-05] Malicious user can steal all assets in BondNFT**

**Report Description**:  
A malicious user can drain all assets in `BondNFT`, causing other users to lose their rewards. When calling `claim()` for an expired bond, it recalculates `accRewardsPerShare`. However, rewards after the `expireEpoch` do not belong to the expired bond and need to be redistributed to all other bonds. This flaw allows an attacker to exploit the redistribution mechanism.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The vulnerability involves improper reward redistribution logic, which is not covered in the response list.

---

#### **[M-06] BondNFTs can revert when transferred**

**Report Description**:  
The `_transfer` function in `BondNFTs` should allow transfers, as per the proposal and sponsor's intent. However, the function may revert, preventing bonds from being sold or borrowed against.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves transfer functionality, which is not mentioned in the response list.

---

#### **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Report Description**:  
In `claim()`, `accRewardsPerShare[][]` is updated to reflect expired shares, but only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed, leading to incorrect reward calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves incomplete epoch updates, which is not covered in the response list.

---

#### **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**

**Report Description**:  
When `totalShares[tigAsset] == 0`, `distribute()` does not update `epoch[tigAsset]`. This causes `createLock()` to set incorrect values for the bond's mint epoch, leading to flawed bond creation and reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves incorrect epoch updates, which is not covered in the response list.

---

#### **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**

**Report Description**:  
After a lock expires, it no longer receives rewards. However, unreleased locks prevent `totalShares` from being updated, causing other bonds to receive a smaller cut of the distribution. This results in bond owners receiving fewer rewards than they should.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves flawed reward distribution due to unreleased locks, which is not covered in the response list.

---

#### **[M-23] Governance NFT holder can lose deserved rewards after Trading._handleOpenFees is called**

**Report Description**:  
The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance. This oversight can cause governance NFT holders to lose deserved rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves missing approval logic, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-05] Malicious user can steal all assets in BondNFT**  
- **[M-06] BondNFTs can revert when transferred**  
- **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**  
- **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**  
- **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**  
- **[M-23] Governance NFT holder can lose deserved rewards after Trading._handleOpenFees is called**

---

### **Conclusion**  
The response list does not adequately address the issues in the issue report. While it covers general vulnerabilities like reentrancy, unchecked arithmetic, and access control, it misses specific issues related to reward distribution, epoch updates, and transfer functionality in `BondNFT`. These gaps indicate a need for a more comprehensive review of the contract's logic and reward mechanisms.","```
None.
```",0.0
Trading.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",9443,1055,"[H-02] Riskless trades due to delay check
`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
  [H-06] Incorrect calculation of new price while adding position
The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.
  [H-09] Users can bypass the `maxWinPercent` limit using a partially closing
Users can bypass the `maxWinPercent` limit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.
  [H-11] Not enough margin pulled or burned from user when adding to a position
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.
  [M-04] Approved operators of Position token can't call Trading.initiateCloseOrder
Approved operators of owner of Position token can't call several function in Trading.
Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function.
  [M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations
Formula for `fee paid` in the `_handleOpenFees`  is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.   [M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds
The function `initiateCloseOrder()`   [M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()
The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.
  [M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18
In Trading.sol a deposit or withdrawal of tokens with decimals higher than 18 will always revert.
  [M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred
When `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`.",10,"pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); 
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; 
    uint private constant liqPercent = 9e9; 

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; 

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; 
        bool actionType; 
    }
    mapping(uint => Delay) public blockDelayPassed; 
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; 

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    

    
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); 
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, 
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); 
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); 
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); 
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); 

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    

    
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); 
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) 
                / DIVISION_CONSTANT 
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); 
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); 
        }
    }

    
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); 
    }

    
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); 
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    

    
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",7509,4,6,"Based on the comprehensive code review and initial analysis, here's a detailed task list for the Trading contract audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct a thorough reentrancy analysis on _handleDeposit and _handleWithdraw methods"",
        ""Review unchecked arithmetic operations, especially in fee calculation functions"",
        ""Verify integer overflow/underflow protection in all mathematical calculations"",
        ""Examine proxy approval mechanism for potential authorization bypass risks"",
        ""Validate input validation across all external and public functions""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit onlyOwner modifier implementations and access control points"",
        ""Review proxy trading approval mechanism for potential exploit vectors"",
        ""Verify strict access controls on critical administrative functions"",
        ""Analyze the _validateProxy method for potential impersonation risks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Trace and validate all external contract calls, especially to tradingExtension"",
        ""Review signature verification process for price data integrity"",
        ""Assess risk of dependency failures across multiple imported interfaces"",
        ""Validate error handling in cross-contract interactions"",
        ""Examine potential attack surfaces in oracle price fetching mechanism""
      ]
    },
    {
      ""Area"": ""Oracle and Price Manipulation"",
      ""Tasks"": [
        ""Comprehensive review of price verification in getVerifiedPrice method"",
        ""Analyze spread calculation and its potential for price manipulation"",
        ""Verify signature validation process for price data"",
        ""Check limit order price range protection mechanisms"",
        ""Evaluate oracle dependency and centralization risks""
      ]
    },
    {
      ""Area"": ""Fee Distribution Mechanism"",
      ""Tasks"": [
        ""Audit _handleOpenFees and _handleCloseFees for mathematical accuracy"",
        ""Verify fee distribution logic across different stakeholders"",
        ""Check fee calculation scalability and potential rounding errors"",
        ""Review referral fee allocation and distribution mechanism"",
        ""Validate fee percentage constraints and administrative controls""
      ]
    },
    {
      ""Area"": ""Position Management"",
      ""Tasks"": [
        ""Review liquidation threshold calculations"",
        ""Verify margin and leverage adjustment logic"",
        ""Analyze position size and minimum position constraints"",
        ""Check stop-loss and take-profit implementation for potential exploitation"",
        ""Validate position state transitions and error handling""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Analyze block delay mechanism for potential manipulation"",
        ""Review limit order execution protection strategies"",
        ""Evaluate potential MEV (Miner Extractable Value) risks"",
        ""Check timestamp-based proxy approvals for front-running vulnerabilities""
      ]
    },
    {
      ""Area"": ""Governance and Emergency Controls"",
      ""Tasks"": [
        ""Review pause and unpause mechanisms"",
        ""Verify emergency stop functionality"",
        ""Analyze owner's ability to modify critical contract parameters"",
        ""Check governance NFT integration and fee distribution mechanism"",
        ""Validate administrative function access controls""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Identify potential gas optimization opportunities"",
        ""Review unchecked blocks and their gas efficiency"",
        ""Analyze complex mathematical operations for computational overhead"",
        ""Check function visibility and optimize where possible"",
        ""Evaluate overall contract bytecode size and complexity""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify ERC-20 token interaction compliance"",
        ""Check permit mechanism implementation"",
        ""Review interface adherence to expected standards"",
        ""Validate token decimal handling across different asset interactions""
      ]
    }
  ]
}

This comprehensive task list covers critical audit areas identified in the contract, prioritizing security, functionality, and potential vulnerabilities. Each area includes specific, actionable tasks that systematically address potential risks and implementation nuances.

The tasks are designed to provide a structured approach to auditing the Trading contract, focusing on its complex mechanisms for leveraged trading, fee distribution, position management, and external interactions.

Would you like me to elaborate on any specific area or provide more detailed guidance for any of these audit tasks?","After reviewing the provided smart contract, I've performed a thorough audit and analysis. Here are my findings:

{
  ""ReviewingTheCode"": ""The contract appears to be a trading platform for leveraged trading positions. It allows users to open, close, and modify trading positions with features like leverage, stop-loss, take-profit, limit orders, and liquidations. The system uses multiple tokens, stable coins, and vaults to handle margin deposits and withdrawals."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Trading"",
    ""Purpose"": ""A decentralized platform for leveraged trading with margin positions. It allows traders to open long/short positions, set limits, and manage their trading activities with various fee structures."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""MetaContext"", ""ITrading""],
      ""Imports"": [
        ""MetaContext"", 
        ""ITrading"", 
        ""IERC20"", 
        ""IPairsContract"", 
        ""IReferrals"", 
        ""IPosition"", 
        ""IGovNFT"", 
        ""IStableVault"", 
        ""TradingLibrary""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DIVISION_CONSTANT"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Scaling factor for percentage calculations (1e10)""
      },
      {
        ""Name"": ""liqPercent"",
        ""Type"": ""uint private constant"",
        ""Purpose"": ""Liquidation percentage threshold (9e9, or 90%)""
      },
      {
        ""Name"": ""openFees"",
        ""Type"": ""Fees struct"",
        ""Purpose"": ""Fee structure for opening positions""
      },
      {
        ""Name"": ""closeFees"",
        ""Type"": ""Fees struct"",
        ""Purpose"": ""Fee structure for closing positions""
      },
      {
        ""Name"": ""limitOrderPriceRange"",
        ""Type"": ""uint"",
        ""Purpose"": ""Allowed price range for limit orders""
      },
      {
        ""Name"": ""maxWinPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Maximum allowed profit percentage""
      },
      {
        ""Name"": ""vaultFundingPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Percentage for vault funding""
      },
      {
        ""Name"": ""pairsContract"",
        ""Type"": ""IPairsContract"",
        ""Purpose"": ""Interface to access trading pairs data""
      },
      {
        ""Name"": ""position"",
        ""Type"": ""IPosition"",
        ""Purpose"": ""Interface to manage positions""
      },
      {
        ""Name"": ""gov"",
        ""Type"": ""IGovNFT"",
        ""Purpose"": ""Governance interface for fee distribution""
      },
      {
        ""Name"": ""tradingExtension"",
        ""Type"": ""ITradingExtension"",
        ""Purpose"": ""Extension contract with additional trading functions""
      },
      {
        ""Name"": ""blockDelayPassed"",
        ""Type"": ""mapping(uint => Delay)"",
        ""Purpose"": ""Stores delay information for each position ID""
      },
      {
        ""Name"": ""blockDelay"",
        ""Type"": ""uint"",
        ""Purpose"": ""Number of blocks to delay between actions""
      },
      {
        ""Name"": ""limitDelay"",
        ""Type"": ""mapping(uint => uint)"",
        ""Purpose"": ""Timestamp delays for limit orders""
      },
      {
        ""Name"": ""allowedVault"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Whitelist of approved stable vaults""
      },
      {
        ""Name"": ""proxyApprovals"",
        ""Type"": ""mapping(address => Proxy)"",
        ""Purpose"": ""Tracks approved proxy addresses for each trader""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initiateMarketOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Open a new market trading position"",
        ""Parameters"": [""TradeInfo calldata _tradeInfo"", ""PriceData calldata _priceData"", ""bytes calldata _signature"", ""ERC20PermitData calldata _permitData"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateCloseOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Close an existing position partially or completely"",
        ""Parameters"": [""uint _id"", ""uint _percent"", ""PriceData calldata _priceData"", ""bytes calldata _signature"", ""address _stableVault"", ""address _outputToken"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""addToPosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Add more margin to an existing position"",
        ""Parameters"": [""uint _id"", ""uint _addMargin"", ""PriceData calldata _priceData"", ""bytes calldata _signature"", ""address _stableVault"", ""address _marginAsset"", ""ERC20PermitData calldata _permitData"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Create a limit order to be executed later"",
        ""Parameters"": [""TradeInfo calldata _tradeInfo"", ""uint256 _orderType"", ""uint256 _price"", ""ERC20PermitData calldata _permitData"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancel a pending limit order"",
        ""Parameters"": [""uint256 _id"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""addMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Add margin to an existing position, decreasing leverage"",
        ""Parameters"": [""uint256 _id"", ""address _marginAsset"", ""address _stableVault"", ""uint256 _addMargin"", ""ERC20PermitData calldata _permitData"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Remove margin from a position, increasing leverage"",
        ""Parameters"": [""uint256 _id"", ""address _stableVault"", ""address _outputToken"", ""uint256 _removeMargin"", ""PriceData calldata _priceData"", ""bytes calldata _signature"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTpSl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Update take-profit or stop-loss levels"",
        ""Parameters"": [""bool _type"", ""uint _id"", ""uint _limitPrice"", ""PriceData calldata _priceData"", ""bytes calldata _signature"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Execute a pending limit order when conditions are met"",
        ""Parameters"": [""uint _id"", ""PriceData calldata _priceData"", ""bytes calldata _signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidatePosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidate a position that reached liquidation threshold"",
        ""Parameters"": [""uint _id"", ""PriceData calldata _priceData"", ""bytes calldata _signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""limitClose"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Close a position when stop-loss or take-profit is triggered"",
        ""Parameters"": [""uint _id"", ""bool _tp"", ""PriceData calldata _priceData"", ""bytes calldata _signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveProxy"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Approve a proxy address to trade on behalf of the caller"",
        ""Parameters"": [""address _proxy"", ""uint256 _timestamp""],
        ""Returns"": []
      },
      {
        ""Name"": ""_closePosition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle position closing logic"",
        ""Parameters"": [""uint _id"", ""uint _percent"", ""uint _price"", ""address _stableVault"", ""address _outputToken"", ""bool _isBot""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handle depositing margin into the system"",
        ""Parameters"": [""address _tigAsset"", ""address _marginAsset"", ""uint256 _margin"", ""address _stableVault"", ""ERC20PermitData calldata _permitData"", ""address _trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handle withdrawing assets from the system"",
        ""Parameters"": [""IPosition.Trade memory _trade"", ""address _stableVault"", ""address _outputToken"", ""uint _toMint""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleOpenFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate and distribute fees for opening positions"",
        ""Parameters"": [""uint _asset"", ""uint _positionSize"", ""address _trader"", ""address _tigAsset"", ""bool _isBot""],
        ""Returns"": [""uint _feePaid""]
      },
      {
        ""Name"": ""_handleCloseFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate and distribute fees for closing positions"",
        ""Parameters"": [""uint _asset"", ""uint _payout"", ""address _tigAsset"", ""uint _positionSize"", ""address _trader"", ""bool _isBot""],
        ""Returns"": [""uint payout_""]
      },
      {
        ""Name"": ""setBlockDelay"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to set block delay parameter"",
        ""Parameters"": [""uint _blockDelay""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to whitelist stable vaults"",
        ""Parameters"": [""address _stableVault"", ""bool _bool""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IPairsContract - Used to get asset information and manage open interest"",
    ""IPosition - Manages the state of trading positions"",
    ""IGovNFT - Used for distributing fees"",
    ""ITradingExtension - Contains extended trading functionality"",
    ""IStableVault - Manages deposits and withdrawals of various assets"",
    ""IStable - Interface for the stable coin used in the system"",
    ""IERC20 - Standard token interface"",
    ""ERC20Permit - Extension for gasless approvals""
  ],
  
  ""SpecialMechanisms"": [
    ""Proxy trading - Allows approved addresses to execute trades on behalf of users"",
    ""Oracle price verification - Uses signed price data to verify asset prices"",
    ""Fee distribution system - Complex fee distribution across multiple stakeholders (DAO, burn, referrals, bots)"",
    ""Referral system - Provides fee discounts and rewards for referrals"",
    ""Position NFTs - Trading positions are represented as NFTs (via the IPosition contract)"",
    ""Two-phase delay mechanism - Prevents certain types of attacks by implementing action delays"",
    ""Funding rate mechanism - Balanced funding rates between long and short positions""
  ],
  
  ""VulnerabilitiesAndConcerns"": [
    ""Reentrancy risks in deposit/withdraw functions although they follow checks-effects-interactions pattern"",
    ""Centralized price oracle system dependent on signed price data"",
    ""Centralized control by owner for setting critical parameters"",
    ""Block-based delays might be manipulated by miners"",
    ""Unchecked arithmetic in multiple places relies on Solidity 0.8+ overflow protection"",
    ""Tight coupling with multiple external contracts creates complex dependencies"",
    ""Potential for front-running on order execution"",
    ""Complex fee calculation logic may lead to unexpected outcomes"",
    ""Timelock or delay mechanisms for owner operations are missing""
  ],
  
  ""Questions"": [
    ""How is the price oracle secured against manipulation?"",
    ""What is the recovery plan in case one of the dependent contracts is compromised?"",
    ""What mechanisms prevent MEV extraction through front-running trades?"",
    ""How are the price signatures validated, and who are the authorized signers?"",
    ""What are the security measures around the proxy approval system?"",
    ""How are the liquidation incentives calculated and distributed?"",
    ""How is the funding rate calculated and balanced between long and short positions?""
  ],
  
  ""RecommendedImprovements"": [
    ""Add timelock mechanisms for owner operations"",
    ""Implement circuit breakers for emergency situations"",
    ""Consider using a more decentralized price oracle system"",
    ""Add more commenting throughout the codebase to explain complex logic"",
    ""Split the contract into more modular components to reduce complexity"",
    ""Add formal verification for critical functions"",
    ""Implement more comprehensive input validation"",
    ""Consider adding upgradability pattern for future protocol improvements""
  ]
}

Based on this audit, the Trading contract is a complex leveraged trading platform with multiple features for margin trading. While the codebase appears well-structured, there are several potential security concerns including centralized control, oracle dependencies, and complex interactions between multiple contracts that could introduce vulnerabilities. The contract implements sophisticated mechanisms for handling fees, referrals, and positions, but would benefit from additional security controls and improved documentation.","I've analyzed the provided security findings for the Trading.sol smart contract. After processing all the entries, I've consolidated similar issues and organized them by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Price Oracle Manipulation Vulnerability"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract relies on external price data passed through parameters (_priceData, _signature) for critical functions without adequate validation. While the contract attempts to verify prices through the tradingExtension.getVerifiedPrice function, this pattern is vulnerable to oracle manipulation attacks if the verification logic is weak. An attacker could potentially pass manipulated price data if signature verification is flawed."",
      ""Impact"": ""Manipulated price data could allow attackers to execute trades at advantageous prices, potentially draining funds from the protocol, manipulating liquidations, or extracting value through unfair trades."",
      ""Location"": ""Functions: initiateMarketOrder, initiateCloseOrder, executeLimitOrder, liquidatePosition, and other functions using tradingExtension.getVerifiedPrice""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions that handle token transfers and external calls do not implement reentrancy guards or follow the checks-effects-interactions pattern. For example, in _handleWithdraw(), _closePosition(), and liquidatePosition(), the contract makes external calls after state changes or performs token transfers before completing all state updates, which could be exploited in reentrancy attacks."",
      ""Impact"": ""An attacker could potentially reenter the contract and manipulate state to drain funds, perform double withdrawals, or create inconsistent contract states leading to significant financial losses."",
      ""Location"": ""_handleWithdraw() function, _closePosition() function, liquidatePosition() function, and other functions making external calls to tokens and contracts""
    },
    {
      ""Issue"": ""Proxy Approval Mechanism Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""The approveProxy() function allows users to approve any address as their proxy with only a timestamp constraint. The function transfers ETH to the proxy address without validation, and there is no mechanism to revoke proxy access before the timestamp expires. The _validateProxy function doesn't perform a null address check and relies solely on timestamp comparison without additional safeguards."",
      ""Impact"": ""Users could have their funds at risk if they approve a malicious proxy or if the proxy's private key is compromised. Once approved, proxies can perform any action on behalf of users until the timestamp expires, with no option for early revocation."",
      ""Location"": ""approveProxy() function and _validateProxy() function""
    },
    {
      ""Issue"": ""Missing Access Control on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions in the contract lack proper access control mechanisms. Functions like executeLimitOrder() and limitClose() can be called by anyone, potentially allowing unauthorized users to manipulate positions and withdraw funds."",
      ""Impact"": ""Malicious actors could manipulate trading positions or execute unauthorized operations, causing financial losses to users."",
      ""Location"": ""Functions: executeLimitOrder(), limitClose(), and similar functions with insufficient access controls""
    },
    {
      ""Issue"": ""Unchecked External Calls and Return Values"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes multiple external calls to tokens and other contracts without adequately checking return values. For instance, in _handleWithdraw() and _handleDeposit(), token transfers are performed without proper verification of success. Some ERC20 tokens return false instead of reverting on failure."",
      ""Impact"": ""Failed token transfers might not revert or be properly detected, potentially leading to inconsistent state, accounting errors, or loss of funds for users."",
      ""Location"": ""_handleWithdraw() function, _handleDeposit() function, and other places where external token transfers are performed""
    },
    {
      ""Issue"": ""Front-Running Vulnerability in Limit Orders"",
      ""Severity"": ""Medium"",
      ""Description"": ""Market orders and limit orders can be front-run by observers who spot pending transactions in the mempool. The executeLimitOrder() function has only basic timestamp checks (limitDelay) but no protection against front-running attacks."",
      ""Impact"": ""Users might receive worse execution prices due to front-running, reducing profit potential or increasing losses. Malicious actors could execute trades before a victim's order to profit from the price movement."",
      ""Location"": ""initiateMarketOrder(), executeLimitOrder() functions""
    },
    {
      ""Issue"": ""Centralization Risks in Contract Administration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has multiple functions that can only be called by the owner, including critical functions like setting fees, max win percentages, allowed vaults, and trading extensions. This creates centralization risks if the owner account is compromised or acts maliciously. There is no timelock or governance process for parameter changes."",
      ""Impact"": ""A compromised or malicious owner could change parameters to extract value from users, set excessively high fees, manipulate trading parameters, approve malicious vaults, or disrupt the system's operation."",
      ""Location"": ""setBlockDelay(), setAllowedVault(), setMaxWinPercent(), setLimitOrderPriceRange(), setFees(), setTradingExtension(), and other owner-only functions""
    },
    {
      ""Issue"": ""Lack of Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract implements price verification, it doesn't have explicit slippage protection for users. When closing positions or handling withdrawals, there's no mechanism allowing users to specify maximum acceptable price movement, which is standard in DeFi protocols."",
      ""Impact"": ""Users may experience higher than expected slippage during high volatility periods, leading to unexpected losses or trades executing at significantly different prices than expected."",
      ""Location"": ""initiateMarketOrder(), initiateCloseOrder(), _closePosition() functions""
    },
    {
      ""Issue"": ""Timestamp and Block Manipulation Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on block.number for delay enforcement in _checkDelay and block.timestamp in several places including proxy validation and limit order delays. Miners can manipulate these values slightly, which could be exploited in time-sensitive operations."",
      ""Impact"": ""Malicious miners could potentially game the system by manipulating block timestamps or numbers, affecting the execution timing of limit orders or proxy validity to their advantage."",
      ""Location"": ""_checkDelay function, limitDelay checks, proxy expiration checks""
    },
    {
      ""Issue"": ""Unchecked Arithmetic Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses the 'unchecked' block for numerous arithmetic operations. While this can save gas, it disables Solidity's default overflow/underflow protection. Some critical calculations involving user funds could overflow/underflow, especially when handling large numbers or percentages."",
      ""Impact"": ""Arithmetic errors could lead to incorrect fee calculations, incorrect position sizes, or other financial discrepancies, potentially affecting user positions or fees."",
      ""Location"": ""Multiple locations throughout the contract, including _handleOpenFees(), _handleCloseFees(), _closePosition(), and other functions with unchecked blocks""
    },
    {
      ""Issue"": ""Insufficient Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack comprehensive input validation. For example, in setFees(), while there's a check that _daoFees >= _botFees+_referralFees*2, there's no verification that the sum of all fees doesn't exceed 100%. Parameter setting functions often have minimal validation constraints."",
      ""Impact"": ""Invalid inputs could lead to unexpected behavior, contract failures, or fees being set to drain user positions or make trading unprofitable."",
      ""Location"": ""setFees() function, other parameter setting functions, and functions accepting complex structures like TradeInfo""
    },
    {
      ""Issue"": ""Unlimited Token Approvals"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses type(uint).max for token approvals in multiple places, which is a security anti-pattern. It also doesn't reset allowances after operations complete, which leaves the contract exposed to potential issues if the approved contract is compromised."",
      ""Impact"": ""If any approved contract is compromised, all tokens held by the Trading contract could be at risk."",
      ""Location"": ""_handleDeposit() function, _handleCloseFees() function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using Solidity 0.8.x which has built-in overflow/underflow protection, the contract uses unchecked blocks for fee calculations and other arithmetic operations. If extreme values are used (like very high leverage or position sizes near uint256.max), calculations might overflow or underflow."",
      ""Impact"": ""Incorrect fee calculations could lead to excessive fees being charged or protocol fees being bypassed. Under specific conditions, arithmetic overflows could lead to incorrect calculations of position sizes, payouts, or fees."",
      ""Location"": ""_handleOpenFees(), _handleCloseFees() functions, and other arithmetic operations""
    },
    {
      ""Issue"": ""Lack of Emergency Stop Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract checks if trading is paused via tradingExtension.paused(), it doesn't directly implement a comprehensive emergency stop mechanism that would allow pausing all operations in case of detected vulnerabilities or attacks."",
      ""Impact"": ""If a vulnerability is discovered, there may be no way to quickly prevent further exploitation while a fix is developed."",
      ""Location"": ""Contract-wide issue, affecting all transaction functions""
    },
    {
      ""Issue"": ""Unsafe Type Casting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs multiple type casts from int256 to uint256 without proper validation, particularly when handling payouts that might be negative. This could lead to unexpected behavior if values are improperly cast."",
      ""Impact"": ""Improper casting of negative values to unsigned integers could lead to unexpected behavior or reverts, affecting position calculations or payouts."",
      ""Location"": ""_closePosition() and _handleCloseFees() functions""
    },
    {
      ""Issue"": ""Inadequate Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""Several admin functions modify critical parameters without emitting events, and some important state changes don't emit events at all. For example, when proxy approvals are made, no event is emitted. This makes it difficult to track important contract state changes off-chain."",
      ""Impact"": ""Reduced transparency for users and monitoring tools about contract configuration changes and important state modifications."",
      ""Location"": ""approveProxy() function, setBlockDelay(), setAllowedVault(), setMaxWinPercent(), and other state-changing functions without appropriate event emissions""
    },
    {
      ""Issue"": ""Unclear Error Messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses numeric error strings (e.g., revert('0'), revert('4')) in many places instead of descriptive custom errors, making it difficult to understand failure reasons and troubleshoot issues."",
      ""Impact"": ""Reduced usability and harder debugging for users and developers interacting with the contract. Makes error diagnosis and error handling more challenging for integrators and users."",
      ""Location"": ""Throughout the contract, particularly in _checkDelay(), _checkOwner(), and other functions using numeric error codes""
    },
    {
      ""Issue"": ""Potentially Harmful maxWinPercent Limitation"",
      ""Severity"": ""Low"",
      ""Description"": ""The maxWinPercent parameter caps trader profits, which could be manipulated by the owner to unfairly limit legitimate trader gains."",
      ""Impact"": ""Traders might not receive their full trading profits if the owner sets an unfavorable maxWinPercent."",
      ""Location"": ""Function: _closePosition(), parameter: maxWinPercent""
    }
  ],
  ""IssueNumber"": 98,
  ""OutputList"": 18
}",585.171172142029,135914.0,35.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] Riskless trades due to delay check**

**Report Description**:  
The `Trading.limitClose()` function uses `_checkDelay()`, which allows for riskless trades. Users can capture price rises by increasing the stop-loss while preventing underwater positions from being closed by continuously increasing the delay. This creates a scenario where users can avoid losses while benefiting from price increases.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of riskless trades enabled by the delay check mechanism in `limitClose()`. This is a missed issue.

---

#### **[H-06] Incorrect calculation of new price while adding position**

**Report Description**:  
The formula used for calculating `_newPrice` in the `addToPosition()` function of `Trading.sol` is incorrect. This leads to users losing part of their funds or profits when using this function.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect price calculations in `addToPosition()`. This is a missed issue.

---

#### **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**

**Report Description**:  
Users can bypass the `maxWinPercent` limit by partially closing their positions. This allows them to receive more funds than the protocol's upper limit, leading to potential financial losses for the protocol.

**Match in Response List**:  
Matches with the issue titled **""Potentially Harmful maxWinPercent Limitation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `maxWinPercent` but does not specifically address the bypass mechanism through partial closing. The impact is partially covered, but the exploit method is missed.

---

#### **[H-11] Not enough margin pulled or burned from user when adding to a position**

**Report Description**:  
When adding to a position, the amount of margin pulled from the user is insufficient. This leaks value from the protocol and lowers the collateralization ratio of `tigAsset`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient margin being pulled or burned when adding to a position. This is a missed issue.

---

#### **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**

**Report Description**:  
Approved operators of the Position token cannot call `Trading.initiateCloseOrder` because the function checks that the caller is the owner of the token using `_checkOwner`. This restricts functionality for approved operators.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of approved operators being unable to call `initiateCloseOrder`. This is a missed issue.

---

#### **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**

**Report Description**:  
The formula for `_feePaid` in `_handleOpenFees` is incorrect, leading to incorrect margin calculations. This directly impacts trader margins and associated fee calculations, posing a high risk.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Fee Calculations""**.

**Validation**:  
**Partially Correct**. The response identifies potential arithmetic issues in fee calculations but does not specifically address the incorrect formula in `_handleOpenFees`. The core issue is partially covered.

---

#### **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**

**Report Description**:  
The owner has the ability to freeze withdrawals and use a timelock to steal all funds, posing significant centralization risks.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risks in Contract Administration""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risks associated with the owner's ability to control critical functions, including freezing withdrawals. The impact is well-covered.

---

#### **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

**Report Description**:  
The open price of a stop order might change during execution, but `Trading.executeLimitOrder()` does not validate StopLoss/TakeProfit for the changed price, leading to potential vulnerabilities.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of StopLoss/TakeProfit validation in `executeLimitOrder()`. This is a missed issue.

---

#### **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Report Description**:  
The `_handleDeposit` and `_handleWithdraw` functions in `Trading.sol` do not account for tokens with decimals higher than 18, causing deposits or withdrawals of such tokens to always revert.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls and Return Values""**.

**Validation**:  
**Partially Correct**. The response identifies issues with external calls but does not specifically address the handling of tokens with decimals higher than 18. The core issue is partially covered.

---

#### **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Report Description**:  
When `initiateMarketOrder` is called, `_marginAfterFees` is calculated incorrectly when a trade is referred, allowing users to open a position with more margin than expected.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Fee Calculations""**.

**Validation**:  
**Partially Correct**. The response identifies potential arithmetic issues in fee calculations but does not specifically address the incorrect calculation in `_handleOpenFees` for referred trades. The core issue is partially covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**

**Partially Correct Matches**:

- **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**
- **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**
- **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**
- **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Missed Issues from Issue Report**:

- **[H-02] Riskless trades due to delay check**
- **[H-06] Incorrect calculation of new price while adding position**
- **[H-11] Not enough margin pulled or burned from user when adding to a position**
- **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**
- **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

--- 

**Conclusion**:  
The response list covers some issues but misses several critical vulnerabilities, particularly those related to specific function implementations (e.g., `limitClose()`, `addToPosition()`, `initiateCloseOrder()`). Additionally, some responses only partially address the issues, missing key details or exploit mechanisms. Improvements are needed to ensure comprehensive coverage of all identified vulnerabilities.","```
1. Centralization Risks in Contract Administration
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Centralization Risks in Contract Administration"".
   - This issue appears at rank 7 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, \( k = 7 \), and there is 1 true positive up to rank 7.
   - \( P@7 = \frac{1}{7} \approx 0.1429 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.1429 \).

**Output**:
```
0.1429
```"
