nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NameWrapper.sol,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",7024,963,"[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.
  [H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy
By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.
When a parent node tries to `setSubnodeOwner / setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.   [H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.
However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking the function `wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   [M-01] wrapETH2LD permissioning is over-extended
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token.   [M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry
There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.


",5,,"pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    

    

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        
        registrar.transferFrom(registrant, address(this), tokenId);

        
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        
        
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        
        
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",4828,3,2,"Based on the comprehensive review of the NameWrapper contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Authorization"",
      ""Tasks"": [
        ""Verify the implementation of onlyTokenOwner modifier for comprehensive access control"",
        ""Audit the isTokenOwnerOrApproved function for potential bypass vulnerabilities"",
        ""Review all onlyController and onlyOwner function modifiers for proper restriction"",
        ""Validate that the Controllable and Ownable inheritance provides robust access management""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Perform a detailed reentrancy analysis on external contract calls (ENS, Registrar)"",
        ""Check for potential integer overflow/underflow in expiry and fuse calculations"",
        ""Verify the security of the onERC721Received implementation against potential token theft"",
        ""Analyze the _mint and _burn methods for potential unauthorized token manipulation"",
        ""Review the upgradeContract mechanism for potential arbitrary code execution risks""
      ]
    },
    {
      ""Area"": ""Permission System (Fuses)"",
      ""Tasks"": [
        ""Comprehensively test the fuse burning and checking mechanisms"",
        ""Validate that all operations properly respect fuse restrictions"",
        ""Verify the logic in _canFusesBeBurned to ensure no unexpected permission bypasses"",
        ""Check the interaction between parent and child node fuse permissions""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit interactions with ENS registry for potential state manipulation"",
        ""Review the setUpgradeContract method for potential security risks"",
        ""Verify safe approval and transfer mechanisms with external contracts"",
        ""Check metadata service integration for potential injection or manipulation""
      ]
    },
    {
      ""Area"": ""Name Management Logic"",
      ""Tasks"": [
        ""Verify the correctness of name wrapping and unwrapping processes"",
        ""Check expiry normalization logic in _normaliseExpiry method"",
        ""Validate the handling of different domain types (root, .eth, subdomains)"",
        ""Review the name storage and retrieval mechanisms in the names mapping""
      ]
    },
    {
      ""Area"": ""Gas Optimization & Efficiency"",
      ""Tasks"": [
        ""Analyze the gas consumption of complex methods like setSubnodeRecord"",
        ""Review byte manipulation methods for potential optimization"",
        ""Check the efficiency of fuse and permission checking mechanisms"",
        ""Verify the gas impact of nested name and permission operations""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Test all custom error conditions for proper reversion"",
        ""Verify handling of expired or near-expiry domains"",
        ""Check behavior with zero-address inputs in critical methods"",
        ""Validate handling of extremely long or short domain names""
      ]
    },
    {
      ""Area"": ""Upgrade Mechanism"",
      ""Tasks"": [
        ""Thoroughly review the upgrade contract integration"",
        ""Verify the security of setUpgradeContract method"",
        ""Check that upgrade methods cannot be abused to steal or manipulate tokens"",
        ""Validate the approval and revocation process for upgrade contracts""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the NameWrapper contract, covering critical areas of security, functionality, and potential vulnerabilities. Each area includes specific, actionable tasks that dive deep into the contract's implementation, ensuring a thorough and methodical audit process.

The tasks are designed to:
1. Identify potential security risks
2. Verify correct implementation of complex logic
3. Ensure robust access controls
4. Check for potential manipulation vectors
5. Optimize gas efficiency
6. Validate error handling and edge cases

Auditors should systematically work through these tasks, documenting findings, potential vulnerabilities, and recommended mitigations.","I've performed a thorough audit of the provided smart contract code. Here's my analysis:

{
  ""ReviewingTheCode"": ""This is a comprehensive ENS (Ethereum Name Service) NameWrapper contract that implements ERC1155 token standard with additional functionality. The contract wraps ENS names as ERC1155 tokens with fuse-based permission systems to control name operations. It provides mechanism for managing ENS names, including wrapping, unwrapping, setting records, and controlling permissions via fuses."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NameWrapper"",
    ""Purpose"": ""To provide a wrapper for ENS names as ERC1155 tokens with a permission system (fuses) that controls name operations. It allows owners to restrict operations on their names like transfers, creating subdomains, or changing resolvers."",
    
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ERC1155Fuse"", ""INameWrapper"", ""Controllable"", ""IERC721Receiver""],
      ""Imports"": [
        ""ERC1155Fuse.sol"",
        ""Controllable.sol"",
        ""INameWrapper.sol"",
        ""INameWrapperUpgrade.sol"",
        ""IMetadataService.sol"",
        ""ENS.sol"",
        ""IBaseRegistrar.sol"",
        ""IERC721Receiver"",
        ""Ownable"",
        ""BytesUtil.sol""
      ]
    },
    
    ""StateVariables"": [
      {
        ""Name"": ""ens"",
        ""Type"": ""ENS"",
        ""Purpose"": ""Reference to the ENS registry contract""
      },
      {
        ""Name"": ""registrar"",
        ""Type"": ""IBaseRegistrar"",
        ""Purpose"": ""Reference to the ENS registrar contract for .eth domains""
      },
      {
        ""Name"": ""metadataService"",
        ""Type"": ""IMetadataService"",
        ""Purpose"": ""Service for providing metadata for the ERC1155 tokens""
      },
      {
        ""Name"": ""names"",
        ""Type"": ""mapping(bytes32 => bytes)"",
        ""Purpose"": ""Maps node (namehash) to the actual name""
      },
      {
        ""Name"": ""ETH_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constant representing the namehash of .eth""
      },
      {
        ""Name"": ""ROOT_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constant representing the namehash of the root node""
      },
      {
        ""Name"": ""upgradeContract"",
        ""Type"": ""INameWrapperUpgrade"",
        ""Purpose"": ""Contract that can be used to upgrade the wrapper""
      },
      {
        ""Name"": ""MAX_EXPIRY"",
        ""Type"": ""uint64"",
        ""Purpose"": ""Maximum possible expiry value""
      }
    ],
    
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with ENS registry, registrar, and metadata service"",
        ""Parameters"": [""ENS _ens"", ""IBaseRegistrar _registrar"", ""IMetadataService _metadataService""],
        ""Returns"": []
      },
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if contract supports a given interface"",
        ""Parameters"": [""bytes4 interfaceId""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""ownerOf"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the owner of a token"",
        ""Parameters"": [""uint256 id""],
        ""Returns"": [""address owner""]
      },
      {
        ""Name"": ""setMetadataService"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the metadata service contract"",
        ""Parameters"": [""IMetadataService _newMetadataService""],
        ""Returns"": []
      },
      {
        ""Name"": ""uri"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the URI for token metadata"",
        ""Parameters"": [""uint256 tokenId""],
        ""Returns"": [""string""]
      },
      {
        ""Name"": ""setUpgradeContract"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the upgrade contract address"",
        ""Parameters"": [""INameWrapperUpgrade _upgradeAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""isTokenOwnerOrApproved"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if an address is the token owner or approved"",
        ""Parameters"": [""bytes32 node"", ""address addr""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getFuses"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Gets the fuses and expiry for a node"",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": [""uint32 fuses"", ""uint64 expiry""]
      },
      {
        ""Name"": ""wrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps a .eth second-level domain"",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry"", ""address resolver""],
        ""Returns"": [""uint64""]
      },
      {
        ""Name"": ""registerAndWrapETH2LD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Registers and wraps a new .eth second-level domain"",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint256 duration"", ""address resolver"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""uint256 registrarExpiry""]
      },
      {
        ""Name"": ""renew"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Renews a .eth domain registration"",
        ""Parameters"": [""uint256 tokenId"", ""uint256 duration"", ""uint64 expiry""],
        ""Returns"": [""uint256 expires""]
      },
      {
        ""Name"": ""wrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps a non-.eth domain"",
        ""Parameters"": [""bytes calldata name"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps a .eth second-level domain"",
        ""Parameters"": [""bytes32 labelhash"", ""address newRegistrant"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps a non-.eth domain"",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets fuses (permissions) for a node"",
        ""Parameters"": [""bytes32 node"", ""uint32 fuses""],
        ""Returns"": [""uint32""]
      },
      {
        ""Name"": ""upgradeETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Upgrades a .eth second-level domain to a new wrapper"",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""upgrade"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Upgrades a non-.eth domain to a new wrapper"",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setChildFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets fuses for a child node"",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setSubnodeOwner"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets a subnode owner"",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address newOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""bytes32 node""]
      },
      {
        ""Name"": ""setSubnodeRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets a subnode's records"",
        ""Parameters"": [""bytes32 parentNode"", ""string memory label"", ""address newOwner"", ""address resolver"", ""uint64 ttl"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets records for a node"",
        ""Parameters"": [""bytes32 node"", ""address owner"", ""address resolver"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""setResolver"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets resolver for a node"",
        ""Parameters"": [""bytes32 node"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTTL"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets TTL for a node"",
        ""Parameters"": [""bytes32 node"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""allFusesBurned"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if specified fuses are all burned (set)"",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""onERC721Received"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles ERC721 token transfers to this contract"",
        ""Parameters"": [""address to"", ""address"", ""uint256 tokenId"", ""bytes calldata data""],
        ""Returns"": [""bytes4""]
      },
      {
        ""Name"": ""onlyTokenOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures caller is token owner or approved"",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": []
      },
      {
        ""Name"": ""operationAllowed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures operation is not prohibited by fuses"",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": []
      },
      {
        ""Name"": ""canCallSetSubnodeOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Checks if can call setSubnodeOwner"",
        ""Parameters"": [""bytes32 node"", ""bytes32 labelhash""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""ENS - The main ENS registry contract"",
    ""IBaseRegistrar - The .eth registrar contract"",
    ""IMetadataService - Service for ERC1155 token metadata"",
    ""INameWrapperUpgrade - Contract for upgrading wrapped names""
  ],
  
  ""SpecialMechanisms"": [
    ""Fuse-based permission system: Uses bit flags to control different operations on names"",
    ""ERC1155 token wrapping of ENS names: ENS names represented as ERC1155 tokens"",
    ""Name expiry mechanism: Handles expiry dates for names to align with ENS registrations"",
    ""Upgradability mechanism: Enables upgrading to a new wrapper contract"",
    ""Hierarchical permission system: Parent nodes can control child nodes unless explicitly restricted""
  ],
  
  ""Questions"": [
    ""How are the fuses actually enforced? The code shows checks in the modifiers but it would be good to verify all operations are properly guarded"",
    ""What happens if the upgradeContract has a vulnerability? There seems to be significant trust placed in this external contract"",
    ""How does the contract handle expired domains? Is there clean-up or garbage collection?"",
    ""Are there gas optimizations possible in the _addLabel and bytes handling?"",
    ""What is the rationale behind having both _setFuses and _setData functions?"",
    ""Is there a risk of hitting block gas limits when dealing with deeply nested names?""
  ]
}

This NameWrapper contract is a complex piece of ENS infrastructure that provides an ownership and permissions layer on top of the ENS registry. It wraps ENS names as ERC1155 tokens and implements a system of ""fuses"" that can restrict various operations once burned. The contract handles both .eth domains and subdomains, with appropriate permissions checks and management of expiration times. Special care has been taken to handle hierarchical ownership, name transfers, and permission management throughout the contract.","I've analyzed the provided security findings from various sources. After consolidating similar issues and ordering them by severity, here's the final report:

{
  ""Findings"": [
    {
      ""Issue"": ""Unauthorized Access and Improper Validation in Upgrade Mechanism"",
      ""Severity"": ""High"",
      ""Description"": ""The upgrade mechanism has several critical flaws: the _prepareUpgrade function burns tokens before transferring ownership to the upgrade contract; the setUpgradeContract function grants the upgrade contract full approval to ENS and registrar contracts without proper validation; and if the upgrade transaction fails after token burning but before ownership transfer, names could be permanently lost. Additionally, approvals might be revoked from the old contract without being granted to the new one if the function fails midway."",
      ""Impact"": ""Potential permanent loss of ENS names during upgrades, theft of domain names if the upgrade contract is compromised, and possible complete control of all names managed by the NameWrapper by a malicious upgrade contract."",
      ""Location"": ""_prepareUpgrade function, setUpgradeContract function, upgradeETH2LD and upgrade functions""
    },
    {
      ""Issue"": ""Missing Access Control for Child Nodes"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions have inconsistent or insufficient access control. The setChildFuses function allows a parent node owner to modify fuses of child nodes without properly verifying permissions. Similarly, setSubnodeOwner and setSubnodeRecord don't verify CANNOT_UNWRAP for existing subnodes, meaning a parent can effectively take control of subdomains that should be restricted. The _transferAndBurnFuses internal function transfers tokens and sets fuses without explicit validation."",
      ""Impact"": ""Parent node owners could potentially modify fuses of child nodes even when the PARENT_CANNOT_CONTROL fuse is burnt, bypassing ownership restrictions and allowing unauthorized transfers of subdomains with specific fuse restrictions."",
      ""Location"": ""setChildFuses function, setSubnodeOwner, setSubnodeRecord, _transferAndBurnFuses""
    },
    {
      ""Issue"": ""Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes external calls to ENS, BaseRegistrar, and other contracts before updating its own state in several functions, creating potential reentrancy vulnerabilities. For example, wrapETH2LD makes external calls to the registrar contract before updating internal state, and _unwrap calls external contracts after changing state but before emitting events."",
      ""Impact"": ""If the external contracts are malicious or compromised, they could re-enter the NameWrapper and manipulate state before operations complete, potentially enabling theft or manipulation of wrapped names through reentrancy attacks."",
      ""Location"": ""wrap, wrapETH2LD, unwrapETH2LD, _unwrap, onERC721Received and other functions making external calls""
    },
    {
      ""Issue"": ""Improper Validation in onERC721Received"",
      ""Severity"": ""High"",
      ""Description"": ""The onERC721Received function verifies that msg.sender is the registrar contract but doesn't verify that 'to' is the contract itself. Additionally, there's no input validation for label length when decoding the label from calldata."",
      ""Impact"": ""A malicious contract could trick the NameWrapper into accepting unauthorized token transfers or executing unwanted operations. Could potentially allow registration of names with invalid labels through direct ERC721 transfers."",
      ""Location"": ""onERC721Received function""
    },
    {
      ""Issue"": ""Unauthorized Access in setFuses"",
      ""Severity"": ""High"",
      ""Description"": ""The setFuses function has issues with access control: it prevents setting PARENT_CANNOT_CONTROL but doesn't properly validate whether the caller has permission to burn fuses based on the parent's ownership status. It might also incorrectly revert if the token owner tries to set this fuse, and doesn't fully validate fuse combinations that might be invalid or contradictory."",
      ""Impact"": ""Users who own tokens cannot set important fuses on their own names, breaking expected permission hierarchies. Unauthorized fuse burning could occur if a child owner burns fuses that should require parent permission."",
      ""Location"": ""setFuses function""
    },
    {
      ""Issue"": ""Potential Manipulation in _canFusesBeBurned"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _canFusesBeBurned function enforces specific rules on fuses that can be burned, but the implementation is flawed and could allow unauthorized fuse burning patterns. There's no validation that the user burning these fuses has the authority to burn PARENT_CANNOT_CONTROL, which should generally require parent ownership."",
      ""Impact"": ""Attackers could potentially burn fuses in invalid combinations, leading to locked names or unauthorized access control states. Could allow improper fuse burning where users can lock names in ways they shouldn't be able to."",
      ""Location"": ""_canFusesBeBurned function""
    },
    {
      ""Issue"": ""Improper Expiry Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _normaliseExpiry function has complex logic for determining expiry times. It simply ensures expiry doesn't exceed maxExpiry or isn't less than oldExpiry, but doesn't validate that the expiry date is reasonable or properly aligned with other constraints. There's no validation that expiry is greater than the current timestamp, potentially allowing already-expired names."",
      ""Impact"": ""Could lead to unexpected behavior when working with expired names or setting new expiry dates. Names could expire prematurely or last longer than intended, affecting the ENS ecosystem's reliability."",
      ""Location"": ""_normaliseExpiry function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Expiry Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses uint64 for expiry values and has a MAX_EXPIRY constant set to the maximum uint64 value. Functions like registrar.nameExpires() return a uint256 which is cast to uint64, potentially causing overflow. Additionally, using type(uint64).max for MAX_EXPIRY could lead to nodes with effective permanent ownership."",
      ""Impact"": ""Could lead to incorrect expiry calculations, potentially allowing names to expire sooner than intended or causing other unexpected behavior. This could lead to nodes being permanently locked if set with MAX_EXPIRY."",
      ""Location"": ""_getETH2LDDataAndNormaliseExpiry function, Constructor and _normaliseExpiry function""
    },
    {
      ""Issue"": ""No Validation for Resolver Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions allow setting a resolver for names, but there's no validation that the resolver address is a valid resolver contract implementing the required interface."",
      ""Impact"": ""Setting an invalid resolver could make ENS names unreachable or non-functional. Names could become unresolvable if an invalid resolver is set, affecting usability of the ENS system."",
      ""Location"": ""wrapETH2LD, setSubnodeRecord, setRecord, setResolver functions""
    },
    {
      ""Issue"": ""Potential Front-running in Subnode Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like setSubnodeOwner and setSubnodeRecord check if the current owner of a node is the NameWrapper contract and take different actions based on this, creating a transaction ordering dependency that could be exploited by front-running."",
      ""Impact"": ""An attacker could monitor the mempool for these transactions and front-run them with their own transaction that changes the ownership state, causing the victim's transaction to execute a different code path than intended."",
      ""Location"": ""setSubnodeOwner and setSubnodeRecord functions""
    },
    {
      ""Issue"": ""Insufficient Label Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _addLabel function only checks if the label length is within bounds (min 1, max 255 characters) but doesn't validate that the label contains actual content or validate character content for DNS compatibility. There's also no check that the resulting name (label + existing name) doesn't exceed storage limits."",
      ""Impact"": ""Could allow registration of misleading, invisible domain names, or names with invalid DNS characters, enabling phishing attacks or causing compatibility issues. Could lead to excessively long name strings causing gas issues."",
      ""Location"": ""_addLabel function""
    },
    {
      ""Issue"": ""Centralization Risk in Owner Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from Ownable with no mechanism to renounce ownership or transfer to a governance mechanism. The owner has permanent privileges to set the metadata service and upgrade contract. If the owner's private key is compromised, an attacker could change critical contract parameters."",
      ""Impact"": ""Centralization risk where the contract owner retains significant control over critical contract functionality. If compromised, an attacker could disrupt the ENS system."",
      ""Location"": ""setMetadataService and setUpgradeContract functions""
    },
    {
      ""Issue"": ""Unprotected Initialization of ETH_NODE and ROOT_NODE"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the constructor, the contract initializes ETH_NODE and ROOT_NODE with special privileges and address(0) as the owner, which could create edge cases or ownership ambiguities. There's no check to ensure this initialization hasn't been tampered with."",
      ""Impact"": ""While this is initialization code, the permanent nature of these settings means any mistake here cannot be fixed later. If deployment parameters are incorrect or manipulated, the foundational nodes of the ENS system would have incorrect permissions permanently."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Unchecked Return Values in ERC721 Interactions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't verify the success of ERC721 transfers from the registrar in functions like unwrapETH2LD. While many ERC721 implementations revert on failure, some might return a boolean, and failure to check this could lead to silent failures."",
      ""Impact"": ""If the transfer fails silently, the contract's state could become inconsistent with the actual token ownership in the registrar."",
      ""Location"": ""unwrapETH2LD function""
    },
    {
      ""Issue"": ""Lack of Emitted Events for Critical Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several critical operations, such as setting the metadata service or upgrade contract, do not emit events. This makes it difficult to track important contract state changes off-chain."",
      ""Impact"": ""Reduced transparency and auditability of contract administrative actions. Makes it harder for users and applications to track important contract state changes, potentially leading to user confusion."",
      ""Location"": ""setMetadataService, setUpgradeContract functions""
    },
    {
      ""Issue"": ""Potential DoS in getData Access"",
      ""Severity"": ""Low"",
      ""Description"": ""The getFuses function reverts with NameNotFound if no fuses are set and there's no name record, instead of returning default values. This inconsistency could cause problems for callers."",
      ""Impact"": ""Applications calling this function may experience unexpected failures, potentially leading to denial of service for specific functionality."",
      ""Location"": ""getFuses function""
    },
    {
      ""Issue"": ""Inefficient Storage of Name Data"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract stores full name data for each wrapped name which is gas inefficient as the parent's name is duplicated in all children. Additionally, the contract never cleans up this storage when names are unwrapped, leading to permanent storage bloat."",
      ""Impact"": ""Higher gas costs for users and potential size limits on deeply nested names. Increasing gas costs for the contract over time and inefficient use of blockchain storage."",
      ""Location"": ""names mapping and related name storage functions, _wrap and _unwrap functions""
    },
    {
      ""Issue"": ""Missing Zero-Address Checks"",
      ""Severity"": ""Low"",
      ""Description"": ""Constructor doesn't validate that input addresses (_ens, _registrar, _metadataService) are non-zero, which could lead to deployment with invalid dependencies."",
      ""Impact"": ""Contract could be deployed with invalid dependency addresses, requiring redeployment."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Gas Optimization Issues"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract performs many operations with strings and bytes, which can be gas-intensive. For example, repeatedly using keccak256(bytes(label)) instead of caching the result. The _normaliseExpiry function also performs checks that might be redundant in some cases."",
      ""Impact"": ""Higher gas costs for users interacting with the contract, especially for operations involving longer names or complex operations."",
      ""Location"": ""Throughout the contract, especially in functions handling label manipulation, _normaliseExpiry function""
    }
  ],
  ""IssueNumber"": 63,
  ""OutputList"": 19
}",425.4114441871643,103783.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Report Description**:  
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to execute malicious code in `onERC1155Received` right after transfer but before new owner and new fuses are set. This allows an attacker to unwrap the subdomain, but the owner and fuses will still be set even for the unwrapped domain, creating a fake ERC1155 NameWrapper token for the domain, which is not owned by NameWrapper.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerabilities""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in functions like `_transferAndBurnFuses`, which aligns with the issue described. The response also correctly explains the risks associated with reentrancy, including potential state manipulation, which is consistent with the issue's impact.

---

#### **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Report Description**:  
By design, the child node's expiry can only be extended up to the parent's current one. However, the current implementation does not enforce this restriction, allowing the child node's expiry to exceed the parent's expiry. This violates the guarantee policy, as users must traverse the hierarchy to understand the guarantees of a name.

**Match in Response List**:  
Matches with the issue titled **""Improper Expiry Validation""**.

**Validation**:  
**Partially Correct**. The response identifies issues with expiry validation but does not explicitly mention the violation of the guarantee policy where a child node's expiry exceeds the parent's expiry. The response focuses on general expiry validation issues, missing the specific hierarchical constraint described in the issue.

---

#### **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Report Description**:  
By design, if the `PARENT_CANNOT_CONTROL` fuse is burnt for a subdomain, the parent should not be able to burn its fuses or change its owner. However, this constraint can be bypassed if the parent node maliciously unwraps itself. The attacker can then use `ENSRegistry::setSubnodeOwner` to re-set themselves as the ENS owner of the subdomain, allowing them to rewrite the fuses and wrapper owner of the subdomain.

**Match in Response List**:  
Matches with the issue titled **""Missing Access Control for Child Nodes""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with insufficient access control for child nodes, including the bypass of `PARENT_CANNOT_CONTROL` by unwrapping the parent node. The response correctly explains the risks associated with unauthorized modifications of child node fuses, which aligns with the issue's impact.

---

#### **[M-01] `wrapETH2LD` permissioning is over-extended**

**Report Description**:  
The current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not the owner to call it if they are either approved for all on the ERC721 registrar or approved on the wrapper. This over-extended permissioning could lead to unauthorized wrapping of domains.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The over-extended permissioning in `wrapETH2LD` is not covered in any of the responses.

---

#### **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Report Description**:  
There is a general incorrect logic of allowing the burning of only the `PARENT_CANNOT_CONTROL` fuse without burning the `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` is burnt, the domain can be unwrapped by its owner and then wrapped again, which clears the `PARENT_CANNOT_CONTROL` fuse. This allows the parent to bypass the limitation of parent control before the expiry.

**Match in Response List**:  
Matches with the issue titled **""Potential Manipulation in _canFusesBeBurned""**.

**Validation**:  
**Partially Correct**. The response identifies issues with fuse burning logic but does not explicitly mention the specific scenario where unwrapping and rewrapping a subdomain clears the `PARENT_CANNOT_CONTROL` fuse. The response focuses on general fuse manipulation risks, missing the specific exploit described in the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**
- **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Partially Correct Matches**:

- **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**
- **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Missed Issues from Issue Report**:

- **[M-01] `wrapETH2LD` permissioning is over-extended**

--- 

This evaluation highlights the coverage, accuracy, and sufficiency of the responses in addressing the reported issues. While some issues were correctly identified, others were partially addressed or missed entirely, indicating room for improvement in the response list.","```
1. Reentrancy Vulnerabilities
2. Missing Access Control for Child Nodes
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Reentrancy Vulnerabilities"" appears at rank 3.
   - ""Missing Access Control for Child Nodes"" appears at rank 2.

2. **Calculate the precision at each rank**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.6667}{2} = \frac{1.1667}{2} \approx 0.5833 \)

**Average Precision (AP)**: 0.5833"
ByteUtil.sol,"pragma solidity ^0.8.4;

library BytesUtils {
    /*
    * @dev Returns the keccak-256 hash of a byte range.
    * @param self The byte string to hash.
    * @param offset The position to start hashing at.
    * @param len The number of bytes to hash.
    * @return The hash of the byte range.
    */
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal.
    * @param self The first bytes to compare.
    * @param other The second bytes to compare.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal. Comparison is done per-rune,
    *      on unicode codepoints.
    * @param self The first bytes to compare.
    * @param offset The offset of self.
    * @param len    The length of self.
    * @param other The second bytes to compare.
    * @param otheroffset The offset of the other string.
    * @param otherlen    The length of the other string.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @param len The number of bytes to compare
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    /*
    * @dev Returns true if the two byte ranges are equal with offsets.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    /*
    * @dev Compares a range of 'self' to all of 'other' and returns True iff
    *      they are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    /*
    * @dev Returns the 8-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 8 bits of the string, interpreted as an integer.
    */
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    /*
    * @dev Returns the 16-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 16 bits of the string, interpreted as an integer.
    */
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    /*
    * @dev Returns the 32-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bits of the string, interpreted as an integer.
    */
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    /*
    * @dev Returns the n byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes.
    * @param len The number of bytes.
    * @return The specified 32 bytes of the string.
    */
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    /*
    * @dev Copies a substring into a new byte string.
    * @param self The byte string to copy from.
    * @param offset The offset to start copying at.
    * @param len The number of bytes to copy.
    */
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    // Maps characters from 0x30 to 0x7A to their base32 values.
    // 0xFF represents invalid characters in that range.
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    /**
     * @dev Decodes unpadded base32 data of up to one word in length.
     * @param self The data to decode.
     * @param off Offset into the string to start at.
     * @param len Number of characters to decode.
     * @return The decoded data, left aligned.
     */
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            // Multiple of 8 characters, no padding
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            // Two extra characters - 1 byte
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            // Four extra characters - 2 bytes
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            // Five extra characters - 3 bytes
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            // Seven extra characters - 4 bytes
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    /**
     * @dev Finds the first occurrence of the byte `needle` in `self`.
     * @param self The string to search
     * @param off The offset to start searching at 
     * @param len The number of bytes to search
     * @param needle The byte to search for
     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.
     */
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",2905,320,"[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters
Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than 32 characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than 32 characters where len or otherlen is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).
  [M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths
Compare will return false answer without reverting when the inputs are not valid.
  [M-08] Wrong Equals Logic
The function `equals` with offset might return true when equals without offset returns false.
",3,,"pragma solidity ^0.8.4;

library BytesUtils {
    
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    
    
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",1636,0,3,"Based on the detailed analysis of the BytesUtils library, here's a comprehensive task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Memory Safety and Low-Level Assembly"",
      ""Tasks"": [
        ""Thoroughly review all assembly blocks for potential out-of-bounds memory access risks"",
        ""Verify boundary checks in readUint8, readUint16, readUint32, readBytes32, and readBytes20 functions"",
        ""Analyze memcpy function for potential memory corruption or overflow vulnerabilities"",
        ""Validate all pointer arithmetic in assembly blocks for precision and safety""
      ]
    },
    {
      ""Area"": ""Input Validation and Error Handling"",
      ""Tasks"": [
        ""Examine require statements for comprehensive input validation"",
        ""Review base32HexDecodeWord function's complex length validation and potential edge cases"",
        ""Assess error handling mechanisms, particularly in functions with multiple input parameters"",
        ""Verify that all input length checks prevent potential integer overflow or underflow""
      ]
    },
    {
      ""Area"": ""Cryptographic Operations"",
      ""Tasks"": [
        ""Validate the keccak function's implementation for cryptographic integrity"",
        ""Review the compare function's bitwise comparison logic for potential side-channel vulnerabilities"",
        ""Ensure that hash-based equality checks (equals functions) are not susceptible to timing attacks""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze assembly-based implementations for potential gas optimization opportunities"",
        ""Review loop structures in compare and base32HexDecodeWord functions for efficiency"",
        ""Assess the overhead of multiple function overloads and their gas implications"",
        ""Evaluate the use of unchecked blocks and their potential risks and benefits""
      ]
    },
    {
      ""Area"": ""Bit Manipulation and Encoding"",
      ""Tasks"": [
        ""Carefully review the base32HexDecodeWord implementation for encoding/decoding accuracy"",
        ""Verify the bit manipulation logic in readBytesN and other bit-level operations"",
        ""Check the base32HexTable lookup mechanism for potential index-out-of-bounds issues""
      ]
    },
    {
      ""Area"": ""Substring and Memory Management"",
      ""Tasks"": [
        ""Verify the substring function's memory allocation and copying mechanism"",
        ""Check for potential memory leaks or inefficient memory usage"",
        ""Validate the find function's implementation for searching byte patterns""
      ]
    },
    {
      ""Area"": ""Comprehensive Edge Case Testing"",
      ""Tasks"": [
        ""Develop test cases for extreme input scenarios (zero-length bytes, max-length inputs)"",
        ""Test boundary conditions in comparison and reading functions"",
        ""Verify behavior with unicode and special character inputs"",
        ""Create test vectors for base32HexDecodeWord with various input lengths and patterns""
      ]
    }
  ]
}

**Key Audit Considerations:**

1. This task list focuses heavily on the library's unique challenges:
   - Extensive use of low-level assembly
   - Complex bit manipulation
   - Cryptographic operations
   - Memory management

2. The primary risks are centered around:
   - Potential memory safety issues
   - Precision in bit-level operations
   - Comprehensive input validation
   - Performance and gas efficiency

3. The audit should pay special attention to:
   - The base32HexDecodeWord function's complex logic
   - Assembly block implementations
   - Boundary checking mechanisms
   - Cryptographic integrity of hash-based comparisons

The task list provides a structured approach to thoroughly examining the BytesUtils library, addressing both security concerns and implementation nuances.","After reviewing the provided Solidity code, I'll present my audit findings in the requested format:

{
  ""ReviewingTheCode"": ""The code appears to be a utility library called BytesUtils that provides various functions for working with byte arrays in Solidity. It offers functionality like keccak256 hashing, comparing bytes, equality checking, reading various data types from bytes, and operations like substring and base32 hex decoding."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BytesUtils"",
    ""Purpose"": ""A utility library that provides helper functions for manipulating and working with byte arrays in Solidity"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": []
    },
    ""StateVariables"": [
      {
        ""Name"": ""base32HexTable"",
        ""Type"": ""bytes constant"",
        ""Purpose"": ""Lookup table for base32hex decoding operations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""keccak"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Computes the keccak256 hash of a portion of a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""compare"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Compares two byte arrays and returns their lexicographical difference"",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""int""]
      },
      {
        ""Name"": ""compare"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Compares specific portions of two byte arrays and returns their lexicographical difference"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len"", ""bytes memory other"", ""uint otheroffset"", ""uint otherlen""],
        ""Returns"": [""int""]
      },
      {
        ""Name"": ""equals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if segments of two byte arrays are equal by comparing their keccak hashes"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other"", ""uint otherOffset"", ""uint len""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if the remaining segments of two byte arrays (from given offsets) are equal"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other"", ""uint otherOffset""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a segment of the first array equals the second array"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if two byte arrays are exactly equal"",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""readUint8"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint8 value from a specified position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint8 ret""]
      },
      {
        ""Name"": ""readUint16"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint16 value from a specified position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint16 ret""]
      },
      {
        ""Name"": ""readUint32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint32 value from a specified position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint32 ret""]
      },
      {
        ""Name"": ""readBytes32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes32 value from a specified position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""readBytes20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes20 value from a specified position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes20 ret""]
      },
      {
        ""Name"": ""readBytesN"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a specified number of bytes from a position in a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint idx"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""memcpy"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function that copies memory from one location to another"",
        ""Parameters"": [""uint dest"", ""uint src"", ""uint len""],
        ""Returns"": []
      },
      {
        ""Name"": ""substring"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Extracts a substring from a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes memory""]
      },
      {
        ""Name"": ""base32HexDecodeWord"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Decodes a base32hex encoded string into bytes32"",
        ""Parameters"": [""bytes memory self"", ""uint off"", ""uint len""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""find"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Finds the first occurrence of a byte in a segment of a byte array"",
        ""Parameters"": [""bytes memory self"", ""uint256 off"", ""uint256 len"", ""bytes1 needle""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [],
  ""SpecialMechanisms"": [
    ""Low-level assembly operations for memory manipulation and optimization"",
    ""Base32hex decoding algorithm with a lookup table"",
    ""Efficient byte comparison using bit masks""
  ],
  ""Questions"": [
    ""What is the intended use case for this library? The functions seem to be designed for working with DNS-related data or other encoded byte streams."",
    ""In base32HexDecodeWord, the error handling for invalid length seems unclear - the function reverts if len % 8 is not in [0,2,4,5,7]. Is there a specific reason for this constraint?"",
    ""The memcpy function uses both unchecked and assembly blocks. Could this be optimized or made more gas-efficient?"",
    ""In the compare function's loop, there's a comment about handling non-full-word comparisons, but the implementation seems complex. Would a simpler approach be safer?"",
    ""Some functions like readBytes20 use complex bit masks in assembly. Are these all necessary or could some be simplified?""
  ]
}

This library appears to be a well-structured utility for byte manipulations in Solidity, likely used for DNS-related operations or other protocols requiring precise byte handling. The extensive use of assembly suggests optimization for gas efficiency, though it also increases the complexity and potential for subtle bugs.","I've analyzed the different findings lists provided for the BytesUtils library. After consolidating similar issues and organizing them by severity, here's the combined report:

{
  ""Findings"": [
    {
      ""Issue"": ""Unchecked Array Bounds and Assembly Operations"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions use assembly blocks without adequate boundary checks before operations. For example, readBytes32() only checks if idx + 32 <= self.length but doesn't verify other safety aspects when performing memory operations. The readUint8() function accesses self[idx] without first verifying that idx is within bounds of the array, unlike other read functions that contain bounds checks."",
      ""Impact"": ""Potential memory corruption, unexpected behavior, or out-of-bounds access that would revert transactions when functions are called with edge case parameters. If used in critical path operations, this could result in denial of service."",
      ""Location"": ""Multiple read functions (readUint16, readUint32, readBytes32, readBytes20, readBytesN), especially readUint8()""
    },
    {
      ""Issue"": ""Missing length checks in memcpy operation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The memcpy function is implemented with unsafe operations that don't properly validate that source and destination memory regions won't overlap. This could lead to unexpected behavior if the function is misused internally within the library."",
      ""Impact"": ""If src and dest memory regions overlap, the data copying operation could corrupt memory and lead to unexpected behavior or vulnerabilities in contracts using this library."",
      ""Location"": ""memcpy function""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow in Compare Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the compare function, there's a subtraction operation: `int diff = int(a & mask) - int(b & mask);` which casts uint values to int before subtraction. If the values are large, this could cause an overflow when converting from uint to int. Although Solidity 0.8.4+ has built-in overflow/underflow protection for arithmetic operations, the casting itself can lead to unexpected behavior."",
      ""Impact"": ""Could result in incorrect comparison results when comparing large byte arrays, potentially affecting contract logic that relies on accurate comparisons."",
      ""Location"": ""compare function, specifically at the line `int diff = int(a & mask) - int(b & mask);`""
    },
    {
      ""Issue"": ""Potential Integer Underflow in Mask Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the compare function, the mask calculation `mask = ~(2 ** (8 * (32 - shortest + idx)) - 1)` could cause an underflow if shortest < 32 and idx > 0. Similar issues exist in readBytesN where the mask calculation uses `256 ** (32 - len)` which could underflow if len > 32 despite the require check."",
      ""Impact"": ""Could result in incorrect comparisons for certain byte patterns, affecting logical decisions based on these comparisons or returning incorrect data."",
      ""Location"": ""compare function mask calculation and readBytesN function""
    },
    {
      ""Issue"": ""Potential Out-of-Gas in Loop Operations for Large Arrays"",
      ""Severity"": ""Medium"",
      ""Description"": ""In functions like compare, find, and memcpy that iterate through bytes arrays, there's no upper bound on the array size. Processing very large arrays could lead to excessive gas consumption or even hitting block gas limits, causing transactions to fail."",
      ""Impact"": ""Operations on large byte arrays could fail due to out-of-gas errors, making the contract functions unreliable for certain inputs. A malicious actor could cause transactions to run out of gas by providing very large byte arrays, leading to denial of service."",
      ""Location"": ""compare function loop: `for (uint idx = 0; idx < shortest; idx += 32)`, find function, and memcpy function""
    },
    {
      ""Issue"": ""Insufficiently Validated Input in Base32HexDecodeWord"",
      ""Severity"": ""Medium"",
      ""Description"": ""The base32HexDecodeWord function performs some validation but may not handle all edge cases correctly. It requires characters to be between 0x30 to 0x7A (ASCII '0' to 'z') and uses a lookup table, but this range includes characters that aren't valid in base32hex encoding. The function contains a generic revert() statement without an error message when the len % 8 doesn't match expected values, and there's no validation to ensure that len is not zero."",
      ""Impact"": ""Could lead to unexpected reverts, incorrect decoding results, or contract failures when processing inputs that are technically within range but not valid base32Hex characters. Users won't receive clear information on why their transaction failed, making debugging difficult."",
      ""Location"": ""base32HexDecodeWord function""
    },
    {
      ""Issue"": ""Missing Input Validation in Substring Method"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the substring method checks that offset + len doesn't exceed the array length, it doesn't validate that len is not 0, which could lead to unnecessary gas consumption for creating an empty byte array. Additionally, it doesn't verify that the values aren't negative or that the operation doesn't revert due to other memory constraints."",
      ""Impact"": ""Inefficient gas usage when creating empty substrings, which could be avoided with additional validation. Potential unexpected reverts or incorrect substring results with certain inputs."",
      ""Location"": ""substring function""
    },
    {
      ""Issue"": ""Inefficient Memory Usage and Implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""The memcpy function uses a loop for copying 32-byte chunks and then handles the remainder with a mask. The substring function creates a new byte array in memory for each call. While functionally correct, these approaches are less gas-efficient than using assembly directly for the entire operation or optimizing memory allocation. For large strings or frequent calls, this could lead to unnecessary memory allocation."",
      ""Impact"": ""Higher gas costs for operations that involve copying or manipulating large byte arrays, which could make certain operations prohibitively expensive."",
      ""Location"": ""memcpy function and substring function""
    },
    {
      ""Issue"": ""Inefficient equals Function Implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""Multiple equals() function overloads use keccak256 hashing for comparison, which is gas-intensive. For small byte arrays, direct comparison would be more efficient."",
      ""Impact"": ""Higher than necessary gas costs when comparing small byte arrays, potentially making contract operations more expensive than they need to be."",
      ""Location"": ""All equals() function implementations""
    },
    {
      ""Issue"": ""Unchecked Arithmetic Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The pointer arithmetic in several functions (e.g., compare, memcpy) happens without overflow checks. While this is likely safe due to memory constraints, it could potentially cause unexpected behavior with extremely large inputs."",
      ""Impact"": ""In extreme edge cases, this could lead to unexpected behavior or memory access errors, though the practical risk is minimal due to the rarity of such extreme values in normal operation."",
      ""Location"": ""compare function (selfptr += 32; otherptr += 32;), memcpy function""
    },
    {
      ""Issue"": ""Return Value Handling in find Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The find() function returns the maximum value of uint256 when the needle is not found, rather than a more explicit return value like -1 (converted appropriately). This approach requires careful handling by callers."",
      ""Impact"": ""Developers using this library might misinterpret the return value, potentially leading to logical errors in code that depends on this function."",
      ""Location"": ""find() function""
    },
    {
      ""Issue"": ""Use of Low-Level Assembly Without Sufficient Comments"",
      ""Severity"": ""Low"",
      ""Description"": ""The code uses assembly extensively throughout the library, which is appropriate for the byte manipulation it's performing. However, some sections lack comprehensive comments explaining the operations and safety considerations, making audit and maintenance challenging."",
      ""Impact"": ""Increases the difficulty of code review and maintenance, potentially leading to the introduction of bugs in future modifications."",
      ""Location"": ""Throughout the library, particularly in readBytes20, readBytesN functions""
    },
    {
      ""Issue"": ""Lack of Zero-length Array Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions don't explicitly handle zero-length arrays, which could lead to unexpected behavior when comparing or manipulating empty byte arrays."",
      ""Impact"": ""Potential incorrect results or reverts when handling empty arrays."",
      ""Location"": ""compare(), equals(), and other utility functions""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 13
}",344.5182061195373,50962.0,32.0,"### **Summary of Matches and Gaps**

---

#### **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Report Description**:
The `BytesUtil.compare` function incorrectly masks irrelevant characters only for strings shorter than 32 characters. For strings longer than 32 characters, the function fails to mask out irrelevant characters in the last pass of the loop when the remainder of the string is 32 characters or less. This leads to incorrect comparisons for strings longer than 32 characters, especially when `len` or `otherlen` is smaller than the string length. Characters beyond the provided length are still accounted for in the comparison, which should be ignored.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of incorrect masking in the `compare` function for strings longer than 32 characters. The issue is entirely missed, and no related vulnerabilities or risks are identified.

---

#### **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Report Description**:
The `compare` function in `BytesUtils` does not revert when the `offset` and `len` parameters exceed the length of the input bytes. Instead, it returns an incorrect result without reverting, which could lead to logical errors in contracts relying on accurate comparisons.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing validation for `offset` and `len` parameters in the `compare` function. This oversight is not covered in any of the responses.

---

#### **[M-08] Wrong Equals Logic**

**Report Description**:
The `equals` function with an offset might return `true` when the `equals` function without an offset returns `false`. This inconsistency in logic could lead to incorrect equality checks, potentially affecting contract behavior.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of inconsistent logic in the `equals` function. This issue is entirely missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**
- **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**
- **[M-08] Wrong Equals Logic**

---

### **Analysis**:
The provided `response_list` does not address any of the issues in the `issue` report. The issues related to incorrect masking in `compare`, missing validation for `offset` and `len`, and inconsistent logic in `equals` are entirely missed. The `response_list` focuses on other vulnerabilities, such as unchecked array bounds, integer overflow/underflow, and inefficient memory usage, but does not cover the specific issues raised in the `issue` report. This indicates a significant gap in the coverage of the `response_list`.","```
None.
```",0.0
