nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
ExtraRewardsDistributor.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenÏ€
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365,268,"[H-01] User can forfeit other user rewards
User can forfeit other user rewards by giving a higher `_startIndex` in `getReward` function.
â€¨
[M-05] Users can grief reward distribution
Users can grief reward distributions by spending dust.
If a reward is targeted for an epoch in the past, a user can front-run the txn in the mempool and callÂ addRewardToEpoch()Â with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert
â€¨â€¨[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.â€¨â€¨â€¨[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens
If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.
",4,,"pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";


contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    
    mapping(address => uint256[]) public rewardEpochs;
    
    mapping(address => mapping(address => uint256)) public userClaims;

    

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    

    
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        
        emit RewardAdded(_token, _epoch, _amount);
    }

    

    
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            
            userClaims[_token][_account] = index;

            
            IERC20(_token).safeTransfer(_account, claimableTokens);

            
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    

    
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        
        uint256 tokenEpochs = rewardEpochs[_token].length;

        
        uint256 epochIndex = userClaims[_token][_account];
        
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",1352,1,3,"Based on the initial analysis and code review, here's a comprehensive audit task list focusing on key areas of concern:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the reentrancy protection mechanisms in _addReward and _getReward functions"",
        ""Verify that nonReentrant modifier is correctly applied to all sensitive transfer operations"",
        ""Check for potential integer overflow/underflow risks in reward calculations"",
        ""Validate input validation and parameter checks in all external functions"",
        ""Ensure SafeERC20 library is used consistently for all token transfers""
      ]
    },
    {
      ""Area"": ""Reward Distribution Logic"",
      ""Tasks"": [
        ""Verify the accuracy of reward calculation mechanism (_claimableRewards function)"",
        ""Audit the epoch-based reward tracking to ensure no rewards can be lost or manipulated"",
        ""Validate the logic for adding rewards to specific epochs in addRewardToEpoch"",
        ""Check for potential rounding errors in reward calculations"",
        ""Review the forfeitRewards mechanism for potential exploitation""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze interactions with IAuraLocker contract for potential vulnerabilities"",
        ""Verify that external contract calls (auraLocker.checkpointEpoch(), auraLocker.epochCount()) are secure"",
        ""Ensure proper handling of different ERC20 token implementations"",
        ""Check for potential oracle or price manipulation risks""
      ]
    },
    {
      ""Area"": ""Access Control and Permissions"",
      ""Tasks"": [
        ""Review access controls for reward addition functions"",
        ""Verify that only authorized addresses can add rewards"",
        ""Check for potential privilege escalation vulnerabilities"",
        ""Validate the scope of external function permissions""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption of reward calculation and claiming mechanisms"",
        ""Review the efficiency of epoch tracking and reward storage"",
        ""Check for potential gas-related vulnerabilities in loops and calculations"",
        ""Evaluate the gas impact of multiple reward claims and additions""
      ]
    },
    {
      ""Area"": ""Edge Cases and Error Handling"",
      ""Tasks"": [
        ""Test scenarios with zero balance, zero rewards, and zero supply"",
        ""Verify handling of tokens with transfer fees or unusual ERC20 behaviors"",
        ""Check boundary conditions in epoch-based reward calculations"",
        ""Validate error handling and revert conditions in all functions"",
        ""Test recovery mechanisms for accidentally sent tokens""
      ]
    },
    {
      ""Area"": ""Potential Attack Vectors"",
      ""Tasks"": [
        ""Analyze potential front-running risks in reward addition functions"",
        ""Check for sandwich attack possibilities in reward claiming"",
        ""Verify protection against reward manipulation"",
        ""Review potential time-based attack vectors in epoch tracking"",
        ""Validate protection against flash loan-based exploits""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers critical smart contract audit areas specific to this reward distribution mechanism.
2. Each area focuses on potential vulnerabilities unique to the contract's design.
3. Tasks are designed to be specific, actionable, and comprehensive.
4. The breakdown addresses technical, security, and economic considerations.

Recommended Next Steps:
- Conduct a detailed review following these task categories
- Use automated analysis tools to supplement manual review
- Perform comprehensive testing covering all identified scenarios
- Consider engaging multiple security experts for cross-validation

Specific Areas of Concern:
- The unusual `_getReward` function visibility (public instead of internal)
- Complex epoch-based reward tracking mechanism
- Potential rounding errors in reward calculations
- External dependency on AuraLocker contract

The task list provides a structured approach to thoroughly audit the ExtraRewardsDistributor contract, ensuring comprehensive security and functionality assessment.","I'll perform a thorough audit of the provided smart contract code following the specified steps.

{
  ""ReviewingTheCode"": ""The code implements an 'ExtraRewardsDistributor' contract designed to distribute additional rewards to users who have locked AURA tokens in the AuraLocker contract. It uses epochs for reward distribution, allowing reward providers to add rewards for specific epochs. Users can then claim rewards they are entitled to based on their locked token balance in those epochs."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ExtraRewardsDistributor"",
    ""Purpose"": ""To distribute extra rewards to users who have locked AURA tokens in the AuraLocker system, with rewards being allocated based on epochs and proportional to users' locked token balances."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""IExtraRewardsDistributor""],
      ""Imports"": [
        ""IExtraRewardsDistributor, IAuraLocker from ./Interfaces.sol"",
        ""IERC20 from @openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"",
        ""SafeERC20 from @openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"",
        ""ReentrancyGuard from @openzeppelin/contracts-0.8/security/ReentrancyGuard.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""auraLocker"",
        ""Type"": ""IAuraLocker"",
        ""Purpose"": ""Immutable reference to the AuraLocker contract that tracks user balances and epochs""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Stores reward rates per token per epoch (token â†’ epoch â†’ rewardPerToken)""
      },
      {
        ""Name"": ""rewardEpochs"",
        ""Type"": ""mapping(address => uint256[])"",
        ""Purpose"": ""Tracks which epochs have rewards for each token (token â†’ array of epochs)""
      },
      {
        ""Name"": ""userClaims"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the index of epochs that users have claimed rewards for (token â†’ user â†’ epochIndex)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the address of the AuraLocker contract"",
        ""Parameters"": [""_auraLocker (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds reward tokens to be distributed for the latest epoch"",
        ""Parameters"": [""_token (address)"", ""_amount (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""addRewardToEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds reward tokens to be distributed for a specific epoch"",
        ""Parameters"": [""_token (address)"", ""_amount (uint256)"", ""_epoch (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation for adding rewards, calculating per-token rates, and updating epoch tracking"",
        ""Parameters"": [""_token (address)"", ""_amount (uint256)"", ""_epoch (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to claim all their available rewards for a specific token"",
        ""Parameters"": [""_account (address)"", ""_token (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Overloaded function that allows claiming rewards from a specific starting index"",
        ""Parameters"": [""_account (address)"", ""_token (address)"", ""_startIndex (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Internal implementation for reward claiming logic"",
        ""Parameters"": [""_account (address)"", ""_token (address)"", ""_startIndex (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""forfeitRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to forfeit unclaimed rewards up to a specific index"",
        ""Parameters"": [""_token (address)"", ""_index (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimableRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to check total claimable rewards for a user and token"",
        ""Parameters"": [""_account (address)"", ""_token (address)""],
        ""Returns"": [""uint256 (reward amount)""]
      },
      {
        ""Name"": ""claimableRewardsAtEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to check claimable rewards for a specific epoch"",
        ""Parameters"": [""_account (address)"", ""_token (address)"", ""_epoch (uint256)""],
        ""Returns"": [""uint256 (reward amount)""]
      },
      {
        ""Name"": ""_allClaimableRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates all claimable rewards for a user across all epochs"",
        ""Parameters"": [""_account (address)"", ""_token (address)"", ""_startIndex (uint256)""],
        ""Returns"": [""uint256 (total rewards)"", ""uint256 (new epoch index)""]
      },
      {
        ""Name"": ""_claimableRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates claimable rewards for a specific epoch"",
        ""Parameters"": [""_account (address)"", ""_token (address)"", ""_epoch (uint256)""],
        ""Returns"": [""uint256 (reward amount)""]
      },
      {
        ""Name"": ""rewardEpochsCount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the count of epochs that have rewards for a token"",
        ""Parameters"": [""_token (address)""],
        ""Returns"": [""uint256 (count)""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IAuraLocker - used to query epoch data, user balances, and checkpoint epochs"",
    ""IERC20 - used for token transfers (safeTransfer, safeTransferFrom)""
  ],
  
  ""SpecialMechanisms"": [
    ""Epoch-based reward distribution system"",
    ""Per-token reward tracking across multiple epochs"",
    ""Proportional reward distribution based on user balances in each epoch"",
    ""ReentrancyGuard to prevent reentrant attacks during token transfers"",
    ""SafeERC20 for secure token transfers""
  ],
  
  ""Questions"": [
    ""Why is _getReward marked as public when it appears to be an internal implementation function?"",
    ""Could there be an issue with reward dust/rounding where some tokens might get stuck in the contract?"",
    ""Is there a potential for frontrunning with the addReward functions?"",
    ""What happens if a token has transfer fees or non-standard ERC20 behavior?"",
    ""Should there be a way to recover tokens accidentally sent to the contract?"",
    ""Is there sufficient validation to ensure rewards can't be added for epochs with zero totalSupply?""
  ]
}

Based on my review, this contract implements a mechanism to distribute extra rewards to users who have locked tokens in the AuraLocker system. The distribution happens on an epoch basis, with rewards being proportional to a user's locked token balance in each epoch. The contract handles tracking which rewards have been claimed by which users and allows for claiming rewards across multiple epochs. 

The main security considerations include the use of ReentrancyGuard to prevent re-entrancy during reward transfers and SafeERC20 for secure token handling. However, there are some questions about edge cases and potential improvements that should be considered during a complete audit.","I have analyzed the eight lists of security findings for the ExtraRewardsDistributor smart contract. After consolidating similar issues and removing redundancies, here's my comprehensive summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Missing Access Control for Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The addReward and addRewardToEpoch functions don't implement proper access control mechanisms. Any external actor can call these functions, potentially adding rewards that could manipulate reward distributions. There's no ownership or role-based access control limiting who can distribute rewards."",
      ""Impact"": ""Unauthorized parties could add rewards, which might lead to manipulation of reward calculations, unfair distribution of rewards, or unexpected behavior. Malicious actors could use this to manipulate reward distributions, confuse users, or potentially create conditions favorable for other exploits."",
      ""Location"": ""addReward function (lines 47-52) and addRewardToEpoch function (lines 54-69)""
    },
    {
      ""Issue"": ""Reentrancy Risk in _getReward Function"",
      ""Severity"": ""High"",
      ""Description"": ""The _getReward function updates state after making an external token transfer, creating a potential re-entrancy vulnerability. Although the contract inherits from ReentrancyGuard, the _getReward function does not use the nonReentrant modifier while making external calls to transfer tokens."",
      ""Impact"": ""A malicious token with a callback mechanism could re-enter the function and potentially drain more rewards than entitled to. This could lead to double claiming of rewards and potential drain of contract funds."",
      ""Location"": ""_getReward() function (lines 111-139), specifically the execution order where token transfer occurs before state updates""
    },
    {
      ""Issue"": ""Incorrect Visibility for _getReward Function"",
      ""Severity"": ""High"",
      ""Description"": ""The _getReward function is marked as public despite having an underscore prefix, which conventionally indicates an internal function. This inconsistency allows anyone to call it directly, potentially claiming rewards on behalf of other users without authorization."",
      ""Impact"": ""Confusion in code organization, potential unintended external access to what should be internal logic, and possible exploitation where malicious actors can call _getReward for any account, potentially frontrunning legitimate users' transactions."",
      ""Location"": ""_getReward function (lines 118-150)""
    },
    {
      ""Issue"": ""Potential Front-running in Reward Distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""When adding rewards to the latest epoch, there's a potential for frontrunning attacks where malicious actors could observe the transaction and quickly modify their locked balances to receive a disproportionate share of the rewards. The addReward function calls auraLocker.checkpointEpoch() which might change the state before calculating rewards."",
      ""Impact"": ""Unfair distribution of rewards, benefiting attackers at the expense of legitimate users. Users monitoring the blockchain could time their stake just before rewards are added to maximize their reward share."",
      ""Location"": ""addReward function and _addReward implementation""
    },
    {
      ""Issue"": ""Lack of Input Validation for Token Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not validate that token addresses are legitimate ERC20 tokens before storing reward data. This could allow adding rewards for non-existent, malicious tokens, or zero addresses. Similarly, there's no validation in forfeitRewards to check if the token exists before accessing array elements."",
      ""Impact"": ""Adding non-ERC20 tokens or zero addresses could break reward calculations, cause transactions to revert unexpectedly, or result in permanent loss of funds if tokens are sent to invalid addresses. Poor error handling could lead to confusing error messages for users."",
      ""Location"": ""addReward, addRewardToEpoch, forfeitRewards functions and other functions accepting token addresses""
    },
    {
      ""Issue"": ""Precision Loss in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calculates rewards per token using the formula (amount * 1e20) / supply, which could lead to precision loss for very small or very large values. For tokens with large amounts or low decimals, arithmetic overflow could occur, as the multiplication happens before division. Additionally, division before multiplication in some calculations may lead to further precision loss."",
      ""Impact"": ""Uneven distribution of rewards, especially for users with very small balances or when the token has a high decimal count. Users might receive slightly less rewards than expected due to rounding errors, which could accumulate over time."",
      ""Location"": ""_addReward function (line 80-83) and _claimableRewards function (line 191-201)""
    },
    {
      ""Issue"": ""Potential Locking of Funds"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the getReward function, rewards are only claimable for epochs that have already passed. If rewards are added but no new epochs are created, those funds could remain locked in the contract. Additionally, the contract lacks functionality to sweep or recover tokens that users never claim."",
      ""Impact"": ""Users may be unable to claim rewards that have been added to the contract, leading to locked funds and poor user experience. Permanent loss of unclaimed reward tokens reduces capital efficiency for the protocol."",
      ""Location"": ""_allClaimableRewards function (lines 172-194)""
    },
    {
      ""Issue"": ""Zero Supply Check Missing"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _addReward function, there's no check that supply is not zero before dividing by it. If totalSupplyAtEpoch returns zero for any reason, this would cause the transaction to revert due to division by zero."",
      ""Impact"": ""Function would revert when adding rewards to epochs with zero total supply, potentially locking rewards and causing failed transactions."",
      ""Location"": ""_addReward function, calculation of rPerT variable""
    },
    {
      ""Issue"": ""Unbounded Loops in _allClaimableRewards"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function _allClaimableRewards iterates through all epochs from the user's last claim to the current epoch. The for loop could potentially iterate through a large number of epochs, consuming significant gas and potentially causing transactions to fail due to exceeding the block gas limit."",
      ""Impact"": ""Failed transactions or prohibitively expensive operations for users with many unclaimed epochs. Transactions may fail due to out-of-gas errors if there are too many epochs to process, potentially locking user rewards."",
      ""Location"": ""_allClaimableRewards function loop (lines 172-194)""
    },
    {
      ""Issue"": ""Incorrect Epoch Validation Logic in forfeitRewards"",
      ""Severity"": ""Medium"",
      ""Description"": ""The forfeitRewards function has an overly restrictive condition that prevents forfeiting certain reward epochs, which may not be intentional. The check `_index < rewardEpochs[_token].length - 1` prevents forfeiting the second-to-last reward epoch, when it should be `_index < rewardEpochs[_token].length`."",
      ""Impact"": ""Users cannot forfeit rewards for certain epochs, limiting flexibility. Users might be forced to claim rewards they intended to forfeit."",
      ""Location"": ""forfeitRewards function (lines 138-156)""
    },
    {
      ""Issue"": ""Missing Zero Amount Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't validate that _amount is greater than zero in addReward and addRewardToEpoch functions, allowing zero rewards to be added which could create unnecessary storage operations and emit misleading events."",
      ""Impact"": ""Allows adding zero rewards, wasting gas and potentially creating confusion in event logs."",
      ""Location"": ""Functions addReward and addRewardToEpoch""
    },
    {
      ""Issue"": ""Lack of Pause Mechanism"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't include a pause mechanism to halt operations in case of emergencies or when security issues are discovered."",
      ""Impact"": ""In case of a discovered vulnerability or exploit, contract owners would have no way to pause operations while a fix is prepared."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Missing Event Details for forfeitRewards"",
      ""Severity"": ""Low"",
      ""Description"": ""While the function emits a ForfeiteReward event, it doesn't include the amount forfeited, making it difficult to track the exact value of rewards being given up. Additionally, there's no validation that the user actually had rewards to forfeit before updating the claim index."",
      ""Impact"": ""Reduced transparency and auditability of the contract's operation. Users could forfeit non-existent rewards or forfeit without understanding what amount they're giving up."",
      ""Location"": ""forfeitRewards function (lines 138-156)""
    },
    {
      ""Issue"": ""Missing Zero Address Check in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor takes an _auraLocker address parameter but doesn't validate if it's a zero address. Since this is an immutable parameter, setting it to the zero address would permanently break the contract's functionality."",
      ""Impact"": ""If deployed with a zero address for auraLocker, the contract would be unusable and would need to be redeployed."",
      ""Location"": ""Constructor (lines 28-30)""
    }
  ],
  ""IssueNumber"": 67,
  ""OutputList"": 14
}",358.90294003486633,49785.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] User can forfeit other user rewards**

**Report Description**:  
The `getReward` function allows a user to forfeit another user's rewards by specifying a higher `_startIndex`. This could lead to unauthorized forfeiture of rewards, potentially causing economic loss for affected users.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Epoch Validation Logic in forfeitRewards""**.

**Validation**:  
**Partially Correct**. The response identifies an issue with the `forfeitRewards` function, specifically the overly restrictive condition preventing forfeiting certain reward epochs. However, it does not address the core issue of unauthorized forfeiture of rewards by manipulating `_startIndex` in `getReward`. The response focuses on a different aspect of the `forfeitRewards` function, missing the critical vulnerability described in the issue.

---

#### **[M-05] Users can grief reward distribution**

**Report Description**:  
Users can grief reward distributions by spending dust amounts. If a reward is targeted for an epoch in the past, a user can front-run the transaction in the mempool and call `addRewardToEpoch()` with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-running in Reward Distribution""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of front-running in reward distribution. It explains how malicious actors could observe transactions and modify their locked balances to receive a disproportionate share of rewards. This aligns with the issue's description of griefing reward distributions by spending dust amounts.

---

#### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Report Description**:  
Rewards may be locked forever if a user doesn't claim them for a very long time, such that too many epochs have passed. The platform may then be forced to reimburse the user, causing significant economic loss.

**Match in Response List**:  
Matches with the issue titled **""Potential Locking of Funds""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of rewards being locked in the contract if no new epochs are created. It explains that users may be unable to claim rewards, leading to locked funds and poor user experience. This aligns with the issue's description of rewards being locked forever due to unclaimed epochs.

---

#### **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

**Report Description**:  
If rewards are given in fee-on-transfer tokens, users may receive no rewards, breaking functionality. This could lead to users losing rewards to other users due to the token's fee mechanism.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens and their impact on reward distribution. This is a missed issue in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-05] Users can grief reward distribution**
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Partially Correct Matches**:

- **[H-01] User can forfeit other user rewards**

**Missed Issues from Issue Report**:

- **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

---

### **Conclusion**

The response list covers some of the issues in the issue report, particularly those related to front-running and locked funds. However, it partially addresses the issue of unauthorized forfeiture of rewards and completely misses the issue of fee-on-transfer tokens. Improvements are needed to ensure comprehensive coverage of all vulnerabilities.","```
1. Potential Front-running in Reward Distribution
2. Potential Locking of Funds
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Potential Front-running in Reward Distribution"" appears at rank 4.
   - ""Potential Locking of Funds"" appears at rank 7.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 7: \( P@7 = \frac{2}{7} \approx 0.2857 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   \[
   AP = \frac{0.25 + 0.2857}{2} \approx 0.26785
   \]

**Output**:
```
0.26785
```"
AuraLocker.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734,876,"[M-03] Improperly Skewed Governance Mechanism
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.â€¨â€¨â€¨[M-04]Â AuraLockerÂ kick reward only takes last locked amount into consideration, instead of whole balance
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired.â€¨In this scenario, to calculate the kick reward,Â `_processExpiredLocks`Â multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.
â€¨â€¨[M-06] Rewards distribution can be delayed/never distributed onÂ AuraLocker.sol#L848
Rewards distribution can be delayed/never distributed onÂ the function `_rewardPerToken()`
â€¨â€¨[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.â€¨â€¨â€¨[M-08] Locking up AURA Token does not increase voting power of individual
Per theÂ documentation, AURA tokens can be locked in the AuraLocker to recieve vlAURA.Â vlAURA is voting powerÂ in the AURA ecosystem.
It is also possible for the users to delegate their voting power to a specific address by calling theÂ `AuraLocker.delegate(address account)`Â function.
However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.
â€¨â€¨[M-10] Increase voting power by tokenizing the address that locks the token
Without restriction on the type of address thatÂ lockÂ the token in function `_lock`, a bad actor could lock the token through the smart contract.
â€¨â€¨[M-14] Integer overflow will lock all rewards inÂ AuraLocker
There is a potential overflow in the rewards calculations which would lead toÂ `updateReward()`Â always reverting.
",7,,"pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}


contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    

    struct RewardData {
        
        uint32 periodFinish;
        
        uint32 lastUpdateTime;
        
        uint96 rewardRate;
        
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; 
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    

    
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    
    mapping(address => RewardData) public rewardData;
    
    mapping(address => mapping(address => bool)) public rewardDistributors;
    
    mapping(address => mapping(address => UserData)) public userData;
    
    uint256 public constant rewardsDuration = 86400 * 7;
    
    uint256 public constant lockDuration = rewardsDuration * 17;

    
    
    uint256 public lockedSupply;
    
    Epoch[] public epochs;
    
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    
    
    mapping(address => address) private _delegates;
    
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    
    
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    
    uint256 public constant denominator = 10000;
    
    address public immutable cvxcrvStaking;
    
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    
    bool public isShutdown = false;

    
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    

    
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    

    
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); 
        require(_delay >= 2, ""min delay""); 
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    

    
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        
        _lock(_account, _amount);
    }

    
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        
        _checkpointEpoch();

        
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        
        lockedSupply = lockedSupply.add(_amount);

        
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    
    function getReward(address _account) external {
        getReward(_account, false);
    }

    
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        
        
        if (epochs[epochindex - 1].date < currentEpoch) {
            
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        
        
        
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            
            locked = userBalance.locked;

            
            userBalance.nextUnlockIndex = length.to32();

            
            
            
            
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            
            
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                
                if (locks[i].unlockTime > expiryTime) break;

                
                locked = locked.add(locks[i].amount);

                
                
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                
                nextUnlockIndex++;
            }
            
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        
        if (reward > 0) {
            
            locked = locked.sub(reward.to112());

            
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    

    
    function delegate(address newDelegatee) external virtual nonReentrant {
        
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        
        
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                
                
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    

    
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        
        
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            
            
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    
                    break;
                }
            }
        }

        return amount;
    }

    
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    

    
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    

    
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        
        
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",6073,0,7,"Based on the comprehensive analysis of the AuraLocker contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly review the `updateReward` modifier for potential reentrancy risks"",
        ""Verify all external calls in `_processExpiredLocks` for potential reentrancy vulnerabilities"",
        ""Check integer overflow/underflow protection in mathematical operations, especially in reward calculations"",
        ""Validate input validation and sanitization in all external and public functions"",
        ""Analyze the delegate mechanism for potential vote manipulation attacks"",
        ""Review the emergency withdrawal (`emergencyWithdraw`) function for potential exploitation""
      ]
    },
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Audit owner-only functions for potential centralization risks"",
        ""Verify the scope and limitations of owner privileges in `addReward`, `approveRewardDistributor`, and `shutdown`"",
        ""Check the implementation of the `Ownable` contract for any potential vulnerabilities"",
        ""Evaluate the emergency shutdown mechanism for potential misuse"",
        ""Review the delegation system's access controls and potential governance attack vectors""
      ]
    },
    {
      ""Area"": ""Reward Distribution Mechanism"",
      ""Tasks"": [
        ""Analyze the reward calculation logic in `_rewardPerToken` and `_earned` functions"",
        ""Verify the correctness of the reward queuing mechanism in `queueNewRewards`"",
        ""Check for potential manipulation of reward rates and distribution"",
        ""Validate the handling of multiple reward tokens"",
        ""Review the kick reward mechanism for potential economic exploits"",
        ""Verify the accuracy of reward tracking across different epochs""
      ]
    },
    {
      ""Area"": ""Locking and Delegation Mechanism"",
      ""Tasks"": [
        ""Audit the lock duration and epoch calculation logic"",
        ""Verify the integrity of the voting power delegation system"",
        ""Check the checkpoint mechanism for potential time-based manipulation"",
        ""Analyze the `balanceAtEpochOf` and `getPastVotes` functions for accuracy"",
        ""Review the delegate transfer and voting power tracking mechanisms"",
        ""Validate the handling of partial and full token locks""
      ]
    },
    {
      ""Area"": ""Mathematical Accuracy"",
      ""Tasks"": [
        ""Review all custom math library implementations for correctness"",
        ""Verify boundary condition handling in mathematical operations"",
        ""Check for potential precision loss in reward and balance calculations"",
        ""Validate the use of bit-sized math operations (AuraMath32, AuraMath112, etc.)"",
        ""Analyze potential rounding errors in reward and supply calculations""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify safe token transfer implementations using SafeERC20"",
        ""Review interactions with external staking contracts (cvxcrvStaking)"",
        ""Check approval and transfer mechanisms for external tokens"",
        ""Validate the handling of different ERC20 token implementations"",
        ""Review the `setApprovals` function for potential approval reset vulnerabilities""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in complex functions like `_processExpiredLocks`"",
        ""Review loop implementations for potential gas griefing"",
        ""Check the efficiency of epoch and checkpoint management"",
        ""Verify the optimization strategies in reward distribution"",
        ""Evaluate the gas costs of delegation and voting power tracking""
      ]
    },
    {
      ""Area"": ""Edge Cases and Error Handling"",
      ""Tasks"": [
        ""Test scenarios with zero balances and zero rewards"",
        ""Verify behavior during contract shutdown"",
        ""Check handling of tokens with different decimal representations"",
        ""Test extreme cases in locking, unlocking, and delegation"",
        ""Validate error message clarity and correctness"",
        ""Review fallback and error handling mechanisms""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC20-like interface compliance"",
        ""Check implementation of voting power tracking against governance standards"",
        ""Review naming and symbol conventions"",
        ""Validate decimals implementation"",
        ""Ensure proper event emissions for key state changes""
      ]
    }
  ]
}

This comprehensive task list covers multiple critical aspects of the AuraLocker contract, providing a structured approach to conducting a thorough security audit. Each area is broken down into specific, actionable tasks that address potential vulnerabilities, mathematical accuracy, and overall contract integrity.

The tasks are designed to:
- Identify and mitigate potential security risks
- Verify the correctness of complex mathematical and governance mechanisms
- Ensure robust error handling and edge case management
- Validate external interactions and token compatibility
- Assess gas efficiency and optimization opportunities

Auditors should systematically work through these tasks, documenting findings, potential vulnerabilities, and recommended improvements.","After a careful review of the provided smart contract code, I'll present my findings in the requested format:

{
  ""ReviewingTheCode"": ""The contract implements a token locking mechanism for a staking system where users can lock AURA tokens for extended periods (17 weeks) to earn various rewards. It includes voting delegation capabilities, reward distribution mechanisms, and a unique 'kick' feature to incentivize the processing of expired locks. The contract appears to be part of a larger protocol ecosystem that includes cvxCRV token interactions."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AuraLocker"",
    ""Purpose"": ""A staking contract that allows users to lock AURA tokens for extended periods (17 weeks) in exchange for rewards, with vote delegation capabilities"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""Ownable"", ""IAuraLocker""],
      ""Imports"": [
        ""IERC20"", 
        ""SafeERC20"", 
        ""Ownable"", 
        ""ReentrancyGuard"",
        ""AuraMath"", 
        ""AuraMath32"", 
        ""AuraMath112"", 
        ""AuraMath224"", 
        ""Interfaces.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""rewardTokens"",
        ""Type"": ""address[]"",
        ""Purpose"": ""List of token addresses that are distributed as rewards""
      },
      {
        ""Name"": ""queuedCvxCrvRewards"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Queued rewards for cvxCrv token that haven't been distributed yet""
      },
      {
        ""Name"": ""newRewardRatio"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Threshold ratio to determine if queued rewards should be distributed immediately""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => RewardData)"",
        ""Purpose"": ""Stores reward-related data for each reward token""
      },
      {
        ""Name"": ""rewardDistributors"",
        ""Type"": ""mapping(address => mapping(address => bool))"",
        ""Purpose"": ""Tracks authorized reward distributors for each reward token""
      },
      {
        ""Name"": ""userData"",
        ""Type"": ""mapping(address => mapping(address => UserData))"",
        ""Purpose"": ""Tracks user-specific reward data for each reward token""
      },
      {
        ""Name"": ""rewardsDuration"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Duration of reward distribution period (7 days)""
      },
      {
        ""Name"": ""lockDuration"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Duration tokens must be locked (17 weeks)""
      },
      {
        ""Name"": ""lockedSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of tokens locked in the contract""
      },
      {
        ""Name"": ""epochs"",
        ""Type"": ""Epoch[]"",
        ""Purpose"": ""Array of epoch data with supply and timestamp information""
      },
      {
        ""Name"": ""balances"",
        ""Type"": ""mapping(address => Balances)"",
        ""Purpose"": ""Tracks user's locked token balances""
      },
      {
        ""Name"": ""userLocks"",
        ""Type"": ""mapping(address => LockedBalance[])"",
        ""Purpose"": ""Stores details of each user's locks including amount and unlock time""
      },
      {
        ""Name"": ""_delegates"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps users to their chosen voting delegates""
      },
      {
        ""Name"": ""_checkpointedVotes"",
        ""Type"": ""mapping(address => DelegateeCheckpoint[])"",
        ""Purpose"": ""Records vote checkpoints for delegates""
      },
      {
        ""Name"": ""delegateeUnlocks"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Tracks scheduled unlocks for each delegate at specific timestamps""
      },
      {
        ""Name"": ""stakingToken"",
        ""Type"": ""IERC20 immutable"",
        ""Purpose"": ""The token that users stake (AURA)""
      },
      {
        ""Name"": ""cvxCrv"",
        ""Type"": ""address immutable"",
        ""Purpose"": ""Address of the cvxCrv token""
      },
      {
        ""Name"": ""cvxcrvStaking"",
        ""Type"": ""address immutable"",
        ""Purpose"": ""Address of the cvxCrv staking contract""
      },
      {
        ""Name"": ""kickRewardPerEpoch"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Reward rate for users who kick expired locks""
      },
      {
        ""Name"": ""kickRewardEpochDelay"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum epochs delay required before a lock can be kicked""
      },
      {
        ""Name"": ""isShutdown"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate if the contract has been shut down""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""updateReward"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates reward data for all tokens before executing a function"",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with name, symbol, and required addresses"",
        ""Parameters"": [""string _nameArg"", ""string _symbolArg"", ""address _stakingToken"", ""address _cvxCrv"", ""address _cvxCrvStaking""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new reward token"",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveRewardDistributor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves or revokes a distributor for a specific reward token"",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor"", ""bool _approved""],
        ""Returns"": []
      },
      {
        ""Name"": ""setKickIncentive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets parameters for kick rewards"",
        ""Parameters"": [""uint256 _rate"", ""uint256 _delay""],
        ""Returns"": []
      },
      {
        ""Name"": ""shutdown"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Shuts down the contract (emergency function)"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Locks tokens for a user"",
        ""Parameters"": [""address _account"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_lock"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of token locking logic"",
        ""Parameters"": [""address _account"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims rewards for a user"",
        ""Parameters"": [""address _account"", ""bool _stake""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkpointEpoch"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates epoch data to current time"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""processExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Processes user's expired locks"",
        ""Parameters"": [""bool _relock""],
        ""Returns"": []
      },
      {
        ""Name"": ""kickExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to process another user's expired locks for a reward"",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all locked tokens in emergency shutdown"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_processExpiredLocks"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Processes expired locks with optional relocking"",
        ""Parameters"": [""address _account"", ""bool _relock"", ""address _rewardAddress"", ""uint256 _checkDelay""],
        ""Returns"": []
      },
      {
        ""Name"": ""delegate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Delegates voting rights to another address"",
        ""Parameters"": [""address newDelegatee""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkpointDelegate"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Records a checkpoint of delegated votes"",
        ""Parameters"": [""address _account"", ""uint256 _upcomingAddition"", ""uint256 _upcomingDeduction""],
        ""Returns"": []
      },
      {
        ""Name"": ""delegates"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the current delegate of an account"",
        ""Parameters"": [""address account""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getVotes"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Gets current votes for an account"",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getPastVotes"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Gets votes for an account at a specific timestamp"",
        ""Parameters"": [""address account"", ""uint256 timestamp""],
        ""Returns"": [""uint256 votes""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns user's current locked balance"",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""balanceAtEpochOf"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns user's balance at a specific epoch"",
        ""Parameters"": [""uint256 _epoch"", ""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""lockedBalances"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns detailed information about a user's locks"",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 total"", ""uint256 unlockable"", ""uint256 locked"", ""LockedBalance[] memory lockData""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns total locked supply"",
        ""Parameters"": [],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""queueNewRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Queues new cvxCrv rewards for distribution"",
        ""Parameters"": [""uint256 _rewards""],
        ""Returns"": []
      },
      {
        ""Name"": ""notifyRewardAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Notifies contract of reward amount for non-cvxCrv tokens"",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      },
      {
        ""Name"": ""_notifyReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of reward notification"",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 - ERC20 token standard interface for staking token and rewards"",
    ""IRewardStaking - External staking contract for cvxCrv"",
    ""OpenZeppelin contracts for security (ReentrancyGuard, Ownable)"",
    ""SafeERC20 for safe token transfers"",
    ""AuraMath libraries for safe math operations with different bit sizes""
  ],
  ""SpecialMechanisms"": [
    ""Epoch-based reward distribution system"",
    ""Time-locked staking with 17-week lock periods"",
    ""Reward distribution based on locked token amount"",
    ""Vote delegation system similar to ERC20Votes"",
    ""Checkpointing system for tracking voting power over time"",
    ""Incentivized 'kick' mechanism to encourage processing of expired locks"",
    ""Emergency shutdown capabilities"",
    ""Reward queue mechanism to optimize gas costs during frequent reward distributions""
  ],
  ""Questions"": [
    ""How is the 'newRewardRatio' (830) value determined, and what financial implications does it have?"",
    ""What is the relationship between this contract and the cvxCrv token system?"",
    ""What safeguards exist to prevent manipulation of the voting power through rapid locking/unlocking cycles?"",
    ""How is the reward rate calculated and what prevents potential overflow in reward calculations?"",
    ""Are there any potential timing attacks related to the epoch boundaries?"",
    ""What happens if a user delegates their votes but then transfers their tokens before the delegation period ends?"",
    ""What mechanisms prevent a malicious owner from draining funds from the contract?"",
    ""How does the contract handle scenarios where reward tokens have different decimals than the staking token?""
  ]
}

Based on my audit, this contract implements a staking mechanism for AURA tokens with several noteworthy features:

1. **Locking Mechanism**: Users lock AURA tokens for 17 weeks (lockDuration) to earn rewards.

2. **Reward Distribution**: Multiple reward tokens can be distributed with a 7-day reward period.

3. **Vote Delegation**: Users can delegate their voting power to other addresses, with power proportional to locked tokens.

4. **Epoch System**: Time is divided into weekly epochs for tracking rewards and voting power.

5. **Kick Mechanism**: Users can ""kick"" others with expired locks for a reward, incentivizing regular maintenance.

6. **Checkpointing**: Uses a checkpoint system to track voting power over time, enabling historical queries.

7. **Emergency Features**: Includes owner-controlled emergency shutdown and withdrawal functions.

Potential security concerns include:
- Owner privileges could be misused
- Complex interaction between locking, delegation, and rewards may have edge cases
- Math operations with specific bit sizes require careful handling to prevent overflow
- Delegation system integrity depends on correct checkpoint management
- External contract calls could introduce reentrancy risks (though ReentrancyGuard is used)

The contract appears well-structured overall but has significant complexity due to its multiple features.","I've analyzed the input data containing multiple security assessments of the AuraLocker smart contract. After reviewing and consolidating similar issues, here's my structured response:

{
  ""Findings"": [
    {
      ""Issue"": ""Unsafe Type Casting with Arithmetic Conversion"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses unsafe type casting through various to() methods (to96(), to112(), to224(), etc.) without proper overflow checks when converting between different uint sizes. When values exceed the maximum range for target types, they are silently truncated without any warnings or reverts."",
      ""Impact"": ""This can lead to data corruption, incorrect balances, potential fund theft, and silent overflows in reward calculations, delegation votes, and balance tracking, resulting in users receiving fewer rewards than entitled to or corrupted voting power."",
      ""Location"": ""Throughout the contract, especially in _notifyReward(), _earned(), balanceAtEpochOf(), _checkpointDelegate(), and other functions using AuraMath type conversion methods""
    },
    {
      ""Issue"": ""Reentrancy Vulnerabilities in Token Transfers"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract uses ReentrancyGuard, several functions like getReward() and _processExpiredLocks() make external token transfers after modifying state but before completing all state updates. This doesn't fully adhere to the checks-effects-interactions pattern, making the contract vulnerable to reentrancy if interacting with malicious tokens that implement callbacks."",
      ""Impact"": ""If a reward token has malicious callbacks, it could reenter the contract and manipulate state before the delegation logic completes, potentially leading to fund theft, reward manipulation, or delegated voting power corruption."",
      ""Location"": ""getReward(), processExpiredLocks(), kickExpiredLocks(), and related functions""
    },
    {
      ""Issue"": ""Delegate Checkpoint and Voting Power Manipulation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _checkpointDelegate function has critical issues in how it handles delegation and voting power calculations. It only looks at the latest checkpoint and doesn't properly account for intermediate checkpoints or properly update delegatee votes in certain scenarios like emergency withdrawals. Additionally, the casting of voting power values to uint224 could lead to truncation for large values."",
      ""Impact"": ""This can result in manipulation of governance voting, where some users could have more or less voting power than they should, potentially affecting DAO decisions and allowing attackers to gain disproportionate voting influence."",
      ""Location"": ""_checkpointDelegate() function, emergencyWithdraw() function""
    },
    {
      ""Issue"": ""Potential DoS in _processExpiredLocks and _checkpointEpoch"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions contain unbounded loops, particularly in _processExpiredLocks which iterates through all user locks, and _checkpointEpoch which creates new epochs in a while loop. If a user accumulates many locks or there's a large gap between epochs, these functions could exceed block gas limits."",
      ""Impact"": ""This could lead to a denial of service condition where users are unable to withdraw their tokens, effectively locking their funds indefinitely as transactions would fail due to excessive gas consumption."",
      ""Location"": ""_processExpiredLocks() function, _checkpointEpoch() function, balanceAtEpochOf() function""
    },
    {
      ""Issue"": ""Centralized Control of Reward Distributions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract allows the owner to add reward tokens, approve distributors, recover ERC20 tokens, and shut down the system. While this is a common pattern for administration, it introduces significant centralization risks without any timelock or governance mechanisms."",
      ""Impact"": ""If the owner key is compromised or misused, it could result in theft of rewards, addition of malicious reward tokens, or permanent shutdown of the protocol, potentially leading to loss of user funds."",
      ""Location"": ""addReward(), approveRewardDistributor(), shutdown(), and recoverERC20() functions""
    },
    {
      ""Issue"": ""Lack of Input Validation in Critical Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several important functions lack proper input validation. The addReward function doesn't verify if the _rewardsToken is a valid ERC20 token, lock functions don't validate amount bounds, and notifyRewardAmount performs token transfers after state changes without proper checks."",
      ""Impact"": ""Adding invalid reward tokens could break reward distribution functionality, while locking extreme amounts could cause calculation issues. Failed transfers after state changes could lead to incorrect reward accounting."",
      ""Location"": ""addReward(), _lock(), notifyRewardAmount(), delegate(), and other input-accepting functions""
    },
    {
      ""Issue"": ""Reward Calculation and Distribution Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""The reward mechanism can be manipulated by depositing large amounts just before reward periods end and withdrawing afterward. Additionally, the _notifyReward function recalculates rewardRate without properly validating it won't exceed the contract's ability to pay out rewards, and there's potential frontrunning in reward notification."",
      ""Impact"": ""Early users could claim a disproportionate amount of rewards, leaving later users with less than their fair share. Attackers could potentially manipulate the reward rate to benefit certain users."",
      ""Location"": ""_notifyReward(), _earned(), notifyRewardAmount(), and getReward() functions""
    },
    {
      ""Issue"": ""Precision Loss in Reward Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several reward calculations involve division operations that could lead to precision loss, particularly in _rewardPerToken and _earned functions where division happens before multiplication or when dealing with tokens that have different decimal places."",
      ""Impact"": ""Users might receive slightly fewer rewards than they are entitled to due to rounding errors in calculations, especially with small amounts or tokens with non-standard decimals."",
      ""Location"": ""_rewardPerToken(), _earned(), and related reward calculation functions""
    },
    {
      ""Issue"": ""Potential Block Timestamp Manipulation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract heavily relies on block.timestamp for determining epochs, rewards, and unlock times. Miners can manipulate block timestamps within a small range (typically up to several minutes)."",
      ""Impact"": ""Miners could slightly influence timing-dependent aspects of the contract, potentially gaining small advantages in reward claiming, lock timing, or unlock times, though the impact is limited by the scale of reward durations."",
      ""Location"": ""Throughout the contract, particularly in _checkpointEpoch, _lastTimeRewardApplicable, and lock logic""
    },
    {
      ""Issue"": ""Missing Events for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes, such as updating reward data in _notifyReward or approving tokens in setApprovals, don't emit specific events with detailed information, making it harder to track and audit the contract's behavior off-chain."",
      ""Impact"": ""Reduced transparency and auditability of the contract's operations, making it harder for users and monitoring tools to track changes and potentially missing important state transitions."",
      ""Location"": ""Throughout the contract, especially in reward management functions and setApprovals()""
    },
    {
      ""Issue"": ""ABIEncoderV2 Experimental Pragma"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses 'pragma experimental ABIEncoderV2' which was experimental in older Solidity versions. In 0.8.0+ it's included by default and the experimental pragma is deprecated."",
      ""Impact"": ""Using experimental features could potentially introduce unexpected behavior or bugs, particularly if the contract is compiled with older Solidity versions."",
      ""Location"": ""At the top of the contract file""
    }
  ],
  ""IssueNumber"": 47,
  ""OutputList"": 11
}",484.9466021060944,122362.0,32.0,"### **[M-03] Improperly Skewed Governance Mechanism**

**Report Description**:
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.

**Match in Response List**:
Matches with the issue titled **""Delegate Checkpoint and Voting Power Manipulation""**.

**Validation**:
**Partially Correct**. The response identifies issues with delegation and voting power calculations, which aligns with the core problem of improperly skewed governance mechanisms. However, it does not explicitly address the discrepancy between total supply of votes and individual voting power, which is a critical aspect of the reported issue.

---

### **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**

**Report Description**:
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of kick reward calculation based on the last locked amount instead of the whole balance. This is a missed issue.

---

### **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**

**Report Description**:
Rewards distribution can be delayed/never distributed on the function `_rewardPerToken()`.

**Match in Response List**:
Matches with the issue titled **""Reward Calculation and Distribution Vulnerabilities""**.

**Validation**:
**Correct**. The response identifies vulnerabilities in the reward mechanism, including potential delays in distribution, which aligns with the reported issue. It correctly explains the risks associated with reward distribution.

---

### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**

**Report Description**:
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of rewards being locked forever due to unclaimed rewards over many epochs. This is a missed issue.

---

### **[M-08] Locking up AURA Token does not increase voting power of individual**

**Report Description**:
Per the documentation, AURA tokens can be locked in the AuraLocker to receive vlAURA. vlAURA is voting power in the AURA ecosystem. It is also possible for the users to delegate their voting power to a specific address by calling the `AuraLocker.delegate(address account)` function. However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.

**Match in Response List**:
Matches with the issue titled **""Delegate Checkpoint and Voting Power Manipulation""**.

**Validation**:
**Partially Correct**. The response identifies issues with delegation and voting power calculations, which is related to the reported issue. However, it does not explicitly address the failure of voting power to increase after locking AURA tokens, which is a critical aspect of the reported issue.

---

### **[M-10] Increase voting power by tokenizing the address that locks the token**

**Report Description**:
Without restriction on the type of address that locks the token in function `_lock`, a bad actor could lock the token through the smart contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of tokenizing the address that locks the token, allowing bad actors to exploit the system. This is a missed issue.

---

### **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Report Description**:
There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.

**Match in Response List**:
Matches with the issue titled **""Unsafe Type Casting with Arithmetic Conversion""**.

**Validation**:
**Correct**. The response identifies issues with unsafe type casting and arithmetic conversion, which aligns with the potential overflow in rewards calculations. It correctly explains the risks associated with such vulnerabilities.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**
- **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Partially Correct Matches**:

- **[M-03] Improperly Skewed Governance Mechanism**
- **[M-08] Locking up AURA Token does not increase voting power of individual**

**Missed Issues from Issue Report**:

- **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**
- **[M-10] Increase voting power by tokenizing the address that locks the token**

---","```
1. Reward Calculation and Distribution Vulnerabilities
2. Unsafe Type Casting with Arithmetic Conversion
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reward Calculation and Distribution Vulnerabilities"" appears at rank 7.
   - ""Unsafe Type Casting with Arithmetic Conversion"" appears at rank 1.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 7: \( P@7 = \frac{2}{7} \approx 0.2857 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.2857}{2} = \frac{1.2857}{2} \approx 0.6429
   \]

**Output**:
```
0.6429
```"
ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667,308,"[M-13]Â ConvexMasterChef: WhenÂ `_lpToken`Â is cvx, reward calculation is incorrect
In the ConvexMasterChef contract, a new staking pool can be added using the `add()` function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the `_lpToken` is the same as the reward token (cvx) or not.
â€¨â€¨[M-15]Â ConvexMasterChef:Â `safeRewardTransfer`Â can cause loss of funds
All calculations are rounded down, since a lack of tokens in the contracts cannot be rounding errors' fault. So the function is redundant.â€¨On the other hand, if the contract is undersupplied with cvx tokens, this will cause depositors to be sent less tokens than needed (or none). This is especially unsafe because the tokens that were lacking are not resembled in accountings at all. Thus a depositor may invoke the safeRewardTransfer and not receive tokens they were supposed to.
â€¨â€¨[M-17]Â ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control
Reward token accounting update in `deposit()` and `withdraw()` happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.
â€¨â€¨[M-20]Â massUpdatePools()Â is susceptible to DoS with block gas limit
`massUpdatePools()` is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo.â€¨If poolInfo.length is big enough, block gas limit may be hit.â€¨â€¨â€¨[M-21]Â ConvexMasterChef: When usingÂ `add()`Â andÂ `set()`, it should always callÂ `massUpdatePools()`Â to update all pools
â€¨â€¨[M-22] Duplicate LP token could lead to incorrect reward distribution
It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution

",6,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";


contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    
    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    
    struct PoolInfo {
        IERC20 lpToken; 
        uint256 allocPoint; 
        uint256 lastRewardBlock; 
        uint256 accCvxPerShare; 
        IRewarder rewarder;
    }

    
    IERC20 public immutable cvx;
    
    uint256 public immutable rewardPerBlock;
    
    uint256 public constant BONUS_MULTIPLIER = 2;

    
    PoolInfo[] public poolInfo;
    
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    
    
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2047,0,6,"Based on the comprehensive analysis of the ConvexMasterChef contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in deposit, withdraw, and emergencyWithdraw functions"",
        ""Check for potential integer overflow/underflow vulnerabilities in arithmetic operations"",
        ""Validate SafeMath library usage across all mathematical calculations"",
        ""Inspect external call patterns, especially in rewarder interactions for potential call injection risks""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review onlyOwner modifier implementation for potential centralization risks"",
        ""Verify ownership transfer mechanisms and potential single point of failure"",
        ""Analyze the scope and limitations of owner-controlled functions like add() and set()"",
        ""Check for potential privilege escalation vulnerabilities""
      ]
    },
    {
      ""Area"": ""Reward Distribution Mechanism"",
      ""Tasks"": [
        ""Verify the accuracy of reward calculation logic in pendingCvx() function"",
        ""Validate the reward accumulation mechanism using accCvxPerShare"",
        ""Check handling of edge cases like zero total allocation points"",
        ""Audit the safeRewardTransfer() method for potential reward distribution issues"",
        ""Verify the precision and rounding in reward calculations""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Thoroughly review the IRewarder interface implementation"",
        ""Validate external contract call patterns in onReward() method"",
        ""Check for potential vulnerabilities in cross-contract interactions"",
        ""Verify the safety of external token transfers using SafeERC20""
      ]
    },
    {
      ""Area"": ""Staking Mechanism"",
      ""Tasks"": [
        ""Verify the logic in deposit() and withdraw() functions for potential manipulation"",
        ""Check handling of different pool scenarios (empty pools, zero deposits)"",
        ""Audit the emergencyWithdraw() function for potential exploits"",
        ""Validate the claim() function's access and reward distribution logic""
      ]
    },
    {
      ""Area"": ""Time and Block-based Rewards"",
      ""Tasks"": [
        ""Review getMultiplier() function for potential time-based reward manipulation"",
        ""Verify the handling of start and end blocks in reward distribution"",
        ""Check for potential issues with long-running or expired reward periods""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in massUpdatePools() function"",
        ""Review potential optimization opportunities in reward calculation"",
        ""Check for unnecessary storage reads and writes"",
        ""Verify the efficiency of loop-based operations""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Verify proper error handling in all critical functions"",
        ""Check for comprehensive input validation"",
        ""Test behavior with extreme or unexpected input values"",
        ""Validate error message clarity and specificity""
      ]
    },
    {
      ""Area"": ""Governance and Upgradability"",
      ""Tasks"": [
        ""Assess the flexibility and potential risks of pool management functions"",
        ""Review the implications of changing allocation points"",
        ""Verify the impact of adding or modifying pools mid-operation"",
        ""Check for potential governance attack vectors""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers a comprehensive range of potential vulnerabilities and risks specific to the ConvexMasterChef contract.
2. Each area focuses on critical aspects of smart contract security, functionality, and economic design.
3. Tasks are designed to be specific, actionable, and directly addressing the nuanced complexities of the contract.
4. The approach considers both technical implementation details and broader systemic risks.

Recommendations for Audit Execution:
- Prioritize security-critical tasks first
- Use a combination of static analysis, manual review, and comprehensive testing
- Develop specific test cases for each task to validate contract behavior
- Consider formal verification for critical mathematical and reward distribution logic

The task list provides a structured approach to thoroughly audit the ConvexMasterChef contract, ensuring a comprehensive examination of its security, functionality, and potential risks.","After carefully reviewing the ConvexMasterChef contract, here's my audit analysis:

{
  ""ReviewingTheCode"": ""The code implements a MasterChef-style staking contract for Convex Finance, allowing users to stake LP tokens to earn CVX rewards. It includes functionality for managing multiple pools, calculating and distributing rewards, and handling additional reward tokens through an external rewarder contract."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ConvexMasterChef"",
    ""Purpose"": ""A staking contract that allows users to deposit LP tokens into pools and earn CVX rewards based on allocation points and time staked, with support for additional reward tokens via external rewarder contracts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""SafeMath"",
        ""IERC20"",
        ""SafeERC20"",
        ""Context"",
        ""Ownable"",
        ""IRewarder""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""cvx"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The reward token (CVX) that will be distributed to stakers""
      },
      {
        ""Name"": ""rewardPerBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fixed amount of CVX rewards distributed per block""
      },
      {
        ""Name"": ""BONUS_MULTIPLIER"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant multiplier for reward calculations (set to 2 but not used in calculations)""
      },
      {
        ""Name"": ""poolInfo"",
        ""Type"": ""PoolInfo[]"",
        ""Purpose"": ""Array storing information about each staking pool""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(uint256 => mapping(address => UserInfo))"",
        ""Purpose"": ""Double mapping to track user staking data by pool ID and user address""
      },
      {
        ""Name"": ""totalAllocPoint"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Sum of allocation points across all pools for determining reward distribution""
      },
      {
        ""Name"": ""startBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Block number when reward distribution begins""
      },
      {
        ""Name"": ""endBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Block number when reward distribution ends""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with CVX token, reward rate, and start/end blocks"",
        ""Parameters"": [""_cvx"", ""_rewardPerBlock"", ""_startBlock"", ""_endBlock""],
        ""Returns"": []
      },
      {
        ""Name"": ""poolLength"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the number of pools"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""add"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds a new LP token pool with specified allocation points and rewarder"",
        ""Parameters"": [""_allocPoint"", ""_lpToken"", ""_rewarder"", ""_withUpdate""],
        ""Returns"": []
      },
      {
        ""Name"": ""set"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates pool allocation points and/or rewarder contract"",
        ""Parameters"": [""_pid"", ""_allocPoint"", ""_rewarder"", ""_withUpdate"", ""_updateRewarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMultiplier"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates reward multiplier for a period, capped at endBlock"",
        ""Parameters"": [""_from"", ""_to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pendingCvx"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Views pending CVX rewards for a user in a specific pool"",
        ""Parameters"": [""_pid"", ""_user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""massUpdatePools"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates reward variables for all pools"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates reward variables for a specific pool"",
        ""Parameters"": [""_pid""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits LP tokens, harvests rewards, and updates rewarder contract"",
        ""Parameters"": [""_pid"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Withdraws LP tokens, harvests rewards, and updates rewarder contract"",
        ""Parameters"": [""_pid"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims pending CVX rewards without deposit/withdrawal"",
        ""Parameters"": [""_pid"", ""_account""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Withdraws LP tokens without caring about rewards (emergency use)"",
        ""Parameters"": [""_pid""],
        ""Returns"": []
      },
      {
        ""Name"": ""safeRewardTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers CVX rewards, handling insufficient balance"",
        ""Parameters"": [""_to"", ""_amount""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 token interfaces for CVX and LP tokens"",
    ""IRewarder interface for additional reward distribution"",
    ""OpenZeppelin contracts for standard functionality (SafeMath, SafeERC20, Ownable)""
  ],
  
  ""SpecialMechanisms"": [
    ""MasterChef rewards accumulation pattern with accCvxPerShare mechanism"",
    ""Reward capping at endBlock through the getMultiplier function"",
    ""External rewarder hook pattern to allow additional reward tokens"",
    ""Safe token transfer pattern to handle potential insufficient balance scenarios""
  ],
  
  ""Questions"": [
    ""Why is BONUS_MULTIPLIER set to 2 but never used in reward calculations?"",
    ""Should there be additional access controls for the claim function?"",
    ""Is there any mechanism to handle the case where totalAllocPoint is zero?"",
    ""How are additional rewards from the rewarder contract funded and managed?"",
    ""In emergencyWithdraw, should user.rewardDebt be set to 0 before or after calling the rewarder?""
  ]
}

Based on my analysis, this contract follows the common MasterChef pattern originally from Sushi, but adapted for Convex Finance. It manages staking of LP tokens across multiple pools with different allocation points and rewards users with CVX tokens. The contract also supports external rewarders for additional rewards beyond CVX.

The implementation appears generally sound, but there are a few potential areas for improvement and questions noted in my analysis.","I'll process the issue findings from the ConvexMasterChef contract, combining similar issues and structuring them according to your requirements.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Key Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The deposit(), withdraw(), and claim() functions make external calls to rewarder contracts after state changes but before completing the function execution or emitting events. This follows a pattern where the contract transfers rewards, then updates state variables, creating a potential reentrancy vulnerability. If the rewarder contract is malicious or compromised, it could reenter the contract and exploit the updated state."",
      ""Impact"": ""An attacker could potentially exploit this to drain excessive rewards by repeatedly re-entering the functions before state updates are completed. A malicious rewarder could also manipulate balances or reward calculations, potentially leading to theft of funds."",
      ""Location"": ""deposit() function, withdraw() function, claim() function, safeRewardTransfer() function""
    },
    {
      ""Issue"": ""Missing Access Control on claim() Function"",
      ""Severity"": ""High"",
      ""Description"": ""The claim() function allows any address to trigger reward claims on behalf of any other address. There is no access control to ensure that only the rightful owner of the staked tokens can claim their rewards, meaning that any address can trigger rewards to be sent to any other address."",
      ""Impact"": ""This could lead to users having their rewards claimed at inappropriate times, potentially causing tax implications or other issues based on when rewards are received. It could also be used as part of a larger attack, such as forcing rewards to be sent before a malicious contract interaction."",
      ""Location"": ""claim() function""
    },
    {
      ""Issue"": ""Unchecked Return Values from External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calls external onReward functions on IRewarder contracts but doesn't check the return values. If the rewarder contract fails silently, the main contract won't be aware of the failure. These unchecked external calls could lead to silent failures in reward distribution."",
      ""Impact"": ""Users might not receive additional rewards from the rewarder contract, leading to loss of funds without any indication in the main contract. External rewards might not be properly distributed, but the contract would continue to operate as if they were."",
      ""Location"": ""deposit() function, withdraw() function, claim() function, emergencyWithdraw() function""
    },
    {
      ""Issue"": ""No Validation of Rewarder Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""When adding or updating pool information, there is no validation that the provided rewarder contract adheres to the expected interface or behavior. The add() and set() functions allow the owner to add or modify pools without validating if the provided _rewarder is a legitimate contract that follows the IRewarder interface."",
      ""Impact"": ""Setting an incorrect or malicious rewarder could lead to transaction reverts, potentially locking user funds or preventing reward distributions. It could also enable an attack vector if the rewarder contract is malicious, potentially affecting all users of a pool."",
      ""Location"": ""add() function, set() function""
    },
    {
      ""Issue"": ""Centralization Risk in Pool Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract owner has significant control over the system, including the ability to add pools, change allocation points, and modify rewarders at any time without restrictions or timelocks. This creates a high level of centralization where users must trust the owner not to act maliciously."",
      ""Impact"": ""The owner could manipulate reward distribution, favoring certain pools, or compromise the reward system through malicious rewarder contracts. A malicious or compromised owner could potentially manipulate the system to direct rewards unfairly."",
      ""Location"": ""add() function, set() function""
    },
    {
      ""Issue"": ""Missing Validation for Duplicate LP Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""The add() function does not validate whether an LP token has already been added to a pool. This could allow the same LP token to be added multiple times with different pool IDs."",
      ""Impact"": ""Users might deposit into the wrong pool for a given LP token, leading to unexpected reward distribution or loss of rewards. It could also be exploited to manipulate reward distribution."",
      ""Location"": ""add() function""
    },
    {
      ""Issue"": ""No Slippage Protection for Reward Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the safeRewardTransfer function, if the contract doesn't have enough CVX tokens to pay the full reward, it silently pays less without notifying the user or adjusting any accounting. There's no minimum received amount protection for these transfers."",
      ""Impact"": ""Users may receive fewer rewards than expected without any notification, which could lead to confusion and loss of trust in the protocol."",
      ""Location"": ""safeRewardTransfer() function""
    },
    {
      ""Issue"": ""Potential Block Gas Limit Issues in massUpdatePools"",
      ""Severity"": ""Medium"",
      ""Description"": ""The massUpdatePools function iterates through all pools and calls updatePool for each. As the number of pools grows, this could exceed the block gas limit, making certain functions inoperable. There's no limit on how many pools can be created by the owner."",
      ""Impact"": ""Functions that call massUpdatePools (like add and set) might become unusable if the number of pools grows too large, potentially blocking important administrative operations. This could lead to DoS conditions for contract administration."",
      ""Location"": ""massUpdatePools() function, add() function, set() function""
    },
    {
      ""Issue"": ""No Mechanism to Recover Accidentally Sent Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a function to recover tokens other than the LP tokens that might be accidentally sent to the contract."",
      ""Impact"": ""Any ERC20 tokens (besides the LP tokens being staked) sent to the contract will be permanently locked."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Potential for Arithmetic Overflow/Precision Loss in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses fixed-point arithmetic with a precision of 1e12 for tracking rewards. This approach may lead to precision loss in certain calculations, especially when handling very small or very large amounts. Despite using SafeMath, the multiplication and division operations in reward calculations could potentially overflow or lead to precision loss due to the order of operations."",
      ""Impact"": ""Users with small stake amounts might not receive accurate rewards due to rounding errors in calculations. Small amounts of rewards may be lost due to rounding errors, particularly for pools with large supply and small reward rates."",
      ""Location"": ""pendingCvx() function, updatePool() function""
    },
    {
      ""Issue"": ""No Input Validation in Various Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions lack proper input validation. The add() and set() functions allow the owner to add or modify pools without validating if the provided _lpToken is a legitimate contract. Functions that accept a pool ID (_pid) parameter do not validate that the ID is within the bounds of the poolInfo array. The deposit() function does not validate that _amount is greater than zero."",
      ""Impact"": ""The owner could accidentally add a malicious or non-compliant token, which could disrupt the entire reward system or lock user funds. Calling functions with an invalid pool ID would cause the transaction to revert due to array access errors."",
      ""Location"": ""add() function, set() function, deposit() function, various functions accepting _pid parameter""
    },
    {
      ""Issue"": ""Unused BONUS_MULTIPLIER Constant"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract declares a BONUS_MULTIPLIER constant with a value of 2, but this multiplier is never used in any calculation throughout the contract. This suggests a possible oversight in the reward calculation logic or an abandoned feature."",
      ""Impact"": ""While not directly a security vulnerability, this could indicate incomplete implementation or testing, and might confuse users or auditors about the actual reward mechanics."",
      ""Location"": ""BONUS_MULTIPLIER constant declaration""
    },
    {
      ""Issue"": ""Lack of Timestamp-Based Reward Distribution"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses block numbers instead of timestamps for reward distribution. This approach is less predictable as block production times can vary."",
      ""Impact"": ""Reward distribution might not align precisely with expected timeframes, leading to slightly unpredictable reward schedules."",
      ""Location"": ""getMultiplier() function, updatePool() function""
    },
    {
      ""Issue"": ""Potential Division by Zero"",
      ""Severity"": ""Low"",
      ""Description"": ""If totalAllocPoint is set to 0 (which can happen if all pools have 0 allocation points), division by zero could occur in reward calculations."",
      ""Impact"": ""Functions like pendingCvx and updatePool would revert, potentially locking user funds temporarily until allocation points are adjusted."",
      ""Location"": ""pendingCvx() function, updatePool() function""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 14
}",390.49330592155457,60707.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**

**Report Description**:  
In the ConvexMasterChef contract, the `add()` function allows adding a new staking pool with `_lpToken` as the staking token. However, there is no validation to check if `_lpToken` is the same as the reward token (cvx). This oversight could lead to incorrect reward calculations if `_lpToken` and cvx are the same.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward calculations when `_lpToken` is the same as the reward token (cvx). This is a specific vulnerability that is not covered in the response list.

---

#### **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Report Description**:  
The `safeRewardTransfer` function rounds down calculations, which can lead to users receiving fewer tokens than expected if the contract is undersupplied with cvx tokens. This is unsafe because the lack of tokens is not accounted for, potentially causing depositors to lose funds.

**Match in Response List**:  
Matches with the issue titled **""No Slippage Protection for Reward Transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with `safeRewardTransfer`, explaining that users may receive fewer rewards than expected without notification. This aligns with the report's description of the vulnerability.

---

#### **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Report Description**:  
The `deposit()` and `withdraw()` functions update reward token accounting after transferring rewards. If the reward token allows for transfer flow control (e.g., ERC777 hooks), an attacker could reenter these functions and drain all reward funds from the contract.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in Key Functions""**.

**Validation**:  
**Correct**. The response correctly identifies the reentrancy vulnerability in `deposit()` and `withdraw()`, explaining the risk of a malicious rewarder contract reentering and exploiting the updated state. This aligns with the report's description.

---

#### **[M-20] massUpdatePools() is susceptible to DoS with block gas limit**

**Report Description**:  
The `massUpdatePools()` function iterates through all pools and calls `updatePool()` for each. If the number of pools is large enough, this could exceed the block gas limit, causing a denial of service (DoS).

**Match in Response List**:  
Matches with the issue titled **""Potential Block Gas Limit Issues in massUpdatePools""**.

**Validation**:  
**Correct**. The response accurately describes the issue, explaining that `massUpdatePools()` could exceed the block gas limit as the number of pools grows, leading to DoS conditions. This matches the report's description.

---

#### **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

**Report Description**:  
The `add()` and `set()` functions do not call `massUpdatePools()` to update all pools. This could lead to outdated reward calculations and incorrect reward distributions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `add()` and `set()` failing to call `massUpdatePools()`. This is a specific vulnerability that is not covered in the response list.

---

#### **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Report Description**:  
The `add()` function does not check for duplicate `lpToken`, allowing multiple pools to have the same `lpToken`. This could lead to incorrect reward distribution and potential exploitation.

**Match in Response List**:  
Matches with the issue titled **""Missing Validation for Duplicate LP Tokens""**.

**Validation**:  
**Correct**. The response accurately identifies the issue, explaining that duplicate `lpToken` could lead to unexpected reward distribution or loss of rewards. This aligns with the report's description.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**
- **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**
- **[M-20] massUpdatePools() is susceptible to DoS with block gas limit**
- **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**
- **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

---

### **Conclusion**

The response list covers most of the issues in the report accurately, particularly those related to reentrancy, gas limits, and duplicate LP tokens. However, it misses two specific vulnerabilities: incorrect reward calculations when `_lpToken` is the same as the reward token (cvx) and the failure to call `massUpdatePools()` in `add()` and `set()`. These gaps should be addressed to ensure comprehensive coverage of the vulnerabilities in the ConvexMasterChef contract.","```
1. No Slippage Protection for Reward Transfers
2. Reentrancy Vulnerability in Key Functions
3. Potential Block Gas Limit Issues in massUpdatePools
4. Missing Validation for Duplicate LP Tokens
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""No Slippage Protection for Reward Transfers"" appears at rank 7.
   - ""Reentrancy Vulnerability in Key Functions"" appears at rank 1.
   - ""Potential Block Gas Limit Issues in massUpdatePools"" appears at rank 9.
   - ""Missing Validation for Duplicate LP Tokens"" appears at rank 6.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 6: \( P@6 = \frac{2}{6} \approx 0.333 \)
   - At rank 7: \( P@7 = \frac{3}{7} \approx 0.429 \)
   - At rank 9: \( P@9 = \frac{4}{9} \approx 0.444 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.333 + 0.429 + 0.444}{4} \approx \frac{2.206}{4} \approx 0.552
   \]

**Output**:
```
0.552
```"
