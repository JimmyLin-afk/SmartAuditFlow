nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTXStakingZap.sol,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,428,"[H-01] ERC20 transferFrom return values not checked
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
",1,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,1,0,"Based on the comprehensive initial analysis, here's a detailed audit task list for the NFTXStakingZap contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly verify the reentrancy protection in nonReentrant modifier across all payable and external functions"",
        ""Check for potential integer overflow/underflow risks in mathematical operations, especially in liquidity calculations"",
        ""Validate input validation and sanitization in all public and external functions"",
        ""Analyze transfer and approval mechanisms for potential external call vulnerabilities"",
        ""Review error handling and revert conditions for comprehensive security coverage""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyOwner modifier implementation for potential centralization risks"",
        ""Verify the ownership transfer and renouncement mechanisms"",
        ""Assess the potential impact of owner-controlled parameters like lpLockTime and inventoryLockTime"",
        ""Review the rescue function for potential misuse or unauthorized token extraction""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate interaction safety with NFTX Vault Factory, LP Staking, and Inventory Staking contracts"",
        ""Verify the correctness of SushiSwap router interactions and liquidity provision logic"",
        ""Check the special transfer mechanisms for CryptoKitties and CryptoPunks for potential edge cases"",
        ""Analyze the pairFor and sortTokens functions for potential manipulation"",
        ""Verify approval and transfer mechanisms for ERC721 and ERC1155 tokens""
      ]
    },
    {
      ""Area"": ""Staking Mechanisms"",
      ""Tasks"": [
        ""Review timelock implementation for LP and inventory staking"",
        ""Verify the correctness of token minting and staking calculations"",
        ""Check for potential issues with different lock time configurations"",
        ""Validate the event emission for staking operations"",
        ""Assess the handling of different NFT types (ERC721 and ERC1155)""
      ]
    },
    {
      ""Area"": ""Liquidity Provision"",
      ""Tasks"": [
        ""Verify slippage protection mechanisms in liquidity addition functions"",
        ""Check the accuracy of liquidity calculation and token balance verification"",
        ""Analyze the handling of excess ETH/WETH in liquidity functions"",
        ""Review the token transfer and approval logic during liquidity provision"",
        ""Validate the deterministic pair address calculation""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Verify compatibility with different ERC721 and ERC1155 token implementations"",
        ""Check for potential issues with non-standard token transfers"",
        ""Validate the special handling of CryptoKitties and CryptoPunks tokens"",
        ""Review approval and transfer mechanisms for various token types""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze function complexity and potential gas optimization opportunities"",
        ""Review loop structures and external call patterns for gas efficiency"",
        ""Check the use of immutable and constant variables"",
        ""Verify the efficiency of token transfer and approval mechanisms""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test behavior with zero-value inputs and edge case scenarios"",
        ""Verify error message clarity and specificity"",
        ""Check handling of unexpected token behaviors"",
        ""Assess the contract's resilience to potential manipulation attempts"",
        ""Review fallback and receive function implementations""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the NFTXStakingZap contract, addressing the key areas of concern identified in the initial analysis. The tasks are designed to be specific, actionable, and focused on potential security, functionality, and optimization risks.

Key priorities include:
1. Comprehensive security vulnerability assessment
2. Thorough review of external interactions
3. Validation of staking and liquidity provision mechanisms
4. Checking access control and ownership risks
5. Verifying token handling across different standards

Each task is crafted to guide the auditor in performing a meticulous and systematic review of the contract's implementation.","{
  ""ReviewingTheCode"": ""The NFTXStakingZap contract serves as a liquidity provisioning mechanism for NFT assets via the NFTX protocol. It allows users to deposit ERC721 or ERC1155 tokens to either provide inventory (single-sided staking) or add liquidity (paired with ETH/WETH) to SushiSwap pools. The contract then stakes the resulting LP tokens for the user with time-locking functionality."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXStakingZap"",
    ""Purpose"": ""Facilitates staking NFTs in the NFTX ecosystem through inventory staking and liquidity provision with time-locks"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""INFTXVault"", ""INFTXVaultFactory"", ""INFTXSimpleFeeDistributor"", ""INFTXLPStaking"", 
        ""INFTXInventoryStaking"", ""ITimelockRewardDistributionToken"", ""IUniswapV2Router01"", 
        ""IERC721"", ""IERC1155Upgradeable"", ""IERC20Upgradeable"", ""ERC721HolderUpgradeable"", 
        ""ERC1155HolderUpgradeable"", ""OwnableUpgradeable"", ""IWETH""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Interface to the Wrapped ETH contract""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Interface to the NFTX LP staking contract""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""INFTXInventoryStaking"",
        ""Purpose"": ""Interface to the NFTX inventory staking contract""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Interface to create and manage NFTX vaults""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Interface to SushiSwap router for liquidity operations""
      },
      {
        ""Name"": ""lpLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for locking LP tokens (48 hours default)""
      },
      {
        ""Name"": ""inventoryLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for locking inventory tokens (7 days default)""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Base unit for calculations (10^18)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with factory and router addresses"",
        ""Parameters"": [""_nftxFactory"", ""_sushiRouter""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLPLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets a new lock time for LP tokens (owner only)"",
        ""Parameters"": [""newLPLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""setInventoryLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets a new lock time for inventory (owner only)"",
        ""Parameters"": [""newInventoryLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Stakes ERC721 tokens into inventory staking with timelock"",
        ""Parameters"": [""vaultId"", ""tokenIds""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Stakes ERC1155 tokens into inventory staking with timelock"",
        ""Parameters"": [""vaultId"", ""tokenIds"", ""amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLiquidity721ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds ERC721 and ETH liquidity to a vault pool"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity721ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds ERC721 and ETH liquidity to a vault pool for a specified recipient"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""to""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds ERC1155 and ETH liquidity to a vault pool"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minEthIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds ERC1155 and ETH liquidity to a vault pool for a specified recipient"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minEthIn"", ""to""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds ERC721 and WETH liquidity to a vault pool"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity721To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds ERC721 and WETH liquidity to a vault pool for a specified recipient"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds ERC1155 and WETH liquidity to a vault pool"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds ERC1155 and WETH liquidity to a vault pool for a specified recipient"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""_addLiquidity721WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to process adding ERC721 and WETH liquidity"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""uint256 amountToken"", ""uint256 amountEth"", ""uint256 liquidity""]
      },
      {
        ""Name"": ""_addLiquidity1155WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to process adding ERC1155 and WETH liquidity"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""uint256 amountToken"", ""uint256 amountEth"", ""uint256 liquidity""]
      },
      {
        ""Name"": ""_addLiquidityAndLock"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core function to add liquidity and lock the resulting LP tokens"",
        ""Parameters"": [""vaultId"", ""vault"", ""minTokenIn"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""uint256 amountToken"", ""uint256 amountEth"", ""uint256 liquidity""]
      },
      {
        ""Name"": ""transferFromERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles transfer of ERC721 tokens with special cases for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr"", ""tokenId"", ""to""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles approval of ERC721 tokens with special cases for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr"", ""to"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""pairFor"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Deterministically calculates the SushiSwap pair address for two tokens"",
        ""Parameters"": [""tokenA"", ""tokenB""],
        ""Returns"": [""address pair""]
      },
      {
        ""Name"": ""sortTokens"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Sorts two token addresses for consistent pair address calculation"",
        ""Parameters"": [""tokenA"", ""tokenB""],
        ""Returns"": [""address token0"", ""address token1""]
      },
      {
        ""Name"": ""rescue"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to rescue ERC20 tokens sent to the contract"",
        ""Parameters"": [""token""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""NFTX Vault Factory - For managing vaults and creating new ones"",
    ""NFTX LP Staking - For staking LP tokens with time-locks"",
    ""NFTX Inventory Staking - For single-sided staking of NFTs"",
    ""SushiSwap Router - For liquidity provision operations"",
    ""WETH - For wrapping and unwrapping ETH"",
    ""ERC721/ERC1155 - For handling NFT transfers with special cases for CryptoKitties and CryptoPunks""
  ],
  ""SpecialMechanisms"": [
    ""Time-locked staking - Users' LP tokens and inventory stakes are locked for configurable periods"",
    ""NFT handling with protocol-specific logic for CryptoKitties and CryptoPunks"",
    ""Deterministic pair address calculation without requiring external calls"",
    ""ReentrancyGuard protection for all liquidity functions"",
    ""Handling of both ERC721 and ERC1155 tokens with the same interface pattern""
  ],
  ""Questions"": [
    ""Is there a mechanism to handle slippage protection beyond the minimum input values?"",
    ""What happens if the SushiSwap pair doesn't exist yet? Does the contract create it?"",
    ""Is there a way for users to withdraw their staked assets before the timelock expires?"",
    ""How does the contract handle ERC721 or ERC1155 tokens that don't follow the standard exactly?"",
    ""The contract has a 'rescue' function - are there other emergency or recovery mechanisms?"",
    ""Are there any potential centralization risks from the owner being able to set lock times?""
  ]
}","I've analyzed the input data containing different security reviews of the NFTXStakingZap contract. After consolidating similar issues and removing duplicates, here's the summary of findings:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy risk in ETH refunding"",
      ""Severity"": ""High"",
      ""Description"": ""When refunding excess ETH using low-level call in functions like addLiquidity721ETHTo and addLiquidity1155ETHTo, there's a potential reentrancy risk. Though the contract uses the nonReentrant modifier, the refund happens after critical state changes, allowing recipients to potentially execute malicious code during the callback."",
      ""Impact"": ""Potential reentrancy attacks could drain funds or manipulate state variables, especially through untrusted external NFT contracts."",
      ""Location"": ""addLiquidity721ETHTo() and addLiquidity1155ETHTo() functions where payable(to).call{value: msg.value-amountEth} is used""
    },
    {
      ""Issue"": ""Lack of Access Control in Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The provideInventory721, provideInventory1155, and other liquidity-adding functions do not have appropriate access controls or consistent reentrancy protection. Anyone can call these functions and operate on behalf of users without restrictions."",
      ""Impact"": ""Malicious actors could manipulate these functions to drain users' assets or perform unauthorized operations that affect users' tokens."",
      ""Location"": ""provideInventory721(), provideInventory1155(), addLiquidity721ETH(), addLiquidity1155ETH() functions""
    },
    {
      ""Issue"": ""Rescue Function Allows Owner to Drain All Tokens"",
      ""Severity"": ""High"",
      ""Description"": ""The rescue() function allows the contract owner to withdraw any ERC20 token from the contract, including user tokens that might be temporarily held during operations. There is insufficient validation to prevent withdrawal of tokens needed for ongoing operations."",
      ""Impact"": ""Malicious or compromised owners could steal user funds that are temporarily in the contract during multi-step operations."",
      ""Location"": ""rescue() function""
    },
    {
      ""Issue"": ""Unchecked ETH transfer return values"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses .call{value: x}() to transfer ETH back to users but doesn't check the return value. If the ETH transfer fails, the transaction will still succeed, potentially causing loss of user funds."",
      ""Impact"": ""Failed transfers might not revert the transaction, potentially causing users to believe operations succeeded when they didn't. Users may lose funds without receiving their ETH refunds."",
      ""Location"": ""addLiquidity721ETHTo() and addLiquidity1155ETHTo() functions with payable(to).call{value: msg.value-amountEth}""
    },
    {
      ""Issue"": ""Permanent approvals to external contracts"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives unlimited approval (type(uint256).max) to the SushiSwap router in the constructor, which remains permanently approved. If the router is compromised or has vulnerabilities, all WETH held by this contract could be at risk."",
      ""Impact"": ""If the SushiSwap router is compromised, all WETH held by this contract could be drained."",
      ""Location"": ""constructor() with IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max)""
    },
    {
      ""Issue"": ""Lack of slippage control in liquidity provision"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't implement proper slippage protection, especially in provideInventory functions. While minWethIn parameters are passed to some functions, there's no strong validation that these values make sense."",
      ""Impact"": ""Users could suffer significant financial loss due to sandwich attacks or high slippage in volatile market conditions, potentially receiving fewer tokens than expected."",
      ""Location"": ""_addLiquidityAndLock(), provideInventory721(), provideInventory1155(), and functions that call them""
    },
    {
      ""Issue"": ""Lack of input validation for token IDs and amounts"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions accept arrays of token IDs and amounts without validating that they're not empty, that the lengths match (for 1155 functions), or that the token IDs actually exist and belong to the sender."",
      ""Impact"": ""This could lead to failed transactions, gas waste, unexpected behavior, or loss of funds if invalid token IDs are provided."",
      ""Location"": ""provideInventory721(), provideInventory1155(), addLiquidity721ETH(), addLiquidity1155ETH() and related functions""
    },
    {
      ""Issue"": ""Unbounded loops in token operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions iterate through arrays of token IDs without any upper bound, which could lead to out-of-gas errors if too many tokens are processed in a single transaction."",
      ""Impact"": ""Transactions could fail if the gas limit is exceeded, resulting in denial of service for legitimate users with large token collections."",
      ""Location"": ""provideInventory721(), provideInventory1155(), _addLiquidity721WETH(), _addLiquidity1155WETH() functions""
    },
    {
      ""Issue"": ""Lack of emergency withdrawal function"",
      ""Severity"": ""Medium"",
      ""Description"": ""There is no mechanism for users to withdraw their assets in case of an emergency or critical bug discovered in the contract. The contract also lacks a pause mechanism to halt operations if vulnerabilities are found."",
      ""Impact"": ""If a vulnerability is found, users' funds could be locked or at risk without a way to quickly recover them."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Hardcoded special case handling for certain NFTs"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract includes special case handling for CryptoKitties and CryptoPunks with hard-coded addresses. If these addresses are incorrect for the deployment network or if the interfaces change, it could cause failures."",
      ""Impact"": ""Limited flexibility and potential failure when interacting with these special collections if their interfaces change. Transfers of these special NFTs could fail or behave unexpectedly."",
      ""Location"": ""transferFromERC721() and approveERC721() functions with hardcoded addresses""
    },
    {
      ""Issue"": ""Hardcoded SushiSwap pair initialization code"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses a hardcoded SushiSwap initialization code hash for pair address calculation. If deployed on a network with different parameters or if SushiSwap updates their factory, this will fail."",
      ""Impact"": ""LP token addresses could be incorrectly calculated, causing transactions to fail."",
      ""Location"": ""pairFor function with hardcoded hash value""
    },
    {
      ""Issue"": ""Unchecked deadline in router calls"",
      ""Severity"": ""Low"",
      ""Description"": ""When calling the SushiSwap router, the deadline is set to block.timestamp, which means the transaction must be included in the current block. This provides no protection against pending transactions being executed in future blocks at disadvantageous prices."",
      ""Impact"": ""Transactions could be held in the mempool and executed later when market conditions have changed, potentially resulting in worse execution prices for users."",
      ""Location"": ""_addLiquidityAndLock() function with block.timestamp parameter""
    },
    {
      ""Issue"": ""Centralized control over lock times"",
      ""Severity"": ""Low"",
      ""Description"": ""The owner can change LP and inventory lock times, which affects all users. While there are maximum caps (7 days and 14 days respectively), the owner could set these to much lower values after users have staked."",
      ""Impact"": ""Users who expected longer lock periods might be affected if lock times are reduced, potentially impacting expected rewards."",
      ""Location"": ""setLPLockTime() and setInventoryLockTime() functions""
    },
    {
      ""Issue"": ""Lack of event emissions for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several important functions like provideInventory721(), provideInventory1155(), setLPLockTime(), and setInventoryLockTime() don't emit events, making it harder to track what's happening off-chain."",
      ""Impact"": ""Reduced transparency and difficulty in building monitoring tools or user interfaces that track operations."",
      ""Location"": ""provideInventory721(), provideInventory1155(), setLPLockTime(), setInventoryLockTime() functions""
    },
    {
      ""Issue"": ""Single-step ownership transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a single-step ownership transfer pattern from the OpenZeppelin Ownable contract, which could lead to locked contracts if ownership is transferred to an invalid address."",
      ""Impact"": ""If ownership is accidentally transferred to an incorrect address, all owner-only functions become permanently inaccessible."",
      ""Location"": ""Inherited from Ownable contract""
    },
    {
      ""Issue"": ""Deprecated Uniswap Router Interface"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract imports and uses IUniswapV2Router01 which is an older version of the router interface that has been superseded by IUniswapV2Router02 with additional functionality."",
      ""Impact"": ""The contract may not have access to newer router features or optimizations, potentially reducing efficiency or compatibility with newer protocols."",
      ""Location"": ""Import statement for IUniswapV2Router01 and usage throughout the contract""
    }
  ],
  ""IssueNumber"": 89,
  ""OutputList"": 16
}",397.1113200187683,87575.0,32.0,"### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:
The `transferFrom()` function in the contract returns a boolean value indicating success. This parameter needs to be checked to ensure the transfer has been successful. While the `transfer()` function calls were checked, the `transferFrom()` function calls were not, which could lead to silent failures in token transfers, especially when dealing with untrusted tokens supplied by users. This oversight may result in discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked `transferFrom()` return values. While there is a related issue titled ""Unchecked ETH transfer return values,"" it specifically pertains to ETH transfers and not ERC20 `transferFrom()` calls. The core issue of unchecked `transferFrom()` return values is entirely missed, which is a critical security concern in Solidity smart contracts.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] ERC20 transferFrom return values not checked**

---

The response list fails to address the specific issue of unchecked `transferFrom()` return values, which is a significant security vulnerability in Solidity smart contracts. This gap highlights the need for a more comprehensive review of ERC20 token handling in the contract.","```
None.
```",0.0
Splitter.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162,293,"[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract
In general, the Splitter contract's `incrementWindow` function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the `incrementWindow` function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or `claimForAllWindows ` functions to steal the tokens in the contract.
  [H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker
When the value of currentWindow is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.
currentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.
Furthermore, an attacker can continually increment currentWindow by calling `incrementWindow()`. An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.
  [M-02] Fixed Amount of Gas Sent in Call May Be Insufficient
The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the receive() function. As a result the user would be unable to receive funds from this function.
",3,,"pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract Splitter is SplitStorage {
    
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    
    event TransferETH(
        
        address account,
        
        uint256 amount,
        
        bool success
    );

    
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    

    
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        
        return (amount * percent) / 100;
    }

    
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        
        
        
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    
    
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        
        return computedHash == root;
    }
}",1136,2,1,"Based on the comprehensive analysis of the Splitter contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify Merkle proof implementation for potential bypass vulnerabilities"",
        ""Assess potential integer overflow/underflow risks in percentage calculations"",
        ""Analyze the claim mechanism for potential double-spending vulnerabilities"",
        ""Check for potential reentrancy risks in token transfer operations"",
        ""Validate access control mechanisms in incrementWindow function""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review IRoyaltyVault interface interaction and validate authorization checks"",
        ""Verify IERC20 token transfer implementation and error handling"",
        ""Confirm interface ID (IID_IROYALTY) verification is robust"",
        ""Assess potential risks in cross-contract calls to RoyaltyVault""
      ]
    },
    {
      ""Area"": ""Mathematical Precision & Calculations"",
      ""Tasks"": [
        ""Investigate potential precision loss in scaleAmountByPercentage function"",
        ""Verify scaling mechanism between PERCENTAGE_SCALE and actual percentage calculations"",
        ""Check for rounding errors in percentage-based token distribution"",
        ""Compare and standardize percentage calculation methods"",
        ""Validate handling of edge cases in percentage scaling""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in claimForAllWindows function with potential unbounded loop"",
        ""Review efficiency of Merkle proof verification algorithm"",
        ""Assess memory usage and potential optimizations in function implementations"",
        ""Evaluate gas costs for window incrementation and claim processes""
      ]
    },
    {
      ""Area"": ""Access Control and Permissions"",
      ""Tasks"": [
        ""Verify the authorization mechanism for incrementWindow function"",
        ""Review inheritance from SplitStorage for potential permission bypass risks"",
        ""Confirm merkleRoot update mechanism and access controls"",
        ""Assess potential centralization risks in contract design""
      ]
    },
    {
      ""Area"": ""Data Integrity and State Management"",
      ""Tasks"": [
        ""Validate claim tracking mechanism to prevent double-claiming"",
        ""Review state variable management across different windows"",
        ""Check handling of edge cases in window incrementation"",
        ""Verify consistency of claimed status tracking""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test behavior with zero or extremely small royalty amounts"",
        ""Verify error handling for invalid Merkle proofs"",
        ""Check handling of claims for non-existent or future windows"",
        ""Assess contract behavior with unexpected token transfer amounts""
      ]
    },
    {
      ""Area"": ""Unused and Potential Legacy Code"",
      ""Tasks"": [
        ""Investigate purpose and potential removal of attemptETHTransfer function"",
        ""Review any commented or unused code sections"",
        ""Verify no hidden vulnerabilities in legacy code remnants"",
        ""Recommend code cleanup and simplification where appropriate""
      ]
    }
  ]
}

Key Audit Priorities:
1. The Merkle proof verification mechanism
2. Token transfer security
3. Percentage calculation precision
4. Window incrementation and claim logic
5. Access control mechanisms

Recommendations for Further Investigation:
- Obtain the implementation of SplitStorage contract
- Clarify the exact purpose of the unused ETH transfer function
- Validate the initialization and management of splitAsset
- Confirm the complete tokenomics and allocation strategy

This task list provides a comprehensive approach to auditing the Splitter contract, addressing potential security, efficiency, and design concerns while maintaining a structured and methodical review process.","I'll perform a thorough audit of the Splitter smart contract following the requested steps.

{
  ""ReviewingTheCode"": ""The Splitter contract implements a mechanism for distributing tokens (primarily ERC20) among multiple recipients based on their percentage allocations. It uses a Merkle tree for verification of claims and a window-based system to manage distribution periods. The contract interacts with a RoyaltyVault to receive royalty payments and allows recipients to claim their share of these royalties."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Splitter"",
    ""Purpose"": ""Manages and distributes royalty payments to authorized recipients according to predefined percentage allocations verified through Merkle proofs"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""SplitStorage""],
      ""Imports"": [
        ""SplitStorage.sol"",
        ""IRoyaltyVault from @chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"",
        ""IERC20 from @openzeppelin/contracts/token/ERC20/IERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""PERCENTAGE_SCALE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Scale factor for percentage calculations (10e5)""
      },
      {
        ""Name"": ""IID_IROYALTY"",
        ""Type"": ""bytes4 constant"",
        ""Purpose"": ""Interface ID for IRoyaltyVault used for verification""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""claimForAllWindows"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim their share across all eligible distribution windows at once"",
        ""Parameters"": [""percentageAllocation (uint256)"", ""merkleProof (bytes32[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""getNode"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Generates a Merkle leaf node from an address and percentage allocation"",
        ""Parameters"": [""who (address)"", ""percentageAllocation (uint256)""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""scaleAmountByPercentage"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Scales an amount by a given percentage"",
        ""Parameters"": [""amount (uint256)"", ""scaledPercent (uint256)""],
        ""Returns"": [""scaledAmount (uint256)""]
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim their share for a specific window"",
        ""Parameters"": [""window (uint256)"", ""scaledPercentageAllocation (uint256)"", ""merkleProof (bytes32[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""incrementWindow"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Advances to the next distribution window and records new royalty amount"",
        ""Parameters"": [""royaltyAmount (uint256)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""isClaimed"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a specific address has claimed for a given window"",
        ""Parameters"": [""who (address)"", ""window (uint256)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""setClaimed"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Marks a window as claimed for an address"",
        ""Parameters"": [""who (address)"", ""window (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getClaimHash"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Generates a unique hash for a claim based on address and window"",
        ""Parameters"": [""who (address)"", ""window (uint256)""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""amountFromPercent"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Calculates an amount based on a percentage"",
        ""Parameters"": [""amount (uint256)"", ""percent (uint32)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""transferSplitAsset"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Transfers ERC20 tokens to a recipient"",
        ""Parameters"": [""to (address)"", ""value (uint256)""],
        ""Returns"": [""didSucceed (bool)""]
      },
      {
        ""Name"": ""attemptETHTransfer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Attempts to transfer ETH with gas limit to prevent reentrancy"",
        ""Parameters"": [""to (address)"", ""value (uint256)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""verifyProof"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Verifies a Merkle proof against a root and leaf"",
        ""Parameters"": [""proof (bytes32[])"", ""root (bytes32)"", ""leaf (bytes32)""],
        ""Returns"": [""bool""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 token transfers via the splitAsset address"",
    ""IRoyaltyVault for verification and authorization in incrementWindow"",
    ""External ETH transfers in attemptETHTransfer (though appears unused)""
  ],
  
  ""SpecialMechanisms"": [
    ""Merkle tree verification for validating percentage allocations"",
    ""Window-based distribution system to track royalty payment periods"",
    ""Claim tracking to prevent double-claiming"",
    ""Permission control via IRoyaltyVault interface verification""
  ],
  
  ""Questions"": [
    ""What is contained in the SplitStorage contract that this contract inherits from? It seems crucial to understand its state variables like merkleRoot, claimed mapping, balanceForWindow, etc."",
    ""The PERCENTAGE_SCALE constant is defined as 10e5 but scaleAmountByPercentage divides by 10000 (not 10e5). Is this inconsistency intentional?"",
    ""The attemptETHTransfer function exists but is never called - is it a leftover from previous functionality?"",
    ""What is the security mechanism to update the merkleRoot if recipient allocations change?"",
    ""Is there a mechanism to handle unclaimed funds or expired windows?"",
    ""The splitAsset variable (inherited from SplitStorage) seems critical - how is it initialized and can it be updated?""
  ]
}

After reviewing this contract, I'd like to note some potential security concerns that weren't explicitly requested in the JSON format:

1. **Precision Loss**: The calculation in `scaleAmountByPercentage` might lead to precision loss in certain scenarios.

2. **Unbounded Loop**: The `claimForAllWindows` function contains a loop that iterates through all windows, which could potentially hit gas limits if there are many windows.

3. **No Reentrancy Guard**: While the external token transfer happens at the end of claim functions, it's generally good practice to add a reentrancy guard.

4. **Inconsistent Implementations**: `amountFromPercent` and `scaleAmountByPercentage` do similar things but operate differently.

5. **Unused Function**: The `attemptETHTransfer` function is defined but not used, which adds unnecessary complexity.","I've analyzed the Splitter contract issues from multiple sources. Here's my consolidated summary of the findings:

{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect percentage scaling in scaleAmountByPercentage function"",
      ""Severity"": ""High"",
      ""Description"": ""The scaleAmountByPercentage function divides by a hardcoded value of 10000, despite the contract defining PERCENTAGE_SCALE as 10e5 (1,000,000). This inconsistency creates a discrepancy between the expected percentage scaling and the actual implementation."",
      ""Impact"": ""Users will receive incorrect amounts when claiming their funds - potentially 10-100x more than intended. This will drain the contract funds faster than intended, creating an unfair distribution where early claimers receive more than their fair share."",
      ""Location"": ""scaleAmountByPercentage function""
    },
    {
      ""Issue"": ""No access control for critical functions"",
      ""Severity"": ""High"",
      ""Description"": ""The contract lacks proper access control mechanisms like Ownable or Role-based access control. While incrementWindow has some checks, other potentially sensitive operations aren't protected. There's no admin or owner role defined for contract management."",
      ""Impact"": ""Without proper access controls, unauthorized parties might be able to manipulate the contract state in unintended ways. Limited ability to handle emergency situations, update parameters, or pause the contract in case vulnerabilities are discovered."",
      ""Location"": ""Entire contract structure""
    },
    {
      ""Issue"": ""No method to update merkleRoot"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses a merkleRoot for verification but doesn't provide a way to update it. If the merkle root needs to be changed due to allocation changes or found to be incorrect, there's no mechanism to update it."",
      ""Impact"": ""Lack of flexibility in handling changes to the allocation structure, potentially requiring contract redeployment which impacts users and increases costs. If merkle root can be manipulated or if it's not properly initialized, unauthorized users could potentially claim funds they shouldn't have access to."",
      ""Location"": ""Entire contract - missing functionality""
    },
    {
      ""Issue"": ""Potential reentrancy vulnerability in transferSplitAsset"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the function uses the return value of the ERC20 transfer function and requires it to be successful, it emits an event after the transfer. This pattern could be vulnerable to reentrancy if the ERC20 token implementation is malicious or non-standard."",
      ""Impact"": ""A malicious ERC20 token could potentially reenter the contract during transfer operations, allowing an attacker to potentially claim the same window multiple times or manipulate contract state."",
      ""Location"": ""transferSplitAsset function""
    },
    {
      ""Issue"": ""Unused attemptETHTransfer function with gas limitations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The attemptETHTransfer function contains a low-level call that sends ETH with a hardcoded gas limit of 30000, but this function is never used. The contract appears designed to handle ERC20 tokens, not native ETH."",
      ""Impact"": ""If used in future updates, the low gas limit could cause transfers to fail with more complex receiving contracts. This unused function could confuse users or developers about the contract's functionality."",
      ""Location"": ""attemptETHTransfer function""
    },
    {
      ""Issue"": ""Potential DoS in claimForAllWindows loop"",
      ""Severity"": ""Medium"",
      ""Description"": ""The claimForAllWindows function iterates through all windows from 0 to currentWindow-1. As the number of windows increases over time, this function could hit the block gas limit, making claims impossible for users."",
      ""Impact"": ""As the contract operates for a long time and accumulates many windows, users might be unable to claim their funds due to the function consuming too much gas, effectively locking their funds."",
      ""Location"": ""claimForAllWindows function, specifically the for loop""
    },
    {
      ""Issue"": ""No validation for percentageAllocation"",
      ""Severity"": ""Medium"",
      ""Description"": ""There is no validation that the percentageAllocation is within a reasonable range (e.g., <= 100%). Without this check, users could potentially claim more than they're entitled to if the merkle proof allows it."",
      ""Impact"": ""If the merkle tree includes erroneous allocations (e.g., over 100%), users could claim more funds than they should be entitled to, potentially draining the contract."",
      ""Location"": ""claim and claimForAllWindows functions""
    },
    {
      ""Issue"": ""No mechanism to handle failed ERC20 transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the transferSplitAsset function does check if the transfer succeeded, it simply reverts the transaction. This means if a single transfer fails, the entire claim process fails."",
      ""Impact"": ""A malicious or defective ERC20 token could permanently prevent users from claiming their funds, locking assets in the contract."",
      ""Location"": ""transferSplitAsset function""
    },
    {
      ""Issue"": ""Missing check for zero address in transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The transferSplitAsset function doesn't verify that the destination address is not the zero address. Sending tokens to the zero address would result in those tokens being permanently lost."",
      ""Impact"": ""Potential permanent loss of funds if tokens are accidentally transferred to the zero address."",
      ""Location"": ""transferSplitAsset function""
    },
    {
      ""Issue"": ""No emergency pause or recovery mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks any emergency pause functionality or recovery mechanism. If a critical issue is discovered, there's no way to temporarily halt operations or recover funds."",
      ""Impact"": ""In case of a discovered vulnerability, all funds in the contract could be at risk with no way to protect them until a new contract is deployed."",
      ""Location"": ""Throughout the contract""
    },
    {
      ""Issue"": ""Potential integer overflow in calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""Although Solidity 0.8.x includes overflow protection, the contract performs multiplication before division in scaleAmountByPercentage, which could lead to precision loss in certain scenarios."",
      ""Impact"": ""Precision issues might lead to slightly incorrect token distribution amounts. Could cause transactions to revert unexpectedly when processing large amounts or percentages."",
      ""Location"": ""scaleAmountByPercentage function""
    },
    {
      ""Issue"": ""Unused functions and constants"",
      ""Severity"": ""Low"",
      ""Description"": ""The amountFromPercent function is defined but never used in the contract. Similarly, the PERCENTAGE_SCALE constant is defined but never referenced in the code. The amountFromPercent function also uses a different scaling method (dividing by 100) than scaleAmountByPercentage (dividing by 10000)."",
      ""Impact"": ""Increased deployment and execution gas costs without adding functionality. May also confuse developers maintaining the code, potentially leading to implementation errors in future modifications."",
      ""Location"": ""amountFromPercent function and PERCENTAGE_SCALE constant""
    },
    {
      ""Issue"": ""Inconsistent error messages and event names"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses error messages like 'Failed to transfer ETH' when it's actually transferring ERC20 tokens. Similarly, the event TransferETH is emitted when transferring ERC20 tokens, not ETH."",
      ""Impact"": ""Confusing error messages can make debugging difficult and may mislead users about what's actually happening. Can cause confusion and potential errors in off-chain systems monitoring contract events."",
      ""Location"": ""transferSplitAsset function and TransferETH event""
    },
    {
      ""Issue"": ""Inefficient storage usage in claim tracking"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a mapping of keccak256 hashes to track claimed windows, which is gas-intensive compared to alternative approaches like bit mapping for window tracking."",
      ""Impact"": ""Higher gas costs for users when claiming, especially as the number of windows increases."",
      ""Location"": ""isClaimed and setClaimed functions""
    },
    {
      ""Issue"": ""Missing events for claim operations"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract emits events for transfers and window increments, it doesn't emit events for claim operations. This makes it difficult to track when and how much users have claimed."",
      ""Impact"": ""Reduced transparency and difficulty in tracking claim activity off-chain."",
      ""Location"": ""claim and claimForAllWindows functions""
    }
  ],
  ""IssueNumber"": 72,
  ""OutputList"": 15
}",355.61449432373047,47621.0,32.0,"### **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Report Description**:
The `incrementWindow` function in the Splitter contract is intended to be called only when tokens are transferred to the contract, ensuring that the `balanceForWindow` matches the contract balance. However, anyone can use a fake `RoyaltyVault` contract to call `incrementWindow`, causing `balanceForWindow` to exceed the actual contract balance. This allows verified users to call `claim` or `claimForAllWindows` to steal tokens from the contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific vulnerability where unauthorized users can call `incrementWindow` to manipulate `balanceForWindow` and steal tokens. This is a critical access control issue that is not covered in the response list.

---

### **[H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker**

**Report Description**:
The `claimForAllWindows` function iterates through all windows from 0 to `currentWindow-1`. As `currentWindow` increases over time, the function may exceed the block gas limit, making it unusable. An attacker can exacerbate this issue by repeatedly calling `incrementWindow` with minimal WETH (1 WEI) to increase `currentWindow`, effectively locking users out of claiming their funds.

**Match in Response List**:
Matches with the issue titled **""Potential DoS in claimForAllWindows loop""**.

**Validation**:
**Correct**. The response accurately identifies the DoS risk in `claimForAllWindows` due to the increasing `currentWindow` value. It correctly explains the impact of the gas limit and the potential for attackers to manipulate `currentWindow`, aligning with the issue description.

---

### **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Report Description**:
The `attemptETHTransfer` function sends ETH with a fixed gas limit of 30,000. If the receiver is a contract, this may be insufficient to process the `receive()` function, resulting in failed transfers and users being unable to receive funds.

**Match in Response List**:
Matches with the issue titled **""Unused attemptETHTransfer function with gas limitations""**.

**Validation**:
**Partially Correct**. The response identifies the gas limitation issue in `attemptETHTransfer` but incorrectly states that the function is unused. The issue report highlights the risk of insufficient gas for contract receivers, which is partially addressed in the response. However, the response misses the critical detail that the function is actually used and poses a risk to users.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker**

**Partially Correct Matches**:
- **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Missed Issues from Issue Report**:
- **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

---

The response list covers some issues but misses critical vulnerabilities like unauthorized access to `incrementWindow`. Additionally, it partially addresses the gas limitation issue but incorrectly assumes the function is unused. Improvements are needed to ensure comprehensive coverage of all identified vulnerabilities.","```
1. Potential DoS in claimForAllWindows loop
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential DoS in claimForAllWindows loop"".
   - In the ranked list of predictions, this issue appears at rank 6.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 6, \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.1667 \).

**Output**:
```
0.1667
```"
CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331,310,"[H-04] CoreCollection can be reinitialized
Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.
Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.
However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.
  [H-07] Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it
The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the payableToken is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply check`. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.
  [H-08] Funds cannot be withdrawn in CoreCollection.withdraw
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the withdraw function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.
",3,,"pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    

    
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    

    
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    

    
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",1528,3,0,"Based on the comprehensive analysis of the CoreCollection smart contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the withdraw() function for potential unauthorized token transfers"",
        ""Review transferFrom implementation for potential reentrancy risks"",
        ""Verify protection against integer overflow/underflow in mint and batchMint functions"",
        ""Examine startingIndex generation for potential blockchain manipulation"",
        ""Check merkle proof verification logic for potential bypass vulnerabilities""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Validate onlyOwner modifier implementation across critical functions"",
        ""Review initialization process for potential unauthorized modifications"",
        ""Verify access control in setRoyaltyVault function"",
        ""Check role-based access in mint and claim mechanisms""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze interactions with IRoyaltyVault interface"",
        ""Review ERC20 payment mechanism in mintToken function"",
        ""Verify merkle tree claim verification process"",
        ""Check interactions with splitFactory contract""
      ]
    },
    {
      ""Area"": ""Token Minting & Supply"",
      ""Tasks"": [
        ""Verify maxSupply enforcement in mintToken function"",
        ""Review token ID generation mechanism for randomness and uniqueness"",
        ""Check claim and non-claim minting logic for consistency"",
        ""Validate batch minting process for potential edge cases""
      ]
    },
    {
      ""Area"": ""Royalty & Payment Mechanisms"",
      ""Tasks"": [
        ""Analyze _beforeTokenTransfer royalty distribution logic"",
        ""Verify mintFee calculation and payment handling"",
        ""Review royalty vault initialization and interaction process"",
        ""Check token payment and withdrawal mechanisms""
      ]
    },
    {
      ""Area"": ""Contract Initialization"",
      ""Tasks"": [
        ""Review initialize function for comprehensive parameter validation"",
        ""Verify initialization modifiers (onlyInitialized, onlyUnInitialized)"",
        ""Check one-time initialization protection mechanisms"",
        ""Validate initial state setting for collection metadata""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in batch minting process"",
        ""Review storage variable usage and optimization potential"",
        ""Check loop implementations for gas efficiency"",
        ""Evaluate function modifiers for gas overhead""
      ]
    },
    {
      ""Area"": ""Metadata & URI Management"",
      ""Tasks"": [
        ""Verify baseURI and _baseURI implementation"",
        ""Check metadata update mechanisms"",
        ""Review setCollectionMeta function for potential vulnerabilities"",
        ""Validate token metadata access controls""
      ]
    },
    {
      ""Area"": ""Compliance & Standards"",
      ""Tasks"": [
        ""Verify ERC721 standard compliance"",
        ""Check ERC721Enumerable extension implementation"",
        ""Review inheritance hierarchy for potential standard violations"",
        ""Validate override methods for proper implementation""
      ]
    },
    {
      ""Area"": ""Emergency & Fallback Mechanisms"",
      ""Tasks"": [
        ""Review withdrawal and token recovery options"",
        ""Check emergency stop or pause functionality"",
        ""Validate owner's ability to modify critical contract parameters"",
        ""Analyze contract's resilience to unexpected scenarios""
      ]
    }
  ]
}

**Audit Approach Rationale:**
1. Comprehensive coverage of potential vulnerabilities
2. Deep dive into complex mechanisms like minting and claiming
3. Thorough examination of external interactions
4. Validation of access control and initialization processes
5. Performance and gas efficiency assessment
6. Compliance with blockchain standards and best practices

**Key Focus Areas:**
- Smart contract security
- Claiming mechanism integrity
- Payment and royalty distribution
- Token minting process
- Access control robustness

The task list provides a structured, methodical approach to auditing the CoreCollection smart contract, addressing technical, security, and performance considerations.

Would you like me to elaborate on any specific area or provide more detailed insights into the audit approach?","I've conducted a thorough analysis of the CoreCollection smart contract code. Here are my findings:

{
  ""ReviewingTheCode"": ""The CoreCollection contract appears to be an NFT collection implementation that extends ERC721 with additional functionality including claiming, payment mechanisms, and royalty features. It follows a pattern where the contract is initialized after deployment and allows minting tokens with either payment or claiming based on a merkle proof system."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""CoreCollection"",
    ""Purpose"": ""An extensible NFT collection contract with features for claiming, payments, and royalty distribution"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable"",
        ""ERC721Claimable"",
        ""ERC721Enumerable"",
        ""ERC721Payable""
      ],
      ""Imports"": [
        ""Ownable from @openzeppelin/contracts/access/Ownable.sol"",
        ""ERC721 from @openzeppelin/contracts/token/ERC721/ERC721.sol"",
        ""ERC721Enumerable from @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"",
        ""IERC20 from @openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""IERC721 from @openzeppelin/contracts/token/ERC721/IERC721.sol"",
        ""ERC721Payable (custom contract)"",
        ""ERC721Claimable (custom contract)"",
        ""IRoyaltyVault from @chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""initialized"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to track if the contract has been initialized""
      },
      {
        ""Name"": ""_name"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the NFT collection""
      },
      {
        ""Name"": ""_symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Symbol of the NFT collection""
      },
      {
        ""Name"": ""_baseUri"",
        ""Type"": ""string"",
        ""Purpose"": ""Base URI for token metadata""
      },
      {
        ""Name"": ""maxSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum number of tokens that can be minted""
      },
      {
        ""Name"": ""startingIndex"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Random starting index for token ID assignment""
      },
      {
        ""Name"": ""startingIndexBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Block number when starting index was set""
      },
      {
        ""Name"": ""HASHED_PROOF"",
        ""Type"": ""string"",
        ""Purpose"": ""Stores a hashed proof, likely for verification purposes""
      },
      {
        ""Name"": ""mintFee"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fee required to mint a token (referenced but not declared in the snippet)""
      },
      {
        ""Name"": ""payableToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""Token used for payment (referenced but not declared in the snippet)""
      },
      {
        ""Name"": ""isForSale"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if tokens are available for purchase (referenced but not declared in the snippet)""
      },
      {
        ""Name"": ""splitFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of a factory contract for royalty splitting (referenced but not declared in the snippet)""
      },
      {
        ""Name"": ""royaltyVault"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the royalty vault contract (referenced but not declared in the snippet)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyInitialized"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures function can only be called after initialization""
      },
      {
        ""Name"": ""onlyUnInitialized"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures function can only be called before initialization""
      },
      {
        ""Name"": ""onlyValidSupply"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates that the max supply is greater than zero""
      },
      {
        ""Name"": ""tokenExists"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Verifies that a token with the given ID exists""
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets initial collection parameters"",
        ""Parameters"": [""_collectionName"", ""_collectionSymbol"", ""_collectionURI"", ""_maxSupply"", ""_mintFee"", ""_payableToken"", ""_isForSale"", ""_splitFactory""],
        ""Returns"": []
      },
      {
        ""Name"": ""initializeClaims"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the merkle root for claim verification"",
        ""Parameters"": [""_root""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCollectionMeta"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the collection's name and symbol"",
        ""Parameters"": [""_collectionName"", ""_collectionSymbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Mints tokens either through claiming or purchase"",
        ""Parameters"": [""to"", ""isClaim"", ""claimableAmount"", ""amount"", ""merkleProof""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws accumulated tokens to the owner"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setRoyaltyVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the royalty vault address"",
        ""Parameters"": [""_royaltyVault""],
        ""Returns"": []
      },
      {
        ""Name"": ""setHashedProof"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the hashed proof string (only once)"",
        ""Parameters"": [""_proof""],
        ""Returns"": []
      },
      {
        ""Name"": ""setStartingIndex"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets a random starting index for token ID assignment"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""name"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the collection name, overriding ERC721"",
        ""Parameters"": [],
        ""Returns"": [""string""]
      },
      {
        ""Name"": ""symbol"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the collection symbol, overriding ERC721"",
        ""Parameters"": [],
        ""Returns"": [""string""]
      },
      {
        ""Name"": ""baseURI"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the base URI for token metadata"",
        ""Parameters"": [],
        ""Returns"": [""string""]
      },
      {
        ""Name"": ""_baseURI"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the base URI for token metadata, overriding ERC721"",
        ""Parameters"": [],
        ""Returns"": [""string""]
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Mints a single token with a calculated ID"",
        ""Parameters"": [""_to""],
        ""Returns"": [""tokenId""]
      },
      {
        ""Name"": ""batchMint"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Mints multiple tokens"",
        ""Parameters"": [""_to"", ""_amount"", ""_isClaim""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeTokenTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sends royalties to splitter before token transfer"",
        ""Parameters"": [""_from"", ""_to"", ""_tokenId""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 token contract for payment handling"",
    ""IRoyaltyVault for royalty distribution"",
    ""Merkle tree verification for token claiming"",
    ""ERC721Claimable for claiming functionality"",
    ""ERC721Payable for payment functionality""
  ],
  
  ""SpecialMechanisms"": [
    ""Delayed initialization pattern where contract is deployed first then initialized"",
    ""Merkle tree verification for claiming tokens"",
    ""Pseudorandom token ID generation using block hash and a starting index"",
    ""Royalty distribution system that triggers on token transfers"",
    ""ERC20 token payment support for minting""
  ],
  
  ""Questions"": [
    ""Where are the ERC721Payable and ERC721Claimable implementations defined? These appear to be crucial for understanding the contract's behavior."",
    ""What is the purpose of the HASHED_PROOF variable? It appears to be a one-time settable value but its use is not clear from the code."",
    ""Several modifiers like 'onlyVaultUninitialized', 'onlyNotClaimableSet', and 'onlyValidRoot' are used but not defined in the snippet."",
    ""How does the '_handlePayment' function work? It's called during non-claim minting but not defined in the snippet."",
    ""What does the royalty distribution mechanism look like, especially how 'sendToSplitter' works?"",
    ""There's a potential issue in the withdraw function which uses transferFrom instead of transfer - this requires prior approval."",
    ""How is the ERC721 token enumeration functionality utilized in the contract?""
  ]
}

Based on my analysis, this is a sophisticated NFT collection contract with several notable features:

1. It implements a claim system that likely uses a merkle tree for verification.
2. It has a payment system for minting tokens using an ERC20 token.
3. It includes royalty distribution through a vault system that activates on token transfers.
4. It employs a pseudo-random token ID generation system with a starting index derived from block data.
5. It follows a delayed initialization pattern where the contract is configured after deployment.

There are several areas where the contract could be improved:
- The withdraw function appears to use transferFrom incorrectly (should be transfer)
- Several important components are referenced but not defined in the snippet
- The random number generation for startingIndex is susceptible to miner manipulation

Further review would require the implementation of ERC721Payable and ERC721Claimable to fully understand the contract's behavior and security.","I'll analyze the security findings, combine similar issues, and present them in a consolidated, sorted format.

{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect Token Transfer in withdraw Function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The withdraw function uses transferFrom instead of transfer to move tokens from the contract to the owner. The transferFrom method requires prior approval, which is not set up in this function. This fundamentally incorrect implementation will cause all withdrawal attempts to fail."",
      ""Impact"": ""The owner will be unable to withdraw any funds from the contract, effectively locking all collected fees in the contract permanently with no way to recover them."",
      ""Location"": ""withdraw function""
    },
    {
      ""Issue"": ""Missing Access Control in setRoyaltyVault Function"",
      ""Severity"": ""High"",
      ""Description"": ""The setRoyaltyVault function uses a modifier onlyVaultUninitialized but lacks proper validation for the royaltyVault variable. The function allows either the contract owner or splitFactory address to set the royalty vault, but it doesn't validate whether the provided address is a legitimate royalty vault implementation. Additionally, the splitFactory address is set during initialization without proper validation."",
      ""Impact"": ""Malicious actors could potentially set an arbitrary address as the royalty vault, redirecting funds to their own contract instead of the intended royalty recipients. A compromised splitFactory could set a malicious royalty vault that misappropriates funds."",
      ""Location"": ""setRoyaltyVault function and initialize function""
    },
    {
      ""Issue"": ""Missing Authorization and Validation in mintToken"",
      ""Severity"": ""High"",
      ""Description"": ""The mintToken function allows anyone to call the function and mint tokens without proper access control. While it checks if isForSale is true for regular minting, there's no restriction on who can call the function. Additionally, there's no validation for critical parameters such as recipient addresses."",
      ""Impact"": ""Unauthorized users can mint tokens as long as they meet the minimum conditions, potentially depleting the available supply or causing economic damage to the project. Tokens could be minted to the zero address, effectively burning them."",
      ""Location"": ""mintToken function""
    },
    {
      ""Issue"": ""Missing Input Validation in initialize Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function doesn't verify if all required components are properly set. There's no validation of addresses such as _payableToken or _splitFactory, and no verification that these addresses correspond to valid contracts implementing the required interfaces."",
      ""Impact"": ""The contract could be initialized with invalid or zero addresses for critical components, leading to contract malfunction or fund loss when these components are later used."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Potential Reentrancy in _beforeTokenTransfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _beforeTokenTransfer function makes an external call to the royalty vault contract without proper reentrancy protection. If the royalty vault contract malfunctions or is malicious, it could reenter the original contract during execution."",
      ""Impact"": ""A malicious royalty vault could reenter the contract during token transfers, potentially manipulating token ownership, causing duplicate minting, or other unexpected state changes that could disrupt the contract's functionality."",
      ""Location"": ""_beforeTokenTransfer function""
    },
    {
      ""Issue"": ""Insecure Randomness in setStartingIndex"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setStartingIndex function uses block.number for randomness, which can be predicted and manipulated by miners. This is not a secure source of randomness for determining the collection's starting index."",
      ""Impact"": ""Miners or validators could potentially predict or manipulate the starting index, giving them an advantage in obtaining specific token IDs or more valuable NFTs in the collection."",
      ""Location"": ""setStartingIndex function""
    },
    {
      ""Issue"": ""Unbounded Loop in batchMint"",
      ""Severity"": ""Medium"",
      ""Description"": ""The batchMint function contains a loop that iterates based on user input (_amount) without any gas limit considerations or maximum batch size constraints. If a large number of tokens are requested, the transaction could exceed block gas limits."",
      ""Impact"": ""Large batch minting operations might fail due to out-of-gas errors, potentially causing loss of gas fees without successful minting or preventing legitimate large batch mints."",
      ""Location"": ""batchMint function""
    },
    {
      ""Issue"": ""No Contract Pause Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a pause mechanism, which could be critical in case a vulnerability is discovered after deployment. Once deployed, there's no way to temporarily halt operations if issues arise."",
      ""Impact"": ""If a security issue is identified post-deployment, there's no way to temporarily halt contract operations while a fix is implemented, potentially leading to greater damage."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Centralization Risk in Contract Control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant power to the owner, who can change collection metadata, set royalty vaults, and withdraw all funds. While the setHashedProof function prevents changing HASHED_PROOF once set, there's no way to finalize the contract state to prevent other critical changes after launch."",
      ""Impact"": ""Contract owner retains significant control even after the collection is fully deployed and operational, creating trust issues for users. If the owner's account is compromised, an attacker could drain funds, alter collection data, or disrupt royalty payments."",
      ""Location"": ""Multiple owner-only functions throughout the contract""
    },
    {
      ""Issue"": ""Missing Return Value Validation for ERC20 Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't check the return values of ERC20 token transfers in the withdraw function and potentially other places. Some ERC20 tokens return a boolean to indicate success or failure, and not checking this could lead to silent failures."",
      ""Impact"": ""Token transfers might fail silently, leading to accounting inconsistencies or loss of funds without proper error handling or notification."",
      ""Location"": ""withdraw function and potentially other token transfer operations""
    },
    {
      ""Issue"": ""No Update Mechanism for BaseURI"",
      ""Severity"": ""Low"",
      ""Description"": ""Once the contract is initialized, there's no function to update the baseURI, which might be necessary if the metadata hosting location changes or requires updates."",
      ""Impact"": ""If the original metadata hosting service goes down or changes, the NFT metadata would be permanently inaccessible or incorrect, reducing the value and functionality of the NFTs."",
      ""Location"": ""Missing function to update _baseUri""
    },
    {
      ""Issue"": ""Insufficient Event Emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several events lack important parameters or are missing entirely from state-changing functions. For example, NewWithdrawal doesn't include the token address, and functions like setStartingIndex don't emit events at all."",
      ""Impact"": ""Reduced contract transparency and auditability, making it difficult for users and auditors to track important state changes or monitor contract activities off-chain."",
      ""Location"": ""Various functions including withdraw, setStartingIndex, and batchMint""
    },
    {
      ""Issue"": ""Single-Step Ownership Transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits Ownable which typically implements a single-step ownership transfer. A two-step ownership transfer pattern would be safer to prevent accidental transfers to incorrect addresses."",
      ""Impact"": ""Accidental transfer of ownership to an incorrect address would result in permanent loss of admin control over the contract."",
      ""Location"": ""Inherited from Ownable contract""
    }
  ],
  ""IssueNumber"": 65,
  ""OutputList"": 13
}",359.97687101364136,53148.0,32.0,"### **[H-04] CoreCollection can be reinitialized**

**Report Description**:
The `initialize` function in `CoreCollection` sets the `initialized` flag but does not check if the contract has already been initialized. This allows the function to be rerun multiple times, potentially resetting critical variables like `payableToken`. While the function is `onlyOwner`, the risk remains that the owner could reset the contract either by mistake or with malicious intent, leading to system-breaking consequences.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of reinitialization in the `initialize` function. This is a critical oversight, as reinitialization can reset core variables and compromise the contract's integrity.

---

### **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

**Report Description**:
The `mintToken()` function in `CoreCollection` allows users to mint unique NFTs by either providing a merkle proof or paying a fee in `payableToken`. However, because the `payableToken` is paid before the token is minted, a callback attached to the token transfer could allow reentrancy. This bypasses the `totalSupply() + amount <= maxSupply` check, enabling the minting of duplicate NFTs, especially if the user mints the last token and reenters the function.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the reentrancy vulnerability in the `mintToken()` function. This is a significant security risk, as it could lead to the minting of duplicate NFTs and potential economic damage.

---

### **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Report Description**:
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the contract to the owner. However, `transferFrom` requires prior approval, which is not set up in this function. As a result, the call will revert, locking the funds in the contract permanently.

**Match in Response List**:
Matches with the issue titled **""Incorrect Token Transfer in withdraw Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `transferFrom` method in the `withdraw` function. It correctly explains that the lack of prior approval will cause all withdrawal attempts to fail, effectively locking the funds in the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-04] CoreCollection can be reinitialized**
- **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

---

### **Conclusion**

The response list effectively addresses the issue with the `withdraw` function but fails to cover the reinitialization vulnerability in the `initialize` function and the reentrancy risk in the `mintToken()` function. These omissions represent significant gaps in the security analysis, as both issues could lead to severe consequences for the contract's integrity and functionality.","```
1. Incorrect Token Transfer in withdraw Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Token Transfer in withdraw Function"".
   - This issue appears at **rank 1** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
RoyaltyVault.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751,104,"[H-01] ERC20 transferFrom return values not checked
The transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
  [H-05] Centralisation RIsk: Owner Of RoyaltyVault Can Take All Funds
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.
As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.
  [H-09] ERC20 tokens with no return value will fail to transfer
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.
",3,,"pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",627,3,0,"Based on the detailed code analysis, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the inheritance and implementation of Ownable contract"",
        ""Confirm that sensitive functions like setPlatformFee and setPlatformFeeRecipient are properly restricted to owner"",
        ""Check for potential centralization risks in owner-controlled functions"",
        ""Ensure no critical functions can be called by unauthorized addresses""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Perform a detailed reentrancy analysis on sendToSplitter() function"",
        ""Check for potential integer overflow/underflow risks in fee calculations"",
        ""Verify the safety of external contract calls to splitter and token transfers"",
        ""Validate input validation and error handling in all external functions"",
        ""Assess potential attack vectors in platform fee and recipient setting mechanisms""
      ]
    },
    {
      ""Area"": ""Token Transfer & External Interactions"",
      ""Tasks"": [
        ""Validate ERC20 transfer mechanisms in sendToSplitter()"",
        ""Check return value handling for token transfers and splitter interactions"",
        ""Verify handling of non-standard ERC20 tokens (tokens with transfer fees, deflationary tokens)"",
        ""Ensure robust error handling for failed token transfers or external contract calls""
      ]
    },
    {
      ""Area"": ""State Management & Invariants"",
      ""Tasks"": [
        ""Confirm correct initialization of state variables"",
        ""Verify platform fee calculation logic (basis point calculation)"",
        ""Check constraints on platform fee setting (e.g., maximum fee limit)"",
        ""Validate state changes in setPlatformFee and setPlatformFeeRecipient functions""
      ]
    },
    {
      ""Area"": ""Interface & Compliance"",
      ""Tasks"": [
        ""Verify correct implementation of IRoyaltyVault interface"",
        ""Validate ERC165 interface detection mechanism"",
        ""Confirm compliance with expected contract interactions (ISplitter)"",
        ""Check for any deviation from standard interface implementations""
      ]
    },
    {
      ""Area"": ""Gas Optimization & Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption of key functions, especially sendToSplitter()"",
        ""Review potential optimization opportunities in fee calculations"",
        ""Check for unnecessary storage reads or redundant operations"",
        ""Verify efficient use of memory and storage""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Test behavior when vault balance is zero"",
        ""Verify handling of edge cases in fee calculations"",
        ""Check response to invalid or extreme input values"",
        ""Assess error messages for clarity and informativeness""
      ]
    },
    {
      ""Area"": ""Emergency & Recovery Mechanisms"",
      ""Tasks"": [
        ""Check for emergency stop or pause functionality"",
        ""Verify recovery mechanisms for stuck funds"",
        ""Assess ability to recover mistakenly sent tokens"",
        ""Validate owner's ability to manage contract in exceptional circumstances""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list comprehensively covers potential vulnerabilities and risks identified in the initial analysis.
2. Tasks are specific, actionable, and directly tied to the contract's unique characteristics.
3. Prioritizes critical areas like access control, security vulnerabilities, and external interactions.
4. Includes both technical verification and broader systemic risk assessment.
5. Provides a structured approach to thoroughly audit the RoyaltyVault contract.

Recommended Next Steps:
- Use this task list as a systematic guide for detailed smart contract audit
- Conduct thorough testing for each identified task
- Document findings, potential vulnerabilities, and recommended mitigations
- Provide a comprehensive audit report with detailed insights

Would you like me to elaborate on any specific area or provide more detailed guidance on conducting these audit tasks?","I've carefully analyzed the provided smart contract code. Here's my audit report:

{
  ""ReviewingTheCode"": ""This contract appears to be a royalty vault that holds royalty assets, charges a platform fee, and distributes the remaining funds to a splitter contract. It handles the management of platform fees and recipients, and provides functionality to view the vault balance and send funds to the splitter contract."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RoyaltyVault"",
    ""Purpose"": ""Manages royalty assets, collects platform fees, and distributes the remaining funds to a splitter contract for further distribution."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""VaultStorage"", ""IRoyaltyVault"", ""ERC165"", ""Ownable""],
      ""Imports"": [
        ""IRoyaltyVault"",
        ""VaultStorage"",
        ""ISplitter"",
        ""IERC20"",
        ""ERC165"",
        ""Ownable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""royaltyAsset"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the ERC20 token used for royalty payments (inherited from VaultStorage)""
      },
      {
        ""Name"": ""splitterProxy"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the splitter contract that handles distribution of royalties (inherited from VaultStorage)""
      },
      {
        ""Name"": ""platformFee"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fee percentage charged by the platform in basis points (inherited from VaultStorage)""
      },
      {
        ""Name"": ""platformFeeRecipient"",
        ""Type"": ""address"",
        ""Purpose"": ""Address that receives the platform fee (inherited from VaultStorage)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""getVaultBalance"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Retrieves the current balance of royalty assets in the vault"",
        ""Parameters"": [],
        ""Returns"": [""uint256: The balance of royalty assets""]
      },
      {
        ""Name"": ""sendToSplitter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates platform fee, transfers royalty assets to the splitter and platform fee recipient"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setPlatformFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee percentage (restricted to owner)"",
        ""Parameters"": [""_platformFee: The new platform fee percentage in basis points""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPlatformFeeRecipient"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee recipient address (restricted to owner)"",
        ""Parameters"": [""_platformFeeRecipient: The new platform fee recipient address""],
        ""Returns"": []
      },
      {
        ""Name"": ""getSplitter"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the splitter contract"",
        ""Parameters"": [],
        ""Returns"": [""address: The splitter contract address""]
      },
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public view virtual"",
        ""Purpose"": ""Implements ERC165 to indicate support for IRoyaltyVault interface"",
        ""Parameters"": [""interfaceId: The interface identifier""],
        ""Returns"": [""bool: True if the interface is supported""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC20 token transfers to the splitter and platform fee recipient"",
    ""ISplitter.incrementWindow() call to the splitter contract""
  ],
  
  ""SpecialMechanisms"": [
    ""ERC165 implementation for interface detection"",
    ""Platform fee calculation using basis points (10000 = 100%)"",
    ""Royalty distribution with fee deduction mechanism""
  ],
  
  ""Questions"": [
    ""What are the specific details of the VaultStorage contract and what other state variables might be inherited?"",
    ""Are there any restrictions on who can call the sendToSplitter() function since it's not restricted by a modifier?"",
    ""Is there a maximum limit for the platform fee that can be set by the owner?"",
    ""What happens if the splitter contract rejects the transfer or if incrementWindow() fails?"",
    ""How is the royaltyAsset address initially set?"",
    ""How is the splitterProxy address initially set?"",
    ""Is there any mechanism to rescue tokens sent to this contract by mistake?""
  ]
}","I've analyzed the provided input data containing multiple security reviews of the RoyaltyVault contract. Below is the consolidated report combining similar issues and ordered by severity:

{
  ""Findings"": [
    {
      ""Issue"": ""No Reentrancy Protection"",
      ""Severity"": ""High"",
      ""Description"": ""The sendToSplitter function makes external calls to the token contract and splitter contract without any reentrancy protection. This pattern doesn't follow the checks-effects-interactions pattern and could be vulnerable to reentrancy attacks."",
      ""Impact"": ""A malicious actor could potentially re-enter the sendToSplitter function before the first execution completes, potentially draining more funds than intended or manipulating state in unexpected ways."",
      ""Location"": ""sendToSplitter function""
    },
    {
      ""Issue"": ""Lack of Access Control for sendToSplitter"",
      ""Severity"": ""High"",
      ""Description"": ""The sendToSplitter function is externally accessible without any access control. Anyone can trigger the distribution of royalties at any time."",
      ""Impact"": ""Malicious actors could trigger royalty distributions at inopportune times, potentially disrupting planned distribution schedules, affecting token prices, or causing other market manipulations."",
      ""Location"": ""sendToSplitter function - missing access control modifier""
    },
    {
      ""Issue"": ""Unsafe ERC20 Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract checks the boolean return value of ERC20 transfer calls with strict equality (== true). Some tokens don't return a boolean (like USDT) or may return false without reverting, which could lead to inconsistent state management or silent failures."",
      ""Impact"": ""The contract may not work with certain token standards that don't strictly follow the ERC20 standard, leading to locked funds, accounting errors, or failed operations."",
      ""Location"": ""sendToSplitter function, all require statements checking transfer return values""
    },
    {
      ""Issue"": ""Missing Zero Address Validation for platformFeeRecipient"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setPlatformFeeRecipient function allows setting the platformFeeRecipient to the zero address. This could cause tokens to be permanently lost if the platform fee is greater than zero and sendToSplitter is called."",
      ""Impact"": ""If platformFeeRecipient is set to the zero address, either by mistake or malicious intent, platform fees will be permanently lost, reducing total value captured by the system."",
      ""Location"": ""setPlatformFeeRecipient function""
    },
    {
      ""Issue"": ""No Upper Bound Check on platformFee"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setPlatformFee function does not have an upper bound check, allowing the owner to potentially set the fee to 10000 (100%) or more. This could effectively redirect all funds to the platform and none to the splitter."",
      ""Impact"": ""Owner could maliciously or accidentally set an excessive platform fee, redirecting all funds away from intended recipients through the splitter, violating the trust of users and defeating the purpose of the royalty distribution system."",
      ""Location"": ""setPlatformFee function""
    },
    {
      ""Issue"": ""Unclear Initialization of Contract State"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from VaultStorage but doesn't show how critical state variables (royaltyAsset, splitterProxy, platformFeeRecipient) are initialized. Without proper initialization, the contract could be in an invalid state."",
      ""Impact"": ""Contract may not function correctly if state variables are not properly initialized, leading to failed transactions or locked funds."",
      ""Location"": ""Contract inheritance and initialization""
    },
    {
      ""Issue"": ""Single Point of Failure in Ownership Model"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from Ownable, which means there is a single owner with privileged access to critical functions. If the owner's private key is compromised or lost, critical functions can be maliciously executed or become inaccessible."",
      ""Impact"": ""A compromised owner account could change the platform fee to the maximum value or change the platform fee recipient to a malicious address, effectively stealing all royalty funds."",
      ""Location"": ""Entire contract (Ownable inheritance)""
    },
    {
      ""Issue"": ""Insufficient Validation of Splitter Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The sendToSplitter function assumes the splitterProxy address points to a valid contract implementing the ISplitter interface, but doesn't verify this before attempting to call incrementWindow."",
      ""Impact"": ""If splitterProxy is set to an address that doesn't implement the required interface, the transaction will revert, potentially locking funds in the contract."",
      ""Location"": ""sendToSplitter function - call to ISplitter(splitterProxy).incrementWindow""
    },
    {
      ""Issue"": ""No Emergency Pause Functionality"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks an emergency pause mechanism that would allow the owner to halt operations in case a vulnerability is discovered or an upgrade is needed."",
      ""Impact"": ""If a vulnerability is found, the owner cannot quickly prevent further exploitation until a fix is deployed."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Potential Division Before Multiplication"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation of platformShare involves a division by 10000, which could lead to precision loss if balanceOfVault is small. While this is unlikely to be a major issue given typical token amounts, it's a pattern to be cautious about."",
      ""Impact"": ""Could result in rounding errors in fee calculations with small token amounts."",
      ""Location"": ""sendToSplitter function: uint256 platformShare = (balanceOfVault * platformFee) / 10000;""
    },
    {
      ""Issue"": ""No Mechanism to Recover Stuck Tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""There's no functionality to recover tokens other than the royaltyAsset that might be accidentally sent to the contract."",
      ""Impact"": ""Any tokens other than the specified royaltyAsset will be permanently locked in the contract if sent there by mistake."",
      ""Location"": ""Entire contract - missing recovery functionality""
    },
    {
      ""Issue"": ""Contract Does Not Support ETH Payments"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks fallback or receive functions, meaning it cannot accept ETH directly. This is not necessarily a security issue, but it's important to note if the contract is intended to handle ETH."",
      ""Impact"": ""ETH sent directly to the contract will be rejected, potentially causing confusion or lost funds."",
      ""Location"": ""Entire contract (missing fallback/receive functions)""
    },
    {
      ""Issue"": ""Inconsistent Error Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses require statements with custom error messages for validation, but doesn't use custom errors (introduced in Solidity 0.8.4) which would be more gas efficient."",
      ""Impact"": ""Gas inefficiency and potentially higher transaction costs."",
      ""Location"": ""All require statements in the contract""
    }
  ],
  ""IssueNumber"": 55,
  ""OutputList"": 13
}",310.5657742023468,37623.0,32.0,"### **Output**

---

**[H-01] ERC20 transferFrom return values not checked**

**Report Description**:
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.

**Match in Response List**:
Matches with the issue titled **""Unsafe ERC20 Operations""**.

**Validation**:
**Correct**. The response identifies the issue with unsafe ERC20 operations, specifically mentioning that the contract checks the boolean return value of ERC20 transfer calls with strict equality. This aligns with the issue of not checking the return value of `transferFrom()`, as both involve the same underlying problem of handling ERC20 return values incorrectly.

---

**[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Report Description**:
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g., 100% = 10000), and that share of the contract's balance and future balances will be set to the `platformFeeRecipient` (which is in the owner's control) rather than the splitter contract. As a result, the owner can steal the entire contract balance and any future balances, avoiding the splitter.

**Match in Response List**:
Matches with the issue titled **""No Upper Bound Check on platformFee""**.

**Validation**:
**Correct**. The response accurately identifies the issue of the owner being able to set the platform fee to an arbitrary value, including 100%, which would redirect all funds to the platform fee recipient. This directly addresses the centralization risk described in the issue report.

---

**[H-09] ERC20 tokens with no return value will fail to transfer**

**Report Description**:
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high-profile tokens like USDT). In that case, the `.transfer()` call here will revert even if the transfer is successful because Solidity will check that the RETURNDATASIZE matches the ERC20 interface.

**Match in Response List**:
Matches with the issue titled **""Unsafe ERC20 Operations""**.

**Validation**:
**Correct**. The response correctly identifies the issue with unsafe ERC20 operations, specifically mentioning that some tokens don't return a boolean (like USDT) or may return false without reverting. This aligns with the issue of ERC20 tokens with no return value causing transfers to fail, as both involve the same underlying problem of handling non-compliant ERC20 tokens incorrectly.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] ERC20 transferFrom return values not checked**
- **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**
- **[H-09] ERC20 tokens with no return value will fail to transfer**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

--- 

**Conclusion**:
All issues in the `issue` report were correctly matched and addressed in the `response_list`. The responses accurately identified the vulnerabilities, risks, and impacts, aligning with Solidity best practices and security standards.","```
1. Unsafe ERC20 Operations
2. No Upper Bound Check on platformFee
3. Unsafe ERC20 Operations
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Unsafe ERC20 Operations"" appears at rank 3.
   - ""No Upper Bound Check on platformFee"" appears at rank 5.
   - ""Unsafe ERC20 Operations"" appears again at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)

3. **Average the precision values**:
   - AP = \( \frac{0.333 + 0.4 + 0.333}{3} \approx \frac{1.066}{3} \approx 0.355 \)

**Average Precision (AP)**: 0.355"
SplitFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197,175,"[M-01] DoS: Attacker May Front-Run createSplit() With A merkleRoot Causing Future Transactions With The Same merkleRoot to Revert
A merkleRoot may only be used once in `createSplit()` since it is used as salt to the deployment of a SplitProxy.
The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another createSplit() transaction with a higher gas price that uses the same merkleRoot but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this merkleRoot.
",1,,"pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  

  address public immutable splitter;
  address public immutable royaltyVault;

  
  

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; 
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  

  
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",893,0,1,,,,1200.789150238037,10978.0,25.0,"---

**[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Report Description**:  
The `createSplit()` function uses a `merkleRoot` as a salt for deploying a `SplitProxy`. Since a `merkleRoot` can only be used once, an attacker can front-run a legitimate `createSplit()` transaction by submitting a similar transaction with a higher gas price but altering other fields like `_collectionContract` or `_splitAsset()`. This causes the original transaction to revert, effectively denying the user the ability to use that `merkleRoot` in future transactions. This vulnerability can lead to a Denial of Service (DoS) attack, disrupting the intended functionality of the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The vulnerability involves a front-running attack exploiting the uniqueness of the `merkleRoot` in the `createSplit()` function, which is not mentioned or analyzed in the provided response list. This is a critical oversight, as the issue poses a significant risk to the contract's functionality and user experience.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

--- 

This evaluation highlights a significant gap in the response list, as it fails to address a critical vulnerability related to front-running and DoS attacks in the `createSplit()` function.","```
None.
```",0.0
