nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
TwabRewards.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";

/**
 * @title PoolTogether V4 TwabRewards
 * @author PoolTogether Inc Team
 * @notice Contract to distribute rewards to depositors in a pool.
 * This contract supports the creation of several promotions that can run simultaneously.
 * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.
 * This way, users simply need to hold their tickets to be eligible to claim rewards.
 * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.
 */
contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice Settings of each promotion.
    mapping(uint256 => Promotion) internal _promotions;

    /// @notice Latest recorded promotion id.
    /// @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.
    uint256 internal _latestPromotionId;

    /// @notice Keeps track of claimed rewards per user.
    /// @dev _claimedEpochs[promotionId][user] => claimedEpochs
    /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    /* ============ Events ============ */

    /**
        @notice Emitted when a promotion is created.
        @param promotionId Id of the newly created promotion
    */
    event PromotionCreated(uint256 indexed promotionId);

    /**
        @notice Emitted when a promotion is cancelled.
        @param promotionId Id of the promotion being cancelled
        @param amount Amount of tokens transferred to the promotion creator
    */
    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);

    /**
        @notice Emitted when a promotion is extended.
        @param promotionId Id of the promotion being extended
        @param numberOfEpochs Number of epochs the promotion has been extended by
    */
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    /**
        @notice Emitted when rewards have been claimed.
        @param promotionId Id of the promotion for which epoch rewards were claimed
        @param epochIds Ids of the epochs being claimed
        @param user Address of the user for which the rewards were claimed
        @param amount Amount of tokens transferred to the recipient address
    */
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint256[] epochIds,
        address indexed user,
        uint256 amount
    );

    /* ============ Modifiers ============ */

    /// @dev Ensure that the caller is the creator of the promotion.
    /// @param _promotionId Id of the promotion to check
    modifier onlyPromotionCreator(uint256 _promotionId) {
        require(
            msg.sender == _getPromotion(_promotionId).creator,
            ""TwabRewards/only-promotion-creator""
        );
        _;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc ITwabRewards
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    /// @inheritdoc ITwabRewards
    function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);

        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;
        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    /// @inheritdoc ITwabRewards
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    /// @inheritdoc ITwabRewards
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);
        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);

        for (uint256 index = 0; index < _epochIds.length; index++) {
            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
        }

        return _rewardsAmount;
    }

    /* ============ Internal Functions ============ */

    /**
    @notice Determine if address passed is actually a ticket.
    @param _ticket Address to check
   */
    function _requireTicket(address _ticket) internal view {
        require(_ticket != address(0), ""TwabRewards/ticket-not-zero-address"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(ITicket(_ticket).controller.selector)
        );

        address controllerAddress;

        if (data.length > 0) {
            controllerAddress = abi.decode(data, (address));
        }

        require(succeeded && controllerAddress != address(0), ""TwabRewards/invalid-ticket"");
    }

    /**
        @notice Determine if a promotion is active.
        @param _promotion Promotion to check
    */
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        uint256 _promotionEndTimestamp = _promotion.startTimestamp +
            (_promotion.epochDuration * _promotion.numberOfEpochs);

        require(
            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,
            ""TwabRewards/promotion-not-active""
        );
    }

    /**
        @notice Get settings for a specific promotion.
        @dev Will revert if the promotion does not exist.
        @param _promotionId Promotion id to get settings for
        @return Promotion settings
     */
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        return _promotions[_promotionId];
    }

    /**
        @notice Get the current epoch id of a promotion.
        @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
        @param _promotion Promotion to get current epoch for
        @return Epoch id
     */
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        // elapsedTimestamp / epochDurationTimestamp
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

    /**
        @notice Get reward amount for a specific user.
        @dev Rewards can only be claimed once the epoch is over.
        @param _user User to get reward amount for
        @param _promotion Promotion from which the epoch is
        @param _epochId Epoch id to get reward amount for
        @return Reward amount
     */
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }

    /**
        @notice Get the total amount of tokens left to be rewarded.
        @param _promotion Promotion to get the total amount of tokens left to be rewarded for
        @return Amount of tokens left to be rewarded
     */
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        // _tokensPerEpoch * _numberOfEpochsLeft
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    /**
        @notice Set boolean value for a specific epoch.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0011
        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.
        We get: 0000 0001 << 2 = 0000 0100
        We then OR the mask with the word to set the value.
        We get: 0110 0011 | 0000 0100 = 0110 0111
        @param _userClaimedEpochs Tightly packed epoch ids with their boolean values
        @param _epochId Id of the epoch to set the boolean for
        @return Tightly packed epoch ids with the newly boolean value set
    */
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    /**
        @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0111
        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.
        We get: 0110 0111 >> 2 = 0001 1001
        We then get the value of the last bit by masking with 1.
        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1
        We then return the boolean value true since the last bit is 1.
        @param _userClaimedEpochs Record of epochs already claimed by the user
        @param _epochId Epoch id to check
        @return true if the rewards have already been claimed for the given epoch, false otherwise
     */
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",3228,378,"[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds
In the current implementation of `createPromotion()`, `_epochDuration` is allowed to be 0.
However, when _epochDuration = 0, it will be impossible for users to claim the rewards, and the promotion creator won't be able to cancel it.

[H-02] Backdated _startTimestamp can lead to loss of funds

Function `createPromotion()`
This can lead to loss of funds as there is no recovery function of funds stuck like this
 [H-03] Continue claiming reqrds after numberOfEpochs are over

When claiming rewards via claimRewards(), the function `_calculateRewardAmount()` is called. The function \_calculateRewardAmount() has a check to make sure the epoch is over
  require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over""); 

However neither functions check if the \_epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.
The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log:  Claiming for epoch 1 1  Claiming for epoch 2 1  Claiming for epoch 3 1  Claiming for epoch 4 1  Claiming for epoch 5 1
  [H-04] cancelPromotion is too rigorous

When you cancel a promotion with `cancelPromotion()` then the promotion is complete deleted. This means no-one can claim any rewards anymore, because \_promotions\[\_promotionId] no longer exists.
It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.
  [H-05] Malicious tickets can lead to the loss of all tokens
 function `createPromotion()`
It allows an attacker to retrieve all the tokens of each promotions.
Analysis

Anyone can create a new promotion using createPromotion(). An attacker can create a new malicious promotion with the following parameters:
the address of a malicious ticket smart contract
the token address from the targeted promotion(s)
optionally, _numberOfEpochs equal to 0 to create this promotion for free
The only verification made on the ticket address given by _requireTicket() is that the smart contract must implement the ITicket interface.
  [H-06] Rewards can be claimed multiple times

Function `claimRewards() `
An attacker can claim its reward 256 * epochDuration seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.
Analysis

claimRewards() claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping _claimedEpochs keeps track of claimed rewards per user:
  [H-07] Contract does not work with fee-on transfer tokens

Function `_calculateRewardAmount()`
``` promotion.tokensPerEpoch * promotion.numberOfEpochs ``` 
There exist ERC20 tokens that charge a fee for every transfer.
This kind of token does not work correctly with the TwabRewards contract as the rewards calculation for an user is based on promotion.tokensPerEpoch (see line 320).
However, the actual amount of tokens the contract holds could be less than promotion.tokensPerEpoch * promotion.numberOfEpochs leading to not claimable rewards for users claiming later than others.
  [M-01] cancelPromotion() Unable to cancel unstarted promotions

Submitted by WatchPug, also found by kenzo, and certora
For unstarted promotions, cancelPromotion() will revert at block.timestamp - _promotion.startTimestamp in _getCurrentEpochId().
Call stack: cancelPromotion() -> _getRemainingRewards() -> _getCurrentEpochId().
https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336
function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
    // _tokensPerEpoch * _numberOfEpochsLeft
    return
        _promotion.tokensPerEpoch *
        (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
}

https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279
function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
    // elapsedTimestamp / epochDurationTimestamp
    return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
}
  [M-02] `getRewardsAmount` doesn't check epochs haven't been claimed

In ITwabRewards.sol, it is claimed that getRewardsAmount should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says @dev Will be 0 if user has already claimed rewards for the epoch.)
However, no such check is done in the implementation of getRewardsAmount. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.
  [M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account

Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the _calculateRewardAmount calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste
  [M-04] Unsafe uint64 casting may overflow

The `_calculateRewardAmount` function casts epoch timestamps from uint256 to uint64 and these may overflow. The epochStartTimestamp value is a function of the user-supplied \_epochId value, which could be extremely large (up to 2**255 – 1). While Solidity 0.8.x checks for overflows on arithmetic operations, it does not do so for casting – the OpenZeppelin SafeCast library offers this. The overflow condition could cause \_epochStartTimestamp > \_epochEndTimestamp, which the Ticket.sol getAverageBalanceBetween may not be expected to handle. The \_epochStartTimestamp could overflow to have a value before the actual start of the promotion, also impacting the rewards calculation.
  [M-05] Missing Check When Transferring Tokens Out For A Given Promotion

Submitted by leastwood
Impact

The claimRewards function is called upon by ticket holders who parse a set of _epochIds they wish to claim rewards on. An internal call is made to _calculateRewardAmount to calculate the correct reward amount owed to the user. Subsequently, the _updateClaimedEpoch function will set the epoch bit of the tracked _claimedEpochs mapping, ensuring an epochId cannot be claimed twice for a given promotion.
However, there may be inaccuracies in the _calculateRewardAmount function, which results in more tokens being sent out than allocated by a promotion creator. This severely impacts the ability for users to claim their owed tokens on other promotions.",12,"pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";


contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    

    
    mapping(uint256 => Promotion) internal _promotions;

    
    
    uint256 internal _latestPromotionId;

    
    
    
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    

    
    event PromotionCreated(uint256 indexed promotionId);

    
    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);

    
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint256[] epochIds,
        address indexed user,
        uint256 amount
    );

    

    
    
    modifier onlyPromotionCreator(uint256 _promotionId) {
        require(
            msg.sender == _getPromotion(_promotionId).creator,
            ""TwabRewards/only-promotion-creator""
        );
        _;
    }

    

    
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    
    function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

    
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);

        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;
        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);
        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);

        for (uint256 index = 0; index < _epochIds.length; index++) {
            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
        }

        return _rewardsAmount;
    }

    

    
    function _requireTicket(address _ticket) internal view {
        require(_ticket != address(0), ""TwabRewards/ticket-not-zero-address"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(ITicket(_ticket).controller.selector)
        );

        address controllerAddress;

        if (data.length > 0) {
            controllerAddress = abi.decode(data, (address));
        }

        require(succeeded && controllerAddress != address(0), ""TwabRewards/invalid-ticket"");
    }

    
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        uint256 _promotionEndTimestamp = _promotion.startTimestamp +
            (_promotion.epochDuration * _promotion.numberOfEpochs);

        require(
            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,
            ""TwabRewards/promotion-not-active""
        );
    }

    
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        return _promotions[_promotionId];
    }

    
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

    
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }

    
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",1979,7,5,"Based on the detailed analysis of the TwabRewards contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in token transfer methods (claimRewards, cancelPromotion)"",
        ""Check for potential integer overflow/underflow in reward calculations"",
        ""Audit bit manipulation logic in _updateClaimedEpoch and _isClaimedEpoch methods"",
        ""Validate input parameter ranges and bounds in all external functions"",
        ""Review SafeERC20 usage for comprehensive token transfer security""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Thoroughly test onlyPromotionCreator modifier for strict access control"",
        ""Verify that only promotion creators can cancel or extend promotions"",
        ""Check for potential privilege escalation vulnerabilities"",
        ""Validate address zero checks in critical functions""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit _requireTicket method for robust ticket contract validation"",
        ""Verify static call mechanism for ticket controller check"",
        ""Test interactions with ITicket contract's getAverageBalanceBetween method"",
        ""Validate error handling for external contract calls""
      ]
    },
    {
      ""Area"": ""Reward Distribution Logic"",
      ""Tasks"": [
        ""Verify _calculateRewardAmount calculation accuracy"",
        ""Test edge cases in epoch-based reward distribution"",
        ""Validate proportional reward calculation based on average balance"",
        ""Check for potential rounding errors in token distribution"",
        ""Verify remaining rewards calculation mechanism""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in epoch tracking and reward calculation"",
        ""Review bit manipulation efficiency in claimed epochs tracking"",
        ""Check for potential optimization in loop-based calculations"",
        ""Evaluate function visibility and storage access patterns""
      ]
    },
    {
      ""Area"": ""Front-Running & Transaction Ordering"",
      ""Tasks"": [
        ""Identify potential front-running risks in reward claiming"",
        ""Analyze epoch reward calculation for manipulation vulnerabilities"",
        ""Check for potential time-based attack vectors"",
        ""Verify timestamp-dependent logic robustness""
      ]
    },
    {
      ""Area"": ""Error Handling & Validation"",
      ""Tasks"": [
        ""Comprehensive review of require statement error messages"",
        ""Test all error conditions and revert scenarios"",
        ""Validate input validation across all external functions"",
        ""Check for consistent and informative error reporting""
      ]
    },
    {
      ""Area"": ""Epoch Management"",
      ""Tasks"": [
        ""Verify getCurrentEpochId calculation accuracy"",
        ""Test epoch boundary conditions"",
        ""Check handling of promotions spanning multiple time periods"",
        ""Validate epoch-based reward eligibility logic""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Verify SafeERC20 implementation for non-standard ERC20 tokens"",
        ""Test token transfer mechanisms in createPromotion, extendPromotion"",
        ""Check handling of tokens with different decimal places"",
        ""Validate token balance checks and transfer security""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list comprehensively covers potential vulnerabilities and critical areas of the smart contract.
2. Tasks are specific, actionable, and directly address the complexities observed in the TwabRewards contract.
3. The approach focuses on security, logic validation, and potential edge cases in the reward distribution mechanism.
4. Tasks are grouped by audit areas to provide a structured approach to the security review.

Recommended Next Steps:
- Prioritize tasks based on potential impact and complexity
- Develop detailed test cases for each task
- Conduct thorough manual and automated testing
- Consider formal verification for complex calculation methods","After carefully reviewing the provided smart contract code, here's my analysis:

{
  ""ReviewingTheCode"": ""The TwabRewards contract handles promotional rewards distribution based on time-weighted average balances (TWAB). It allows creators to set up promotions with specific tokens, durations, and reward rates, then users can claim these rewards based on their average token balance during specific epochs."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""TwabRewards"",
    ""Purpose"": ""Manages and distributes token rewards to users based on their time-weighted average balances over defined time periods (epochs)"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ITwabRewards""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"",
        ""./interfaces/ITwabRewards.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""_promotions"",
        ""Type"": ""mapping(uint256 => Promotion)"",
        ""Purpose"": ""Stores promotion details indexed by promotion ID""
      },
      {
        ""Name"": ""_latestPromotionId"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the most recently created promotion ID""
      },
      {
        ""Name"": ""_claimedEpochs"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Tracks which epochs a user has claimed for each promotion using bit mapping""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyPromotionCreator"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the creator of a specific promotion"",
        ""Parameters"": [""uint256 _promotionId""]
      },
      {
        ""Name"": ""createPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new promotion with specified parameters"",
        ""Parameters"": [""address _ticket"", ""IERC20 _token"", ""uint216 _tokensPerEpoch"", ""uint32 _startTimestamp"", ""uint32 _epochDuration"", ""uint8 _numberOfEpochs""],
        ""Returns"": [""uint256 (promotionId)""]
      },
      {
        ""Name"": ""cancelPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows promotion creator to cancel a promotion and withdraw remaining rewards"",
        ""Parameters"": [""uint256 _promotionId"", ""address _to""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""extendPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows adding more epochs to an existing promotion"",
        ""Parameters"": [""uint256 _promotionId"", ""uint8 _numberOfEpochs""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""claimRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to claim rewards for specific epochs in a promotion"",
        ""Parameters"": [""address _user"", ""uint256 _promotionId"", ""uint256[] calldata _epochIds""],
        ""Returns"": [""uint256 (reward amount)""]
      },
      {
        ""Name"": ""getPromotion"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the details of a specific promotion"",
        ""Parameters"": [""uint256 _promotionId""],
        ""Returns"": [""Promotion memory""]
      },
      {
        ""Name"": ""getCurrentEpochId"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the current epoch ID for a promotion"",
        ""Parameters"": [""uint256 _promotionId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getRemainingRewards"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates remaining unclaimed rewards for a promotion"",
        ""Parameters"": [""uint256 _promotionId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getRewardsAmount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates reward amounts for specific epochs for a user"",
        ""Parameters"": [""address _user"", ""uint256 _promotionId"", ""uint256[] calldata _epochIds""],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""_requireTicket"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Validates if an address is a valid ticket"",
        ""Parameters"": [""address _ticket""]
      },
      {
        ""Name"": ""_requirePromotionActive"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a promotion is still active"",
        ""Parameters"": [""Promotion memory _promotion""]
      },
      {
        ""Name"": ""_getPromotion"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Retrieves a promotion by ID"",
        ""Parameters"": [""uint256 _promotionId""],
        ""Returns"": [""Promotion memory""]
      },
      {
        ""Name"": ""_getCurrentEpochId"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates current epoch ID for a promotion"",
        ""Parameters"": [""Promotion memory _promotion""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_calculateRewardAmount"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates reward amount for a user for a specific epoch"",
        ""Parameters"": [""address _user"", ""Promotion memory _promotion"", ""uint256 _epochId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getRemainingRewards"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates remaining rewards for a promotion"",
        ""Parameters"": [""Promotion memory _promotion""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_updateClaimedEpoch"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Updates the bitfield tracking claimed epochs"",
        ""Parameters"": [""uint256 _userClaimedEpochs"", ""uint256 _epochId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_isClaimedEpoch"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if a specific epoch has been claimed"",
        ""Parameters"": [""uint256 _userClaimedEpochs"", ""uint256 _epochId""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ITicket - Used to query user balances and total supplies over time periods"",
    ""IERC20 - Used for handling token transfers (rewards)"",
    ""SafeERC20 - Used for safe token handling operations""
  ],
  ""SpecialMechanisms"": [
    ""Time-weighted average balance (TWAB) reward calculation"",
    ""Bit mapping for efficiently tracking claimed epochs"",
    ""Epoch-based reward distribution system"",
    ""Proportional reward distribution based on user's share of total supply""
  ],
  ""Questions"": [
    ""What's the structure of the Promotion struct? It's used extensively but not defined in the provided code"",
    ""How does the ITwabRewards interface define the contract's required functions?"",
    ""How does the system handle potential integer overflow in reward calculations?"",
    ""Is there any mechanism to prevent frontrunning in epoch-based rewards?"",
    ""How does the contract handle potential issues with non-standard ERC20 tokens?""
  ]
}

After thorough examination, this contract implements a sophisticated reward system for token holders, with rewards proportionally distributed based on time-weighted average balances. The contract uses bit manipulation for efficient tracking of claimed epochs and incorporates safety checks throughout the reward distribution process. The primary security considerations appear to be around token handling, reward calculation accuracy, and ensuring users can't claim rewards multiple times for the same epoch.","{
""Findings"": [
{
""Issue"": ""Reentrancy Vulnerabilities in Token Transfers"",
""Severity"": ""High"",
""Description"": ""Multiple functions (claimRewards, cancelPromotion, extendPromotion) perform state changes after external token transfers without proper reentrancy protection. While SafeERC20 is used, malicious tokens with callbacks could still exploit this pattern."",
""Impact"": ""Attackers could potentially re-enter the contract during token transfers, leading to multiple claims of the same rewards, fund theft, or other state manipulation."",
""Location"": ""claimRewards, cancelPromotion, and extendPromotion functions""
},
{
""Issue"": ""Missing Access Control and Validation"",
""Severity"": ""High"",
""Description"": ""Several critical functions lack proper access control and input validation. The claimRewards function allows anyone to claim on behalf of any user, and the extendPromotion function doesn't verify the caller is the promotion creator."",
""Impact"": ""Unauthorized users can manipulate rewards, claim on behalf of others, and potentially exploit the system through front-running attacks."",
""Location"": ""claimRewards and extendPromotion functions""
},
{
""Issue"": ""Integer Overflow/Underflow Risks"",
""Severity"": ""Medium"",
""Description"": ""Multiple arithmetic operations are vulnerable to overflow/underflow, including epoch calculations and reward computations. The numberOfEpochs (uint8) can overflow when extended, and bit shifting operations in _updateClaimedEpoch could overflow if _epochId >= 256."",
""Impact"": ""Overflow/underflow could lead to incorrect reward calculations, broken epoch tracking, and potential loss of funds."",
""Location"": ""extendPromotion, _updateClaimedEpoch, and _calculateRewardAmount functions""
},
{
""Issue"": ""Insufficient Parameter Validation"",
""Severity"": ""Medium"",
""Description"": ""Critical parameters like epochDuration, startTimestamp, and tokensPerEpoch lack proper validation in createPromotion. Zero values and invalid timestamps are not properly checked."",
""Impact"": ""Invalid parameters could create non-functional promotions, cause division by zero errors, or allow immediate claims without proper participation."",
""Location"": ""createPromotion function parameter validation""
},
{
""Issue"": ""Precision Loss in Reward Calculations"",
""Severity"": ""Medium"",
""Description"": ""The reward calculation formula in _calculateRewardAmount can suffer from precision loss due to integer division, especially when dealing with small balances relative to total supply."",
""Impact"": ""Users with small balances might receive zero rewards even when entitled to small amounts, leading to unfair distribution."",
""Location"": ""_calculateRewardAmount function""
},
{
""Issue"": ""Timestamp Dependency"",
""Severity"": ""Low"",
""Description"": ""The contract relies heavily on block.timestamp for epoch calculations and reward distribution timing, which can be slightly manipulated by miners."",
""Impact"": ""Minor manipulation of timestamps could affect reward calculations and epoch transitions in edge cases."",
""Location"": ""_getCurrentEpochId and _calculateRewardAmount functions""
}
],
""IssueNumber"": 47,
""OutputList"": 6
}",77.4932131767273,15619.0,8.0,"### **[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds**

**Report Description**:
The `createPromotion()` function allows `_epochDuration` to be set to 0. When `_epochDuration = 0`, users cannot claim rewards, and the promotion creator cannot cancel the promotion. This can freeze the creator's funds indefinitely.

**Match in Response List**:
Matches with the issue titled **""Insufficient Parameter Validation""**.

**Validation**:
**Correct**. The response identifies the lack of validation for critical parameters like `epochDuration` in `createPromotion()`. It correctly highlights the risks of invalid parameters, which aligns with the issue's description of freezing funds due to `_epochDuration = 0`.

---

### **[H-02] Backdated _startTimestamp can lead to loss of funds**

**Report Description**:
The `createPromotion()` function does not validate `_startTimestamp`. A backdated timestamp can lead to loss of funds, as there is no recovery mechanism for funds stuck in such promotions.

**Match in Response List**:
Matches with the issue titled **""Insufficient Parameter Validation""**.

**Validation**:
**Correct**. The response addresses the lack of validation for critical parameters like `startTimestamp` in `createPromotion()`. It correctly identifies the risks of invalid timestamps, which aligns with the issue's description of potential fund loss.

---

### **[H-03] Continue claiming rewards after numberOfEpochs are over**

**Report Description**:
The `claimRewards()` function does not check if `_epochId` is within the range of reward epochs. This allows users to claim rewards indefinitely as long as there are tokens in the contract, even after the reward period is over.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of unchecked `_epochId` validation in `claimRewards()`.

---

### **[H-04] cancelPromotion is too rigorous**

**Report Description**:
The `cancelPromotion()` function deletes the promotion entirely, preventing users from claiming rewards and locking unclaimed tokens in the contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of overly rigorous cancellation in `cancelPromotion()`.

---

### **[H-05] Malicious tickets can lead to the loss of all tokens**

**Report Description**:
The `createPromotion()` function allows the use of malicious ticket contracts that implement the `ITicket` interface. An attacker can create a promotion with a malicious ticket contract and retrieve all tokens from other promotions.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of malicious ticket contracts in `createPromotion()`.

---

### **[H-06] Rewards can be claimed multiple times**

**Report Description**:
The `claimRewards()` function allows an attacker to claim rewards multiple times for the same epoch, potentially retrieving all tokens associated with the promotion.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerabilities in Token Transfers""**.

**Validation**:
**Partially Correct**. The response identifies reentrancy risks in token transfers but does not specifically address the issue of multiple claims for the same epoch in `claimRewards()`.

---

### **[H-07] Contract does not work with fee-on transfer tokens**

**Report Description**:
The `_calculateRewardAmount()` function does not account for fee-on-transfer tokens, leading to discrepancies in token balances and unclaimable rewards for users.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of fee-on-transfer tokens in `_calculateRewardAmount()`.

---

### **[M-01] cancelPromotion() Unable to cancel unstarted promotions**

**Report Description**:
The `cancelPromotion()` function reverts for unstarted promotions due to a calculation in `_getCurrentEpochId()`, preventing cancellation.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of inability to cancel unstarted promotions in `cancelPromotion()`.

---

### **[M-02] getRewardsAmount doesn't check epochs haven't been claimed**

**Report Description**:
The `getRewardsAmount()` function does not check if epochs have already been claimed, leading to incorrect reward amounts being displayed to users.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of unchecked claimed epochs in `getRewardsAmount()`.

---

### **[M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account**

**Report Description**:
Users with small reward claims may not claim them due to high gas costs, leading to dust balances that cannot be reclaimed by an admin.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this specific issue of unclaimable dust balances.

---

### **[M-04] Unsafe uint64 casting may overflow**

**Report Description**:
The `_calculateRewardAmount()` function casts epoch timestamps from `uint256` to `uint64`, which may overflow, leading to incorrect reward calculations.

**Match in Response List**:
Matches with the issue titled **""Integer Overflow/Underflow Risks""**.

**Validation**:
**Correct**. The response identifies overflow/underflow risks in arithmetic operations, including casting in `_calculateRewardAmount()`. It correctly highlights the risks of incorrect reward calculations due to overflow.

---

### **[M-05] Missing Check When Transferring Tokens Out For A Given Promotion**

**Report Description**:
The `claimRewards()` function may transfer more tokens than allocated due to inaccuracies in `_calculateRewardAmount()`, impacting other promotions.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerabilities in Token Transfers""**.

**Validation**:
**Partially Correct**. The response identifies reentrancy risks in token transfers but does not specifically address the issue of inaccuracies in `_calculateRewardAmount()` leading to over-transfers.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds**
- **[H-02] Backdated _startTimestamp can lead to loss of funds**
- **[M-04] Unsafe uint64 casting may overflow**

**Partially Correct Matches**:

- **[H-06] Rewards can be claimed multiple times**
- **[M-05] Missing Check When Transferring Tokens Out For A Given Promotion**

**Missed Issues from Issue Report**:

- **[H-03] Continue claiming rewards after numberOfEpochs are over**
- **[H-04] cancelPromotion is too rigorous**
- **[H-05] Malicious tickets can lead to the loss of all tokens**
- **[H-07] Contract does not work with fee-on transfer tokens**
- **[M-01] cancelPromotion() Unable to cancel unstarted promotions**
- **[M-02] getRewardsAmount doesn't check epochs haven't been claimed**
- **[M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account**

---","1. Insufficient Parameter Validation  
2. Integer Overflow/Underflow Risks","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Insufficient Parameter Validation"" appears at rank 4.
   - ""Integer Overflow/Underflow Risks"" appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.333 + 0.5}{2} = \frac{0.833}{2} \approx 0.4165
   \]

**Average Precision (AP)**: 0.4165"
