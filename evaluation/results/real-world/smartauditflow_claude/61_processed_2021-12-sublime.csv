nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,Match,Partially,Not Match,LLM-generated,matchList,MAP
CreditLine.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",10034.0,1061.0,"[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way

Submitted by 0x0x0x
Current implementation to get the price is as follows: 
(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset); 
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050
But it should not consult `borrowToken / collateralToken`, rather it should consult the invers
  [H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens

Submitted by harleythedog
Impact

It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.
Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by _borrowTokensToLiquidate) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.
  [M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender

Submitted by hyh, also found by 0x0x0x
Impact

Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.
  [M-08] Missing approve(0)

There are 3 instances where the IERC20.approve() function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling approve(_spender, 0). Transactions will revert when using an unsupported token like USDT (see the approve() function requirement at line 199).",4.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';



contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    
    address public savingsAccount;

    
    address public priceOracle;

    
    address public strategyRegistry;

    
    address public defaultStrategy;

    
    uint256 public protocolFeeFraction;

    
    address public protocolFeeCollector;

    
    uint256 public liquidatorRewardFraction;
    
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    
    event CreditLineAccepted(uint256 indexed id);

    
    event CreditLineReset(uint256 indexed id);

    
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CreditLineClosed(uint256 indexed id);

    
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    
    event PriceOracleUpdated(address indexed priceOracle);

    
    event SavingsAccountUpdated(address indexed savingsAccount);

    
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",7331.0,2.0,2.0,"Based on the comprehensive analysis of the CreditLine smart contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly review reentrancy protection mechanisms, especially in external call functions like borrow(), repay(), and liquidate()"",
        ""Validate SafeMath library usage to prevent integer overflow/underflow vulnerabilities"",
        ""Check for potential unhandled edge cases in interest calculation and debt tracking"",
        ""Verify that all external contract calls have proper error handling and return value checks"",
        ""Audit the receive() function for potential security risks and ensure it only accepts calls from approved sources""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review the implementation of onlyOwner, onlyCreditLineBorrower, and onlyCreditLineLender modifiers"",
        ""Verify that critical functions like updateDefaultStrategy() have appropriate access restrictions"",
        ""Check the ownership transfer mechanism in the initializer function"",
        ""Ensure no potential privilege escalation paths exist in the contract""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate interactions with PriceOracle, including price feed reliability and manipulation resistance"",
        ""Review the integration with SavingsAccount, checking for potential exploits in deposit and withdrawal mechanisms"",
        ""Audit the strategy selection and interaction logic in collateral management"",
        ""Verify the robustness of cross-contract calls to IYield and IStrategyRegistry""
      ]
    },
    {
      ""Area"": ""Complex Logic Analysis"",
      ""Tasks"": [
        ""Deeply analyze the interest calculation mechanism for precision and potential rounding errors"",
        ""Review the collateralization ratio calculation and liquidation threshold logic"",
        ""Verify the borrowable amount calculation for potential exploitation"",
        ""Check the completeness of credit line state transitions (REQUESTED -> ACTIVE -> CLOSED/LIQUIDATED)"",
        ""Audit the auto-liquidation mechanism for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""Financial Risk Mitigation"",
      ""Tasks"": [
        ""Verify the protocol fee collection mechanism for potential manipulation"",
        ""Review the liquidator reward calculation for fairness and potential gaming"",
        ""Check the handling of bad debt scenarios during liquidation"",
        ""Analyze the risk management strategies for different asset types and volatility""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Review loop structures in functions like calculateTotalCollateralTokens() for potential gas inefficiencies"",
        ""Check the use of storage vs. memory in complex functions"",
        ""Analyze the efficiency of strategy-based collateral management"",
        ""Verify that external calls and state modifications are optimized""
      ]
    },
    {
      ""Area"": ""Upgradability and Initialization"",
      ""Tasks"": [
        ""Verify the correctness of the initializer function and its parameter validation"",
        ""Check for potential vulnerabilities in the upgradeable contract pattern"",
        ""Ensure proper initialization of all critical state variables"",
        ""Review the transfer of ownership during initialization""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Verify comprehensive error handling for all external function calls"",
        ""Check handling of zero-value transactions and edge case scenarios"",
        ""Review error messages for clarity and informativeness"",
        ""Ensure proper validation of input parameters across all functions""
      ]
    },
    {
      ""Area"": ""Oracle and Price Feed Security"",
      ""Tasks"": [
        ""Analyze the robustness of price feed integration in IPriceOracle"",
        ""Check for potential price manipulation vectors"",
        ""Verify handling of stale or unavailable price feeds"",
        ""Review the precision and decimal handling in price calculations""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the CreditLine smart contract, covering critical areas of security, functionality, and potential risks. Each area is broken down into specific, actionable tasks that will help ensure a thorough and methodical audit process.

The tasks are designed to:
1. Identify potential security vulnerabilities
2. Verify the correctness of complex financial logic
3. Ensure robust access control
4. Validate external contract interactions
5. Optimize gas efficiency
6. Check upgradability mechanisms
7. Analyze error handling and edge cases
8. Assess oracle and price feed security

Auditors should systematically work through these tasks, documenting findings, potential issues, and recommended improvements for each area.","I've carefully analyzed the provided smart contract code. Here's my audit report:

{
  ""ReviewingTheCode"": ""The CreditLine contract implements a decentralized credit line system where borrowers can request credit lines with collateral and lenders can approve them. It allows borrowers to deposit collateral, borrow against it, repay the borrowed amount with interest, and manages liquidation scenarios. The contract uses OpenZeppelin libraries for security, implements reentrancy protection, and employs an upgradeable pattern."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""CreditLine"",
    ""Purpose"": ""To facilitate collateralized lending between lenders and borrowers with customizable terms including interest rates, collateral ratios, and auto-liquidation features"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""OwnableUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""IPriceOracle.sol"",
        ""IYield.sol"",
        ""ISavingsAccount.sol"",
        ""SavingsAccountUtil.sol"",
        ""IStrategyRegistry.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""creditLineCounter"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Counter to generate unique IDs for credit lines""
      },
      {
        ""Name"": ""YEAR_IN_SECONDS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Constant representing the number of seconds in a year (365 days)""
      },
      {
        ""Name"": ""creditLineVariables"",
        ""Type"": ""mapping(uint256 => CreditLineVariables)"",
        ""Purpose"": ""Maps credit line IDs to their variable parameters like status, principal, and interest""
      },
      {
        ""Name"": ""creditLineConstants"",
        ""Type"": ""mapping(uint256 => CreditLineConstants)"",
        ""Purpose"": ""Maps credit line IDs to their constant parameters like lender, borrower, borrowRate""
      },
      {
        ""Name"": ""collateralShareInStrategy"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Maps credit line IDs to their collateral shares distributed across different strategies""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the SavingsAccount contract""
      },
      {
        ""Name"": ""priceOracle"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the PriceOracle contract""
      },
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StrategyRegistry contract""
      },
      {
        ""Name"": ""defaultStrategy"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the default investment strategy""
      },
      {
        ""Name"": ""protocolFeeFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Protocol fee percentage in 10^30 precision""
      },
      {
        ""Name"": ""protocolFeeCollector"",
        ""Type"": ""address"",
        ""Purpose"": ""Address that collects protocol fees""
      },
      {
        ""Name"": ""liquidatorRewardFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Liquidator reward percentage in 10^30 precision""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""ifCreditLineExists"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures that a credit line with the given ID exists"",
        ""Parameters"": [""uint256 _id""]
      },
      {
        ""Name"": ""onlyCreditLineBorrower"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the borrower of the credit line"",
        ""Parameters"": [""uint256 _id""]
      },
      {
        ""Name"": ""onlyCreditLineLender"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the lender of the credit line"",
        ""Parameters"": [""uint256 _id""]
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with required parameters (used instead of constructor for upgradeability)"",
        ""Parameters"": [""address _defaultStrategy"", ""address _priceOracle"", ""address _savingsAccount"", ""address _strategyRegistry"", ""address _owner"", ""uint256 _protocolFeeFraction"", ""address _protocolFeeCollector"", ""uint256 _liquidatorRewardFraction""]
      },
      {
        ""Name"": ""calculateInterest"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates interest based on principal, rate, and time elapsed"",
        ""Parameters"": [""uint256 _principal"", ""uint256 _borrowRate"", ""uint256 _timeElapsed""],
        ""Returns"": [""uint256 interest""]
      },
      {
        ""Name"": ""calculateInterestAccrued"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates interest accrued for a specific credit line since last update"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 interestAccrued""]
      },
      {
        ""Name"": ""calculateCurrentDebt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates total current debt (principal + accumulated interest) for a credit line"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 currentDebt""]
      },
      {
        ""Name"": ""calculateBorrowableAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates how much a borrower can borrow based on collateral and debt"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 borrowableAmount""]
      },
      {
        ""Name"": ""request"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a credit line request with specified terms"",
        ""Parameters"": [""address _requestTo"", ""uint256 _borrowLimit"", ""uint256 _borrowRate"", ""bool _autoLiquidation"", ""uint256 _collateralRatio"", ""address _borrowAsset"", ""address _collateralAsset"", ""bool _requestAsLender""],
        ""Returns"": [""uint256 creditLineId""]
      },
      {
        ""Name"": ""accept"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the non-requesting party to accept a credit line request"",
        ""Parameters"": [""uint256 _id""]
      },
      {
        ""Name"": ""depositCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits collateral for a credit line"",
        ""Parameters"": [""uint256 _id"", ""uint256 _amount"", ""address _strategy"", ""bool _fromSavingsAccount""]
      },
      {
        ""Name"": ""borrow"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows borrower to borrow against their collateral"",
        ""Parameters"": [""uint256 _id"", ""uint256 _amount""]
      },
      {
        ""Name"": ""repay"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Repays borrowed amount with accrued interest"",
        ""Parameters"": [""uint256 _id"", ""uint256 _amount"", ""bool _fromSavingsAccount""]
      },
      {
        ""Name"": ""close"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes a credit line after full repayment"",
        ""Parameters"": [""uint256 _id""]
      },
      {
        ""Name"": ""calculateCurrentCollateralRatio"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates current collateral-to-debt ratio"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 collateralRatio""]
      },
      {
        ""Name"": ""calculateTotalCollateralTokens"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates total collateral tokens across all strategies"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""withdrawCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows borrower to withdraw excess collateral"",
        ""Parameters"": [""uint256 _id"", ""uint256 _amount"", ""bool _toSavingsAccount""]
      },
      {
        ""Name"": ""withdrawableCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates how much collateral can be withdrawn while maintaining the ideal ratio"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 withdrawableAmount""]
      },
      {
        ""Name"": ""liquidate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates a credit line if collateral ratio falls below ideal"",
        ""Parameters"": [""uint256 _id"", ""bool _toSavingsAccount""]
      },
      {
        ""Name"": ""borrowTokensToLiquidate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates how many tokens are needed to liquidate a position"",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256 borrowTokens""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IPriceOracle - Used to get asset price feeds for collateralization calculations"",
    ""ISavingsAccount - For managing deposits, withdrawals, and transfers of collateral"",
    ""IYield - For interacting with yield strategies"",
    ""IStrategyRegistry - For retrieving available investment strategies"",
    ""IERC20 - For token transfers and approvals"",
    ""ETH transfers - Contract can receive and send ETH""
  ],
  
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern using OpenZeppelin's upgradeable contracts"",
    ""Interest calculation using time-based accrual"",
    ""Collateralization ratio management for loan health"",
    ""Auto-liquidation mechanism when collateral ratio falls below ideal"",
    ""Protocol fee collection on borrowing"",
    ""Liquidator reward system to incentivize timely liquidations"",
    ""Strategy-based collateral management across different yield strategies""
  ],
  
  ""Questions"": [
    ""How are price feeds maintained and updated in the PriceOracle contract?"",
    ""What happens if a price feed becomes unavailable or stale during critical operations?"",
    ""How are liquidation thresholds determined, and is there any time-based buffer before liquidation?"",
    ""Is there a circuit breaker or pause mechanism in case of extreme market volatility?"",
    ""How are upgrades to the contract managed and who has the authority to perform them?"",
    ""What precision is used for interest rate calculations and could there be rounding errors?"",
    ""Is there any mechanism to handle bad debt in case liquidation doesn't cover the full loan amount?"",
    ""How are different collateral types valued and what slippage is expected during liquidation?"",
    ""What happens if the SavingsAccount or strategy contracts have issues or are compromised?""
  ]
}","I've analyzed the provided security findings for the CreditLine contract. I've identified common issues across the different analyses and consolidated them while preserving important details.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerabilities in critical functions"",
      ""Severity"": ""High"",
      ""Description"": ""Despite using ReentrancyGuard, several functions in the contract make external calls before updating state variables, violating the checks-effects-interactions pattern. Functions like repay(), borrow(), withdrawCollateral(), and liquidate() interact with external contracts through _transferCollateral, _withdrawBorrowAmount, and other internal functions before updating critical state variables."",
      ""Impact"": ""Attackers could potentially reenter the contract during execution and manipulate state, potentially draining collateral, exploiting debt calculations, or stealing funds through multiple withdrawals."",
      ""Location"": ""repay(), borrow(), withdrawCollateral(), liquidate() functions and supporting internal functions like _transferCollateral(), _withdrawBorrowAmount(), _repay()""
    },
    {
      ""Issue"": ""Oracle manipulation and price vulnerability risks"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies heavily on price oracle data for critical operations such as calculating collateral ratios, liquidation thresholds, and borrowable amounts. There are no safeguards against price manipulation, flash loan attacks, or stale price data. The contract lacks slippage protection and doesn't implement time-weighted average prices (TWAP) or multi-oracle verification."",
      ""Impact"": ""Malicious actors could manipulate price feeds temporarily to trigger unfair liquidations, borrow more than they should with insufficient collateral, or extract value from the protocol through flash loan attacks."",
      ""Location"": ""calculateCurrentCollateralRatio(), calculateBorrowableAmount(), withdrawableCollateral(), _borrowTokensToLiquidate(), and liquidate() functions""
    },
    {
      ""Issue"": ""Incorrect collateral calculation during liquidation"",
      ""Severity"": ""High"",
      ""Description"": ""In the liquidate function, _borrowTokensToLiquidate calculates a reward for liquidators but doesn't properly verify that the collateral value is sufficient to cover both the debt and the liquidator reward. The liquidation mechanism lacks protections against flash crashes or brief market volatility."",
      ""Impact"": ""In certain market conditions, liquidators might receive excessive rewards, causing borrowers to lose more collateral than necessary or lenders to receive insufficient funds. Users could have their collateral liquidated during brief market volatility, even if the price quickly recovers."",
      ""Location"": ""liquidate() function and _borrowTokensToLiquidate() function""
    },
    {
      ""Issue"": ""Integer overflow/underflow risks in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using SafeMath, several functions perform complex calculations with large numbers, multiply before division, or use constants like 10^30 that could lead to overflows or precision loss. Functions like calculateInterest() multiply large values before division, which could lead to overflow for large principal amounts, high borrow rates, or long time periods."",
      ""Impact"": ""Arithmetic errors could lead to incorrect interest calculations, collateral ratio errors, or transaction failures. This could result in unfair liquidations, incorrect borrowing limits, or locked funds."",
      ""Location"": ""calculateInterest(), calculateBorrowableAmount(), calculateCurrentCollateralRatio(), _borrowTokensToLiquidate() functions""
    },
    {
      ""Issue"": ""Lack of input validation in critical functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions including initialize(), request(), and parameter update functions lack thorough input validation. For example, the request() function doesn't properly validate that collateral ratio, borrow rate, and other parameters are within reasonable bounds. Critical parameters like borrowRate and collateralRatio have no upper limits or sanity checks."",
      ""Impact"": ""Setting extreme values for these parameters could break the economics of the lending system, potentially allowing creation of credit lines with impractical or insecure terms that might result in immediate liquidation, predatory lending terms, or excessive borrowing."",
      ""Location"": ""initialize(), request(), _createRequest(), and parameter-setting functions""
    },
    {
      ""Issue"": ""Centralization risks with admin functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract owner has significant control over critical parameters like fees, oracles, strategies, and contract addresses without timelocks or governance mechanisms. Critical parameters like defaultStrategy, priceOracle, protocolFeeFraction, and liquidatorRewardFraction can all be changed by the owner without any safeguards."",
      ""Impact"": ""A compromised or malicious owner could manipulate protocol parameters to extract excessive value through fees, redirect funds to attacker-controlled addresses, or force liquidations through oracle manipulations."",
      ""Location"": ""updateProtocolFeeFraction(), updateProtocolFeeCollector(), updateDefaultStrategy(), updatePriceOracle(), and other admin functions with onlyOwner modifier""
    },
    {
      ""Issue"": ""Unchecked return values from external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions make external calls to other contracts but don't properly check return values, particularly when interacting with the ISavingsAccount and IYield interfaces, or when using low-level .call() for ETH transfers."",
      ""Impact"": ""If the underlying contracts don't behave as expected or transfers fail silently, it could lead to inconsistent state or lost funds. Failed operations could leave the contract in an inconsistent state where accounting doesn't match actual token balances."",
      ""Location"": ""_withdrawBorrowAmount(), _transferCollateral(), and borrow() functions""
    },
    {
      ""Issue"": ""Gas limitations in loops over strategies"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like calculateTotalCollateralTokens(), _depositCollateralFromSavingsAccount(), _withdrawBorrowAmount(), and _transferCollateral iterate through all registered strategies without any upper limit on the number of iterations, which could lead to out-of-gas errors if there are too many strategies."",
      ""Impact"": ""If the number of strategies grows beyond a certain point, functions might become unusable due to exceeding block gas limits. This could prevent critical operations like collateral deposits, withdrawals, or liquidations, potentially locking user funds."",
      ""Location"": ""calculateTotalCollateralTokens(), _depositCollateralFromSavingsAccount(), _withdrawBorrowAmount(), _transferCollateral(), and similar functions with strategy loops""
    },
    {
      ""Issue"": ""No zero-address checks in critical functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions don't validate that address parameters aren't the zero address. While some addresses are checked in update functions, others like depositCollateral() and _repay() don't verify that asset addresses aren't zero. This is especially important when dealing with ERC20 tokens."",
      ""Impact"": ""Funds could be sent to the zero address, resulting in permanent loss. Potential loss of collateral if deposited to an invalid or non-existent strategy."",
      ""Location"": ""depositCollateral() function, _repay() function, request() function, accept() function""
    },
    {
      ""Issue"": ""Lack of emergency pause mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks an emergency pause mechanism that could halt operations in case of detected vulnerabilities or unexpected behavior. This is especially concerning for a financial contract managing potentially significant assets."",
      ""Impact"": ""If a vulnerability is discovered, there's no way to quickly pause operations to prevent exploits while a fix is developed, potentially putting user funds at risk for an extended period."",
      ""Location"": ""Throughout the contract""
    },
    {
      ""Issue"": ""Potential ETH loss in receive() function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The receive() function only accepts ETH from the savingsAccount address, but doesn't have any mechanism to handle or use the received ETH. There's no clear path for this ETH to be utilized."",
      ""Impact"": ""ETH sent to the contract might become trapped without a way to retrieve it."",
      ""Location"": ""receive() function""
    },
    {
      ""Issue"": ""Unsafe ERC20 operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract mostly uses SafeERC20, but some operations call raw approve() which can fail silently for non-compliant tokens."",
      ""Impact"": ""Approvals could fail without reverting, causing subsequent operations to fail unexpectedly."",
      ""Location"": ""Functions _depositCollateral and _repay""
    },
    {
      ""Issue"": ""Lack of slippage protection for token transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""When converting between tokens and shares in functions like _depositCollateral, there's no minimum amount check, which could lead to front-running or sandwich attacks."",
      ""Impact"": ""Borrowers or lenders could receive fewer tokens than expected due to price manipulation, affecting the solvency of credit lines."",
      ""Location"": ""Functions interacting with external protocols like _depositCollateral, _withdrawBorrowAmount""
    },
    {
      ""Issue"": ""Insufficient ETH validation in _repay function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _repay function, when the borrowAsset is ETH (address(0)), it checks if msg.value == _amount, but doesn't handle the case where excess ETH is sent."",
      ""Impact"": ""If a user sends more ETH than needed, the excess ETH will be locked in the contract with no way to retrieve it."",
      ""Location"": ""_repay function""
    },
    {
      ""Issue"": ""Missing event emission in state-changing functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several critical operations don't emit events with sufficient information, making it difficult to track off-chain. Functions like updateinterestAccruedTillLastPrincipalUpdate(), _resetCreditLine(), and state changes in _transferCollateral don't emit events to track these state changes."",
      ""Impact"": ""Limited transparency and auditability of critical operations, complicating incident response and user monitoring. Reduces transparency and makes it harder for users and interfaces to track state changes."",
      ""Location"": ""updateinterestAccruedTillLastPrincipalUpdate() function, _resetCreditLine() function, _transferCollateral() and other internal functions that handle significant asset movements""
    },
    {
      ""Issue"": ""Lack of time-bound constraints in interest calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculateInterest function doesn't have any constraints on the _timeElapsed parameter, which means interest could be calculated for extremely long periods potentially leading to very large interest accruals."",
      ""Impact"": ""If a credit line remains active for an extremely long period, the interest calculation might result in unreasonably high amounts."",
      ""Location"": ""calculateInterest() function""
    },
    {
      ""Issue"": ""Inconsistent error handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a mix of require statements and reverts with custom messages. This inconsistency makes error handling more difficult for client applications."",
      ""Impact"": ""Reduces usability and makes integration more complex."",
      ""Location"": ""Throughout the contract""
    }
  ],
  ""IssueNumber"": 70,
  ""OutputList"": 17
}",405.924029350281,135548.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way**

**Report Description**:  
The `_borrowTokensToLiquidate` function in `CreditLine.sol` incorrectly consults the price oracle for the ratio of `borrowToken / collateralToken` instead of the inverse (`collateralToken / borrowToken`). This could lead to incorrect liquidation calculations, potentially causing unfair liquidations or incorrect collateral distributions.

**Match in Response List**:  
Matches with the issue titled **""Oracle manipulation and price vulnerability risks""**.

**Validation**:  
**Partially Correct**. The response identifies the general risk of oracle manipulation and price vulnerabilities, which is relevant to the issue. However, it does not specifically address the incorrect usage of the oracle in `_borrowTokensToLiquidate`, which is the core of the reported issue. The response focuses on broader oracle risks (e.g., flash loan attacks, stale data) rather than the specific implementation error.

---

#### **[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**

**Report Description**:  
When `autoLiquidation` is set to `false`, only the lender should be able to liquidate the credit line. However, the implementation allows anyone to liquidate without supplying the required `borrowTokens`. This results in the liquidator receiving all collateral, causing significant losses to the lender.

**Match in Response List**:  
**No match found**.

**Validation**:  
The response list does not address this specific issue. The reported vulnerability is a critical access control flaw with severe financial implications, but it is not covered in the response list.

---

#### **[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**

**Report Description**:  
The `liquidate` function fails to transfer borrowed ETH to the lender, leaving the funds in the contract. While the funds are not lost, manual intervention is required to recover them, leading to operational inefficiencies and potential disputes.

**Match in Response List**:  
**No match found**.

**Validation**:  
The response list does not address this issue. The reported problem is a specific implementation flaw in the `liquidate` function, which is not covered in the response list.

---

#### **[M-08] Missing approve(0)**

**Report Description**:  
The contract calls `IERC20.approve()` without first setting the allowance to zero. This can cause transactions to revert when interacting with tokens like USDT, which require the allowance to be reset to zero before approval.

**Match in Response List**:  
Matches with the issue titled **""Unsafe ERC20 operations""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unsafe ERC20 operations, specifically mentioning the use of raw `approve()` without handling non-compliant tokens like USDT. This aligns with the reported issue and addresses the core problem.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-08] Missing approve(0)**

**Partially Correct Matches**:

- **[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way**

**Missed Issues from Issue Report**:

- **[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**
- **[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**

---

### **Analysis of Gaps**

1. **Access Control Flaws**:  
   The response list does not address the critical access control issue in **[H-06]**, which allows unauthorized liquidation and bypasses the requirement to supply `borrowTokens`. This is a significant oversight, as it directly impacts the security and financial integrity of the protocol.

2. **ETH Transfer Issues**:  
   The response list misses the issue in **[M-02]**, where borrowed ETH is not transferred to the lender during liquidation. This is a specific implementation flaw that could lead to operational inefficiencies and disputes.

3. **Oracle Implementation Errors**:  
   While the response list covers general oracle risks, it does not specifically address the incorrect usage of the oracle in **[H-01]**. This highlights a gap in identifying specific implementation errors versus broader risks.

---

### **Recommendations**

1. **Expand Coverage of Access Control Issues**:  
   The response list should include vulnerabilities related to improper access control, especially in critical functions like liquidation.

2. **Address Specific Implementation Flaws**:  
   The response list should focus on specific implementation errors (e.g., incorrect oracle usage, missing ETH transfers) in addition to broader risks.

3. **Include ETH Handling Issues**:  
   The response list should cover issues related to ETH handling, such as failed transfers or trapped ETH, which are common in smart contracts.

By addressing these gaps, the response list can provide more comprehensive coverage of the reported issues and better align with Solidity best practices and security standards.",1,1,2,17,"```
1. Unsafe ERC20 operations
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unsafe ERC20 operations"".
   - In the ranked list of predictions, ""Unsafe ERC20 operations"" appears at rank **13**.

2. **Calculate the precision at rank 13**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 13, \( P@13 = \frac{1}{13} \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = P@13 = \frac{1}{13} \).

**Output**:
```
0.07692307692307693
```"
SavingsAccountUtil.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            //pool
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",989.0,128.0,"[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss

Submitted by WatchPug
The function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.
 However, since savingsAccountTransfer() does not return the result of _savingsAccount.transfer(), but returned _amount instead, which means that SavingsAccountUtil.depositFromSavingsAccount() may not return the actual shares (when pps is not 1).",1.0,,"pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",979.0,1.0,0.0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze potential reentrancy risks in token transfer and withdrawal functions"",
        ""Verify SafeERC20 implementation prevents common ERC20 transfer vulnerabilities"",
        ""Check for integer overflow/underflow risks in amount calculations"",
        ""Validate low-level ETH transfer calls for potential security weaknesses"",
        ""Examine conditional logic for potential bypassing of security checks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Thoroughly review ISavingsAccount interface implementation details"",
        ""Validate strategy parameter usage and potential attack vectors"",
        ""Verify token approval mechanisms and potential allowance manipulation"",
        ""Check for proper validation of external contract calls"",
        ""Assess the security of cross-contract interactions""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Analyze ETH and ERC20 token handling logic for edge cases"",
        ""Verify precise token transfer mechanisms"",
        ""Check handling of tokens with non-standard transfer behaviors"",
        ""Validate share conversion and token amount calculations"",
        ""Ensure proper handling of zero-value and dust amount transfers""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review access control mechanisms in deposit and withdrawal functions"",
        ""Verify address validation and permission checks"",
        ""Check for potential unauthorized transfer vulnerabilities"",
        ""Assess the scope of internal function permissions""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in token transfer and savings account operations"",
        ""Identify potential gas optimization opportunities"",
        ""Review conditional logic for gas efficiency"",
        ""Check for redundant computations or unnecessary operations""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Review error handling and require statement coverage"",
        ""Verify comprehensive error messaging"",
        ""Check for proper handling of failed token transfers"",
        ""Assess graceful failure mechanisms"",
        ""Validate error propagation across different function calls""
      ]
    },
    {
      ""Area"": ""Decimal Precision"",
      ""Tasks"": [
        ""Analyze potential precision loss in token and share conversions"",
        ""Verify handling of tokens with different decimal places"",
        ""Check rounding mechanisms and their potential impact"",
        ""Assess potential economic vulnerabilities from precision issues""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify adherence to ERC20 standard requirements"",
        ""Check compatibility with different token implementations"",
        ""Assess library's flexibility with various token types"",
        ""Review strategy compatibility and standardization""
      ]
    }
  ],
  ""KeyObservationsAndRationale"": [
    ""The task list covers comprehensive security, functional, and optimization aspects."",
    ""Tasks are specifically tailored to the SavingsAccountUtil library's unique characteristics."",
    ""Prioritizes identifying potential vulnerabilities in complex token interaction logic."",
    ""Focuses on both technical implementation details and broader security considerations.""
  ],
  ""RecommendedNextSteps"": [
    ""Conduct a detailed line-by-line review following these task categories"",
    ""Use static analysis tools to complement manual audit"",
    ""Perform extensive testing with various token types and edge cases"",
    ""Consider formal verification for critical sections of the code""
  ]
}
","{
  ""ReviewingTheCode"": ""This code is a library called SavingsAccountUtil that provides utility functions for interacting with a savings account system. It handles operations like depositing, withdrawing, and transferring tokens both directly and through a savings account interface. The library implements various patterns for token handling, including special consideration for ETH (represented as address(0)) and ERC20 tokens."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SavingsAccountUtil"",
    ""Purpose"": ""A utility library that facilitates operations with a savings account system, handling deposits, withdrawals, and transfers of both ETH and ERC20 tokens."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": [
        ""../interfaces/ISavingsAccount.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol""
      ]
    },
    ""StateVariables"": [],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""depositFromSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles deposit from a savings account to either another savings account or a direct wallet"",
        ""Parameters"": [
          ""_savingsAccount (ISavingsAccount): The savings account interface"",
          ""_from (address): Source address"",
          ""_to (address): Destination address"",
          ""_amount (uint256): Amount to deposit"",
          ""_token (address): Token address (address(0) for ETH)"",
          ""_strategy (address): Strategy address for the savings account"",
          ""_withdrawShares (bool): Whether to withdraw shares or tokens"",
          ""_toSavingsAccount (bool): Whether the destination is a savings account""
        ],
        ""Returns"": [""uint256: Amount of tokens or shares received""]
      },
      {
        ""Name"": ""directDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles direct deposit to either a savings account or a wallet"",
        ""Parameters"": [
          ""_savingsAccount (ISavingsAccount): The savings account interface"",
          ""_from (address): Source address"",
          ""_to (address): Destination address"",
          ""_amount (uint256): Amount to deposit"",
          ""_token (address): Token address (address(0) for ETH)"",
          ""_toSavingsAccount (bool): Whether the destination is a savings account"",
          ""_strategy (address): Strategy address for the savings account""
        ],
        ""Returns"": [""uint256: Amount of tokens or shares received""]
      },
      {
        ""Name"": ""directSavingsAccountDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits tokens directly to a savings account"",
        ""Parameters"": [
          ""_savingsAccount (ISavingsAccount): The savings account interface"",
          ""_from (address): Source address"",
          ""_to (address): Destination address"",
          ""_amount (uint256): Amount to deposit"",
          ""_token (address): Token address (address(0) for ETH)"",
          ""_strategy (address): Strategy address for the savings account""
        ],
        ""Returns"": [""uint256 _sharesReceived: Amount of shares received""]
      },
      {
        ""Name"": ""savingsAccountTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens between savings accounts"",
        ""Parameters"": [
          ""_savingsAccount (ISavingsAccount): The savings account interface"",
          ""_from (address): Source address"",
          ""_to (address): Destination address"",
          ""_amount (uint256): Amount to transfer"",
          ""_token (address): Token address (address(0) for ETH)"",
          ""_strategy (address): Strategy address for the savings account""
        ],
        ""Returns"": [""uint256: Amount transferred""]
      },
      {
        ""Name"": ""withdrawFromSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws tokens from a savings account"",
        ""Parameters"": [
          ""_savingsAccount (ISavingsAccount): The savings account interface"",
          ""_from (address): Source address"",
          ""_to (address): Destination address"",
          ""_amount (uint256): Amount to withdraw"",
          ""_token (address): Token address (address(0) for ETH)"",
          ""_strategy (address): Strategy address for the savings account"",
          ""_withdrawShares (bool): Whether to withdraw shares or tokens""
        ],
        ""Returns"": [""uint256 _amountReceived: Amount of tokens received""]
      },
      {
        ""Name"": ""transferTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers ETH or ERC20 tokens between addresses"",
        ""Parameters"": [
          ""_token (address): Token address (address(0) for ETH)"",
          ""_amount (uint256): Amount to transfer"",
          ""_from (address): Source address"",
          ""_to (address): Destination address""
        ],
        ""Returns"": [""uint256: Amount transferred""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ISavingsAccount interface for interacting with a savings account contract"",
    ""SafeERC20 for safe ERC20 token transfers"",
    ""ERC20 token contracts through IERC20 interface"",
    ""ETH transfers through low-level call""
  ],
  ""SpecialMechanisms"": [
    ""ETH handling using address(0) as token address and low-level calls"",
    ""Conditional logic for token transfers based on source and destination types"",
    ""Different deposit/withdrawal flows based on whether operation involves savings accounts"",
    ""Support for strategy-based deposits in savings accounts"",
    ""Handling of both direct token transfers and share-based operations""
  ],
  ""Questions"": [
    ""What is the purpose of the _strategy parameter and how are different strategies implemented?"",
    ""Why is ReentrancyGuard imported but not used in the library?"",
    ""How does the ISavingsAccount interface define the various methods being called (deposit, withdraw, transfer, etc.)?"",
    ""What security mechanisms exist in the ISavingsAccount implementation to prevent unauthorized withdrawals?"",
    ""Is there proper validation in the ISavingsAccount implementation for the _withdrawShares parameter?"",
    ""When handling ETH transfers, is the contract accounting for gas costs properly?"",
    ""Is there comprehensive error handling for failed token transfers beyond the basic require statements?"",
    ""How does the system handle potential precision loss when converting between tokens and shares?""
  ]
}
","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in transferTokens function"",
      ""Severity"": ""Critical"",
      ""Description"": ""Multiple instances of reentrancy vulnerability were found in the transferTokens function where ETH transfers are performed using low-level calls without proper reentrancy protection. Although ReentrancyGuard is imported, it's not applied to library functions. External calls are made before state changes, allowing potential reentrant calls."",
      ""Impact"": ""Malicious contracts receiving ETH could reenter and manipulate contract state, potentially leading to fund theft or unexpected behavior."",
      ""Location"": ""transferTokens function (ETH transfer logic using .call{value:})""
    },
    {
      ""Issue"": ""Unchecked return values from transfer operations"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions call external transfer operations (transfer/transferFrom) but don't check return values. This includes savingsAccountTransfer, withdrawFromSavingsAccount, and other functions interacting with ISavingsAccount."",
      ""Impact"": ""Silent failures could occur where operations appear successful but actually failed, leading to accounting inconsistencies or loss of funds."",
      ""Location"": ""savingsAccountTransfer function and other functions making external calls""
    },
    {
      ""Issue"": ""Unsafe ERC20 approval pattern"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple instances found where safeApprove is used without first setting allowance to zero. This affects directSavingsAccountDeposit and other functions performing token approvals."",
      ""Impact"": ""Transactions may fail with certain ERC20 tokens (like USDT) that require allowance reset, causing denial of service for those tokens."",
      ""Location"": ""directSavingsAccountDeposit function and other approval functions""
    },
    {
      ""Issue"": ""ETH value handling vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple issues with ETH handling including: inconsistent validation between functions, potential double-spending of msg.value, incorrect refund recipient (msg.sender instead of _from), and ETH getting locked in contract."",
      ""Impact"": ""Could lead to loss of funds, incorrect accounting, or unexpected behavior in ETH transfers."",
      ""Location"": ""transferTokens function and other ETH handling functions""
    },
    {
      ""Issue"": ""Missing zero address validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions accept address parameters without validating they're not zero addresses (except when explicitly checking for ETH). This affects _to, _from, _token, and _strategy parameters."",
      ""Impact"": ""Tokens or ETH could be accidentally sent to the zero address, resulting in permanent loss of funds."",
      ""Location"": ""All functions handling address parameters""
    },
    {
      ""Issue"": ""Lack of input validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions lack validation for critical parameters like _amount (not checking >0) and contract addresses (not verifying they contain code)."",
      ""Impact"": ""Could lead to unexpected behavior, failed transactions, or interaction with invalid contracts."",
      ""Location"": ""Throughout the library functions""
    },
    {
      ""Issue"": ""Insufficient error handling and feedback"",
      ""Severity"": ""Medium"",
      ""Description"": ""Generic error messages ('Transfer failed') and lack of specific error handling make debugging difficult. Some functions return hardcoded values regardless of operation success."",
      ""Impact"": ""Difficult troubleshooting and poor user experience when operations fail. Callers may receive incorrect success indications."",
      ""Location"": ""Error messages and return values throughout the library""
    },
    {
      ""Issue"": ""Lack of event emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""No events are emitted for important operations like deposits, withdrawals, and transfers, making off-chain tracking difficult."",
      ""Impact"": ""Reduced transparency and auditability of contract operations."",
      ""Location"": ""Throughout the library""
    },
    {
      ""Issue"": ""Unused ReentrancyGuard import"",
      ""Severity"": ""Low"",
      ""Description"": ""ReentrancyGuard is imported but not used in the library, creating potential confusion about security measures."",
      ""Impact"": ""Code bloat and misleading security assumptions for developers."",
      ""Location"": ""Library imports section""
    }
  ],
  ""IssueNumber"": 39,
  ""OutputList"": 9
}",1105.81838583946,100740.0,114.0,"---

**[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

**Report Description**:  
The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for a given `_asset`. However, the function `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()` but instead returns `_amount`. This means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares when the price per share (pps) is not 1. This discrepancy can lead to incorrect accounting and potential fund loss.

**Match in Response List**:  
Matches with the issue titled **""Unchecked return values from transfer operations""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unchecked return values from transfer operations, which is related to the core problem described in the issue report. However, the response does not specifically address the incorrect return value of `SavingsAccountUtil.depositFromSavingsAccount()` and its impact on fund accounting when the price per share is not 1. While the response covers the broader issue of unchecked return values, it misses the critical detail of how this affects the specific function and its expected behavior.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

**Missed Issues from Issue Report**:  
- *None*

---",0,0,1,0,"```
None.
```",0.0
Pool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",10152.0,1045.0,"[H-03] denial of service

Submitted by certora
https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.
  [M-03] Collateral can be deposited in a finished pool

The `_depositCollateral` function doesn't check the status of the pool so collateral can be deposited in a finished loan. This can happen by mistake and all funds will be lost.
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207",2.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';


contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, 
        ACTIVE, 
        CLOSED, 
        CANCELLED, 
        DEFAULTED, 
        TERMINATED 
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; 
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    
    mapping(address => LendingDetails) public lenders;

    
    PoolConstants public poolConstants;

    
    PoolVariables public poolVariables;

    
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        

        
        
        
        
        
        
        
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            
            _withdrawRepayment(msg.sender);
        }
        
        _burn(msg.sender, _actualBalance);

        
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    
    receive() external payable {}

    
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",7067.0,1.0,1.0,"Based on the comprehensive initial analysis, I'll create a detailed task list for auditing this DeFi lending pool contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze reentrancy protection in external calls, especially in deposit and withdrawal functions"",
        ""Verify SafeMath library usage for all arithmetic operations to prevent integer overflow/underflow"",
        ""Check for potential unhandled edge cases in margin call and liquidation mechanisms"",
        ""Validate input validation and sanitization in all external and public functions"",
        ""Review access control modifiers for comprehensive protection against unauthorized actions""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all external contract calls to price oracles for potential manipulation risks"",
        ""Verify the integrity of interactions with IPoolFactory, IYield, and ISavingsAccount interfaces"",
        ""Analyze potential attack vectors in cross-contract method calls"",
        ""Check for proper error handling in external contract interactions"",
        ""Validate that all external calls have appropriate checks and balances""
      ]
    },
    {
      ""Area"": ""Collateral and Liquidation Mechanism"",
      ""Tasks"": [
        ""Deeply analyze the collateral ratio calculation logic for potential vulnerabilities"",
        ""Verify the margin call and liquidation process for fairness and completeness"",
        ""Check the penalty calculation mechanism for potential gaming or exploitation"",
        ""Validate the token transfer logic during liquidation and margin calls"",
        ""Review the logic for handling different pool states during liquidation""
      ]
    },
    {
      ""Area"": ""Financial Calculations"",
      ""Tasks"": [
        ""Audit interest calculation methods for precision and potential rounding errors"",
        ""Verify the proportional repayment distribution logic"",
        ""Check all token conversion and price calculation methods"",
        ""Validate fee calculation and distribution mechanisms"",
        ""Review the handling of different decimal precisions in financial calculations""
      ]
    },
    {
      ""Area"": ""Access Control and Governance"",
      ""Tasks"": [
        ""Comprehensively review all access control modifiers"",
        ""Verify the owner and role-based access control implementation"",
        ""Check the initialization process for potential security gaps"",
        ""Validate the emergency pause and termination mechanisms"",
        ""Review the lender verification process and its effectiveness""
      ]
    },
    {
      ""Area"": ""Contract Upgradeability"",
      ""Tasks"": [
        ""Audit the Initializable pattern implementation"",
        ""Verify the upgrade mechanism's security"",
        ""Check for potential storage collision risks"",
        ""Validate the initialization process for preventing multiple initializations"",
        ""Review the proxy contract interactions""
      ]
    },
    {
      ""Area"": ""Performance and Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in critical functions"",
        ""Check for unnecessary storage reads and writes"",
        ""Verify the efficiency of complex calculations"",
        ""Review loop structures and potential gas-intensive operations"",
        ""Assess the impact of multiple external contract calls on gas costs""
      ]
    },
    {
      ""Area"": ""Token Mechanics"",
      ""Tasks"": [
        ""Audit the ERC20 token implementation, including transfer and balance logic"",
        ""Verify token minting and burning mechanisms"",
        ""Check the handling of token transfers during different pool states"",
        ""Validate the token balance tracking for lenders"",
        ""Review the interaction between pool tokens and underlying assets""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Identify and test potential edge cases in loan lifecycle"",
        ""Verify error handling in critical functions"",
        ""Check the behavior during extreme market conditions"",
        ""Validate the handling of failed external calls"",
        ""Review error message clarity and informativeness""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the smart contract, covering critical areas of security, functionality, and performance. Each area includes specific, actionable tasks that will help thoroughly examine the contract's implementation and potential vulnerabilities.

The tasks are designed to:
1. Identify potential security risks
2. Verify the correctness of complex financial mechanisms
3. Ensure robust access control
4. Check for potential optimization opportunities
5. Validate error handling and edge case management

Would you like me to elaborate on any specific area or provide more detailed guidance for any of these tasks?","I've conducted a thorough audit of the provided smart contract. Here are my findings:

{
  ""ReviewingTheCode"": ""The code presents a lending pool contract that enables users to lend assets to borrowers with collateral requirements. It includes features like margin calls, liquidation mechanisms, repayment tracking, and various pool states to manage the lifecycle of loans."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Pool"",
    ""Purpose"": ""A DeFi lending protocol that manages collateralized loans between lenders and borrowers with specific terms and conditions"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC20PausableUpgradeable"",
        ""IPool"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""SafeERC20"",
        ""SafeMath"",
        ""ReentrancyGuard"",
        ""Initializable"",
        ""ERC20PausableUpgradeable"",
        ""IPoolFactory"",
        ""IPriceOracle"",
        ""IYield"",
        ""IRepayment"",
        ""ISavingsAccount"",
        ""SavingsAccountUtil"",
        ""IPool"",
        ""IExtension"",
        ""IVerification""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""poolFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the factory contract that creates pool instances""
      },
      {
        ""Name"": ""LoanStatus enum"",
        ""Type"": ""enum"",
        ""Purpose"": ""Defines possible states of a loan: COLLECTION, ACTIVE, CLOSED, CANCELLED, DEFAULTED, TERMINATED""
      },
      {
        ""Name"": ""lenders"",
        ""Type"": ""mapping(address => LendingDetails)"",
        ""Purpose"": ""Maps lender addresses to their lending details including interest withdrawn and margin call data""
      },
      {
        ""Name"": ""poolConstants"",
        ""Type"": ""PoolConstants struct"",
        ""Purpose"": ""Stores immutable loan parameters like borrower, amounts, ratios, assets, etc.""
      },
      {
        ""Name"": ""poolVariables"",
        ""Type"": ""PoolVariables struct"",
        ""Purpose"": ""Stores mutable pool state variables like liquidity shares and loan status""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the pool with loan parameters"",
        ""Parameters"": [""Multiple loan parameters including amounts, rates, addresses, durations""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows depositing additional collateral"",
        ""Parameters"": [""amount"", ""transferFromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralInMarginCall"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds collateral to cover a margin call for a lender"",
        ""Parameters"": [""lender"", ""amount"", ""transferFromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawBorrowedAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows borrower to withdraw borrowed funds when conditions are met"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to lend tokens to the pool"",
        ""Parameters"": [""lender"", ""amount"", ""strategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancels the pool, returning collateral minus penalty"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidatePool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates the pool when borrower defaults"",
        ""Parameters"": [""fromSavingsAccount"", ""toSavingsAccount"", ""receiveLiquidityShare""],
        ""Returns"": []
      },
      {
        ""Name"": ""requestMarginCall"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Lender requests a margin call when collateral ratio drops below ideal"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidateForLender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates collateral for a specific lender who failed margin call"",
        ""Parameters"": [""lender"", ""fromSavingsAccount"", ""toSavingsAccount"", ""receiveLiquidityShare""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawRepayment"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows lender to withdraw repaid amounts"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows lender to withdraw liquidity when pool is closed/defaulted/cancelled"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""closeLoan"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes the loan when fully repaid"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""terminatePool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to forcibly terminate the pool"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getCurrentCollateralRatio"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates current collateral ratio for the pool or specific lender"",
        ""Parameters"": [""lender (optional)""],
        ""Returns"": [""uint256 ratio""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IPoolFactory - Used to access protocol-level configuration and other contract addresses"",
    ""IPriceOracle - Used for price conversions between tokens"",
    ""IYield - Manages yield-generating strategies for deposited collateral"",
    ""IRepayment - Handles repayment tracking and calculations"",
    ""ISavingsAccount - Interface for the protocol's savings accounts"",
    ""IExtension - For additional pool functionalities"",
    ""IVerification - For lender verification requirements"",
    ""SavingsAccountUtil - Helper for savings account operations"",
    ""ERC20 tokens - For token transfers and balance operations""
  ],
  
  ""SpecialMechanisms"": [
    ""Proxy pattern with Initializable contract for upgradeability"",
    ""ERC20 token representation for lenders' positions"",
    ""Collateral-to-loan ratio monitoring and enforcement"",
    ""Margin call system with time-based liquidation"",
    ""Multi-state loan lifecycle management"",
    ""Fee collection mechanism for protocol sustainability"",
    ""Repayment distribution proportional to lender positions"",
    ""Price oracle integration for collateral valuation"",
    ""ReentrancyGuard to prevent reentrancy attacks"",
    ""Integration with yield-generating strategies for collateral""
  ],
  
  ""SecurityIssues"": [
    ""In _beforeTokenTransfer, the rounding in divisions may lead to minor accounting discrepancies when transferring partial positions"",
    ""Potential for front-running in price-sensitive operations like liquidation"",
    ""Collateral valuation depends on oracle's price which might be manipulated in low liquidity markets"",
    ""Some functions like liquidatePool don't verify if borrowed amount needs to be repaid at all"",
    ""Potential precision loss in calculations involving very large or small values"",
    ""Interest calculation could potentially overflow for very large loan amounts or long time periods""
  ],
  
  ""Questions"": [
    ""What mechanisms ensure price oracles can't be manipulated?"",
    ""How are repayments validated or enforced?"",
    ""Is there a mechanism to upgrade the pool implementation if vulnerabilities are found?"",
    ""What happens if the savings strategy contracts have issues or are compromised?"",
    ""How are fees distributed to the protocol?"",
    ""What happens if there's a global market downturn affecting multiple collateral assets simultaneously?""
  ]
}

This DeFi lending protocol implements a comprehensive lending pool system with various safeguards and mechanisms. The contract allows borrowers to take loans against collateral, while lenders can provide liquidity and earn interest. It includes advanced features like margin calls, liquidations, and integration with external yield-generating strategies. 

The contract uses upgradeable proxy patterns and incorporates multiple security mechanisms including reentrancy guards and pausability. The loan lifecycle is well-defined with clear state transitions from collection to active to closed/defaulted/cancelled states.

However, there are potential concerns with price oracle dependencies, complex interest calculations, and the handling of extreme market conditions that could benefit from additional review or stress testing.","I've analyzed the input data and combined similar issues from multiple assessments. Here's the consolidated list of security findings:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in token transfers"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions in the contract don't follow the checks-effects-interactions pattern. In the _beforeTokenTransfer function, external calls (via _withdrawRepayment) are made before updating state variables like lenders[_from/to].effectiveInterestWithdrawn. Similar issues exist in liquidatePool and withdrawBorrowedAmount functions where token transfers occur before state updates. Despite the nonReentrant modifier preventing recursive calls, a malicious contract could still execute harmful code in its fallback function during token transfers."",
      ""Impact"": ""An attacker could exploit this vulnerability to withdraw more funds than entitled to, potentially draining funds from the contract or manipulating the protocol's accounting system through reentrancy attacks."",
      ""Location"": ""_beforeTokenTransfer function, _withdrawRepayment function, liquidatePool function, withdrawBorrowedAmount function""
    },
    {
      ""Issue"": ""Price oracle manipulation vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies heavily on price oracles for determining collateral ratios, liquidation amounts, and token conversions. There's no protection against flash loan attacks that could manipulate these prices, and the oracle implementation lacks fallback mechanisms if the oracle fails or provides incorrect data."",
      ""Impact"": ""Attackers could use flash loans to temporarily manipulate asset prices reported by the oracle, triggering unnecessary liquidations or affecting collateral ratio calculations. This could lead to improper liquidations, incorrect valuation of collateral, or allowing borrowers to extract more value than their collateral should permit."",
      ""Location"": ""getEquivalentTokens(), correspondingBorrowTokens(), calculateCollateralRatio() functions""
    },
    {
      ""Issue"": ""Margin Call Timestamp Validation Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""In the getMarginCallEndTime() function, there's a check that resets the margin call end time to 0 if the current timestamp exceeds the margin call end time plus twice the margin call duration. This allows a malicious lender to avoid liquidation by never calling this function until the condition is met."",
      ""Impact"": ""The margin call mechanism can be completely bypassed, allowing undercollateralized positions to avoid liquidation, potentially leading to bad debt in the protocol."",
      ""Location"": ""getMarginCallEndTime() function""
    },
    {
      ""Issue"": ""Unchecked return values from external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes numerous external calls to other contracts (like SavingsAccountUtil functions) without checking return values. While some functions use SafeERC20, others rely on external calls that may not properly handle failed transfers. This is particularly risky when transferring tokens or interacting with third-party protocols."",
      ""Impact"": ""Failed transfers might not be detected, leading to inconsistent contract state, accounting inconsistencies, or loss of funds where users are recorded as having received tokens they didn't actually get."",
      ""Location"": ""Throughout the contract, particularly in _deposit, _withdraw, withdrawRepayment, withdrawLiquidity, and other functions making external calls""
    },
    {
      ""Issue"": ""Centralization risk with onlyOwner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract includes functions like terminatePool() that can only be called by the owner. This creates a centralization risk where the pool factory owner has significant control over the pool operations and user funds."",
      ""Impact"": ""If the owner account is compromised or acts maliciously, they could terminate pools, seize collateral arbitrarily, and disrupt the lending operations, potentially leading to loss of user funds."",
      ""Location"": ""terminatePool function and onlyOwner modifier""
    },
    {
      ""Issue"": ""Lack of slippage protection in token conversions"",
      ""Severity"": ""Medium"",
      ""Description"": ""When converting between tokens based on oracle prices, there's no slippage protection or minimum output enforcement. This is particularly problematic during liquidations or margin calls when market volatility may be high."",
      ""Impact"": ""Users might receive significantly fewer tokens than expected during conversions, especially in volatile market conditions, leading to unfavorable liquidations or exchanges."",
      ""Location"": ""correspondingBorrowTokens() function, liquidation functions""
    },
    {
      ""Issue"": ""Front-running vulnerability in margin call liquidation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The liquidation functions are susceptible to front-running, where miners or observers can see pending liquidation transactions and execute them before the original submitter. This allows malicious actors to front-run margin call transactions."",
      ""Impact"": ""Users attempting to perform liquidations might have their transactions front-run, allowing others to capture the liquidation rewards instead. This can result in unfair profit distribution and may discourage legitimate liquidators from participating in the protocol."",
      ""Location"": ""liquidatePool(), liquidateForLender() and margin call related functions""
    },
    {
      ""Issue"": ""Missing input validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions in the contract don't sufficiently validate input parameters. The initialize() function accepts many parameters but lacks validation for critical values such as _borrowRate, _idealCollateralRatio, _repaymentInterval, and other important parameters. There are also missing zero address checks for important addresses like _borrower, _poolSavingsStrategy, etc."",
      ""Impact"": ""Contract could be initialized with inappropriate values or extreme parameters, leading to unexpected behavior, unusable pools, or vulnerabilities. In the case of zero addresses, this could lead to locked funds or protocol malfunctions."",
      ""Location"": ""initialize() function and other functions accepting external inputs or address parameters""
    },
    {
      ""Issue"": ""Potential precision loss in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calculations involve division operations that could lead to precision loss or rounding errors, particularly when dealing with token decimals, interest calculations, and percentage calculations. Examples include the calculations in correspondingBorrowTokens(), getEquivalentTokens(), and calculateCollateralRatio()."",
      ""Impact"": ""Precision loss could result in incorrect token amounts being calculated, potentially affecting repayments, liquidations, interest payments, or other critical financial operations. Users might receive slightly less or more tokens than expected."",
      ""Location"": ""correspondingBorrowTokens(), getEquivalentTokens(), calculateCollateralRatio(), and other calculation functions""
    },
    {
      ""Issue"": ""Integer overflow/underflow risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using SafeMath for arithmetic operations, there are places where complex calculations could potentially overflow or underflow, particularly in pricing and interest calculations. The contract uses Solidity 0.7.6, which doesn't have built-in overflow protection like later versions."",
      ""Impact"": ""Arithmetic errors could lead to incorrect collateral ratio calculations, interest payments, or liquidation thresholds, potentially causing financial losses or unexpected contract behavior."",
      ""Location"": ""interestPerSecond, calculateCollateralRatio, time calculations, and other arithmetic operations""
    },
    {
      ""Issue"": ""Potential division by zero"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions in the contract perform divisions without checking if the denominator is zero. For example, in _beforeTokenTransfer, lenders[_from/to].effectiveInterestWithdrawn calculations divide by _totalSupply without checking if it's zero."",
      ""Impact"": ""Functions could revert unexpectedly if divisions by zero occur, potentially locking funds in the contract or causing denial of service."",
      ""Location"": ""_beforeTokenTransfer, calculateCollateralRatio, and other functions with divisions""
    },
    {
      ""Issue"": ""Improper validation in margin call mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The margin call mechanism has complex timing requirements that might not account for all edge cases, especially in the getMarginCallEndTime function where time-based validation occurs."",
      ""Impact"": ""Borrowers might avoid liquidation due to timing issues, or lenders might be unable to liquidate when they should be able to, leading to increased risk for lenders."",
      ""Location"": ""getMarginCallEndTime and requestMarginCall functions""
    },
    {
      ""Issue"": ""Unsafe external contract dependencies"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract depends on external contracts (like PriceOracle, SavingsAccount) without proper validation of their behavior or fallback mechanisms if they fail."",
      ""Impact"": ""If any dependency contract is compromised or malfunctioning, it could affect the entire pool's operation and security."",
      ""Location"": ""Functions interacting with external contracts via interfaces""
    },
    {
      ""Issue"": ""Potential for gas limit denial of service"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _beforeTokenTransfer function performs complex operations including interest calculations that scale with the number of lenders. Complex calculations and potential loops in functions like calculating repayments could hit block gas limits if the number of transactions or complexity grows too large."",
      ""Impact"": ""The contract could become unusable if gas limits are exceeded, preventing users from transferring tokens or interacting with the contract. Functions might become unusable if they consistently hit gas limits, preventing critical operations like withdrawals or liquidations."",
      ""Location"": ""_beforeTokenTransfer() function, interestToPay and calculateCollateralRatio functions""
    },
    {
      ""Issue"": ""Block timestamp manipulation vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses block.timestamp for time-sensitive calculations like margin call periods and pool cancelation penalties. Miners can manipulate block.timestamp to some extent, which could affect the timing of operations."",
      ""Impact"": ""Miners could slightly manipulate timing-dependent functions to their advantage in edge cases, potentially affecting liquidations or penalty calculations."",
      ""Location"": ""getMarginCallEndTime(), _calculatePenaltyTime(), and other time-dependent functions""
    },
    {
      ""Issue"": ""Missing events for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several important functions and state changes don't emit events, making it difficult to track off-chain what's happening in the protocol. Examples include withdrawRepayment() and functions that modify margin call end times."",
      ""Impact"": ""Limited transparency and difficulty for users and monitoring systems to track protocol activity. Reduced auditability of pool operations, making it difficult for users to track important state changes."",
      ""Location"": ""withdrawRepayment() and other functions without event emissions, various state-changing functions throughout the contract""
    },
    {
      ""Issue"": ""Inadequate error messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses short error codes (like 'OB1', 'IL1', etc.) instead of descriptive error messages. This inconsistency can make error handling and debugging more difficult."",
      ""Impact"": ""Developers and users may have difficulty identifying and resolving errors, leading to poor user experience and potential maintenance issues. Users may struggle to understand why transactions revert."",
      ""Location"": ""Throughout the contract in require statements""
    },
    {
      ""Issue"": ""Solidity version 0.7.6 susceptible to known vulnerabilities"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses Solidity 0.7.6, which has known vulnerabilities that were fixed in later versions. While not immediately exploitable in this contract, it's generally recommended to use more recent compiler versions."",
      ""Impact"": ""Potential exposure to known compiler bugs or vulnerabilities that were fixed in later versions."",
      ""Location"": ""pragma directive at the top of the file""
    },
    {
      ""Issue"": ""Unused or ineffective payable modifiers"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions are marked as payable but don't actually handle ETH transfers or use msg.value. Examples include liquidatePool(), depositCollateral(), and lend()."",
      ""Impact"": ""Users might accidentally send ETH to these functions, which would be locked in the contract without any way to retrieve it. This can lead to loss of funds."",
      ""Location"": ""Functions with the payable modifier that don't handle ETH, like liquidatePool(), depositCollateral(), and lend()""
    }
  ],
  ""IssueNumber"": 69,
  ""OutputList"": 19
}",405.759552001953,133176.0,32.0,"### **[H-03] Denial of Service**

**Report Description**:
If the borrow token is `address(0)` (ether), and someone calls `withdrawLiquidity`, it calls `SavingsAccountUtil.transferTokens`, which will transfer `msg.value` (of `withdrawLiquidity`, because it's an internal function) to `msg.sender`. In other words, the liquidity provided will pay to themselves, and their liquidity tokens will still be burned. Therefore, they will never be able to get their funds back. This creates a denial of service scenario where users lose their funds permanently.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The denial of service vulnerability described in the issue report is unique and not covered by any of the findings in the response list. The response list focuses on reentrancy, unchecked external calls, and other vulnerabilities but does not mention the specific scenario where users lose funds due to improper handling of `address(0)` tokens in `withdrawLiquidity`.

---

### **[M-03] Collateral can be deposited in a finished pool**

**Report Description**:
The `_depositCollateral` function doesn't check the status of the pool, so collateral can be deposited in a finished loan. This can happen by mistake, and all funds will be lost. This oversight allows users to deposit collateral into a pool that is no longer active, leading to potential loss of funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The issue of depositing collateral into a finished pool is not mentioned in any of the findings. The response list covers various vulnerabilities such as reentrancy, price oracle manipulation, and centralization risks but does not mention the specific problem of depositing collateral into a finished pool.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] Denial of Service**
- **[M-03] Collateral can be deposited in a finished pool**

---

### **Conclusion**
The response list does not adequately address the issues reported in the `issue` list. Both the denial of service vulnerability and the issue of depositing collateral into a finished pool are missed entirely. The response list focuses on a broad range of vulnerabilities but fails to cover these specific scenarios, indicating a gap in the analysis.",0,0,2,19,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is zero."
YearnYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into YVault
 * @author Sublime
 **/
contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        //mint vault
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        //lock collateral in vault
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1949.0,240.0,"[H-04] Yearn token <> shares conversion decimal issue

Submitted by cmichel
The yearn strategy YearnYield converts shares to tokens by doing pricePerFullShare * shares / 1e18:
``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
    if (shares == 0) return 0;
    // @audit should divided by vaultDecimals 
    amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
}
```
But Yearn's getPricePerFullShare seems to be in vault.decimals() precision, i.e., it should convert it as pricePerFullShare * shares / (10 ** vault.decimals()). The vault decimals are the same as the underlying token decimals",1.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';


contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    mapping(address => address) public override liquidityToken;

    
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1345.0,1.0,0.0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify the correctness of the onlySavingsAccount and onlyOwner modifiers"",
        ""Audit the initialize() function for potential initialization vulnerabilities"",
        ""Ensure proper ownership transfer mechanisms are secure"",
        ""Check for potential privilege escalation risks in owner-only functions""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct a comprehensive reentrancy attack vector analysis"",
        ""Verify SafeMath usage and check for potential integer overflow/underflow scenarios"",
        ""Investigate potential risks in ETH transfer mechanisms (using .call{})"",
        ""Review approve(0) pattern in _depositERC20 for token approval bypass vulnerabilities"",
        ""Analyze emergency withdraw function for potential fund draining risks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate interfaces with Yearn vaults (IyVault) for potential manipulation"",
        ""Review token transfer mechanisms using SafeERC20"",
        ""Check handling of different token types (standard, non-standard, fee-on-transfer)"",
        ""Verify price calculation methods in getTokensForShares and getSharesForTokens""
      ]
    },
    {
      ""Area"": ""Asset Management"",
      ""Tasks"": [
        ""Audit liquidity token mapping for potential address injection attacks"",
        ""Verify token locking and unlocking mechanisms"",
        ""Check restrictions on asset deposits and withdrawals"",
        ""Validate share calculation and conversion logic""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in token deposit and withdrawal functions"",
        ""Review approval mechanism for potential gas optimization"",
        ""Check for redundant storage reads or calculations"",
        ""Evaluate the efficiency of internal deposit and withdraw methods""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test handling of zero-value transactions"",
        ""Verify error message clarity and comprehensiveness"",
        ""Check handling of unexpected token behaviors"",
        ""Validate function behaviors with extreme input values""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify compliance with ERC-20 standard interaction methods"",
        ""Check adherence to OpenZeppelin contract standards"",
        ""Review upgrade mechanism for potential vulnerabilities"",
        ""Ensure proper event emissions for critical state changes""
      ]
    },
    {
      ""Area"": ""Governance and Emergency Mechanisms"",
      ""Tasks"": [
        ""Audit the emergencyWithdraw function for potential misuse"",
        ""Verify owner's ability to update protocol addresses"",
        ""Check limitations on savings account updates"",
        ""Review receive() function for potential attack vectors""
      ]
    }
  ]
}
","{
  ""ReviewingTheCode"": ""This is a Yearn Finance integration contract that enables depositing assets (both ETH and ERC20 tokens) into Yearn vaults, managing yield-bearing tokens, and withdrawing assets. It acts as an intermediary between users and Yearn vaults, tracking shares and allowing for controlled access through a savings account."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""YearnYield"",
    ""Purpose"": ""Provides an interface for interacting with Yearn Finance vaults, allowing deposits and withdrawals of both ETH and ERC20 tokens while tracking yield-bearing shares. It serves as a yield generation mechanism likely for a broader DeFi application."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IYield"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/IyVault.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address authorized to interact with the contract for locking/unlocking tokens""
      },
      {
        ""Name"": ""liquidityToken"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps underlying assets to their corresponding Yearn vault tokens""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlySavingsAccount"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function calls to only the savingsAccount address""
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with owner and savings account addresses"",
        ""Parameters"": [""_owner: address"", ""_savingsAccount: address payable""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the savings account address (only owner can call)"",
        ""Parameters"": [""_savingsAccount: address payable""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation for updating savings account address"",
        ""Parameters"": [""_savingsAccount: address payable""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateProtocolAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Maps an asset to its corresponding Yearn vault token (only owner can call)"",
        ""Parameters"": [""_asset: address"", ""_liquidityToken: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Emergency function to withdraw assets to a specified wallet (only owner can call)"",
        ""Parameters"": [""_asset: address"", ""_wallet: address payable""],
        ""Returns"": [""received: uint256""]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Deposits assets into Yearn vaults and tracks shares (only savingsAccount can call)"",
        ""Parameters"": [""user: address"", ""asset: address"", ""amount: uint256""],
        ""Returns"": [""sharesReceived: uint256""]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens from Yearn vaults based on share amount (only savingsAccount can call)"",
        ""Parameters"": [""asset: address"", ""amount: uint256""],
        ""Returns"": [""received: uint256""]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers vault tokens directly to savings account (only savingsAccount can call)"",
        ""Parameters"": [""asset: address"", ""amount: uint256""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of underlying tokens for a given share amount"",
        ""Parameters"": [""shares: uint256"", ""asset: address""],
        ""Returns"": [""amount: uint256""]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the amount of shares for a given token amount"",
        ""Parameters"": [""amount: uint256"", ""asset: address""],
        ""Returns"": [""shares: uint256""]
      },
      {
        ""Name"": ""_depositETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles ETH deposits into Yearn vaults"",
        ""Parameters"": [""vault: address"", ""amount: uint256""],
        ""Returns"": [""sharesReceived: uint256""]
      },
      {
        ""Name"": ""_depositERC20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles ERC20 token deposits into Yearn vaults"",
        ""Parameters"": [""asset: address"", ""vault: address"", ""amount: uint256""],
        ""Returns"": [""sharesReceived: uint256""]
      },
      {
        ""Name"": ""_withdrawETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles ETH withdrawals from Yearn vaults"",
        ""Parameters"": [""vault: address"", ""amount: uint256""],
        ""Returns"": [""received: uint256""]
      },
      {
        ""Name"": ""_withdrawERC"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles ERC20 token withdrawals from Yearn vaults"",
        ""Parameters"": [""asset: address"", ""vault: address"", ""amount: uint256""],
        ""Returns"": [""tokensReceived: uint256""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive ETH"",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IyVault - Interface for Yearn Finance vaults"",
    ""IERC20 - Standard ERC20 token interface"",
    ""SafeERC20 - Library for safe ERC20 operations"",
    ""SafeMath - Library for safe math operations"",
    ""External calls to Yearn vaults for deposits and withdrawals"",
    ""ETH transfers to savingsAccount and specified wallets""
  ],
  ""SpecialMechanisms"": [
    ""Proxy pattern through OwnableUpgradeable and Initializable (for upgradeable contracts)"",
    ""Reentrancy protection via ReentrancyGuard"",
    ""Approval pattern for ERC20 tokens before depositing"",
    ""Conversion mechanism between vault shares and underlying assets"",
    ""Support for both ETH and ERC20 tokens""
  ],
  ""Questions"": [
    ""What's the significance of SavingsAccountUpdated event declaration? It's emitted but not declared in the contract."",
    ""Does the contract correctly handle fee-on-transfer tokens?"",
    ""In _depositERC20, why approve with 0 first, then approve with amount?"",
    ""In emergencyWithdraw, it withdraws the entire balance of shares - is there a way to withdraw only a portion?"",
    ""How does the contract handle potential price manipulation of Yearn vault tokens?"",
    ""Is there a security issue with the direct ETH transfer via call()?"",
    ""Should unlockShares have restrictions on which assets can be transferred, similar to unlockTokens?""
  ]
}
","{
  ""Findings"": [
    {
      ""Issue"": ""Improper Use of ReentrancyGuard in Upgradeable Context"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract mixes upgradeable patterns (OwnableUpgradeable, Initializable) with non-upgradeable ReentrancyGuard, leading to potential storage collisions and ineffective reentrancy protection due to missing initialization."",
      ""Impact"": ""Storage layout corruption or malfunctioning nonReentrant modifier, possibly enabling reentrancy attacks in proxy deployments."",
      ""Location"": ""Contract inheritance declaration and initialize() function""
    },
    {
      ""Issue"": ""Missing Slippage Protection in Vault Operations"",
      ""Severity"": ""High"",
      ""Description"": ""Deposit and withdrawal functions (_depositETH, _depositERC20, _withdrawETH, _withdrawERC) lack slippage parameters and minimum expected returns, exposing users to price manipulation and front-running."",
      ""Impact"": ""Users may receive significantly fewer tokens or shares than expected, leading to financial loss in volatile market conditions."",
      ""Location"": ""Vault interaction functions""
    },
    {
      ""Issue"": ""Insufficient Validation for LiquidityToken Configuration"",
      ""Severity"": ""High"",
      ""Description"": ""The updateProtocolAddresses function allows setting arbitrary or zero addresses without checking if they are valid Yearn vaults, leading to potential misconfiguration or asset loss."",
      ""Impact"": ""Funds may be directed to invalid or malicious contracts, resulting in permanent loss or failed operations."",
      ""Location"": ""updateProtocolAddresses function""
    },
    {
      ""Issue"": ""Unchecked Return Values in External Vault Calls"",
      ""Severity"": ""High"",
      ""Description"": ""Functions interacting with Yearn vaults do not verify return values for deposit and withdraw calls, risking silent failures or incorrect accounting."",
      ""Impact"": ""Potential loss or locking of funds if external vault operations fail without reverting."",
      ""Location"": ""_depositETH, _depositERC20, _withdrawETH, _withdrawERC""
    },
    {
      ""Issue"": ""Reentrancy Risk in ETH Transfer Patterns"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like emergencyWithdraw and unlockTokens make external calls (ETH transfers via call()) after state changes, which could enable reentrancy via malicious fallback functions."",
      ""Impact"": ""May allow attackers to exploit reentrancy patterns to drain funds or manipulate state."",
      ""Location"": ""emergencyWithdraw and unlockTokens functions""
    },
    {
      ""Issue"": ""Centralization Risk from Owner Privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract grants the owner extensive power to update protocol addresses and withdraw all funds in emergencies without any time delay or multi-sig governance."",
      ""Impact"": ""If the owner's private key is compromised, an attacker could immediately seize all user funds."",
      ""Location"": ""updateProtocolAddresses and emergencyWithdraw""
    },
    {
      ""Issue"": ""Unsafe ERC20 Approval Pattern"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses the approve(0) followed by approve(amount) pattern without checking return values, which is unnecessary for most tokens and may fail on non-standard ones."",
      ""Impact"": ""May cause deposit failures or higher gas costs; tokens like USDT could fail silently."",
      ""Location"": ""_depositERC20 function""
    },
    {
      ""Issue"": ""No Validation for LiquidityToken Existence"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like lockTokens and unlockTokens do not verify if liquidityToken[asset] is set before using it."",
      ""Impact"": ""Operations may fail unexpectedly or result in fund locking due to uninitialized token mappings."",
      ""Location"": ""lockTokens, unlockTokens, getTokensForShares, getSharesForTokens""
    },
    {
      ""Issue"": ""Improper ETH Handling and Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""When asset is ETH, the contract does not always enforce correct msg.value validation, and may allow ETH to be mistakenly sent during ERC20 interactions."",
      ""Impact"": ""Leads to accidental fund loss or ETH being trapped in the contract."",
      ""Location"": ""lockTokens, unlockTokens, and ETH-specific branches""
    },
    {
      ""Issue"": ""Precision Loss in Share Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""Calculations in getSharesForTokens and getTokensForShares perform division after multiplication, which can lead to rounding errors."",
      ""Impact"": ""Users may receive slightly fewer shares or tokens than expected, particularly on small-value transactions."",
      ""Location"": ""getSharesForTokens and getTokensForShares functions""
    },
    {
      ""Issue"": ""Missing Event Emission for Critical Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The emergencyWithdraw function lacks event emission, reducing transparency and making it harder to audit emergency activity off-chain."",
      ""Impact"": ""Obscures critical actions from users, auditors, and monitoring tools."",
      ""Location"": ""emergencyWithdraw function""
    }
  ],
  ""IssueNumber"": 41,
  ""OutputList"": 11
}
",1109.79977083206,119371.0,105.0,"---

**[H-04] Yearn token <> shares conversion decimal issue**

**Report Description**:
The `YearnYield` strategy converts shares to tokens using the formula `pricePerFullShare * shares / 1e18`. However, Yearn's `getPricePerFullShare` function returns values in `vault.decimals()` precision, meaning the correct formula should be `pricePerFullShare * shares / (10 ** vault.decimals())`. This oversight can lead to incorrect token conversions, especially when the underlying token's decimals differ from `1e18`. This could result in financial discrepancies and potential vulnerabilities in the contract's accounting logic.

**Match in Response List**:
Matches with the issue titled **""Precision Loss in Share Calculations""**.

**Validation**:
**Partially Correct**. The response identifies the issue of precision loss in share calculations, which is relevant to the reported problem. However, it does not specifically address the incorrect use of `1e18` instead of `vault.decimals()` in the conversion formula. The response focuses on general rounding errors rather than the specific decimal precision mismatch, which is the core issue in the report. Therefore, while the response touches on the broader problem, it misses critical details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-04] Yearn token <> shares conversion decimal issue**

**Missed Issues from Issue Report**:
- *None*

---",0,0,1,0,"```
None.
```",0.0
AaveYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into Aave protocol
 * @author Sublime
 **/
contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of wethGateway used to deposit ETH to aave
     */
    address public wethGateway;

    /**
     * @notice address of protocolDataProvider which provides info about aTokens related to any token
     */
    address public protocolDataProvider;

    /**
     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token
     */
    address public lendingPoolAddressesProvider;

    /**
     * @notice address of savings account contract
     */
    address payable public savingsAccount;

    /**
     * @notice aave referral code to represent sublime
     */
    uint16 public referralCode;

    /**
     * @notice emitted when aave protocol related addresses are updated
     * @param wethGateway address of wethGateway
     * @param protocolDataProvider address of protocol data provider
     * @param lendingPoolAddressesProvider address of lending pool addresses provider
     */
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    /**
     * @notice emitted when aave referral code is updated
     * @param referralCode updated referral code
     */
    event ReferralCodeUpdated(uint16 referralCode);

    /**
     * @notice verifies if savings account invoked the contract
     */
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice To initialize the contract addresses interacting with this contract
     * @dev can only be initialized once
     * @param _owner address of owner
     * @param _savingsAccount address of the savings account contract
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider the address of ProtocolDataProvider
     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider
     **/
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return aToken address of liquidity token
     **/
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    /**
     * @notice used to update savings account address
     * @dev only owner can update
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update aave protocol related addresses
     * @dev only owner can update
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider address of protocol data provider
     * @param _lendingPoolAddressesProvider address of lending pool addresses provider
     */
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice used to update referral code
     * @dev only owner can update
     * @param _referralCode updated referral code
     */
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @notice Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //lock collateral
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //approve collateral to vault
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        //lock collateral in vault
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        //lock collateral
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        //withdraw collateral from vault
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",2772.0,335.0,"[H-05] Aave's share tokens are rebasing breaking current strategy code

When depositing into Aave through the `AaveYield.lockTokens` contract strategy, one receives the sharesReceived amount corresponding to the diff of aToken balance, which is just always the deposited amount as aave is a rebasing token and 1.0 aToken = 1.0 underlying at each deposit / withdrawal.
Note that this sharesReceived (the underlying deposit amount) is cached in a balanceInShares map in SavingsAccount.deposit which makes this share static and not dynamically rebasing anymore:
  [M-07] AaveYield: Misspelled external function name making functions fail

In AaveYield.sol the functions:
liquidityToken
_withdrawETH
_depositETH
Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`
This function does not exist in the wethGateway contract, causing these function to fail with the error ""Fallback not allowed"".
The function they should be calling is getWethAddress() without the ""A"".
Small yet dangerous typo.",2.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';


contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public wethGateway;

    
    address public protocolDataProvider;

    
    address public lendingPoolAddressesProvider;

    
    address payable public savingsAccount;

    
    uint16 public referralCode;

    
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    
    event ReferralCodeUpdated(uint16 referralCode);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",1924.0,1.0,1.0,"Based on the comprehensive review of the AaveYield smart contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection on all external functions using ReentrancyGuard"",
        ""Audit SafeMath and SafeERC20 library usage for potential overflow/underflow risks"",
        ""Verify zero-address checks in all address parameter inputs"",
        ""Review referralCode input validation and potential manipulation risks"",
        ""Analyze potential edge cases in token conversion calculations (getTokensForShares, getSharesForTokens)""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify onlySavingsAccount modifier implementation and potential bypass methods"",
        ""Review owner-only function access control mechanisms"",
        ""Check initialization process for potential ownership transfer vulnerabilities"",
        ""Validate the scope and limitations of owner privileges""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all external contract interactions with Aave protocols"",
        ""Verify approval mechanisms for token transfers and deposits"",
        ""Check error handling in external contract calls"",
        ""Review potential risks in WETH Gateway and Lending Pool interactions"",
        ""Validate referral code implementation in Aave deposit methods""
      ]
    },
    {
      ""Area"": ""Upgrade and Initialization"",
      ""Tasks"": [
        ""Review initializer function for complete state initialization"",
        ""Verify upgrade path and potential state inconsistencies"",
        ""Check for proper initialization guards"",
        ""Validate that all critical addresses can be updated safely""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Audit ETH and ERC20 token handling mechanisms"",
        ""Verify token conversion logic accuracy"",
        ""Check emergency withdrawal functionality"",
        ""Review token approval and transfer mechanisms"",
        ""Validate handling of different token types (standard, non-standard)""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review function visibility and optimization opportunities"",
        ""Analyze storage variable usage and potential optimization"",
        ""Check for unnecessary computational complexity"",
        ""Verify efficient use of memory and storage""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test scenarios with zero amounts and edge case inputs"",
        ""Verify error message clarity and specificity"",
        ""Check handling of unexpected token behaviors"",
        ""Review fallback and receive function implementation"",
        ""Validate error propagation in nested function calls""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify compliance with IYield interface requirements"",
        ""Check adherence to OpenZeppelin contract standards"",
        ""Review ERC20 interaction patterns"",
        ""Validate Aave protocol integration standards""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, functional, and optimization aspects.
2. Tasks are specific, actionable, and directly tied to the contract's unique characteristics.
3. Prioritizes critical areas like external interactions, access control, and potential vulnerabilities.
4. Includes both technical implementation checks and broader architectural considerations.

Recommended Next Steps:
- Conduct a detailed line-by-line code review
- Perform extensive testing across various scenarios
- Consider professional smart contract auditing tools
- Implement comprehensive test cases covering all identified task areas

The task list provides a structured approach to thoroughly audit the AaveYield smart contract, ensuring robust security, functionality, and compliance.","I've conducted a thorough audit of the provided smart contract code. Here's my analysis in the requested JSON format:

{
  ""ReviewingTheCode"": ""The contract 'AaveYield' implements a yield-generating strategy using Aave protocol. It serves as an integration layer between a savings account system and Aave's lending pools, allowing for deposits and withdrawals of both ETH and ERC20 tokens. The contract handles the conversion between underlying assets and Aave's interest-bearing tokens (aTokens)."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AaveYield"",
    ""Purpose"": ""A contract that integrates with Aave protocol to generate yield on deposited assets (ETH and ERC20 tokens). It acts as an intermediary between a savings account system and Aave's lending pools."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IYield"", ""Initializable"", ""OwnableUpgradeable"", ""ReentrancyGuard""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/IWETHGateway.sol"",
        ""../interfaces/Invest/AaveLendingPool.sol"",
        ""../interfaces/Invest/IScaledBalanceToken.sol"",
        ""../interfaces/Invest/IProtocolDataProvider.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""wethGateway"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of Aave's WETH Gateway contract that handles ETH deposits/withdrawals""
      },
      {
        ""Name"": ""protocolDataProvider"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of Aave's Protocol Data Provider contract that provides information about reserves""
      },
      {
        ""Name"": ""lendingPoolAddressesProvider"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of Aave's Lending Pool Addresses Provider contract that provides the address of the current lending pool""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the savings account contract that interacts with this yield contract""
      },
      {
        ""Name"": ""referralCode"",
        ""Type"": ""uint16"",
        ""Purpose"": ""Referral code used for Aave deposits""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlySavingsAccount"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to only the savingsAccount address"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with required addresses (using initializer pattern)"",
        ""Parameters"": [""_owner"", ""_savingsAccount"", ""_wethGateway"", ""_protocolDataProvider"", ""_lendingPoolAddressesProvider""],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidityToken"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Gets the corresponding aToken address for a given asset"",
        ""Parameters"": [""asset""],
        ""Returns"": [""aToken""]
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the savings account address (owner only)"",
        ""Parameters"": [""_savingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateAaveAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates Aave-related contract addresses (owner only)"",
        ""Parameters"": [""_wethGateway"", ""_protocolDataProvider"", ""_lendingPoolAddressesProvider""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateReferralCode"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the referral code used for Aave deposits (owner only)"",
        ""Parameters"": [""_referralCode""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Emergency function to withdraw all tokens of a specific asset (owner only)"",
        ""Parameters"": [""_asset"", ""_wallet""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Deposits assets into Aave to generate yield"",
        ""Parameters"": [""user"", ""asset"", ""amount""],
        ""Returns"": [""sharesReceived""]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws assets from Aave and returns them to the savings account"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers aTokens directly to the savings account"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""amount""]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of underlying tokens for a given amount of aToken shares"",
        ""Parameters"": [""shares"", ""asset""],
        ""Returns"": [""amount""]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the amount of aToken shares for a given amount of underlying tokens"",
        ""Parameters"": [""amount"", ""asset""],
        ""Returns"": [""shares""]
      },
      {
        ""Name"": ""_depositETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to deposit ETH into Aave"",
        ""Parameters"": [""amount""],
        ""Returns"": [""aToken"", ""sharesReceived""]
      },
      {
        ""Name"": ""_depositERC20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to deposit ERC20 tokens into Aave"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""aToken"", ""sharesReceived""]
      },
      {
        ""Name"": ""_withdrawETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to withdraw ETH from Aave"",
        ""Parameters"": [""amount""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""_withdrawERC"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to withdraw ERC20 tokens from Aave"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""tokensReceived""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Fallback function to receive ETH"",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Aave's WETH Gateway (for ETH deposits/withdrawals)"",
    ""Aave's Protocol Data Provider (for reserve information)"",
    ""Aave's Lending Pool Addresses Provider (to get lending pool address)"",
    ""Aave's Lending Pool (for deposits/withdrawals)"",
    ""Aave's aTokens (interest-bearing tokens representing deposits)"",
    ""ERC20 token contracts (for token transfers/approvals)""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern using OpenZeppelin's upgradeable contracts"",
    ""Proxy pattern (implicit through the use of Initializable)"",
    ""Reentrancy protection on all external-facing functions that interact with Aave"",
    ""Calculation of exchange rates between aTokens and underlying tokens using Aave's scaled balances and liquidity index""
  ],
  ""Questions"": [
    ""Is there a SavingsAccountUpdated event that's emitted in _updateSavingsAccount but not declared in the contract?"",
    ""The unlockShares function only works with aTokens and not ETH - is this intentional?"",
    ""What happens if Aave adds or removes support for certain tokens after this contract is deployed?"",
    ""How does the contract handle rebasing tokens or tokens with non-standard ERC20 implementations?"",
    ""Is there a specific reason why ReentrancyGuard is imported from contracts but OwnableUpgradeable is from contracts-upgradeable?"",
    ""Are there any liquidation risks for the deposited assets on Aave?"",
    ""How is the contract upgraded if needed given it's using the initializable pattern?""
  ]
}","I've analyzed the provided issues and consolidated similar ones. Here's the combined security report:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in critical functions"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions in the contract, especially emergencyWithdraw and unlockTokens, have reentrancy vulnerabilities. While the contract inherits ReentrancyGuard, emergencyWithdraw lacks the nonReentrant modifier. Additionally, the unlockTokens function makes external calls to transfer ETH after state changes, creating potential reentrancy vectors."",
      ""Impact"": ""An attacker could potentially re-enter the contract during ETH transfers and drain funds if the receiving address is a malicious contract with fallback logic."",
      ""Location"": ""emergencyWithdraw function, unlockTokens function for ETH handling""
    },
    {
      ""Issue"": ""Incorrect inheritance and initialization of ReentrancyGuard"",
      ""Severity"": ""High"",
      ""Description"": ""The contract inherits from ReentrancyGuard (non-upgradeable) while also using OwnableUpgradeable. This mixing creates inconsistency in the inheritance pattern. Additionally, there's no call to __ReentrancyGuard_init() in the initialize function, meaning the reentrancy protection may not be properly initialized in an upgradeable context."",
      ""Impact"": ""The ReentrancyGuard might not function correctly in the proxy pattern, potentially allowing reentrancy attacks despite the nonReentrant modifier being used."",
      ""Location"": ""Contract declaration and inheritance, initialize() function""
    },
    {
      ""Issue"": ""Initialization function lacks access control"",
      ""Severity"": ""High"",
      ""Description"": ""The initialize() function does not have access control. Since this is an upgradeable contract (inherits from OwnableUpgradeable), the initialize function should have proper access restriction to prevent unauthorized initialization."",
      ""Impact"": ""Anyone can call initialize() after deployment but before it's initialized, taking ownership of the contract and setting critical parameters like _savingsAccount, _wethGateway, etc."",
      ""Location"": ""initialize() function""
    },
    {
      ""Issue"": ""Incorrect calculation in getTokensForShares"",
      ""Severity"": ""High"",
      ""Description"": ""The calculation in getTokensForShares seems complex and potentially incorrect. It uses scaledBalanceOf which already represents the user's balance adjusted for interest, then applies additional interest calculations that could lead to incorrect values. Additionally, if the contract holds no aTokens, this function will revert with a division by zero error."",
      ""Impact"": ""Users might receive incorrect amounts of tokens when converting shares, potentially leading to loss of funds or function reverts that could block functionality."",
      ""Location"": ""getTokensForShares function""
    },
    {
      ""Issue"": ""Unchecked return values from external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes external calls to the Aave protocols in functions like _depositERC20, _withdrawERC, _depositETH, and others, but doesn't validate the return values to ensure the operations were successful."",
      ""Impact"": ""If these external calls fail silently (return false instead of reverting), the contract would continue execution as if they succeeded, leading to inconsistent state and possibly loss of funds."",
      ""Location"": ""_depositERC20, _withdrawERC, _depositETH functions""
    },
    {
      ""Issue"": ""Precision loss in share calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Both token/share conversion functions (getTokensForShares and getSharesForTokens) perform divisions that could lead to precision loss and rounding errors, especially for small amounts or tokens with few decimals. The getSharesForTokens function performs division after multiplication, which can lead to precision loss."",
      ""Impact"": ""Users might receive slightly fewer tokens or shares than expected, leading to value erosion over multiple operations."",
      ""Location"": ""getTokensForShares and getSharesForTokens functions""
    },
    {
      ""Issue"": ""Lack of slippage protection in deposit and withdrawal functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The deposit and withdrawal functions don't implement any slippage protection. When calling functions like _withdrawETH or _withdrawERC, there is no minimum received amount check. This is especially problematic during market volatility or manipulation."",
      ""Impact"": ""Users might receive fewer tokens or shares than expected if the exchange rate changes unfavorably between transaction submission and execution."",
      ""Location"": ""Functions _depositETH(), _depositERC20(), _withdrawETH(), and _withdrawERC()""
    },
    {
      ""Issue"": ""Insufficient input validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions like lockTokens, unlockTokens, and others lack comprehensive input validation. For example, the contract doesn't validate if an asset is supported by Aave before attempting to deposit or withdraw it, or check for zero addresses in certain functions."",
      ""Impact"": ""Using unsupported assets can cause transaction failures and wasted gas. It may also lead to tokens being accidentally locked for the zero address."",
      ""Location"": ""lockTokens(), unlockTokens(), and getSharesForTokens functions""
    },
    {
      ""Issue"": ""Potential token approval front-running"",
      ""Severity"": ""Medium"",
      ""Description"": ""In _depositERC20(), the contract sets token approvals to 0 and then to the desired amount in separate operations. This pattern is vulnerable to front-running attacks on some ERC20 tokens and is no longer considered best practice."",
      ""Impact"": ""An attacker could monitor the mempool and front-run the second approval transaction, potentially leading to failed deposits or locked tokens."",
      ""Location"": ""_depositERC20() function in the approval lines""
    },
    {
      ""Issue"": ""Lack of emergency pause functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has an emergencyWithdraw function but lacks a pause mechanism that would allow halting all operations in case of a detected vulnerability or attack."",
      ""Impact"": ""In case of an ongoing attack or discovered vulnerability, the contract cannot be quickly paused to prevent further exploits while a fix is developed."",
      ""Location"": ""Contract-wide issue""
    },
    {
      ""Issue"": ""Missing event emission for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical operations, like emergencyWithdraw, don't emit events, making it difficult to track these operations off-chain."",
      ""Impact"": ""Reduced transparency and auditability of emergency withdrawals, which could be problematic for accounting and regulatory compliance."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Unnecessary recasting of addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract declares savingsAccount as 'address payable' but then recasts msg.sender to compare with it in the onlySavingsAccount modifier."",
      ""Impact"": ""No direct security impact, but it introduces unnecessary complexity and potential mistakes."",
      ""Location"": ""Modifier onlySavingsAccount()""
    },
    {
      ""Issue"": ""ETH amount verification is bypassed when called by contract"",
      ""Severity"": ""Low"",
      ""Description"": ""In lockTokens(), the contract verifies msg.value equals amount only for ETH deposits, but this check can be bypassed if the function is called by another contract that sets a different msg.value."",
      ""Impact"": ""A malicious contract could potentially call lockTokens with ETH but specify a different amount parameter, causing accounting inconsistencies."",
      ""Location"": ""Function lockTokens()""
    },
    {
      ""Issue"": ""Potential ETH loss in receive function"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract has a receive function that accepts ETH but doesn't implement any logic to handle or account for received ETH. This could lead to ETH being locked in the contract without proper accounting."",
      ""Impact"": ""ETH sent directly to the contract might be locked or not properly accounted for."",
      ""Location"": ""receive function""
    }
  ],
  ""IssueNumber"": 56,
  ""OutputList"": 14
}",347.242653131485,59142.0,32.0,"### **[H-05] Aave's share tokens are rebasing breaking current strategy code**

**Report Description**:
When depositing into Aave through the `AaveYield.lockTokens` contract strategy, the `sharesReceived` amount corresponds to the difference in `aToken` balance. Since Aave is a rebasing token, `1.0 aToken = 1.0 underlying` at each deposit/withdrawal. However, the `sharesReceived` (the underlying deposit amount) is cached in a `balanceInShares` map in `SavingsAccount.deposit`, making the share static and not dynamically rebasing. This breaks the strategy code, as the cached value does not reflect the rebasing nature of Aave tokens, leading to incorrect accounting and potential loss of funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of Aave's rebasing tokens and the static caching of `sharesReceived` in `SavingsAccount.deposit`. This is a critical issue that affects the core functionality of the strategy, and its absence in the response list indicates a significant gap in the analysis.

---

### **[M-07] AaveYield: Misspelled external function name making functions fail**

**Report Description**:
In `AaveYield.sol`, the functions `liquidityToken`, `_withdrawETH`, and `_depositETH` make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`. However, this function does not exist in the `wethGateway` contract, causing these functions to fail with the error ""Fallback not allowed"". The correct function to call is `getWethAddress()` (without the ""A""). This typo is small but dangerous, as it renders these functions non-functional.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the misspelled external function name in `AaveYield.sol`. This is a critical issue that prevents the affected functions from executing correctly, and its absence in the response list indicates a significant oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-05] Aave's share tokens are rebasing breaking current strategy code**
- **[M-07] AaveYield: Misspelled external function name making functions fail**

---

### **Conclusion**
The response list does not address the two provided issues, indicating a significant gap in the analysis. Both issues are critical and directly impact the functionality and security of the smart contract. The response list should be updated to include these issues to ensure comprehensive coverage of potential vulnerabilities.",0,0,2,14,"```
None.
```",0.0
SavingsAccount.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';

/**
 * @title Savings account contract with Methods related to savings account
 * @notice Implements the functions related to savings account
 * @author Sublime
 **/
contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of the strategy registry used to whitelist strategies
     */
    address public strategyRegistry;

    /**
     * @notice address of the credit lines contract
     */
    address public creditLine;

    /**
     * @notice mapping from user to token to strategy to balance of shares
     * @dev user -> token -> strategy (underlying address) -> amount (shares)
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    /**
     * @notice mapping from user to token to toAddress for approval to amount approved
     * @dev user => token => to => amount
     */
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    /**
     * @notice modifier to check if address is the credit line
     * @param _caller address to check if credit line
     */
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    /**
     * @dev initialize the contract
     * @param _owner address of the owner of the savings account contract
     * @param _strategyRegistry address of the strategy registry
     * @param _creditLine address of the credit line contract
     **/
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    /**
     * @notice used to update credit line contract address
     * @dev only owner can update
     * @param _creditLine updated address of credit lines
     */
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    /**
     * @notice used to update strategy registry address
     * @dev only owner can update
     * @param _strategyRegistry updated address of strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to deposit tokens into strategy via savings account
     * @dev if token is address(0), then it is Ether
     * @param _amount amount of tokens deposited
     * @param _token address of token contract
     * @param _strategy address of the strategy into which tokens are to be deposited
     * @param _to address to deposit to
     */
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    /**
     * @dev Used to switch saving strategy of an _token
     * @param _currentStrategy initial strategy of token
     * @param _newStrategy new strategy to invest
     * @param _token address of the token
     * @param _amount amount of tokens to be reinvested
     */
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _from address from which tokens will be withdrawn
     * @param _to address to which token should be withdrawn
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    /**
     * @notice used to withdraw a token from all strategies
     * @param _token address of token which is to be withdrawn
     */
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    /**
     * @notice used to approve allowance to an address
     * @dev this is prone to race condition, hence increaseAllowance is recommended
     * @param _amount amount of tokens approved
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    /**
     * @notice used to increase allowance to an address
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _to address of the address approved to
     */
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used to decrease allowance to an address
     * @param _amount amount of tokens allowance is decreased by
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _from address of the lender of the credit line which is being replenished
     */
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    /**
     * @notice used to transfer tokens
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        //update allowance
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        //reduce sender's balance
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to query total tokens of a token with a user
     * @param _user address of the user
     * @param _token address of token
     * @return _totalTokens total number of tokens of the token with the user
     */
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",4178.0,482.0,"[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues

Function `withdrawAll()` `switchStrategy()`

Full withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for AaveYield. That is, as the whole amount is required to be moved at once from Aave, both withdrawAll and switchStrategy will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues.
 `withdrawAll` will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system.
 `switchStrategy` will subtract full number of shares for the _amount requested from the old strategy, while adding lesser partial number of shares for _tokensReceived to the new one with the same effect of freezing user's funds within the system.
  [H-08] Possibility to drain SavingsAccount contract assets

A malicious actor can manipulate `switchStrategy()` function in a way to withdraw tokens that are locked in SavingsAccount contract (the risk severity should be reviewed)",2.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';


contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public strategyRegistry;

    
    address public creditLine;

    
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",3020.0,2.0,0.0,"Based on the comprehensive analysis of the SavingsAccount smart contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the reentrancy protection mechanisms, especially in withdraw and transfer functions"",
        ""Verify SafeMath usage to prevent integer overflow/underflow vulnerabilities"",
        ""Check for potential unauthorized access points in external function calls"",
        ""Validate input validation and sanitization across all external and public functions"",
        ""Review error handling and require statement implementations""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyCreditLine and onlyOwner modifier implementations"",
        ""Verify the initialize function's access control and initialization process"",
        ""Examine the increaseAllowanceToCreditLine function for potential abuse"",
        ""Check the transferOwnership mechanism for potential centralization risks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze interactions with IStrategyRegistry, ensuring robust strategy validation"",
        ""Review IYield interface implementation and potential attack vectors"",
        ""Verify token transfer mechanisms, especially for ETH and ERC20 tokens"",
        ""Check approve and allowance mechanisms for potential manipulation"",
        ""Validate cross-contract call security in deposit, withdraw, and switch strategy functions""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Verify share calculation mechanisms across different strategies"",
        ""Check handling of tokens with non-standard transfer behaviors"",
        ""Audit the getTotalTokens function for accuracy and potential manipulation"",
        ""Review token balance tracking in balanceInShares mapping"",
        ""Validate token conversion between shares and tokens""
      ]
    },
    {
      ""Area"": ""Complex Logic"",
      ""Tasks"": [
        ""Analyze the strategy switching mechanism for potential edge cases"",
        ""Review withdrawAll implementations for completeness and gas efficiency"",
        ""Verify the share transfer and allowance mechanisms"",
        ""Check the logic for handling zero-address tokens and ETH"",
        ""Validate the increaseAllowance and decreaseAllowance implementations""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas-intensive operations in loops and multiple mappings"",
        ""Review the efficiency of strategy-related function calls"",
        ""Check for unnecessary storage reads and writes"",
        ""Analyze the gas cost of complex functions like withdrawAll and switchStrategy""
      ]
    },
    {
      ""Area"": ""Upgradability and Initialization"",
      ""Tasks"": [
        ""Verify the correct implementation of the initializer function"",
        ""Check for potential reinitalization vulnerabilities"",
        ""Audit the update functions for strategyRegistry and creditLine"",
        ""Ensure proper ownership transfer mechanisms""
      ]
    },
    {
      ""Area"": ""Error Handling and Events"",
      ""Tasks"": [
        ""Review all error messages for clarity and specificity"",
        ""Verify that all critical state changes emit appropriate events"",
        ""Check event parameters for completeness and accuracy"",
        ""Ensure consistent error handling across different function scenarios""
      ]
    }
  ]
}

Key observations and recommendations:

1. The contract demonstrates a sophisticated approach to managing yield-generating strategies with multiple layers of security.

2. Critical areas of focus include:
   - The complex share calculation and token conversion mechanisms
   - External interactions with strategy and yield contracts
   - Access control and allowance management

3. Potential risks to investigate:
   - Precision loss in share calculations
   - Potential vulnerabilities in strategy switching
   - Complex allowance and transfer mechanisms

4. Recommended deep-dive areas:
   - IYield interface implementation
   - Strategy registry validation
   - Token handling across different strategy types

The task list provides a comprehensive framework for a thorough, multi-faceted audit of the SavingsAccount contract, addressing security, functionality, and potential optimization opportunities.","Based on my examination of the provided smart contract, here's a detailed audit:

{
  ""ReviewingTheCode"": ""This is a SavingsAccount contract that allows users to deposit, withdraw, and manage tokens across different yield-generating strategies. It implements functionality for token transfers, approvals, and strategy switching while maintaining balances in shares."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SavingsAccount"",
    ""Purpose"": ""A contract that enables users to deposit tokens into different yield strategies, track balances in shares, allow transfers between accounts, and manage withdrawals from different strategies."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ISavingsAccount"", ""Initializable"", ""OwnableUpgradeable"", ""ReentrancyGuard""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""ISavingsAccount"",
        ""IStrategyRegistry"",
        ""IYield""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the strategy registry contract that maintains available strategies""
      },
      {
        ""Name"": ""creditLine"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of a creditLine contract that has special permissions""
      },
      {
        ""Name"": ""balanceInShares"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks user balances in shares for each token and strategy combination""
      },
      {
        ""Name"": ""allowance"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks allowances given by users to other addresses to spend their tokens""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyCreditLine"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to only the creditLine address"",
        ""Parameters"": [""address _caller""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with owner, strategyRegistry, and creditLine addresses"",
        ""Parameters"": [""address _owner"", ""address _strategyRegistry"", ""address _creditLine""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateCreditLine"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the creditLine address (only owner)"",
        ""Parameters"": [""address _creditLine""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateStrategyRegistry"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the strategyRegistry address (only owner)"",
        ""Parameters"": [""address _strategyRegistry""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits tokens into a strategy and assigns shares to a specified recipient"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _to""],
        ""Returns"": [""uint256 (shares received)""]
      },
      {
        ""Name"": ""switchStrategy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Moves tokens from one strategy to another"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _currentStrategy"", ""address _newStrategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens or shares from a strategy to a specified address"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address payable _to"", ""bool _withdrawShares""],
        ""Returns"": [""uint256 (amount received)""]
      },
      {
        ""Name"": ""withdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens from another user's balance if authorized by allowance"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _from"", ""address payable _to"", ""bool _withdrawShares""],
        ""Returns"": [""uint256 (amount received)""]
      },
      {
        ""Name"": ""withdrawAll"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all tokens of a specific type across all strategies"",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256 (amount received)""]
      },
      {
        ""Name"": ""withdrawAll"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all tokens of a specific type from a specific strategy"",
        ""Parameters"": [""address _token"", ""address _strategy""],
        ""Returns"": [""uint256 (amount received)""]
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the allowance for another address to spend tokens"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the allowance for another address"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Decreases the allowance for another address"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseAllowanceToCreditLine"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases allowance for creditLine (only callable by creditLine)"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _from""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers shares from caller to another address"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _to""],
        ""Returns"": [""uint256 (amount transferred)""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers shares from one address to another if authorized by allowance"",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _from"", ""address _to""],
        ""Returns"": [""uint256 (amount transferred)""]
      },
      {
        ""Name"": ""getTotalTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates total tokens owned by a user across all strategies"",
        ""Parameters"": [""address _user"", ""address _token""],
        ""Returns"": [""uint256 _totalTokens""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IStrategyRegistry - Used to verify strategies and get strategy lists"",
    ""IYield - Interface for interacting with yield strategies (lockTokens, unlockTokens, getSharesForTokens, etc.)"",
    ""IERC20 - Standard ERC20 token interface for token transfers and approvals"",
    ""External ETH transfers using call function""
  ],
  
  ""SpecialMechanisms"": [
    ""Proxy pattern with upgradeable contracts (using Initializable from OpenZeppelin)"",
    ""ReentrancyGuard to prevent reentrancy attacks"",
    ""Token balance accounting using shares rather than direct token amounts"",
    ""Support for both ERC20 tokens and ETH (represented as address(0))"",
    ""Strategy switching mechanism to move funds between different yield strategies"",
    ""Allowance mechanism similar to ERC20 but for controlling access to shares""
  ],
  
  ""Questions"": [
    ""What is the exact implementation of IYield interface? Understanding how the yield strategies handle tokens is important for full security assessment."",
    ""How does the strategy registry manage and validate strategies?"",
    ""Are there any restrictions on who can add strategies to the registry?"",
    ""What happens if a strategy becomes compromised or deprecated?"",
    ""Does the contract properly handle tokens with transfer fees or rebasing mechanisms?"",
    ""In the withdrawAll function, what happens if unlocking tokens from a strategy fails?"",
    ""How are shares calculated and valued across different strategies?"",
    ""Is there a risk of precision loss when converting between tokens and shares?""
  ]
}","I've analyzed the provided issue lists and consolidated similar issues into a comprehensive set. Here's the result:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in switchStrategy function"",
      ""Severity"": ""High"",
      ""Description"": ""Despite using the nonReentrant modifier, there's a reentrancy vulnerability in the switchStrategy function. The contract updates the user's balance in the current strategy before making external calls to unlockTokens and lockTokens. If the external IYield strategy contract is malicious or compromised, it could reenter the contract during these calls before the operation is complete."",
      ""Impact"": ""An attacker could potentially exploit this to drain funds by manipulating the state between external calls, allowing recursive calls that could lead to fund theft."",
      ""Location"": ""switchStrategy function (lines 120-163)""
    },
    {
      ""Issue"": ""Reentrancy risk in token transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The _transfer function uses low-level call for ETH transfers without proper protection mechanisms. While most functions are protected by the nonReentrant modifier, the underlying _transfer function could be vulnerable to reentrancy attacks when handling ETH transfers."",
      ""Impact"": ""A malicious recipient contract could reenter the contract during the ETH transfer and potentially manipulate contract state or drain funds."",
      ""Location"": ""_transfer function (lines 215-264)""
    },
    {
      ""Issue"": ""Missing Access Control in withdrawAll"",
      ""Severity"": ""High"",
      ""Description"": ""The withdrawAll functions lack proper access control. Unlike withdrawFrom, these functions don't check if an address has permission to withdraw all funds from a user's account. This breaks the permission model established elsewhere in the contract."",
      ""Impact"": ""Anyone can call withdrawAll to withdraw all tokens from their own account, regardless of allowances set by creditLine or other entities. This could disrupt protocols relying on token allowances for financial operations."",
      ""Location"": ""withdrawAll functions (lines 223-296)""
    },
    {
      ""Issue"": ""Inconsistent state management in case of external call failures"",
      ""Severity"": ""High"",
      ""Description"": ""The contract modifies state (e.g., updating balanceInShares) before making external calls to other contracts. If those calls fail, the state changes will be reverted, but there's inconsistent handling of these scenarios across different functions."",
      ""Impact"": ""Failed external calls can leave users with inconsistent state or locked funds, potentially leading to accounting issues or loss of funds."",
      ""Location"": ""Multiple functions making external calls to IYield strategies""
    },
    {
      ""Issue"": ""Incorrect ERC20 approval pattern"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the switchStrategy function, the contract approves tokens to the new strategy without first resetting the allowance to zero. Some ERC20 tokens (like USDT) require setting approval to 0 before changing it to another non-zero value. This is against the recommended pattern for certain ERC20 tokens that might have vulnerabilities with the approve function."",
      ""Impact"": ""The function might fail when switching strategies for certain tokens, causing denial of service. For certain ERC20 implementations, this could also lead to double-spend attacks where both the old and new allowance values could be utilized."",
      ""Location"": ""switchStrategy function (line 137-155)""
    },
    {
      ""Issue"": ""Lack of slippage protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""When withdrawing or switching strategies, there's no slippage protection mechanism or minimum amount check. The contract doesn't verify if the number of tokens received meets a minimum threshold, which may result in users receiving significantly fewer tokens than expected due to market fluctuations or manipulation."",
      ""Impact"": ""Users could receive significantly fewer tokens than expected due to market fluctuations or malicious strategies. This makes transactions vulnerable to sandwich attacks or unexpected price movements, potentially leading to value loss."",
      ""Location"": ""withdraw, withdrawFrom, and switchStrategy functions""
    },
    {
      ""Issue"": ""Potential denial of service in withdrawAll function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The withdrawAll function loops through all registered strategies, which could potentially hit gas limits if there are too many strategies registered. If the gas limit is reached, the transaction would revert and users couldn't withdraw their funds."",
      ""Impact"": ""Users might be unable to withdraw all their funds if there are too many strategies registered, effectively locking their assets."",
      ""Location"": ""withdrawAll function (lines 228-296)""
    },
    {
      ""Issue"": ""Insufficient strategy validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (withdraw, withdrawFrom, withdrawAll) don't validate if the strategy is registered in the strategyRegistry before operating on them, relying on subsequent calls to fail instead of checking upfront. Only deposit and switchStrategy validate the strategy's existence using IStrategyRegistry."",
      ""Impact"": ""Interacting with non-existent or deprecated strategies could lead to unexpected behavior, transaction failures, or locked funds."",
      ""Location"": ""withdraw, withdrawFrom, and withdrawAll functions""
    },
    {
      ""Issue"": ""Missing zero address validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (withdrawFrom, switchStrategy, transfer, transferFrom) don't validate that the _to address is not the zero address before transferring funds, unlike the deposit function which includes this check."",
      ""Impact"": ""Funds could be accidentally or maliciously sent to the zero address and become permanently lost or unrecoverable."",
      ""Location"": ""withdrawFrom, switchStrategy, transfer, and transferFrom functions""
    },
    {
      ""Issue"": ""Centralization risk with owner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant power to the owner, who can update critical components like strategyRegistry and creditLine. If the owner is compromised, it could affect all user funds. There's no timelock or multi-signature requirement for these sensitive operations."",
      ""Impact"": ""A malicious or compromised owner could replace the strategyRegistry or creditLine with malicious contracts to steal funds, creating a central point of failure that could compromise the entire system."",
      ""Location"": ""updateStrategyRegistry and updateCreditLine functions""
    },
    {
      ""Issue"": ""Inconsistent ETH handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract handles ETH (address(0)) differently across functions, creating inconsistency. Some functions use msg.value validation while others don't check for proper ETH value. This non-standard approach could cause confusion or integration issues."",
      ""Impact"": ""Could lead to unexpected behavior when dealing with ETH transfers, particularly in complex operations. May also cause integration difficulties with other systems that use a different convention for representing ETH."",
      ""Location"": ""_depositToYield function (line 96) vs other functions handling ETH""
    },
    {
      ""Issue"": ""Missing return value checks from ERC20 calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calls to external contracts (IYield interfaces) and token operations don't validate return values or handle potential failures properly, especially for non-standard tokens."",
      ""Impact"": ""If the token transfer fails silently or external strategy contracts behave unexpectedly, the contract may continue execution as if the operation succeeded, potentially leading to accounting issues or unexpected behavior."",
      ""Location"": ""_depositToYield function and other functions interacting with ERC20 tokens""
    },
    {
      ""Issue"": ""Initialization vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function is external and can be called by anyone if not properly protected during deployment. A malicious actor could potentially frontrun the deployment transaction and initialize the contract with their own parameters. Additionally, the contract uses initializer pattern but first calls __Ownable_init() and then immediately transfers ownership, which might create confusion."",
      ""Impact"": ""An attacker could gain ownership of the contract by calling initialize before the legitimate owner, leading to potential confusion about ownership and privileges."",
      ""Location"": ""initialize function (lines 46-60)""
    },
    {
      ""Issue"": ""Inheritance issues with ReentrancyGuard"",
      ""Severity"": ""Medium"",
      ""Description"": ""ReentrancyGuard is imported from OpenZeppelin but is not properly initialized since it's not using the upgradeable version (should be ReentrancyGuardUpgradeable for consistency with OwnableUpgradeable). The contract inherits from it but never calls its initializer."",
      ""Impact"": ""The nonReentrant modifier might not function correctly in the context of proxy upgrades, potentially leaving functions vulnerable to reentrancy attacks. Future contract upgrades might also break due to storage layout incompatibilities."",
      ""Location"": ""Contract inheritance declaration (line 13-16)""
    },
    {
      ""Issue"": ""No emergency pause mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks an emergency pause or fund recovery mechanisms in case vulnerabilities are discovered in integrated strategies. There's no way to quickly secure funds or pause operations."",
      ""Impact"": ""If a vulnerability is found in the contract or its integrated strategies, there's no way to quickly pause the contract to prevent further exploitation while a fix is developed."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Precision loss in token-to-shares conversion"",
      ""Severity"": ""Low"",
      ""Description"": ""When converting between tokens and shares in various functions, there could be precision loss, especially if the underlying yield strategies use different decimal standards."",
      ""Impact"": ""Users might receive slightly fewer tokens than expected due to rounding issues in conversion calculations, which could accumulate into meaningful losses over time."",
      ""Location"": ""Functions calling IYield(_strategy).getSharesForTokens and getTokensForShares""
    },
    {
      ""Issue"": ""Lack of events for important state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical state changes don't emit events, such as in the initialize function when setting critical contract parameters like strategyRegistry and creditLine addresses. This makes it difficult to track important changes off-chain."",
      ""Impact"": ""Reduced transparency and more difficult tracking of actual token movements and state changes, especially in complex operations. Makes debugging and monitoring more challenging."",
      ""Location"": ""initialize function and other state-changing functions""
    },
    {
      ""Issue"": ""No mechanism to recover accidentally sent tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't have a mechanism to recover tokens that might be accidentally sent directly to the contract address rather than deposited through the proper functions."",
      ""Impact"": ""Tokens sent directly to the contract could be permanently locked and unrecoverable."",
      ""Location"": ""Throughout the contract (missing functionality)""
    }
  ],
  ""IssueNumber"": 80,
  ""OutputList"": 18
}",388.757920026779,73918.0,32.0,"### **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**

**Report Description**:
The `withdrawAll()` and `switchStrategy()` functions in the SavingsAccount contract can lead to incorrect accounting and frozen user funds if the underlying strategy (e.g., AaveYield) has liquidity issues. Specifically:
- `withdrawAll()` deletes the user's entry even if only a partial withdrawal is possible, locking the remaining funds in the strategy.
- `switchStrategy()` subtracts the full number of shares from the old strategy but adds a lesser number of shares to the new strategy if the withdrawal is partial, effectively freezing the user's funds within the system.

**Match in Response List**:
No direct match found. The closest related issue is **""Inconsistent state management in case of external call failures""**, which mentions that failed external calls can leave users with inconsistent state or locked funds. However, this does not specifically address the liquidity issues in `withdrawAll()` and `switchStrategy()`.

**Validation**:
**Incorrect**. The response does not directly address the core issue of liquidity problems in `withdrawAll()` and `switchStrategy()`. While it mentions inconsistent state management due to external call failures, it does not cover the specific risks of partial withdrawals and frozen funds caused by strategy liquidity issues.

---

### **[H-08] Possibility to drain SavingsAccount contract assets**

**Report Description**:
A malicious actor can manipulate the `switchStrategy()` function to withdraw tokens locked in the SavingsAccount contract. The severity of this risk should be reviewed, as it could potentially lead to asset drainage.

**Match in Response List**:
No direct match found. The closest related issue is **""Reentrancy vulnerability in switchStrategy function""**, which discusses a reentrancy vulnerability in `switchStrategy()`. However, this does not specifically address the risk of draining assets from the SavingsAccount contract.

**Validation**:
**Incorrect**. The response does not address the specific risk of asset drainage through manipulation of `switchStrategy()`. While it identifies a reentrancy vulnerability, it does not cover the potential for malicious actors to drain locked tokens from the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**
- **[H-08] Possibility to drain SavingsAccount contract assets**

---

### **Analysis of Gaps**:
The `response_list` does not adequately address the specific issues raised in the `issue` report. While it covers general vulnerabilities like reentrancy and inconsistent state management, it misses the critical risks associated with liquidity issues in `withdrawAll()` and `switchStrategy()` and the potential for asset drainage. These gaps highlight the need for more detailed and specific responses to ensure comprehensive coverage of all vulnerabilities in the contract.",0,1,1,18,"```
None.
```",0.0
PriceOracle.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     **/
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param token address of token for which price feed is added
     * @param priceOracle addrewss of the price feed for the token
     **/
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",2032.0,223.0,"[H-09] PriceOracle Does Not Filter Price Feed Outliers

Function `getLatestPrice()`

If for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.
In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.",1.0,,"pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    
    mapping(bytes32 => address) public uniswapPools;

    
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",1404.0,1.0,0.0,"Based on the comprehensive initial analysis, here's a detailed task list for auditing the PriceOracle contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify SafeMath usage to prevent potential arithmetic overflow/underflow"",
        ""Check for reentrancy risks in external contract calls (Chainlink and Uniswap)"",
        ""Validate input sanitization for all external and public functions"",
        ""Review error handling in try-catch blocks in getDecimals function""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Analyze Chainlink price feed validation mechanism for robustness"",
        ""Evaluate TWAP (Time-Weighted Average Price) calculation for potential manipulation"",
        ""Check staleness protection for oracle price feeds"",
        ""Verify decimal normalization logic between different price sources""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review ownership transfer and initialization process"",
        ""Verify onlyOwner modifier implementation for sensitive functions"",
        ""Check for potential centralization risks in admin functions"",
        ""Validate event emissions for critical administrative actions""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit interface interactions with Chainlink AggregatorV3Interface"",
        ""Review Uniswap V3 OracleLibrary integration"",
        ""Check token decimal retrieval fallback mechanism"",
        ""Verify error handling for external contract calls""
      ]
    },
    {
      ""Area"": ""Price Calculation Logic"",
      ""Tasks"": [
        ""Verify price calculation accuracy across different token decimal configurations"",
        ""Check fallback mechanism between Chainlink and Uniswap price sources"",
        ""Analyze token pair identification and normalization logic"",
        ""Validate handling of zero addresses and non-existent feeds""
      ]
    },
    {
      ""Area"": ""Contract Upgradability"",
      ""Tasks"": [
        ""Review Initializable pattern implementation"",
        ""Check for potential storage collision risks"",
        ""Verify initialization function security"",
        ""Validate ownership transfer in initialization""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of key functions"",
        ""Review memory vs storage usage"",
        ""Check inline assembly or optimization opportunities"",
        ""Evaluate computational complexity of price calculation methods""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test behavior with tokens having non-standard decimal implementations"",
        ""Verify handling of price feeds with zero or extreme values"",
        ""Check error reversion messages for clarity and specificity"",
        ""Test scenarios with unsupported token pairs""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify adherence to IPriceOracle interface requirements"",
        ""Check ERC20 token interaction compliance"",
        ""Review event emissions for standards compatibility"",
        ""Validate function visibility and access modifiers""
      ]
    }
  ]
}

Key Audit Priorities:
1. Oracle price feed integrity and manipulation resistance
2. Security of external contract interactions
3. Robust error handling and input validation
4. Comprehensive access control mechanisms

Recommended Next Steps:
- Conduct thorough unit testing for each identified task
- Perform static code analysis
- Consider formal verification of critical mathematical operations
- Develop comprehensive test cases covering edge cases and potential attack vectors

The task list provides a structured approach to auditing the PriceOracle contract, focusing on critical security, performance, and reliability aspects.","After carefully analyzing the provided smart contract, here's my detailed audit in the requested format:

{
  ""ReviewingTheCode"": ""This contract serves as a price oracle that provides price data between two tokens. It uses both Chainlink and Uniswap V3 as data sources, with Chainlink being the primary source and Uniswap as a fallback. The contract is upgradeable, following the OpenZeppelin upgradeable pattern, and includes owner-only administrative functions to set price feeds."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PriceOracle"",
    ""Purpose"": ""To provide token price data from either Chainlink oracles or Uniswap pools, with Chainlink being prioritized."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""IPriceOracle""
      ],
      ""Imports"": [
        ""@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol"",
        ""@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/token/ERC20/ERC20.sol"",
        ""./interfaces/IPriceOracle.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""uniswapPriceAveragingPeriod"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Time period for calculating TWAP (Time-Weighted Average Price) from Uniswap pools""
      },
      {
        ""Name"": ""chainlinkFeedAddresses"",
        ""Type"": ""mapping(address => PriceData)"",
        ""Purpose"": ""Maps token addresses to their corresponding Chainlink price feed info""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maps token addresses to their decimal precision values""
      },
      {
        ""Name"": ""uniswapPools"",
        ""Type"": ""mapping(bytes32 => address)"",
        ""Purpose"": ""Maps token pair identifiers to their Uniswap pool addresses""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the upgradeable contract and transfers ownership to admin"",
        ""Parameters"": [""_admin: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""getChainlinkLatestPrice"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Fetches the latest price ratio between two tokens using Chainlink price feeds"",
        ""Parameters"": [""num: address"", ""den: address""],
        ""Returns"": [""price: uint256"", ""decimals: uint256""]
      },
      {
        ""Name"": ""getDecimals"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Safely determines the decimal precision of an ERC20 token"",
        ""Parameters"": [""_token: address""],
        ""Returns"": [""decimals: uint8""]
      },
      {
        ""Name"": ""getUniswapLatestPrice"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Fetches the latest price ratio between two tokens using Uniswap TWAP"",
        ""Parameters"": [""num: address"", ""den: address""],
        ""Returns"": [""price: uint256"", ""decimals: uint256""]
      },
      {
        ""Name"": ""getUniswapPoolTokenId"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Generates a unique identifier for a token pair, regardless of token order"",
        ""Parameters"": [""num: address"", ""den: address""],
        ""Returns"": [""poolId: bytes32""]
      },
      {
        ""Name"": ""getLatestPrice"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Main interface function that attempts to get price from Chainlink first, then falls back to Uniswap"",
        ""Parameters"": [""num: address"", ""den: address""],
        ""Returns"": [""price: uint256"", ""decimals: uint256""]
      },
      {
        ""Name"": ""doesFeedExist"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Checks if a price feed exists for a token pair in either Chainlink or Uniswap"",
        ""Parameters"": [""token1: address"", ""token2: address""],
        ""Returns"": [""exists: bool""]
      },
      {
        ""Name"": ""setChainlinkFeedAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to configure a Chainlink price feed for a token"",
        ""Parameters"": [""token: address"", ""priceOracle: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setUniswapFeedAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to configure a Uniswap pool for a token pair"",
        ""Parameters"": [""token1: address"", ""token2: address"", ""pool: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setUniswapPriceAveragingPeriod"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to set the time period for Uniswap TWAP calculation"",
        ""Parameters"": [""_uniswapPriceAveragingPeriod: uint32""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Chainlink AggregatorV3Interface for price data"",
    ""Uniswap V3 OracleLibrary for TWAP calculations"",
    ""ERC20 contracts for querying token decimals""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern using OpenZeppelin's Initializable and OwnableUpgradeable"",
    ""Fallback mechanism between Chainlink and Uniswap price sources"",
    ""Token pair normalization for Uniswap pools using keccak256 hash"",
    ""Time-Weighted Average Price (TWAP) calculation for Uniswap prices"",
    ""SafeMath for arithmetic operations to prevent overflows""
  ],
  ""Questions"": [
    ""What is the value of uniswapPriceAveragingPeriod initialized to?"",
    ""Are there any events defined in IPriceOracle interface or elsewhere that are emitted in functions like setChainlinkFeedAddress?"",
    ""What happens if a token doesn't implement the decimals function according to ERC20 standard?"",
    ""How does the contract handle tokens with different decimal places correctly?"",
    ""Is there any protection against price manipulation in the Uniswap TWAP mechanism?""
  ]
}

Based on the audit, I've identified several potential concerns:

1. The `uniswapPriceAveragingPeriod` variable is not initialized in the `initialize` function, which could lead to using a zero value for TWAP calculations.

2. The error handling for failed decimal queries is basic - it returns 0 which could cause issues with price calculations.

3. There is no validation when setting Chainlink feed addresses to ensure they correspond to the correct token.

4. The contract lacks mechanisms to check for stale Chainlink data beyond the basic roundID comparison.

5. There's no circuit breaker mechanism if prices deviate significantly between updates.

The contract overall seems well-structured with appropriate use of libraries and design patterns, but these potential issues should be addressed to enhance security and reliability.","I've analyzed the input data containing various security issues identified in the PriceOracle contract. After merging similar issues, removing redundancies, and sorting by severity, here's the consolidated output:

{
  ""Findings"": [
    {
      ""Issue"": ""Inadequate price staleness validation"",
      ""Severity"": ""High"",
      ""Description"": ""The contract checks if Chainlink timestamps are non-zero and if answeredInRound >= roundID, but doesn't verify that the timestamp is recent enough. This basic validation is insufficient as it doesn't protect against stale prices that pass these checks. Without a proper freshness check against the current block timestamp, the contract could use outdated price data in its calculations."",
      ""Impact"": ""Stale price data could be used for critical financial operations, potentially enabling exploits during market volatility, allowing attackers to manipulate financial decisions, and causing significant financial losses to dependent systems."",
      ""Location"": ""getChainlinkLatestPrice function""
    },
    {
      ""Issue"": ""Price manipulation vulnerability in Uniswap TWAP"",
      ""Severity"": ""High"",
      ""Description"": ""The getUniswapLatestPrice function and uniswapPriceAveragingPeriod parameter lack proper validation. The uniswapPriceAveragingPeriod is not initialized in the initialize function, and there's no minimum bound validation when setting it. If this period is set too short or remains at the default zero value, it makes prices susceptible to manipulation through flash loan attacks and similar methods."",
      ""Impact"": ""If uniswapPriceAveragingPeriod is set too low or left uninitialized (zero), prices could be manipulated through flash loans or other temporary market distortions, allowing attackers to influence the oracle price and potentially causing significant financial damage to dependent protocols."",
      ""Location"": ""getUniswapLatestPrice function, setUniswapPriceAveragingPeriod function, and uniswapPriceAveragingPeriod state variable""
    },
    {
      ""Issue"": ""No circuit breaker for extreme price movements"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a circuit breaker mechanism or safety check to detect and handle extreme price movements or flash crashes. There are no bounds checks on price values to identify abnormal prices that could indicate oracle manipulation or failure."",
      ""Impact"": ""During periods of extreme market volatility, flash crashes, or oracle failures, the system could use highly volatile or manipulated prices that don't reflect true market conditions, leading to improper liquidations or other adverse effects in dependent protocols."",
      ""Location"": ""getLatestPrice function, getChainlinkLatestPrice and getUniswapLatestPrice functions""
    },
    {
      ""Issue"": ""Insufficient validation of oracle addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""When setting Chainlink or Uniswap feed addresses via setChainlinkFeedAddress and setUniswapFeedAddress, there's minimal validation that the provided addresses are actually valid oracles or pools implementing the expected interfaces. The functions don't check for zero addresses, and for Chainlink it only checks the decimals but doesn't verify other critical functionalities."",
      ""Impact"": ""Setting an incorrect, malicious, or zero address oracle could lead to incorrect price data being returned, potentially leading to system-wide issues including incorrect liquidations, incorrect loan values, or economic attacks on dependent protocols."",
      ""Location"": ""setChainlinkFeedAddress and setUniswapFeedAddress functions""
    },
    {
      ""Issue"": ""Potential arithmetic issues in price calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""While SafeMath is used for multiplication and division, the price calculation in getChainlinkLatestPrice involves multiple operations with large numbers and decimal adjustments. This complex calculation with multiple multiplications and divisions could lead to precision loss, overflow, or underflow in certain scenarios, especially when dealing with tokens that have unusual decimal values."",
      ""Impact"": ""Incorrect price calculations due to precision loss, overflow, or underflow could affect dependent protocols and lead to financial losses or unexpected behavior in systems relying on this oracle."",
      ""Location"": ""getChainlinkLatestPrice function, particularly the price calculation""
    },
    {
      ""Issue"": ""Unsafe handling of token decimals"",
      ""Severity"": ""Medium"",
      ""Description"": ""The getDecimals function returns 0 if it fails to retrieve the decimals of a token or the call fails. This value is then used in price calculations without further validation. For non-standard tokens with a faulty decimals() implementation, the contract will use 0 decimals for calculations."",
      ""Impact"": ""If a token implementation has a faulty decimals() function or doesn't conform to ERC20 standards, using 0 as the default could result in drastically incorrect price calculations, potentially by orders of magnitude."",
      ""Location"": ""getDecimals function and its usage in getChainlinkLatestPrice""
    },
    {
      ""Issue"": ""Inconsistent error handling and fallback behavior"",
      ""Severity"": ""Medium"",
      ""Description"": ""The getLatestPrice function silently falls back to Uniswap TWAP if Chainlink data is unavailable, without notifying the consumer. Additionally, the contract uses a mix of require statements, custom error messages, and silent returns for different error conditions, making it difficult for integrating systems to uniformly handle errors."",
      ""Impact"": ""Applications using this oracle might make assumptions about price quality and reliability without knowing the actual source. Callers may struggle to properly handle all error cases, potentially resulting in unexpected behaviors in dependent systems."",
      ""Location"": ""getLatestPrice function, error handling throughout the contract""
    },
    {
      ""Issue"": ""Centralization risk in oracle management"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from OwnableUpgradeable, giving the owner full control over setting price feeds and parameters with no time-locks or governance processes. The owner can instantly change price sources and parameters, creating a single point of failure."",
      ""Impact"": ""A compromised owner account could manipulate the entire system by pointing to fraudulent price feeds or setting inappropriate parameters, potentially causing significant financial damage to dependent systems."",
      ""Location"": ""setChainlinkFeedAddress, setUniswapFeedAddress, and setUniswapPriceAveragingPeriod functions""
    },
    {
      ""Issue"": ""Missing events for critical parameter changes"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract emits events for feed updates and averaging period changes, it doesn't emit events for initialization or ownership transfers, which are significant administrative changes that should be logged."",
      ""Impact"": ""Reduced transparency and auditability of administrative actions on the contract, making it more difficult to track contract deployment, configuration, and monitor for proper setup."",
      ""Location"": ""initialize function and ownership transfers""
    }
  ],
  ""IssueNumber"": 109,
  ""OutputList"": 9
}",351.865062236786,52838.0,32.0,"### **[H-09] PriceOracle Does Not Filter Price Feed Outliers**

**Report Description**:  
The `getLatestPrice()` function in the `PriceOracle` contract does not filter or validate price feed outliers. If the Chainlink oracle returns a malformed price due to manipulation or malfunction, the result is passed directly to users, potentially causing unintended consequences. This vulnerability provides a substantial attack surface, as price outliers can significantly impact user economics. Implementing mitigation mechanics, such as bounds checks or circuit breakers, is recommended to ensure sustainable price movements and reduce risks.

**Match in Response List**:  
Matches with the issue titled **""No circuit breaker for extreme price movements""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of a circuit breaker mechanism or safety checks for extreme price movements, which aligns with the issue of price feed outliers. However, the response does not explicitly address the specific risk of Chainlink oracle manipulation or malfunction, nor does it propose mitigation mechanics like bounds checks or outlier filtering. While the core concern is acknowledged, critical details and potential solutions are missing.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-09] PriceOracle Does Not Filter Price Feed Outliers**

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation highlights that while the response partially addresses the issue, it lacks specificity and actionable recommendations to fully mitigate the described vulnerability.",1,0,0,9,"```
None.
```",0.0
NoYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to query liquidity token for a given asset
     * @param _asset address of the asset
     * @return _tokenAddress address of the lqiudity token for the asset
     **/
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    /**
     * @notice Used to lock tokens in the protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from the protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return tokensReceived received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",1322.0,165.0,"[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()

Submitted by WatchPug, also found by 0x1f8b
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83
function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
    require(_wallet != address(0), 'cant burn');
    uint256 amount = IERC20(_asset).balanceOf(address(this));
    IERC20(_asset).safeTransfer(_wallet, received);
    received = amount;
}

received is not being assigned prior to L81, therefore, at L81, received is 0.
As a result, the emergencyWithdraw() does not work, in essence.


[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract

The `emergencyWithdraw` function is implemented in all yield sources to allow the onlyOwner role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on _asset which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the NoYield contract in the event of an emergency.
  [M-06] NoYield.sol Tokens with fee on transfer are not supported

There are ERC20 tokens that charge fee for every transfer() or transferFrom().
In the current implementation, NoYield.sol#lockTokens() assumes that the received amount is the same as the transfer amount, and uses it to calculate sharesReceived amounts.
As a result, in `unlockTokens()`, later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance.
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L93-L106",3.0,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';


contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",786.0,2.0,1.0,"Based on the detailed analysis of the NoYield contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in lockTokens and unlockTokens methods"",
        ""Investigate potential integer overflow/underflow risks in token amount calculations"",
        ""Check for unchecked external calls, especially in ETH transfer methods"",
        ""Validate low-level call implementation in _unlockTokens method""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify owner and savingsAccount role separation"",
        ""Audit onlySavingsAccount and onlyOwner modifier implementations"",
        ""Review initialize function for potential initialization vulnerabilities"",
        ""Check transferOwnership mechanism for potential privilege escalation""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Validate SafeERC20 usage for token transfers"",
        ""Verify handling of both ERC20 tokens and native ETH"",
        ""Check token amount validation in lockTokens and unlockTokens methods"",
        ""Review 1:1 token-to-share ratio implementation""
      ]
    },
    {
      ""Area"": ""Emergency Mechanisms"",
      ""Tasks"": [
        ""Audit emergencyWithdraw function for potential vulnerabilities"",
        ""Verify emergency withdrawal access controls"",
        ""Check for complete token recovery mechanisms"",
        ""Validate event logging for emergency withdrawals""
      ]
    },
    {
      ""Area"": ""Contract Interactions"",
      ""Tasks"": [
        ""Investigate unused imports (ICEther.sol, ICToken.sol)"",
        ""Verify interface compliance with IYield"",
        ""Check external contract interaction patterns"",
        ""Review potential attack vectors in cross-contract calls""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze function gas costs"",
        ""Review use of pure and view functions"",
        ""Check storage variable access patterns"",
        ""Evaluate SafeMath library usage efficiency""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Review require statement implementations"",
        ""Check error message clarity and specificity"",
        ""Validate error handling in token transfer methods"",
        ""Ensure comprehensive error coverage in critical functions""
      ]
    },
    {
      ""Area"": ""Event and Logging"",
      ""Tasks"": [
        ""Verify event emission in key functions"",
        ""Check event data completeness"",
        ""Validate event logging for critical state changes"",
        ""Ensure events provide sufficient context for off-chain tracking""
      ]
    }
  ]
}

Key observations driving this task list:

1. The contract has several potential vulnerabilities, particularly in the emergencyWithdraw function.
2. There's a mix of token and ETH handling that requires careful verification.
3. Access control mechanisms need thorough review.
4. Unused imports and potential interface misalignments exist.
5. The 1:1 token-to-share ratio implementation requires careful scrutiny.

The task list is designed to provide a comprehensive, systematic approach to auditing the NoYield contract, addressing security, functionality, and optimization concerns.","I'll perform a thorough audit of the provided smart contract code:

{
  ""ReviewingTheCode"": ""The contract 'NoYield' implements the IYield interface and serves as a non-yielding investment strategy in a savings system. It acts as a pass-through contract that doesn't actually generate yield but maintains a 1:1 ratio between tokens and shares. It includes functionality for locking tokens, unlocking tokens, and emergency withdrawals."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NoYield"",
    ""Purpose"": ""A non-yield-generating investment strategy contract that implements the IYield interface. It allows users to lock tokens in the contract and unlock them later with a 1:1 token-to-share ratio."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IYield"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/ICEther.sol"",
        ""../interfaces/Invest/ICToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the savings account contract that can call privileged functions""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlySavingsAccount"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function access to only the savingsAccount address"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with an owner and savings account address"",
        ""Parameters"": [""_owner (address)"", ""_savingsAccount (address payable)""],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidityToken"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the same asset address as passed in, implementing the IYield interface"",
        ""Parameters"": [""_asset (address)""],
        ""Returns"": [""_tokenAddress (address)""]
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the savings account address, only callable by owner"",
        ""Parameters"": [""_savingsAccount (address payable)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of updating savings account address"",
        ""Parameters"": [""_savingsAccount (address payable)""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to withdraw all tokens of a specific asset in case of emergency"",
        ""Parameters"": [""_asset (address)"", ""_wallet (address payable)""],
        ""Returns"": [""received (uint256)""]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Locks tokens into the contract, only callable by savingsAccount"",
        ""Parameters"": [""user (address)"", ""asset (address)"", ""amount (uint256)""],
        ""Returns"": [""sharesReceived (uint256)""]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlocks tokens and transfers them to the savingsAccount"",
        ""Parameters"": [""asset (address)"", ""amount (uint256)""],
        ""Returns"": [""tokensReceived (uint256)""]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Identical to unlockTokens in this implementation"",
        ""Parameters"": [""asset (address)"", ""amount (uint256)""],
        ""Returns"": [""received (uint256)""]
      },
      {
        ""Name"": ""_unlockTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation for unlocking tokens"",
        ""Parameters"": [""asset (address)"", ""amount (uint256)""],
        ""Returns"": [""received (uint256)""]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""external pure"",
        ""Purpose"": ""Returns the same amount as shares (1:1 ratio)"",
        ""Parameters"": [""shares (uint256)"", ""asset (address)""],
        ""Returns"": [""amount (uint256)""]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external pure"",
        ""Purpose"": ""Returns the same amount as tokens (1:1 ratio)"",
        ""Parameters"": [""amount (uint256)"", ""asset (address)""],
        ""Returns"": [""shares (uint256)""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""Interacts with ERC20 tokens using SafeERC20 library"",
    ""Makes a low-level call to savingsAccount when transferring ETH"",
    ""Receives ETH when locking native ETH tokens""
  ],
  
  ""SpecialMechanisms"": [
    ""Implements a proxy pattern with the Initializable contract and initialize function instead of a constructor"",
    ""Uses ReentrancyGuard to prevent reentrancy attacks"",
    ""Handles both ERC20 tokens and native ETH"",
    ""Uses the upgradeable version of Ownable for access control""
  ],
  
  ""Questions"": [
    ""There's a potential bug in the emergencyWithdraw function where it uses 'received' in the IERC20 transfer before 'received' is assigned a value. It should be transferring 'amount' instead of 'received'."",
    ""The contract imports ICEther.sol and ICToken.sol but doesn't use them. Are they needed?"",
    ""The contract uses SafeMath but actual SafeMath operations are not visible in the provided code."",
    ""What events are part of the IYield interface that are being emitted (LockedTokens, UnlockedTokens, SavingsAccountUpdated)?""
  ]
}","{
""Findings"": [
{
""Issue"": ""Incorrect Implementation of emergencyWithdraw Function"",
""Severity"": ""High"",
""Description"": ""The emergencyWithdraw function contains a critical logic error where it attempts to transfer tokens using the 'received' variable before it's initialized. The function transfers 'received' amount to the wallet but only sets 'received = amount' after the transfer. Additionally, the function lacks ETH withdrawal capability and doesn't emit events for tracking."",
""Impact"": ""The emergency withdrawal mechanism is completely broken. It will transfer 0 tokens while reporting a successful withdrawal of the full balance. This prevents the rescue of both tokens and ETH in emergency situations, potentially leading to permanent fund loss."",
""Location"": ""emergencyWithdraw function""
},
{
""Issue"": ""Inheritance and Initialization Pattern Issues"",
""Severity"": ""Medium"",
""Description"": ""The contract mixes upgradeable (OwnableUpgradeable) and non-upgradeable (ReentrancyGuard) patterns. The ReentrancyGuard is not properly initialized in the upgradeable context, and the initialization function can potentially be front-run by attackers."",
""Impact"": ""This could lead to initialization issues during upgrades, potentially compromising the contract's security features, particularly the reentrancy protection. Additionally, front-running of initialization could allow attackers to take control of the contract."",
""Location"": ""Contract inheritance declarations and initialize function""
},
{
""Issue"": ""Unsafe ETH Handling"",
""Severity"": ""Medium"",
""Description"": ""The contract uses low-level .call for ETH transfers without proper gas limitations, lacks receive/fallback functions for direct ETH transfers, and doesn't implement proper validation for ETH operations. There's also no balance checking before ETH transfers."",
""Impact"": ""This could lead to trapped ETH in the contract, potential reentrancy vulnerabilities despite guards, and failed transactions due to insufficient balance or gas issues."",
""Location"": ""_unlockTokens function and throughout contract""
},
{
""Issue"": ""Insufficient Input Validation"",
""Severity"": ""Medium"",
""Description"": ""The contract lacks proper validation for asset addresses, doesn't verify token contract existence, and has no protection against non-standard or malicious token implementations. This includes missing validation in token/shares conversion functions."",
""Impact"": ""Integration with problematic or non-standard tokens could lead to unexpected behaviors, trapped funds, or contract state inconsistencies."",
""Location"": ""lockTokens, unlockTokens, and token conversion functions""
},
{
""Issue"": ""Missing Events and Transparency"",
""Severity"": ""Low"",
""Description"": ""Critical functions like emergencyWithdraw don't emit events, reducing transparency and making it difficult to track important contract actions off-chain."",
""Impact"": ""Reduced auditability and monitoring capability for critical contract operations, particularly during emergency situations."",
""Location"": ""emergencyWithdraw and other critical functions""
},
{
""Issue"": ""Code Quality and Maintenance Issues"",
""Severity"": ""Low"",
""Description"": ""The contract contains unused imports (ICEther, ICToken), redundant SafeMath usage, and inconsistent implementation of interfaces. The yield calculation functions provide misleading implementations."",
""Impact"": ""While not directly security-critical, these issues can lead to maintenance confusion, increased gas costs, and potential misunderstandings by integrating protocols."",
""Location"": ""Throughout contract, particularly in import statements and yield calculation functions""
}
],
""IssueNumber"": 42,
""OutputList"": 6
}",311.0,10709.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Report Description**:  
The `emergencyWithdraw` function in `NoYield.sol` has a critical logic error. The variable `received` is used in the `safeTransfer` call before it is initialized, resulting in a transfer of `0` tokens. This renders the function ineffective, as it fails to transfer the intended amount of tokens during an emergency withdrawal.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Implementation of emergencyWithdraw Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `emergencyWithdraw` function, specifically the incorrect usage of the `received` variable before initialization. It also highlights the broader impact of this issue, which aligns with the report's description. The response fully covers the vulnerability and its implications.

---

#### **[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**

**Report Description**:  
The `emergencyWithdraw` function does not support ETH withdrawals because it treats ETH as a zero address asset. However, the function reverts when `_asset` is the zero address, making it impossible to withdraw ETH in an emergency.

**Match in Response List**:  
Partially matches with the issue titled **""Unsafe ETH Handling""**.

**Validation**:  
**Partially Correct**. The response identifies issues with ETH handling in the contract, including the lack of proper validation and balance checking. However, it does not explicitly mention the inability to withdraw ETH due to the zero address check in `emergencyWithdraw`. While related, the response misses the specific issue described in the report.

---

#### **[M-06] NoYield.sol Tokens with fee on transfer are not supported**

**Report Description**:  
The `lockTokens` function assumes that the received amount is the same as the transfer amount, which is incorrect for tokens with fee-on-transfer mechanisms. This can lead to insufficient balance issues in `unlockTokens`, potentially causing reverts and preventing users from withdrawing their tokens.

**Match in Response List**:  
Partially matches with the issue titled **""Insufficient Input Validation""**.

**Validation**:  
**Partially Correct**. The response mentions insufficient input validation for asset addresses and token contract existence but does not specifically address the issue of fee-on-transfer tokens. While the response touches on related concerns, it does not fully cover the vulnerability described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Partially Correct Matches**:

- **[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**
- **[M-06] NoYield.sol Tokens with fee on transfer are not supported**

**Missed Issues from Issue Report**:

- *None* (All issues are at least partially matched, but some critical details are missing in the responses.)

---

### **Overall Assessment**

The `response_list` provides a good coverage of the issues reported, with one **correct match** and two **partially correct matches**. However, the partially correct responses miss critical details that are essential for fully understanding and addressing the vulnerabilities. Specifically:

1. The **ETH withdrawal issue** in `emergencyWithdraw` is not explicitly mentioned, despite being a significant flaw.
2. The **fee-on-transfer token issue** is not directly addressed, though it is somewhat related to the broader topic of insufficient input validation.

To improve the responses, the following additions are recommended:

- Explicitly mention the inability to withdraw ETH due to the zero address check in `emergencyWithdraw`.
- Address the specific issue of fee-on-transfer tokens and its impact on `lockTokens` and `unlockTokens`.
- Provide detailed mitigation strategies for each issue, such as proper initialization of variables, handling ETH withdrawals, and accounting for fee-on-transfer tokens.

By addressing these gaps, the responses would provide a more comprehensive and accurate coverage of the reported issues.",0,0,3,0,"```
1. Incorrect Implementation of emergencyWithdraw Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Incorrect Implementation of emergencyWithdraw Function"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - There is only one true positive, so the AP is simply the precision at rank 1.

**Output**:
- The **Average Precision (AP)** for the query is `1.0`."
PoolFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';

/**
 * @title Pool Factory contract with methods for handling different pools
 * @notice Implements the functions related to Pool (CRUD)
 * @author Sublime
 */
contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    /*
     * @notice Used to define limits for the Pool parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /**
     * @notice function definition of the pool contract
     */
    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(""initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)""))

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public poolImpl;

    /**
     * @notice address of the contract storing the user registry
     */
    address public override userRegistry;

    /**
     * @notice address of the contract storing the strategy registry
     */
    address public strategyRegistry;

    /**
     * @notice address of the latest implementation of the extension logic
     */
    address public override extension;

    /**
     * @notice address of the latest implementation of the repayment logic
     */
    address public override repaymentImpl;

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public override priceOracle;

    /**
     * @notice address of the savings account used
     */
    address public override savingsAccount;

    /**
     * @notice the time interval for the lenders to make contributions to pool
     */
    uint256 public override collectionPeriod;

    /**
     * @notice the time interval for the borrower to withdraw the loan from pool
     */
    uint256 public override loanWithdrawalDuration;

    /**
     * @notice the time interval for the active stage of the margin call
     */
    uint256 public override marginCallDuration;

    /**
     * @notice Fraction of the requested amount for pool below which pool is cancelled
     */
    uint256 public override minBorrowFraction;

    /**
     * @notice the fraction used for calculating the liquidator reward
     */
    uint256 public override liquidatorRewardFraction;

    /**
     * @notice the fraction used for calculating the penalty when the pool is cancelled
     */
    uint256 public override poolCancelPenaltyMultiple;

    /**
     * @notice Contract Address of no yield
     */
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    /*
     * @notice Used to mark assets supported for borrowing
     */
    mapping(address => bool) isBorrowToken;

    /*
     * @notice Used to mark supported collateral assets
     */
    mapping(address => bool) isCollateralToken;

    /**
     * @notice Used to keep track of valid pool addresses
     */
    mapping(address => bool) public override poolRegistry;

    /*
     * @notice Used to set the min/max borrow amount for Pools
     */
    Limits poolSizeLimit;

    /*
     * @notice Used to set the min/max collateral ratio for Pools
     */
    Limits idealCollateralRatioLimit;

    /*
     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools
     */
    Limits borrowRateLimit;

    /*
     * @notice used to set the min/max repayment interval for Pools
     */
    Limits repaymentIntervalLimit;

    /*
     * @notice used to set the min/max number of repayment intervals for Pools
     */
    Limits noOfRepaymentIntervalsLimit;

    /**
     * @notice functions affected by this modifier can only be invoked by the Pool
     */
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    /**
     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool
     */
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    /**
     * @notice returns the owner of the pool
     */
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    /**
     * @notice used to initialize the pool factory
     * @dev initializer can only be run once
     * @param _admin address of admin
     * @param _collectionPeriod period for which lenders can lend for pool
     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts
     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained
     * @param _poolInitFuncSelector function signature for initializing pool
     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30
     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30
     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30
     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee
     * @param _protocolFeeCollector address where protocol fee is collected
     * @param _noStrategy address of the no strategy address
     */
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    /**
     * @notice used to setImplementation addresses
     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke
     * @param _poolImpl address of the implementation address of pool
     * @param _repaymentImpl address of the implementation address of repayments
     * @param _userRegistry address of the user registry where users are verified
     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted
     * @param _priceOracle address of the price oracle
     * @param _savingsAccount address of the savings account contract
     * @param _extension address of the extension contract for pools
     */
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    /**
     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request
     * @param _poolSize loan amount requested
     * @param _borrowToken borrow asset requested
     * @param _collateralToken collateral asset requested
     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower
     * @param _borrowRate interest rate provided by the borrower
     * @param _repaymentInterval interval between the last dates of two repayment cycles
     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan
     * @param _poolSavingsStrategy savings strategy selected for the pool collateral
     * @param _collateralAmount collateral amount deposited
     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet
     * @param _salt random and unique initial seed
     */
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    // @dev These functions are used to avoid stack too deep
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    // @dev These functions are used to avoid stack too deep
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    /**
     * @notice invoked to check if pool parameters are within thresholds
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    /**
     * @notice used to update the list of supported borrow tokens
     * @param _borrowToken address of the borrow asset
     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset
     */
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    /**
     * @notice used to update the list of supported Collateral tokens
     * @param _collateralToken address of the Collateral asset
     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset
     */
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    /**
     * @notice used to update the pointer to Initializer function of the proxy pool contract
     * @param _functionId updated function definition of the proxy pool contract
     */
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    /**
     * @notice used to update the Pool.sol logic
     * @param _poolLogic the address of the new Pool logic contract
     */
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    /**
     * @notice used to update the user registry
     * @param _userRegistry address of the contract storing the user registry
     */
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    /**
     * @notice used to update the strategy registry
     * @param _strategyRegistry address of the contract storing the strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the implementation of the repayment logic
     * @param _repaymentImpl address of the updated repayment.sol contract
     */
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    /**
     * @notice used to update contract address of nostrategy contract
     * @param _noStrategy address of the updated noYield.sol contract
     */
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    /**
     * @notice used to update the implementation of the price oracle logic
     * @param _priceOracle address of the updated price oracle contract
     */
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the extensions contract
     * @param _extension address of the updated extensions contract
     */
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    /**
     * @notice used to update the savings account contract
     * @param _savingsAccount address of the updated savings account contract
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the collection period of the Pool
     * @param _collectionPeriod updated value of the collection period
     */
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    /**
     * @notice used to update the loan withdrawal duration by owner
     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration
     */
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    /**
     * @notice used to update the active stage of the margin call of the Pool
     * @param _marginCallDuration updated value of the margin call duration
     */
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    /**
     * @notice used to update the min borrow fraction by owner
     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30
     */
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    /**
     * @notice used to update the reward fraction for liquidation of the Pool
     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30
     */
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the pool cancel penalty multiple
     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30
     */
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    /**
     * @notice used to update the fraction of borrowed amount charged as protocol fee
     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the address in which protocol fee is collected
     * @param _protocolFeeCollector updated address of protocol fee collector
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the thresholds of the pool size of the Pool
     * @param _min updated value of the minimum threshold value of the pool size
     * @param _max updated value of the maximum threshold value of the pool size
     */
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collateral ratio of the Pool
     * @param _min updated value of the minimum threshold value of the collateral ratio
     * @param _max updated value of the maximum threshold value of the collateral ratio
     */
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the Pool
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the repayment interval of the Pool
     * @param _min updated value of the minimum threshold value of the repayment interval
     * @param _max updated value of the maximum threshold value of the repayment interval
     */
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the number of repayment intervals of the Pool
     * @param _min updated value of the minimum threshold value of the number of repayment intervals
     * @param _max updated value of the maximum threshold value of the number of repayment intervals
     */
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    /**
     * @notice used to query protocol fee fraction and address of the collector
     * @return protocolFee Fraction multiplied by 10**30
     * @return address of protocol fee collector
     */
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",6187.0,746.0,"[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it

If a borrower calls the createPool function with a non-zero value, but also includes an ERC20 token address for _collateralToken, then the Ether value sent will be locked in the PoolFactory contract forever.
createPool L260-317
In the _createPool function, a _collateralToken address other than the zero address will set the amount variable to zero. That amount variable will be passed to create2 which will send 0 wei to the newly created Pool contract.
``` // _createPool L349
uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;
```",1.0,,"pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';


contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    
    struct Limits {
        uint256 min;
        uint256 max;
    }

    
    bytes4 public poolInitFuncSelector; 

    
    address public poolImpl;

    
    address public override userRegistry;

    
    address public strategyRegistry;

    
    address public override extension;

    
    address public override repaymentImpl;

    
    address public override priceOracle;

    
    address public override savingsAccount;

    
    uint256 public override collectionPeriod;

    
    uint256 public override loanWithdrawalDuration;

    
    uint256 public override marginCallDuration;

    
    uint256 public override minBorrowFraction;

    
    uint256 public override liquidatorRewardFraction;

    
    uint256 public override poolCancelPenaltyMultiple;

    
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    
    mapping(address => bool) isBorrowToken;

    
    mapping(address => bool) isCollateralToken;

    
    mapping(address => bool) public override poolRegistry;

    
    Limits poolSizeLimit;

    
    Limits idealCollateralRatioLimit;

    
    Limits borrowRateLimit;

    
    Limits repaymentIntervalLimit;

    
    Limits noOfRepaymentIntervalsLimit;

    
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",3731.0,0.0,1.0,"Based on the comprehensive analysis of the PoolFactory contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Verify the completeness of the onlyOwner modifier implementation"",
        ""Check that all critical update functions have proper access control"",
        ""Ensure the initialize function can only be called once"",
        ""Validate the ownership transfer mechanism for security""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct a thorough reentrancy analysis, especially in createPool and _createPool methods"",
        ""Check for potential integer overflow/underflow in mathematical operations"",
        ""Verify input validation for all external and public functions"",
        ""Analyze the CREATE2 deployment mechanism for potential address collision risks"",
        ""Review the handling of ETH transfers in pool creation"",
        ""Verify that all external contract calls have proper error handling""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate integration with IVerification for user verification"",
        ""Review price oracle interaction and potential manipulation risks"",
        ""Check strategy registry validation process"",
        ""Analyze the security of cross-contract calls in pool creation"",
        ""Verify the integrity of token support mappings (isBorrowToken, isCollateralToken)""
      ]
    },
    {
      ""Area"": ""Pool Creation Constraints"",
      ""Tasks"": [
        ""Thoroughly test the isWithinLimits function for all edge cases"",
        ""Verify the correctness of pool parameter limits (poolSizeLimit, borrowRateLimit, etc.)"",
        ""Check the validation logic for borrow and collateral tokens"",
        ""Ensure all pool creation constraints are comprehensive and cannot be bypassed""
      ]
    },
    {
      ""Area"": ""Protocol Fee Mechanism"",
      ""Tasks"": [
        ""Verify the correctness of protocol fee fraction calculation"",
        ""Check the implementation of getProtocolFeeData function"",
        ""Ensure protocol fee collector address cannot be set to a zero address"",
        ""Validate that protocol fee updates have appropriate constraints""
      ]
    },
    {
      ""Area"": ""Proxy and Upgradability"",
      ""Tasks"": [
        ""Review the proxy contract deployment mechanism"",
        ""Verify the security of the pool implementation update process"",
        ""Check for potential vulnerabilities in the upgradability pattern"",
        ""Ensure proper initialization of proxy contracts""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption of key functions"",
        ""Review the efficiency of mapping and storage operations"",
        ""Check for potential gas optimization opportunities"",
        ""Verify that complex operations are implemented efficiently""
      ]
    },
    {
      ""Area"": ""Event Logging and Transparency"",
      ""Tasks"": [
        ""Verify that all critical state changes emit events"",
        ""Check the completeness and accuracy of event parameters"",
        ""Ensure no sensitive information is exposed through events""
      ]
    },
    {
      ""Area"": ""Emergency and Fallback Mechanisms"",
      ""Tasks"": [
        ""Check for the existence of emergency stop or pause functionality"",
        ""Verify the process for handling unexpected scenarios"",
        ""Review the contract's resilience to potential system-wide failures""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers multiple critical aspects of smart contract security.
2. Each area focuses on specific potential vulnerabilities or improvement opportunities.
3. Tasks are designed to be actionable and specific to the PoolFactory contract's unique characteristics.
4. The list prioritizes security, functionality, and efficiency.

Recommended Next Steps:
- Conduct a detailed review following these task categories
- Use automated analysis tools to supplement manual review
- Perform comprehensive testing covering all identified task areas
- Consider a formal verification process for critical functions

The task list provides a structured approach to auditing the PoolFactory contract, ensuring a comprehensive examination of its security, functionality, and potential risks.","After reviewing the smart contract in detail, here's my comprehensive audit analysis:

{
  ""ReviewingTheCode"": ""The code defines a PoolFactory contract that acts as a factory for creating lending pools. It allows borrowers to create pools with specific terms, manages the creation of proxy contracts for these pools, and enforces various constraints on pool parameters. The contract also includes extensive configuration capabilities accessible only to the contract owner."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PoolFactory"",
    ""Purpose"": ""A factory contract that creates and manages lending pools with configurable parameters, enforces constraints on pool creation, and maintains registry of created pools."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable"", ""IPoolFactory""],
      ""Imports"": [
        ""Proxy.sol"",
        ""IPoolFactory"", 
        ""IPool"", 
        ""IVerification"", 
        ""IStrategyRegistry"", 
        ""IRepayment"", 
        ""IPriceOracle"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""Limits struct"",
        ""Type"": ""struct"",
        ""Purpose"": ""Defines minimum and maximum limits for various pool parameters""
      },
      {
        ""Name"": ""poolInitFuncSelector"",
        ""Type"": ""bytes4"",
        ""Purpose"": ""Function selector for pool initialization""
      },
      {
        ""Name"": ""poolImpl"",
        ""Type"": ""address"",
        ""Purpose"": ""Implementation address for the pool contract""
      },
      {
        ""Name"": ""userRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the user registry contract for verification""
      },
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the strategy registry contract""
      },
      {
        ""Name"": ""extension"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the extension contract""
      },
      {
        ""Name"": ""repaymentImpl"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the repayment implementation contract""
      },
      {
        ""Name"": ""priceOracle"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the price oracle contract""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the savings account contract""
      },
      {
        ""Name"": ""collectionPeriod"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the collection period for pools""
      },
      {
        ""Name"": ""loanWithdrawalDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration allowed for loan withdrawal""
      },
      {
        ""Name"": ""marginCallDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration allowed for margin calls""
      },
      {
        ""Name"": ""minBorrowFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum fraction of the pool that can be borrowed""
      },
      {
        ""Name"": ""liquidatorRewardFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction of collateral given as reward to liquidators""
      },
      {
        ""Name"": ""poolCancelPenaltyMultiple"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Penalty multiplier for canceling a pool""
      },
      {
        ""Name"": ""noStrategyAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address representing no strategy option""
      },
      {
        ""Name"": ""protocolFeeFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction of fees collected by the protocol""
      },
      {
        ""Name"": ""protocolFeeCollector"",
        ""Type"": ""address"",
        ""Purpose"": ""Address where protocol fees are sent""
      },
      {
        ""Name"": ""isBorrowToken"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks which tokens can be borrowed""
      },
      {
        ""Name"": ""isCollateralToken"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks which tokens can be used as collateral""
      },
      {
        ""Name"": ""poolRegistry"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Registry of created pool addresses""
      },
      {
        ""Name"": ""Various Limits variables"",
        ""Type"": ""Limits struct"",
        ""Purpose"": ""Define min/max limits for pool size, collateral ratio, borrow rate, etc.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to registered pools only""
      },
      {
        ""Name"": ""onlyBorrower"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to verified borrowers only""
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with default parameters"",
        ""Parameters"": [""_admin"", ""_collectionPeriod"", ""_loanWithdrawalDuration"", ""_marginCallDuration"", ""_poolInitFuncSelector"", ""_liquidatorRewardFraction"", ""_poolCancelPenaltyMultiple"", ""_minBorrowFraction"", ""_protocolFeeFraction"", ""_protocolFeeCollector"", ""_noStrategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""setImplementations"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates addresses of various implementation contracts"",
        ""Parameters"": [""_poolImpl"", ""_repaymentImpl"", ""_userRegistry"", ""_strategyRegistry"", ""_priceOracle"", ""_savingsAccount"", ""_extension""],
        ""Returns"": []
      },
      {
        ""Name"": ""createPool"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows borrowers to create new lending pools with specified parameters"",
        ""Parameters"": [""_poolSize"", ""_borrowRate"", ""_borrowToken"", ""_collateralToken"", ""_idealCollateralRatio"", ""_repaymentInterval"", ""_noOfRepaymentIntervals"", ""_poolSavingsStrategy"", ""_collateralAmount"", ""_transferFromSavingsAccount"", ""_salt"", ""_verifier"", ""_lenderVerifier""],
        ""Returns"": []
      },
      {
        ""Name"": ""_createPool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal implementation of pool creation logic"",
        ""Parameters"": [""_poolSize"", ""_borrowRate"", ""_borrowToken"", ""_collateralToken"", ""_idealCollateralRatio"", ""_repaymentInterval"", ""_noOfRepaymentIntervals"", ""_poolSavingsStrategy"", ""_collateralAmount"", ""_transferFromSavingsAccount"", ""_salt"", ""_lenderVerifier""],
        ""Returns"": []
      },
      {
        ""Name"": ""_encodePoolInitCall"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Encodes initialization call data for new pool"",
        ""Parameters"": [""_poolSize"", ""_borrowRate"", ""_borrowToken"", ""_collateralToken"", ""_idealCollateralRatio"", ""_repaymentInterval"", ""_noOfRepaymentIntervals"", ""_poolSavingsStrategy"", ""_collateralAmount"", ""_transferFromSavingsAccount"", ""_lenderVerifier""],
        ""Returns"": [""data (bytes)""]
      },
      {
        ""Name"": ""_deploy"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deploys new contract using CREATE2 opcode"",
        ""Parameters"": [""amount"", ""salt"", ""bytecode""],
        ""Returns"": [""addr (address)""]
      },
      {
        ""Name"": ""isWithinLimits"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if a value is within specified min/max limits"",
        ""Parameters"": [""_value"", ""_min"", ""_max""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getProtocolFeeData"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns protocol fee percentage and collector address"",
        ""Parameters"": [],
        ""Returns"": [""uint256"", ""address""]
      },
      {
        ""Name"": ""Various update functions"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only functions to update contract parameters and limits"",
        ""Parameters"": [""Varies by function""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IVerification contract for user verification"",
    ""IPriceOracle contract for price feed verification"",
    ""IStrategyRegistry contract for validating pool strategies"",
    ""SublimeProxy contract deployed for each new pool"",
    ""CREATE2 opcode for deterministic pool address generation""
  ],
  ""SpecialMechanisms"": [
    ""Proxy pattern: Uses proxy contracts to create upgradeable pools"",
    ""Factory pattern: Central factory for creating and registering new pool instances"",
    ""CREATE2 deployment: Uses CREATE2 for deterministic address generation"",
    ""Parameter limits system: Enforces constraints on pool creation parameters"",
    ""Verification system: Ensures only verified borrowers can create pools""
  ],
  ""Questions"": [
    ""Are there safeguards against potential reentrancy attacks during pool creation, especially when handling ETH?"",
    ""Is there validation that _protocolFeeFraction is within reasonable bounds (e.g., <100%)?"",
    ""How does the contract handle the scenario if _poolSavingsStrategy is set to noStrategyAddress?"",
    ""Is there a mechanism to pause pool creation in case of an emergency?"",
    ""Are there safeguards to prevent manipulation of the price oracle to create imbalanced pools?"",
    ""How are existing pools affected when global parameters like liquidatorRewardFraction are updated?""
  ]
}","I'll process the provided lists of security issues for the `PoolFactory.sol` contract, consolidating similar items and structuring the output as requested.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy risk in createPool function"",
      ""Severity"": ""High"",
      ""Description"": ""The createPool function performs external calls through interfaces like IPriceOracle and IStrategyRegistry before state changes are committed. When using ETH as collateral, the contract forwards ETH to the newly created contract using the low-level create2 opcode before the pool is registered in the poolRegistry mapping. If the created contract has malicious code in its constructor, it could reenter the PoolFactory contract during pool creation."",
      ""Impact"": ""An attacker could potentially exploit this to re-enter the function and create multiple pools, manipulate the contract state, or drain funds before the first transaction completes."",
      ""Location"": ""createPool function, _deploy function and _createPool function""
    },
    {
      ""Issue"": ""Unguarded external initialization"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract uses initializer modifier to protect the initialize function, the setImplementations function doesn't verify if critical contract addresses have already been set, potentially allowing them to be overwritten after initial setup."",
      ""Impact"": ""Allows the owner to change critical contract addresses at any time, which could disrupt the entire system if done maliciously or erroneously."",
      ""Location"": ""setImplementations function""
    },
    {
      ""Issue"": ""Insufficient ETH validation in createPool function"",
      ""Severity"": ""High"",
      ""Description"": ""When using ETH as collateral (_collateralToken is address(0)), the function validates that msg.value equals _collateralAmount. However, if ETH is not the collateral, the function doesn't check if msg.value is 0. Additionally, there's no proper validation that the ETH was correctly forwarded to the new pool contract during the create2 deployment."",
      ""Impact"": ""ETH sent by mistake could be permanently locked in the contract as there's no mechanism to withdraw them. Potential loss of ETH sent as collateral during pool creation."",
      ""Location"": ""createPool function and _deploy function""
    },
    {
      ""Issue"": ""No validation for compatible implementations"",
      ""Severity"": ""High"",
      ""Description"": ""When updating contract implementations (poolImpl, repaymentImpl, etc.), there's no verification that these implementations are compatible with the current system or follow expected interfaces."",
      ""Impact"": ""Incompatible implementations could break system functionality, potentially resulting in locked funds or broken loan pools."",
      ""Location"": ""updatePoolLogic(), updateRepaymentImpl() and other implementation update functions""
    },
    {
      ""Issue"": ""Lack of input validation for address parameters"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions that update critical addresses (like setImplementations, updateSavingsAccount, updatePriceoracle, etc.) do not validate that the provided addresses are non-zero or contain code. This could allow critical components to be set to invalid addresses."",
      ""Impact"": ""Setting critical system components to the zero address or invalid addresses could break core functionality and potentially lock user funds or create security vulnerabilities."",
      ""Location"": ""setImplementations function and all update functions that accept address parameters""
    },
    {
      ""Issue"": ""Centralized control by owner"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract grants the owner extensive control with many critical functions accessible only to the owner. The owner can update critical parameters, supported tokens, and system components without timelock or governance mechanisms. This creates a centralization risk."",
      ""Impact"": ""If the owner account is compromised, the attacker could manipulate critical protocol parameters, potentially leading to financial losses for users. Users must trust the owner not to make malicious changes."",
      ""Location"": ""All functions with onlyOwner modifier""
    },
    {
      ""Issue"": ""No two-step ownership transfer pattern"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses OpenZeppelin's OwnableUpgradeable without implementing a two-step ownership transfer process, creating risks during ownership transitions."",
      ""Impact"": ""Ownership could be permanently lost if transferred to an incorrect address, leaving the contract without administration."",
      ""Location"": ""OwnableUpgradeable implementation""
    },
    {
      ""Issue"": ""Lack of input validation for critical parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (e.g., updateLiquidatorRewardFraction, updateProtocolFeeFraction, initialize) accept critical parameters without validating they are within reasonable bounds. Parameters like _liquidatorRewardFraction, _protocolFeeFraction, _poolCancelPenaltyMultiple, etc., don't have proper bounds checking when updated."",
      ""Impact"": ""Setting extreme values could break system economics, create overflow/underflow conditions, or allow unfair value extraction. This could lead to protocol malfunction, excessive fees, or other economic vulnerabilities."",
      ""Location"": ""initialize function and all update functions that accept numerical parameters""
    },
    {
      ""Issue"": ""No timelock for critical parameter changes"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical protocol parameters can be changed by the owner with immediate effect. There's no timelock mechanism to allow users to react to announced changes before they take effect."",
      ""Impact"": ""Users cannot exit the protocol if they disagree with parameter changes, which could lead to financial losses if parameters are changed unfavorably."",
      ""Location"": ""All update functions like updateProtocolFeeFraction, updateLiquidatorRewardFraction, etc.""
    },
    {
      ""Issue"": ""Initialization can be frontrun"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize() function can be called by anyone before the contract owner, allowing an attacker to gain ownership of the contract if it's deployed without proper initialization."",
      ""Impact"": ""An attacker could potentially take control of the contract if they frontrun the legitimate initialization transaction."",
      ""Location"": ""initialize() function""
    },
    {
      ""Issue"": ""Potential for front-running in pool creation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The deterministic address generation in create2 makes it possible for observers to calculate the address of a pool before it's created. The salt for pool creation is derived from user input (_salt) and msg.sender, which could be predictable or reused. This could enable front-running attacks."",
      ""Impact"": ""Allows MEV (Miner Extractable Value) opportunities as addresses can be predicted before deployment. Users might be unable to create pools at their desired addresses, or attackers could create malicious pools with predictable addresses."",
      ""Location"": ""_createPool() function, where salt is calculated, and _deploy function using create2""
    },
    {
      ""Issue"": ""No slippage protection in pool creation"",
      ""Severity"": ""Medium"",
      ""Description"": ""When creating pools, there's no mechanism to protect users from rate changes or price slippage that might occur between transaction submission and execution. There's no timestamp or deadline parameter to protect against transaction delays."",
      ""Impact"": ""Users might create pools with unintended economic parameters if market conditions change during transaction confirmation. Front-running or market volatility could result in pools being created with unfavorable or manipulated terms."",
      ""Location"": ""createPool function and _createPool function""
    },
    {
      ""Issue"": ""Potential silent failures in token transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""When transferring collateral from savings account (_transferFromSavingsAccount flag), there's no validation whether the transfer was successful or not. The contract assumes token transfers will succeed but doesn't verify the results."",
      ""Impact"": ""Could lead to pools being created without proper collateral, potentially jeopardizing lender funds."",
      ""Location"": ""createPool function""
    },
    {
      ""Issue"": ""Potential integer overflow in isWithinLimits function"",
      ""Severity"": ""Medium"",
      ""Description"": ""While Solidity 0.7.6 has some overflow protection, complex mathematical operations should be handled carefully. The isWithinLimits function assumes valid inputs and has unusual logic for handling cases when min or max are zero."",
      ""Impact"": ""Overflows could lead to incorrect validation results, allowing values outside the intended range to pass validation. Admins might inadvertently set too permissive limits thinking zero values provide a constraint."",
      ""Location"": ""isWithinLimits function""
    },
    {
      ""Issue"": ""Insufficient validation in pool creation parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract validates inputs against min/max limits, it doesn't check that the limits themselves make sense or validate whether the specified ideal collateral ratio is compatible with the precision of the price feed from the oracle."",
      ""Impact"": ""Pools could be created with economically unsound parameters, leading to unexpected behavior, unusable pools, incorrect collateral calculations, or unjustified liquidations."",
      ""Location"": ""createPool function, particularly the validation section with isWithinLimits() calls""
    },
    {
      ""Issue"": ""Lack of emergency pause mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't implement a pause mechanism to halt operations in case of detected vulnerabilities or attacks."",
      ""Impact"": ""In case of a discovered vulnerability, there's no way to quickly pause the contract functionality to prevent exploitation."",
      ""Location"": ""Global contract functionality""
    },
    {
      ""Issue"": ""Missing reentrancy protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not use a reentrancy guard, particularly in functions that handle ETH transfers like createPool. This could potentially be exploited in combination with other vulnerabilities."",
      ""Impact"": ""Potential for reentrancy attacks if the pool initialization process includes calls to untrusted contracts."",
      ""Location"": ""createPool and _deploy functions that handle ETH""
    },
    {
      ""Issue"": ""Unbounded arrays and gas concerns"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _encodePoolInitCall function creates a data payload with many parameters. If these parameters grow or if the initialization function grows in complexity, it may lead to out-of-gas errors when deploying new pools."",
      ""Impact"": ""Pool creation might fail due to gas limits, or the contract might become unusable if the initialization function grows too large in future versions."",
      ""Location"": ""_encodePoolInitCall function""
    },
    {
      ""Issue"": ""Potential DoS with unbounded loops in pool creation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't impose a limit on the number of pools that can be created. Since the contract tracks all pools in the poolRegistry mapping, operations that might iterate over all pools could become prohibitively expensive as the number of pools grows."",
      ""Impact"": ""Operations that iterate over all pools could become prohibitively expensive or exceed block gas limits as the number of pools grows, potentially leading to denial of service."",
      ""Location"": ""createPool function and poolRegistry mapping""
    },
    {
      ""Issue"": ""Create2 address predictability concerns"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses Create2 opcode for deploying pools with deterministic addresses. This creates predictable addresses which might lead to unintended consequences if not properly managed."",
      ""Impact"": ""Potential for targeted attacks against pools deployed at predictable addresses."",
      ""Location"": ""_deploy function""
    },
    {
      ""Issue"": ""No validation of _salt uniqueness"",
      ""Severity"": ""Low"",
      ""Description"": ""The createPool function uses a salt derived from the provided _salt and msg.sender, but there's no check to verify that this combination hasn't been used before. If the same salt is used twice, the transaction will revert but without a clear error message."",
      ""Impact"": ""Failed transactions with obscure error messages, leading to poor user experience and potentially wasted gas."",
      ""Location"": ""_createPool function""
    },
    {
      ""Issue"": ""No mechanism to remove or deprecate pools from registry"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract adds pools to the registry but provides no way to remove them, even if they're found to be vulnerable or problematic."",
      ""Impact"": ""Inability to remove compromised or deprecated pools could lead to users interacting with unsafe pools."",
      ""Location"": ""Overall contract design - no function to remove poolRegistry entries""
    },
    {
      ""Issue"": ""Risk of contract size limit with create2"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses create2 for deployment but doesn't verify the deployed bytecode matches expectations. If the bytecode is too large, deployment might fail but appear successful."",
      ""Impact"": ""Deployed pool contracts might be incomplete or fail to operate as expected."",
      ""Location"": ""_deploy function""
    },
    {
      ""Issue"": ""Missing events for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical operations don't emit events, making it difficult to track important state changes off-chain. For example, the initialize function sets many important parameters but doesn't emit events for these initial settings, and when a pool is removed from the registry, no event is emitted."",
      ""Impact"": ""Lack of events for important state changes makes it difficult for off-chain systems to track the state of the protocol, potentially leading to user confusion or interface issues. Reduced transparency and ability to track system changes."",
      ""Location"": ""initialize function, _createPool function where poolRegistry[pool] = true is set, and throughout the contract""
    },
    {
      ""Issue"": ""No limit validation when updating limits"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like updatePoolSizeLimit don't verify that the minimum is less than or equal to the maximum, potentially allowing invalid limit configurations."",
      ""Impact"": ""Invalid limit configurations could make it impossible to create new pools that satisfy the requirements."",
      ""Location"": ""updatePoolSizeLimit, updateidealCollateralRatioLimit, updateBorrowRateLimit, updateRepaymentIntervalLimit, updateNoOfRepaymentIntervalsLimit functions""
    }
  ],
  ""IssueNumber"": 67,
  ""OutputList"": 25
}",402.048222064972,87578.0,32.0,"### **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

**Report Description**:
If a borrower calls the `createPool` function with a non-zero value but includes an ERC20 token address for `_collateralToken`, the Ether value sent will be locked in the `PoolFactory` contract forever. In the `_createPool` function, if `_collateralToken` is not the zero address, the `amount` variable is set to zero. This `amount` variable is passed to `create2`, which sends 0 wei to the newly created `Pool` contract. As a result, the Ether sent by the borrower remains in the `PoolFactory` contract with no mechanism to retrieve it.

**Match in Response List**:
Matches with the issue titled **""Insufficient ETH validation in createPool function""**.

**Validation**:
**Correct**. The response accurately identifies the issue of insufficient ETH validation in the `createPool` function. It correctly explains that if ETH is not the collateral, the function does not check if `msg.value` is zero, leading to the potential for ETH to be permanently locked in the contract. This aligns with the issue described in the report, where Ether can be locked in the `PoolFactory` contract without a way to retrieve it.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---",1,0,0,25,"```
1. Insufficient ETH validation in createPool function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Insufficient ETH validation in createPool function"".
   - This issue appears at rank **3** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, \( k = 3 \), and there is **1** true positive up to rank 3.
   - \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only **1** true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.333 \).

**Output**:
```
0.333
```"
,,,,,,,,,,,,,,4828.21559548378,773020.0,443.0,,3,2,12,102,,
