nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Locke.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6655,856,"[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount, which may cause fund loss to users
Variables `depositTokenFlashloanFeeAmount`   Submitted by WatchPug, also found by 0x0x0x, ScopeLift, gpersoon, harleythedog, hyh, gzeon, jonah1005, and kenzo
https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654 ```
uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
```
In the current implementation, depositTokenFlashloanFeeAmount is not excluded when calculating excess depositToken. Therefore, the stream creator can call recoverTokens(depositToken, recipient) and retrieve depositTokenFlashloanFeeAmount if there are any.
As a result:
When the protocol governance calls claimFees() and claim accumulated depositTokenFlashloanFeeAmount, it may fail due to insufficient balance of depositToken.
Or, part of users' funds (depositToken) will be transferred to the protocol governance as fees, causing some users unable to withdraw or can only withdraw part of their deposits.
 [H-02] Tokens can be stolen when depositToken == rewardToken

Submitted by cmichel, also found by 0x0x0x, gzeon, Ruhum, gpersoon, hack3r-0m, and pauliax
The Streaming contract allows the deposit and reward tokens to be the same token.
I believe this is intended, think Sushi reward on Sushi as is the case with xSushi.
The reward and deposit balances are also correctly tracked independently in depositTokenAmount and rewardTokenAmount. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:
function recoverTokens(address token, address recipient) public lock {
  [H-03] Reward token not correctly recovered

Submitted by cmichel, also found by GeekyLumberjack, kenzo, pedroais, and hyh
The Streaming contract allows recovering the reward token by calling recoverTokens(rewardToken, recipient).
However, the excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount):
function recoverTokens(address token, address recipient) public lock {

[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets

Function `arbitraryCall`
https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735
function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
    // cannot have an active incentive for the callee
    require(incentives[who] == 0, ""inc"");
    ...

When an incentiveToken is claimed after endStream, incentives[who] will be 0 for that incentiveToken.
If the protocol gov is malicious or compromised, they can call arbitraryCall() with the address of the incentiveToken as who and transferFrom() as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.
  [H-05] Possible incentive theft through the arbitraryCall() function

The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).
However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().
In summary:
If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.
Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.
  [H-06] Creating rewardTokens without streaming depositTokens
 function `updateStreamInternal`
stake and withdraws can generate rewardTokens without streaming depositTokens. It does not matter whether the stream is a sale or not.
The following lines can increase the reward balance on a withdraw some time after stake: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222
  [H-07] Business logic bug in __abdicate() function - 2 Bugs

Submitted by cyberboy, also found by Meta0xNull
Impact

The \__abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the ""gov"" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.

[H-08] ts.tokens sometimes calculated incorrectly

function stake

Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.
Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0
  if (acctTimeDelta > 0 && ts.tokens > 0) {

Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.
``` function stake(uint112 amount) public lock updateStream(msg.sender) {
    ...         
    uint112 trueDepositAmt = uint112(newBal - prevBal);
    ... 
    ts.tokens += trueDepositAmt;
 ```   [H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max

Submitted by hack3r-0m
Impact

https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229
reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls exit or withdraw function it will revert and that user will not able to withdraw funds permanentaly.

[H-10] recoverTokens doesn't work when isSale is true

In `recoverTokens` function, the logic to calculate the excess number of deposit tokens in the contract is: ```
uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
```
This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.
  [M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens

Any airdrop gathered with arbitraryCall will be immediately lost as an attacker can track arbitraryCall transactions and back run them with calls to recoverTokens, which doesn't track any tokens besides reward, deposit and incentive tokens, and will give the airdrop away.

[M-04] arbitraryCall() can get blocked by an attacker

Submitted by GiveMeTestEther, also found by ScopeLift
Impact

arbitraryCall()'s (L733) use case is to claim airdrops by ""gov"". If the address ""who"" is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable, because on L735 there is a require(incentives\[who] == 0, ""inc""); that reverts if a ""who"" token was received as an incentive.
In this case the the incentives\[who] can be set to 0 by the stream creator by calling claimIncentive() but only after the stream has ended according to require(block.timestamp >= endStream, ""stream""); (L520)
If the airdrop is only claimable before the end of the stream, then the airdrop can never be claimed.
If ""gov"" is not the stream creator then the stream creator must become also the ""gov"" because claimIncentive() only can be called by the stream creator and the arbitraryCall() only by ""gov"". If resetting incentives\[who] to 0 by calling claimIncentive() and arbitraryCall() for the ""who"" address doesn't happen atomic, an attacker can send between those two calls again a ""who"" token.
",12,,"pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";


contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    
    
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    
    
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}


contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    
    
    
    uint32 private immutable startTime;
    
    uint32 private immutable streamDuration;
    
    uint32 private immutable depositLockDuration;
    
    uint32 private immutable rewardLockDuration;

    
    uint32 private immutable endStream;
    
    uint32 private immutable endDepositLock;
    
    uint32 private immutable endRewardLock;

    
    address public immutable rewardToken;
    
    address public immutable depositToken;

    
    uint64 public immutable streamId;

    
    uint16 private immutable feePercent;
    
    bool private immutable feeEnabled;

    
    bool public immutable isSale;

    
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    

    
    
    uint112 private rewardTokenAmount;
    
    uint112 private depositTokenAmount;
    

    
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    

    
    uint256 private cumulativeRewardPerToken;
    

    
    uint256 private totalVirtualBalance;
    

    
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    

    
    mapping (address => TokenStream) public tokensNotYetStreamed;

    
    mapping (address => uint112) public incentives;

    
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    
    modifier updateStream(address who) {
        
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            
            cumulativeRewardPerToken = rewardPerToken();

            
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                
                
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) 
        public 
    {
        
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        
        require(feePercent < 10000, ""fee"");
    
        
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        
        streamId = _streamId;

        
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        
        if (feeEnabled) {
            
            
            
            
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

     
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        

        
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

     
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

     
    function exit() public updateStream(msg.sender) {
        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

     
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

     
    function claimIncentive(address token) public lock {
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

     
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        
        
        require(amount > 0, ""amt"");

        
        require(block.timestamp > endDepositLock, ""lock"");

        
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

     
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        
        cumulativeRewardPerToken = rewardPerToken();

        
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

     
    function creatorClaimSoldTokens(address destination) public lock {
        
        require(isSale, ""!sale"");

        
        require(!claimedDepositTokens, ""claimed"");
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

     
    function claimFees(address destination) public lock externallyGoverned {
        
        require(block.timestamp >= endStream, ""stream"");

        
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    

     
    function recoverTokens(address token, address recipient) public lock {
        
        
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            
            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            
            
            
            
            
            

            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        
        
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; 

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        
        require(incentives[who] == 0, ""inc"");
        
        require(who != depositToken && who != rewardToken, ""erc"");

        
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; 

    
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        
        
        
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",4772,10,2,"Based on the comprehensive code review and analysis, here's a detailed audit task list focusing on the most critical areas:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the arbitraryCall function for potential security risks"",
        ""Review reentrancy protection in the lock modifier"",
        ""Validate integer overflow prevention in mathematical calculations"",
        ""Inspect SafeTransferLib usage for complete token transfer safety"",
        ""Verify access control mechanisms in governance functions""
      ]
    },
    {
      ""Area"": ""Access Control and Governance"",
      ""Tasks"": [
        ""Audit the two-step governance transfer process for potential exploitation"",
        ""Verify emergency_gov role's capabilities and limitations"",
        ""Check for potential centralization risks in governance model"",
        ""Validate external governance interactions in ExternallyGoverned contract"",
        ""Ensure proper isolation of privileged functions""
      ]
    },
    {
      ""Area"": ""Token Stream Mechanics"",
      ""Tasks"": [
        ""Analyze precision and rounding in reward calculation methods"",
        ""Review dilutedBalance calculation for potential edge cases"",
        ""Validate time-based streaming logic in updateStreamInternal"",
        ""Check token vesting parameters for potential manipulation"",
        ""Verify correct handling of different token decimals""
      ]
    },
    {
      ""Area"": ""Flash Loan Mechanism"",
      ""Tasks"": [
        ""Thoroughly test flash loan implementation for reentrancy risks"",
        ""Verify fee calculation and collection process"",
        ""Check balance validation before and after flash loan"",
        ""Ensure no unauthorized token transfers during flash loan"",
        ""Review LockeCallee interface implementation requirements""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate external contract call safety in arbitraryCall"",
        ""Check for potential oracle manipulation risks"",
        ""Verify token interaction safety with different ERC20 implementations"",
        ""Review error handling in external contract interactions"",
        ""Ensure comprehensive input validation for external calls""
      ]
    },
    {
      ""Area"": ""Economic Model and Tokenomics"",
      ""Tasks"": [
        ""Analyze fee mechanism implementation and potential exploits"",
        ""Review stream creation parameters for economic risks"",
        ""Validate incentive mechanism for potential manipulation"",
        ""Check token distribution logic in stake and withdraw functions"",
        ""Verify token recovery mechanisms for potential drainage""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas optimization opportunities"",
        ""Review use of immutable and constant variables"",
        ""Analyze storage and memory usage in complex functions"",
        ""Check for unnecessary computational complexity"",
        ""Verify efficient use of modifiers and internal functions""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test boundary conditions in time-based stream calculations"",
        ""Verify error handling for unexpected token behaviors"",
        ""Check handling of zero-value or dust amount transactions"",
        ""Review edge cases in stream creation and token streaming"",
        ""Validate error messages and revert conditions""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the Stream contract, addressing the key areas of concern identified in the initial analysis. The tasks are:
- Specific and actionable
- Directly tied to the contract's unique characteristics
- Covering multiple dimensions of smart contract security
- Prioritizing the most critical potential vulnerabilities

The list is structured to guide a thorough, methodical audit process, ensuring that no critical aspects of the contract are overlooked.","After carefully analyzing the provided smart contract code, here's my comprehensive audit:

{
  ""ReviewingTheCode"": ""The code consists of multiple contracts related to creating and managing token streams. The primary contracts are 'Governed', 'ExternallyGoverned', 'Stream', and 'StreamFactory'. The system appears to be designed for token vesting or distribution over time with configurable parameters and optional fee mechanisms."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Stream and StreamFactory"",
    ""Purpose"": ""A system for creating token streaming mechanisms where tokens are gradually released over time. Supports both regular token streaming and token sales with configurable lock periods and fees."",
    
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""LockeERC20"", ""ExternallyGoverned"", ""Governed""],
      ""Imports"": [""LockeERC20.sol"", ""SafeTransferLib"", ""ERC20""]
    },
    
    ""StateVariables"": [
      {
        ""Name"": ""streamParams (in StreamFactory)"",
        ""Type"": ""GovernableStreamParams struct"",
        ""Purpose"": ""Stores parameters for stream creation including duration limits""
      },
      {
        ""Name"": ""feeParams (in StreamFactory)"",
        ""Type"": ""GovernableFeeParams struct"",
        ""Purpose"": ""Stores fee configuration for streams""
      },
      {
        ""Name"": ""startTime, streamDuration, depositLockDuration, rewardLockDuration"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Time parameters controlling the stream lifecycle""
      },
      {
        ""Name"": ""rewardToken, depositToken"",
        ""Type"": ""address"",
        ""Purpose"": ""Addresses of the tokens used for rewards and deposits""
      },
      {
        ""Name"": ""rewardTokenAmount, depositTokenAmount"",
        ""Type"": ""uint112"",
        ""Purpose"": ""Track amounts of tokens in the contract""
      },
      {
        ""Name"": ""tokensNotYetStreamed"",
        ""Type"": ""mapping(address => TokenStream)"",
        ""Purpose"": ""Tracks user balances and rewards within the stream""
      }
    ],
    
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor (Stream)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes a new stream with specified parameters"",
        ""Parameters"": [""streamId, creator, isSale, rewardToken, depositToken, startTime, streamDuration, depositLockDuration, rewardLockDuration, feePercent, feeEnabled""],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to deposit tokens into the stream"",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to withdraw their staked tokens"",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to claim their earned rewards after the reward lock period"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""flashloan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Enables flashloan functionality for specified tokens"",
        ""Parameters"": [""token"", ""to"", ""amount"", ""data""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateStream"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates stream state before function execution"",
        ""Parameters"": [""who""],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""createStream (in StreamFactory)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates a new Stream contract with specified parameters"",
        ""Parameters"": [""rewardToken"", ""depositToken"", ""startTime"", ""streamDuration"", ""depositLockDuration"", ""rewardLockDuration"", ""isSale""],
        ""Returns"": [""Stream""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""ERC20 token contract interactions for transfers and approval checking"",
    ""LockeCallee interface for flashloan callbacks"",
    ""External calls in arbitraryCall function (potential security risk)""
  ],
  
  ""SpecialMechanisms"": [
    ""Factory pattern for creating new Stream instances"",
    ""Token streaming with time-based dilution calculations"",
    ""Flashloan mechanism with fee collection"",
    ""Governance system with emergency override"",
    ""Two-step governance transfer pattern"",
    ""Incentive mechanism for additional token rewards"",
    ""Reentrancy protection via lock modifier""
  ],
  
  ""VulnerabilitiesAndConcerns"": [
    {
      ""Issue"": ""Unchecked external call in arbitraryCall"",
      ""Severity"": ""High"",
      ""Description"": ""The arbitraryCall function performs a low-level call to an arbitrary address with arbitrary data, which could be used maliciously if governance is compromised.""
    },
    {
      ""Issue"": ""Precision loss in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calculations involving division may lose precision, potentially affecting reward distributions.""
    },
    {
      ""Issue"": ""Integer overflow potential in dilutedBalance"",
      ""Severity"": ""Medium"",
      ""Description"": ""The dilutedBalance function could potentially overflow if timeRemaining approaches zero.""
    },
    {
      ""Issue"": ""Reliance on block.timestamp"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses block.timestamp for time-sensitive calculations, which can be manipulated by miners within a small range.""
    },
    {
      ""Issue"": ""No input validation for token addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""No checks to ensure token addresses are valid ERC20 implementations.""
    }
  ],
  
  ""RecommendedImprovements"": [
    ""Replace the arbitraryCall function with more specific, limited functionality"",
    ""Add more checks for valid token addresses and contract interactions"",
    ""Consider using SafeMath or similar libraries for calculations"",
    ""Add more events for better off-chain tracking of contract state changes"",
    ""Consider adding emergency pause functionality""
  ],

  ""Questions"": [
    ""What is the purpose of the LockeERC20 base contract?"",
    ""How is the merkleAccess boolean in TokenStream struct used?"",
    ""Is there a specific reason for using uint112 for token amounts instead of uint256?"",
    ""Why is there no validation that rewardToken and depositToken are valid ERC20 tokens?"",
    ""What security measures protect the governance system from compromise?""
  ]
}

After performing this audit, I've identified several significant concerns:

1. The most critical issue is the `arbitraryCall` function, which allows the governor to execute arbitrary code from the contract. This represents a significant security risk if governance is compromised.

2. The contract has a complex time-based streaming mechanism with multiple parameters that could potentially be manipulated or contain edge cases, especially around time boundaries.

3. There are precision concerns in several mathematical calculations that could lead to rounding errors affecting users' rewards.

4. The flashloan functionality introduces additional complexity and potential attack vectors if not implemented correctly.

5. The contract uses a custom reentrancy guard pattern rather than a standard library implementation, which warrants extra scrutiny.

The contract is relatively sophisticated with multiple inheritance and complex token economics. It would benefit from more comprehensive input validation and simpler, more focused functionality rather than the current multi-purpose design.","I'll analyze the input data to identify, combine, and organize the security issues.

{
  ""Findings"": [
    {
      ""Issue"": ""Unsafe external call in arbitraryCall function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The arbitraryCall function allows the governor to make arbitrary calls to any address with any data. While some basic checks are in place to prevent direct token manipulation (by checking token balances before and after the call), this function can still be exploited in several ways to compromise the contract. This is extremely dangerous as it can be used to execute almost any operation, potentially including selfdestruct or other destructive actions."",
      ""Impact"": ""If the governance key is compromised, an attacker could execute malicious code that could destroy the contract, drain funds, manipulate protocol state, or exploit other vulnerabilities that aren't protected by the basic balance checks."",
      ""Location"": ""arbitraryCall() function in Stream contract""
    },
    {
      ""Issue"": ""Reentrancy vulnerability in flashloan function"",
      ""Severity"": ""High"",
      ""Description"": ""The flashloan function in the Stream contract transfers tokens to an external contract before ensuring that the required fee has been returned. This creates a classic reentrancy vulnerability, as the recipient contract could potentially call back into Stream contract functions before the loan is finalized. Although the lock modifier is used, the external call to LockeCallee.lockeCall happens after the tokens are transferred but before balance checks are performed."",
      ""Impact"": ""An attacker could exploit this to drain tokens from the contract, manipulate contract state, or bypass security checks in the contract by crafting a malicious contract that calls back into Stream functions before the balance checks are performed."",
      ""Location"": ""flashloan() function in Stream contract""
    },
    {
      ""Issue"": ""Reentrancy vulnerability in withdrawal functions"",
      ""Severity"": ""High"",
      ""Description"": ""The withdraw and exit functions in the Stream contract transfer tokens to the user after state modifications. This is generally safe due to the lock modifier, but relies on a simple unlocked state variable to prevent reentrancy. If the unlock logic is bypassed or the token's transfer function allows reentrancy, funds could be drained."",
      ""Impact"": ""An attacker might exploit this to drain tokens by reentering the contract through callbacks, potentially allowing them to repeatedly withdraw the same tokens before the contract state is updated."",
      ""Location"": ""withdraw() and exit() functions in Stream contract""
    },
    {
      ""Issue"": ""Inadequate token balance verification in flashloan"",
      ""Severity"": ""High"",
      ""Description"": ""The flashloan function only checks that token balances don't decrease, but doesn't verify that the full amount plus fee was returned. An attacker could exploit this by returning slightly more than the initial balance but less than the required fee."",
      ""Impact"": ""Potential theft of funds by returning less than the required amount in flashloan operations, allowing borrowers to return less than they borrowed as long as they pay the fee."",
      ""Location"": ""flashloan() function in Stream contract""
    },
    {
      ""Issue"": ""Integer overflow/underflow in dilutedBalance calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The dilutedBalance function performs complex mathematical operations that could potentially overflow or underflow, especially when time values approach the stream end time. If timeRemaining becomes very small (close to the end of the stream), the calculation could result in extremely large numbers before the division, leading to potential overflow issues."",
      ""Impact"": ""Could lead to incorrect calculation of virtual balances, affecting reward distribution. Near the end of a stream, calculations may become imprecise or overflow, potentially leading to incorrect token allocations or reverted transactions."",
      ""Location"": ""dilutedBalance() function in Stream contract""
    },
    {
      ""Issue"": ""Integer overflow/underflow in token balance updates"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract uses Solidity 0.8.0+ which has built-in overflow checking, there are explicit unchecked blocks and complex arithmetic operations in the contract that could still lead to unexpected behavior. For example, in the earned() function, complex calculations involving ts.virtualBalance could potentially overflow."",
      ""Impact"": ""Incorrect reward calculations or token balance manipulations that could affect users' funds, especially when dealing with large numbers or extreme time periods."",
      ""Location"": ""earned(), fundStream(), updateStreamInternal() functions in Stream contract""
    },
    {
      ""Issue"": ""Incorrect reward calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The reward calculation in rewardPerToken() relies on precise timestamps and division operations that could result in rounding errors over time. Division before multiplication can lead to precision loss, especially with large numbers. Additionally, in the claimReward function, the stream accounting is updated but the lastUpdate timestamp is set to lastApplicableTime() which might be in the past if the stream has already ended."",
      ""Impact"": ""Users might receive slightly fewer or more rewards than they should, affecting the fairness of the distribution system. This could lead to incorrect reward calculations if there are subsequent interactions with the contract, particularly around the time when the stream ends."",
      ""Location"": ""rewardPerToken() and claimReward() functions in Stream contract""
    },
    {
      ""Issue"": ""Centralized governance control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant power to governors and stream creators. The governor can execute arbitrary calls, claim fees, and has other privileged actions. The stream creator can claim sold tokens and recover tokens. The emergency governance role can execute sensitive functions without sufficient restrictions or delays."",
      ""Impact"": ""Users are exposed to centralization risks if governors or stream creators act maliciously or are compromised. A compromised governor could potentially drain funds or manipulate the contract in unintended ways."",
      ""Location"": ""Throughout the contract, especially in governed/emergency_governed modifiers and functions like arbitraryCall, claimFees, recoverTokens, and creatorClaimSoldTokens""
    },
    {
      ""Issue"": ""Timestamp dependence"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract heavily relies on block.timestamp for critical calculations like reward distribution and lock periods. Miners can manipulate block timestamps to a certain extent, which could affect time-sensitive operations."",
      ""Impact"": ""Potential manipulation of reward calculations by miners, though the practical impact is limited given the small amount of flexibility miners have with timestamps. This could affect reward distributions, particularly around stream end times."",
      ""Location"": ""Multiple functions including updateStreamInternal, lastApplicableTime, dilutedBalance""
    },
    {
      ""Issue"": ""Incorrect fee calculation in flashloan"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the flashloan function, the fee calculation uses a hardcoded value (10/10000 = 0.1%) rather than using the contract's feePercent parameter, creating an inconsistency with the rest of the contract's fee model."",
      ""Impact"": ""The flashloan function will always charge 0.1% fee regardless of the contract's configured feePercent, limiting flexibility and potentially causing inconsistent economics."",
      ""Location"": ""flashloan function in Stream contract""
    },
    {
      ""Issue"": ""Insufficient validation in updateStreamInternal"",
      ""Severity"": ""Medium"",
      ""Description"": ""The updateStreamInternal function has complex logic that may not handle edge cases correctly, especially around the stream start and end times. The function contains multiple branches and conditionals that make it difficult to reason about all possible execution paths, increasing the risk of logical errors."",
      ""Impact"": ""Could result in incorrect reward calculations or token distributions. The complexity of this core function increases the risk of subtle errors in stream accounting."",
      ""Location"": ""updateStreamInternal() function in Stream contract""
    },
    {
      ""Issue"": ""Lock mechanism vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The lock modifier only sets unlocked to 1 at the end of function execution. If a function reverts, the contract could remain in a locked state (unlocked = 2), potentially bricking the contract."",
      ""Impact"": ""If a function with the lock modifier reverts, the contract would remain locked and subsequent calls to locked functions would fail."",
      ""Location"": ""lockInternal function and lock modifier in Stream contract""
    },
    {
      ""Issue"": ""No pause mechanism for emergency scenarios"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contracts lack a pause mechanism to stop operations in case of discovered vulnerabilities or other emergencies."",
      ""Impact"": ""In case of discovered exploits, there's no way to pause operations while fixes are prepared."",
      ""Location"": ""Both Stream and StreamFactory contracts""
    },
    {
      ""Issue"": ""Lack of validation for zero addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions don't validate that addresses like token addresses are non-zero, which could lead to unexpected behavior if zero addresses are provided. The Stream constructor doesn't validate important parameters like startTime being in the future or that rewardToken and depositToken are actual ERC20 tokens."",
      ""Impact"": ""Could result in locked tokens or contract failures if zero addresses are used. If the contract is created directly (not through the factory), it might be initialized with invalid parameters leading to unexpected behavior."",
      ""Location"": ""Constructor and various functions throughout both contracts""
    },
    {
      ""Issue"": ""Fee calculation precision issues"",
      ""Severity"": ""Low"",
      ""Description"": ""Fee calculations involve division operations that may result in rounding errors, potentially causing small amounts of tokens to be lost due to precision issues. The dilutedBalance function uses fixed-point arithmetic with a scaling factor of 10^6, which may not be sufficient for all token decimals."",
      ""Impact"": ""Small amounts of tokens could be lost due to rounding errors in fee calculations. Users might receive slightly less rewards than expected due to rounding errors."",
      ""Location"": ""fundStream() and flashloan() functions in Stream contract""
    },
    {
      ""Issue"": ""Insufficient event emission and transparency"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state-changing operations like setting the emergency governor don't emit events, making it harder to track governance changes off-chain. For example, there's no event emitted when unstreamed tokens are updated in updateStreamInternal."",
      ""Impact"": ""Reduced transparency and ability to track contract state changes off-chain, complicating integration with frontends and monitoring systems. This makes it more difficult to monitor contract state changes."",
      ""Location"": ""setEmergencyGov() function in Governed contract and other functions missing event emissions""
    },
    {
      ""Issue"": ""Improper error handling and misleading error messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses short, cryptic error messages (like 'amt', 'erc', 'f1') that don't clearly indicate what went wrong, making debugging and user experience worse."",
      ""Impact"": ""Poor user experience and difficulty in identifying issues during operation or during audits."",
      ""Location"": ""Throughout the contract in require statements""
    },
    {
      ""Issue"": ""emergencyGov can't be removed once set"",
      ""Severity"": ""Low"",
      ""Description"": ""There's no mechanism to remove emergency governance access. Once set, the emergency governor can't be revoked except by setting it to address(0)."",
      ""Impact"": ""If the emergency governor address is compromised, there's no way to revoke its privileges unless the main governor is still in control."",
      ""Location"": ""Governed contract, setEmergencyGov function""
    }
  ],
  ""IssueNumber"": 80,
  ""OutputList"": 18
}",400.3166720867157,100400.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount, which may cause fund loss to users**

**Report Description**:  
The `excess` calculation in the `recoverTokens` function does not exclude `depositTokenFlashloanFeeAmount`. This allows the stream creator to retrieve the fee amount, potentially causing fund loss to users or failure in fee claims by the protocol governance.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue of incorrect excess calculation or the associated risks of fund loss.

---

#### **[H-02] Tokens can be stolen when depositToken == rewardToken**

**Report Description**:  
When `depositToken` and `rewardToken` are the same, the `recoverTokens` function allows the token to be recovered twice, leading to potential theft of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of double recovery when `depositToken` and `rewardToken` are the same.

---

#### **[H-03] Reward token not correctly recovered**

**Report Description**:  
The `recoverTokens` function incorrectly calculates the excess amount for `rewardToken`, leading to incorrect recovery of tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward token recovery.

---

#### **[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets**

**Report Description**:  
The `arbitraryCall` function allows the protocol governance to steal funds from users' wallets by calling `transferFrom` on incentive tokens after the stream ends.

**Match in Response List**:  
Matches with the issue titled **""Unsafe external call in arbitraryCall function""**.

**Validation**:  
**Correct**. The response accurately identifies the risks associated with the `arbitraryCall` function, including the potential for fund theft if the governance key is compromised.

---

#### **[H-05] Possible incentive theft through the arbitraryCall() function**

**Report Description**:  
The `arbitraryCall` function can be used to pre-approve token allowances for malicious recipients, enabling theft of incentive tokens.

**Match in Response List**:  
Matches with the issue titled **""Unsafe external call in arbitraryCall function""**.

**Validation**:  
**Correct**. The response covers the risks of arbitrary calls, including the potential for pre-approval and theft of incentive tokens.

---

#### **[H-06] Creating rewardTokens without streaming depositTokens**

**Report Description**:  
The `updateStreamInternal` function allows reward tokens to be generated without streaming deposit tokens, leading to incorrect reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of incorrect reward token generation.

---

#### **[H-07] Business logic bug in __abdicate() function - 2 Bugs**

**Report Description**:  
The `__abdicate` function does not reset the emergency and pending governors, allowing a pending governor to reclaim governance.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of incomplete governance abdication.

---

#### **[H-08] ts.tokens sometimes calculated incorrectly**

**Report Description**:  
The `ts.tokens` calculation in the `stake` function can be incorrect due to improper updates of `ts.lastUpdate`, leading to potential over-withdrawal.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of incorrect token balance updates.

---

#### **[H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max**

**Report Description**:  
The `exit` and `withdraw` functions can revert due to overflow for high values, causing permanent loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Integer overflow/underflow in token balance updates""**.

**Validation**:  
**Partially Correct**. The response identifies overflow risks but does not specifically address the DOS issue in `exit` and `withdraw` functions.

---

#### **[H-10] recoverTokens doesn't work when isSale is true**

**Report Description**:  
The `recoverTokens` function fails to correctly calculate excess deposit tokens when `isSale` is true, breaking the function's functionality.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of incorrect token recovery in the `isSale` scenario.

---

#### **[M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens**

**Report Description**:  
Airdrops gathered via `arbitraryCall` can be stolen using `recoverTokens`, as the function does not track these tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of airdrop theft via `recoverTokens`.

---

#### **[M-04] arbitraryCall() can get blocked by an attacker**

**Report Description**:  
An attacker can block `arbitraryCall` by sending incentive tokens, preventing the governance from claiming airdrops.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of blocking `arbitraryCall` via incentive tokens.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets**
- **[H-05] Possible incentive theft through the arbitraryCall() function**

**Partially Correct Matches**:

- **[H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max**

**Missed Issues from Issue Report**:

- **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve depositTokenFlashloanFeeAmount, which may cause fund loss to users**
- **[H-02] Tokens can be stolen when depositToken == rewardToken**
- **[H-03] Reward token not correctly recovered**
- **[H-06] Creating rewardTokens without streaming depositTokens**
- **[H-07] Business logic bug in __abdicate() function - 2 Bugs**
- **[H-08] ts.tokens sometimes calculated incorrectly**
- **[H-10] recoverTokens doesn't work when isSale is true**
- **[M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens**
- **[M-04] arbitraryCall() can get blocked by an attacker**

---

The response list covers some critical issues, particularly around the `arbitraryCall` function, but misses or partially addresses many other vulnerabilities, especially those related to token recovery, governance, and reward calculations.",1. Unsafe external call in arbitraryCall function,1.0
