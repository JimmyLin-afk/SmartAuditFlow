nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LaunchEvent.sol,"// SPDX-License-Identifier: None
// Copyright (c) 2022 Trader Joe - All rights reserved

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";

/// @title Rocket Joe Launch Event
/// @author Trader Joe
/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price
contract LaunchEvent is Ownable {
    /// @notice The phases the launch event can be in
    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        /// @notice How much AVAX user can deposit for this launch event
        /// @dev Can be increased by burning more rJOE, but will always be
        /// smaller than `maxAllocation`
        uint256 allocation;
        /// @notice How much AVAX user has deposited for this launch event
        uint256 balance;
        /// @notice Whether user has withdrawn the LP
        bool hasWithdrawnPair;
        /// @notice Whether user has withdrawn the issuing token incentives
        bool hasWithdrawnIncentives;
    }

    /// @notice Issuer of sale tokens
    address public issuer;

    /// @notice The start time of phase 1
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,
    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.
    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,
    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives
    uint256 public tokenIncentivesPercent;

    /// @notice Floor price in AVAX per token (can be 0)
    /// @dev floorPrice is scaled to 1e18
    uint256 public floorPrice;

    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens
    uint256 public userTimelock;

    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens
    uint256 public issuerTimelock;

    /// @notice The max withdraw penalty during phase 1, in parts per 1e18
    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17
    uint256 public maxWithdrawPenalty;

    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18
    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    /// @dev The address of the JoePair, set after createLiquidityPool is called
    IJoePair public pair;

    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.
    /// Used to calculate the amount of LP to send based on the user's participation in the launch event
    uint256 private wavaxAllocated;

    /// @dev The exact supply of LP minted when creating the initial liquidity pair.
    uint256 private lpSupply;

    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial
    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`
    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed
    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,
    /// tokenReserve will be equal to 0)
    uint256 private tokenReserve;

    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right
    /// amounts to issuer and users
    uint256 private tokenIncentivesBalance;
    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created
    uint256 private tokenIncentivesForUsers;
    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.
    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there
    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`
    uint256 private tokenIncentiveIssuerRefund;

    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's
    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the
    /// penaltyCollector can collect the excess using `skim()`
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    /// @notice Receive AVAX from the WAVAX contract
    /// @dev Needed for withdrawing from WAVAX contract
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    /// @notice Modifier which ensures contract is in a defined phase
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    /// @notice Ensures launch event is stopped/running
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    /// @notice Initialise the launch event with needed paramaters
    /// @param _issuer Address of the token issuer
    /// @param _auctionStart The start time of the auction
    /// @param _token The contract address of auctioned token
    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives
    /// @param _floorPrice The minimum price the token is sold at
    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18
    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18
    /// @param _maxAllocation The maximum amount of AVAX depositable
    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity
    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity
    /// @dev This function is called by the factory immediately after it creates the contract instance
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); // 50%
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); // 50%
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`
        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).
        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    /// @notice The current phase the auction is in
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    /// @notice Deposits AVAX and burns rJoe
    /// @dev Checks are done in the `_depositWAVAX` function
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Burn tokens and update allocation.
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    /// @notice Withdraw AVAX, only permitted during phase 1 and 2
    /// @param _amount The amount of AVAX to withdraw
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    /// @notice Create the JoePair
    /// @dev Can only be called once after phase 3 has started
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        /// We can't trust the output cause of reflect tokens
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, // tokenA
            tokenAddress, // tokenB
            wavaxReserve, // amountADesired
            tokenAllocated, // amountBDesired
            wavaxReserve, // amountAMin
            tokenAllocated, // amountBMin
            address(this), // to
            block.timestamp // deadline
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    /// @notice Withdraw liquidity pool tokens
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    /// @notice Withdraw incentives tokens
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    /// @notice Withdraw AVAX if launch has been cancelled
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    /// @notice Stops the launch event and allows participants withdraw deposits
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.
    /// Any excess tokens are sent to the penaltyCollector
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    /// @notice Returns the current penalty for early withdrawal
    /// @return The penalty to apply to a withdrawal amount
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    /// @notice Returns the current balance of the pool
    /// @return The balances of WAVAX and issued token held by the launch contract
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    /// @notice Get the rJOE amount needed to deposit AVAX
    /// @param _avaxAmount The amount of AVAX to deposit
    /// @return The amount of rJOE needed
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    /// @notice The total amount of liquidity pool tokens the user can withdraw
    /// @param _user The address of the user to check
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    /// @dev Bytecode size optimization for the `atPhase` modifier.
    /// This works becuase internal functions are not in-lined in modifiers
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    /// @notice Send AVAX
    /// @param _to The receiving address
    /// @param _value The amount of AVAX to send
    /// @dev Will revert on failure
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}

",5261,626,"[H-01] Users can lose value in emergency state

Submitted by cmichel, also found by static
Imagine the following sequence of events:
LaunchEvent.createPair() is called which sets wavaxReserve = 0, adds liquidity to the pair and receives lpSupply LP tokens.
LaunchEvent.allowEmergencyWithdraw() is called which enters emergency / paused mode and disallows normal withdrawals.
Users can only call LaunchEvent.emergencyWithdraw which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.
   [H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached

Submitted by cmichel
In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.
Note that the floorPrice is supposed to have a precision of 18:
/// @param _floorPrice Price of each token in AVAX, scaled to 1e18
The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals:
// @audit should be wavaxReserve * 1e18 / floorPrice
tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;

This computation does not work for tokens that don't have 18 decimals.
  
[M-02] Owner of LaunchEvent token has the ability to DOS attack the event

The owner of the token for which the `LaunchEvent` was created, has the ability to DOS attack the event. They can prevent the LaunchEvent from creating a JoePair which in turn limits the access to the following two functions: withdrawLiquidity() & withdrawIncentives(). Thus, stopping anybody from withdrawing their LP tokens.
The owner of the RocketJoe platform has the ability to enable the emergency withdrawal allowing the depositors to take back their AVAX. But, they lose their burned rJOE tokens and the gas fees.
The dev team might use this attack vector if they think the price of their token is too low. In that case, they can DOS attack the LaunchEvent. If the RocketJoe owner enables the emergency withdrawal, the dev team is able to take back their initial deposit. Thus, they don't lose anything but their reputation.
  [M-05] Failed transfer with low level call could be overlooked

Submitted by harleythedog, also found by sirhashalot
In LaunchEvent.sol, the function _safeTransferAVAX is as follows:
function _safeTransferAVAX(address _to, uint256 _value) internal {
    (bool success, ) = _to.call{value: _value}(new bytes(0));
    require(success, ""LaunchEvent: avax transfer failed"");
}

This function is utilized in a few different places in the contract. According to the Solidity docs), ""The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed"".
As a result, it is possible that this call will fail, but _safeTransferAVAX will not notice anything went wrong. In particular, it is possible that the address rocketJoeFactory.penaltyCollector() is a deleted contract (perhaps a security flaw was found and selfdestruct was called so that users know to use an updated smart contract), but _safeTransferAVAX will not revert. If rocketJoeFactory.penaltyCollector() is indeed a non-existent contract, it would be better for _safeTransferAVAX to revert until an admin can manually correct the penaltyCollector in the factory.
 
[M-07] withdrawAVAX() function has call to sender without reentrancy protection

Submitted by jayjonah8
In LauchEvent.sol the `withdrawAVAX()` function makes an external call to the msg.sender by way of _safeTransferAVAX. This allows the caller to reenter this and other functions in this and other protocol files. To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.
 
[M-08] LP Tokens May Be Locked in Contract Due to allowEmergencyWithdraw() in Stage 3

Submitted by kirk-baird
The function `allowEmergencyWithdraw()` may be called by the rocketJoeFactory.owner() at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.
Proof of Concept

If allowEmergencyWithdraw() is called stopped is set to true. As a result functions withdrawIncentives() and withdrawLiquidity() will revert due to the isStopped(false) modifier reverting.
Additionally, emergencyWithdraw() will revert since all the WAVAX and token balances have been transferred to the liquidity pool.
Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.
  [M-09] createPair() expects zero slippage

The LaunchEvent.sol `createPair()` function calls router.addLiquidity() with a amountADesired == amountAMin and amountBDesired == amountBMin. Because there is no allowance for slippage, if the zero slippage requirement is not met then the addLiquidity() function will revert and prevent users from using the createPair() function. This could be caused either by frontrunning the createPair call or in a situation where the liquidity pool exists but does not allow for zero slippage with the assets it is holding.
  [M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`
 It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.
  [M-12] Pair creation can be denied

Submitted by cmichel, also found by harleythedog, UncleGrandpa925, and WatchPug
The LaunchEvent.createPair requires that no previous pool was created for the WAVAX <> _token pair.
function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
    (address wavaxAddress, address tokenAddress) = (
        address(WAVAX),
        address(token)
    );
    // @audit grief: anyone can create pair
    require(
        factory.getPair(wavaxAddress, tokenAddress) == address(0),
        ""LaunchEvent: pair already created""
    );

    // ...
}

A griefer can create a pool for the WAVAX <> _token pair by calling JoeFactory.createPair(WAVAX, _token) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.
",9,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";




contract LaunchEvent is Ownable {
    
    
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        
        
        
        uint256 allocation;
        
        uint256 balance;
        
        bool hasWithdrawnPair;
        
        bool hasWithdrawnIncentives;
    }

    
    address public issuer;

    
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    
    
    
    
    uint256 public tokenIncentivesPercent;

    
    
    uint256 public floorPrice;

    
    uint256 public userTimelock;

    
    uint256 public issuerTimelock;

    
    
    uint256 public maxWithdrawPenalty;

    
    
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    
    IJoePair public pair;

    
    
    uint256 private wavaxAllocated;

    
    uint256 private lpSupply;

    
    
    
    
    
    uint256 private tokenReserve;

    
    
    uint256 private tokenIncentivesBalance;
    
    uint256 private tokenIncentivesForUsers;
    
    
    
    uint256 private tokenIncentiveIssuerRefund;

    
    
    
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    
    
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); 
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); 
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        
        
        
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    
    
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        
        if (newAllocation > user.allocation) {
            
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            
            
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    
    
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    
    
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, 
            tokenAddress, 
            wavaxReserve, 
            tokenAllocated, 
            wavaxReserve, 
            tokenAllocated, 
            address(this), 
            block.timestamp 
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    
    
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    
    
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    
    
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    
    
    
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    
    
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    
    
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    
    
    
    
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}",3591,2,7,"Based on the detailed analysis of the LaunchEvent contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in all external and public functions"",
        ""Audit transfer and approval mechanisms for potential external call vulnerabilities"",
        ""Check for potential integer overflow/underflow in mathematical calculations"",
        ""Validate input validation and range checks for all function parameters"",
        ""Review error handling and revert conditions for comprehensive protection""
      ]
    },
    {
      ""Area"": ""Access Control & Ownership"",
      ""Tasks"": [
        ""Validate the ownership transfer and management mechanism"",
        ""Review access restrictions in critical functions like initialize and emergencyWithdraw"",
        ""Ensure proper role-based access controls for issuer and factory interactions"",
        ""Check the security of the allowEmergencyWithdraw function"",
        ""Verify the timelocked withdrawal mechanisms for both users and issuer""
      ]
    },
    {
      ""Area"": ""Token Economics & Allocation"",
      ""Tasks"": [
        ""Audit token incentives calculation and distribution logic"",
        ""Verify the precision of token and AVAX reserve calculations"",
        ""Review the floor price mechanism and its impact on token allocation"",
        ""Check the rJoe burning mechanism for potential economic exploits"",
        ""Validate the token allocation percentages and distribution rules""
      ]
    },
    {
      ""Area"": ""Liquidity Pool and AMM Interactions"",
      ""Tasks"": [
        ""Review the createPair function for potential price manipulation risks"",
        ""Audit the liquidity allocation and LP token distribution mechanism"",
        ""Verify the interaction with Trader Joe's router and factory contracts"",
        ""Check for potential front-running vulnerabilities in AVAX deposit and pair creation"",
        ""Validate the pairBalance calculation for accuracy and fairness""
      ]
    },
    {
      ""Area"": ""Phase Management and Time-based Mechanics"",
      ""Tasks"": [
        ""Verify the integrity of phase transition logic in currentPhase function"",
        ""Audit the penalty calculation mechanism for potential manipulation"",
        ""Review the time-based withdrawal restrictions"",
        ""Check for potential timestamp manipulation risks"",
        ""Validate the phase-specific function modifiers""
      ]
    },
    {
      ""Area"": ""Emergency and Failsafe Mechanisms"",
      ""Tasks"": [
        ""Review the emergency withdrawal process for potential abuse"",
        ""Validate the skim function and excess token handling"",
        ""Check the stopped flag mechanism and its security implications"",
        ""Verify the conditions for allowing emergency withdrawals"",
        ""Audit the fallback and receive functions for potential vulnerabilities""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Verify safe interaction with WAVAX, rJoe, and other external contracts"",
        ""Check approval and transfer mechanisms for external tokens"",
        ""Review error handling in external contract calls"",
        ""Validate the integrity of interface implementations"",
        ""Audit the potential risks of relying on external contract states""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Review storage variable packing and optimization"",
        ""Check for redundant calculations and potential gas savings"",
        ""Validate the efficiency of loop-free and minimal computation approaches"",
        ""Review function visibility and modifier usage for gas efficiency"",
        ""Analyze the computational complexity of key functions""
      ]
    },
    {
      ""Area"": ""Token Standard Compliance"",
      ""Tasks"": [
        ""Verify ERC20 token interaction compatibility"",
        ""Check metadata and decimals handling"",
        ""Review token transfer and approval mechanisms"",
        ""Validate support for non-standard ERC20 tokens"",
        ""Ensure proper handling of tokens with transfer fees or rebasing mechanisms""
      ]
    }
  ]
}

This comprehensive task list covers multiple critical aspects of the LaunchEvent smart contract, providing a structured approach to thoroughly audit its security, functionality, and economic design. Each area focuses on specific potential vulnerabilities and design considerations, ensuring a holistic review of the contract's implementation.

The tasks are designed to be:
- Relevant to the contract's unique architecture
- Specific in targeting potential vulnerabilities
- Actionable for an experienced smart contract auditor
- Comprehensive in covering technical and economic aspects

Would you like me to elaborate on any of these audit tasks or provide more detailed guidance on their execution?","I'll perform a thorough audit of the LaunchEvent smart contract following the requested steps.

{
  ""ReviewingTheCode"": ""The LaunchEvent contract implements a three-phase token launch mechanism for issuing new tokens while requiring participants to burn rJoe tokens. It manages AVAX deposits from users, handles liquidity pool creation, and distributes tokens and liquidity according to specific rules across different phases. The contract integrates with Trader Joe's DEX infrastructure for liquidity provision."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LaunchEvent"",
    ""Purpose"": ""Manages a token launch event with three phases where users deposit AVAX in exchange for a new token, creates a liquidity pool, and distributes LP tokens with time-locked withdrawals."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"",
        ""./interfaces/IJoeFactory.sol"",
        ""./interfaces/IJoePair.sol"",
        ""./interfaces/IJoeRouter02.sol"",
        ""./interfaces/IRocketJoeFactory.sol"",
        ""./interfaces/IRocketJoeToken.sol"",
        ""./interfaces/IWAVAX.sol""
      ]
    },
    
    ""StateVariables"": [
      {
        ""Name"": ""issuer"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the token issuer who launches the token""
      },
      {
        ""Name"": ""auctionStart"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp when the auction (Phase One) starts""
      },
      {
        ""Name"": ""PHASE_ONE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the first phase in seconds""
      },
      {
        ""Name"": ""PHASE_ONE_NO_FEE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the fee-free period in Phase One""
      },
      {
        ""Name"": ""PHASE_TWO_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the second phase in seconds""
      },
      {
        ""Name"": ""tokenIncentivesPercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Percentage of token allocated as incentives for users""
      },
      {
        ""Name"": ""floorPrice"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum price for the token in terms of AVAX""
      },
      {
        ""Name"": ""userTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timelock duration for users to withdraw LP tokens""
      },
      {
        ""Name"": ""issuerTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timelock duration for issuer to withdraw LP tokens""
      },
      {
        ""Name"": ""maxWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum penalty for early withdrawal in Phase One""
      },
      {
        ""Name"": ""fixedWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fixed penalty for withdrawal in Phase Two""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""IRocketJoeToken"",
        ""Purpose"": ""Reference to the rJoe token contract""
      },
      {
        ""Name"": ""rJoePerAvax"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Ratio of rJoe tokens required per AVAX deposited""
      },
      {
        ""Name"": ""WAVAX"",
        ""Type"": ""IWAVAX"",
        ""Purpose"": ""Reference to the wrapped AVAX token contract""
      },
      {
        ""Name"": ""token"",
        ""Type"": ""IERC20Metadata"",
        ""Purpose"": ""Token being launched""
      },
      {
        ""Name"": ""router"",
        ""Type"": ""IJoeRouter02"",
        ""Purpose"": ""Reference to the Trader Joe router for creating and managing liquidity""
      },
      {
        ""Name"": ""factory"",
        ""Type"": ""IJoeFactory"",
        ""Purpose"": ""Reference to the Trader Joe factory for creating pairs""
      },
      {
        ""Name"": ""rocketJoeFactory"",
        ""Type"": ""IRocketJoeFactory"",
        ""Purpose"": ""Reference to the factory that creates LaunchEvent contracts""
      },
      {
        ""Name"": ""initialized"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if the contract has been initialized""
      },
      {
        ""Name"": ""stopped"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if the launch event has been stopped""
      },
      {
        ""Name"": ""maxAllocation"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum AVAX allocation per user""
      },
      {
        ""Name"": ""getUserInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Maps user addresses to their participation details""
      },
      {
        ""Name"": ""pair"",
        ""Type"": ""IJoePair"",
        ""Purpose"": ""Reference to the created liquidity pair""
      }
    ],
    
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets initial state of the contract with parameters provided by the factory"",
        ""Parameters"": [""_issuer"", ""_auctionStart"", ""_token"", ""_tokenIncentivesPercent"", ""_floorPrice"", ""_maxWithdrawPenalty"", ""_fixedWithdrawPenalty"", ""_maxAllocation"", ""_userTimelock"", ""_issuerTimelock""],
        ""Returns"": []
      },
      {
        ""Name"": ""currentPhase"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Determines the current phase of the launch based on current timestamp"",
        ""Parameters"": [],
        ""Returns"": [""Phase""]
      },
      {
        ""Name"": ""depositAVAX"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to deposit AVAX during Phase One, burning rJoe tokens proportionally"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAVAX"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to withdraw deposited AVAX during Phase One and Two with penalties"",
        ""Parameters"": [""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""createPair"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates the AVAX-token liquidity pair on Trader Joe in Phase Three"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users and issuer to withdraw LP tokens after timelock period"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawIncentives"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users and issuer to withdraw token incentives"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows emergency withdrawal when contract is stopped"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""allowEmergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows factory owner to enable emergency withdrawal mode"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""skim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers excess tokens or AVAX to the penalty collector"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getPenalty"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the current withdrawal penalty based on elapsed time"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getReserves"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current WAVAX and token reserves"",
        ""Parameters"": [],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""getRJoeAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates rJoe amount needed for a given AVAX amount"",
        ""Parameters"": [""_avaxAmount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pairBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates user's share of LP tokens"",
        ""Parameters"": [""_user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""atPhase"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures function is called during a specific phase"",
        ""Parameters"": [""_phase""],
        ""Returns"": []
      },
      {
        ""Name"": ""timelockElapsed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the appropriate timelock period has elapsed"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""isStopped"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Checks if contract is in stopped state based on parameter"",
        ""Parameters"": [""_stopped""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""rJoe.burnFrom() - Burns rJoe tokens from user when depositing AVAX"",
    ""WAVAX.deposit() - Wraps AVAX into WAVAX"",
    ""WAVAX.withdraw() - Unwraps WAVAX to AVAX"",
    ""WAVAX.transfer() - Transfers WAVAX tokens"",
    ""WAVAX.approve() - Approves router to spend WAVAX"",
    ""token.transfer() - Transfers the launched tokens"",
    ""token.approve() - Approves router to spend tokens"",
    ""router.addLiquidity() - Creates liquidity pair on Trader Joe"",
    ""pair.transfer() - Transfers LP tokens to users or issuer""
  ],
  
  ""SpecialMechanisms"": [
    ""Three-phase token launch process (Phase 1: AVAX collection, Phase 2: Preparation, Phase 3: Pool creation)"",
    ""rJoe token burning mechanism to participate in the launch"",
    ""Dynamic withdrawal penalties that vary by phase and time elapsed"",
    ""Floor price protection mechanism that adjusts token allocation if necessary"",
    ""Timelocked LP token withdrawals with different periods for users and issuer"",
    ""Emergency withdrawal system that can be triggered by factory owner""
  ],
  
  ""Questions"": [
    ""Is there any front-running vulnerability in the createPair function?"",
    ""What happens if the token being launched has transfer fees or rebasing mechanisms?"",
    ""How is the contract protected against price manipulation just before liquidity is created?"",
    ""What mechanism prevents the contract from being drained if the token has approval exploits?"",
    ""Could there be issues with precision loss in the calculation of tokenIncentivesForUsers?"",
    ""How does the contract handle potential overflow or underflow in fund calculations?"",
    ""Is there a mechanism to recover if the issuer fails to deposit enough tokens initially?""
  ]
}

Looking deeper into security concerns, I would highlight the following issues:

1. The contract lacks input validation in some areas, particularly around token interactions which might lead to vulnerabilities with non-standard ERC20 tokens.

2. There's potential for precision loss in several calculations involving division, which could lead to rounding errors that affect users' allocations.

3. The contract's reliance on block.timestamp for phase transitions and penalty calculations could potentially be manipulated by miners to a small degree.

4. The emergency withdrawal mechanism gives significant power to the factory owner, which requires users to trust this entity.

5. The contract doesn't have a mechanism to handle unforeseen circumstances like failed transactions during the liquidity creation phase.

Overall, the contract implements a structured token launch mechanism with reasonable safety controls, but the complexity of the multi-phase process introduces several potential failure points that would need careful testing and auditing.","I've analyzed the provided security findings for the LaunchEvent smart contract. After processing the input data, I've combined similar issues, structured the output, and ordered them by severity:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in withdrawAVAX"",
      ""Severity"": ""Critical"",
      ""Description"": ""The withdrawAVAX function performs external calls (WAVAX.withdraw and _safeTransferAVAX) before updating state variables. This violates the checks-effects-interactions pattern and creates a reentrancy vulnerability where an attacker could exploit the order of operations to drain funds from the contract."",
      ""Impact"": ""An attacker could potentially drain more AVAX than they are entitled to by repeatedly calling withdrawAVAX before the state variables are updated, leading to significant loss of funds."",
      ""Location"": ""withdrawAVAX function""
    },
    {
      ""Issue"": ""No validation of token transfer success"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses token.transfer() without checking the return value. Some ERC20 tokens return false on failure instead of reverting. The contract assumes all transfers will succeed without explicitly handling potential failures."",
      ""Impact"": ""Failed token transfers might not be detected, potentially leading to loss of funds, incorrect accounting, or permanently blocked operations like withdrawIncentives if token transfers fail silently."",
      ""Location"": ""Various places where token.transfer is called (withdrawLiquidity, withdrawIncentives functions)""
    },
    {
      ""Issue"": ""Lack of input validation in initialize function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function doesn't validate important parameters such as _tokenIncentivesPercent, _floorPrice, _maxAllocation, and doesn't check for zero addresses for critical parameters like _issuer and _token. Extremely high values could lead to mathematical errors or economic exploitation."",
      ""Impact"": ""Could lead to unexpected behavior, improper token distribution, or economic attacks if parameters are set to extreme values. Setting critical addresses to zero could result in locked tokens or inaccessible functionality."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Precision loss in token calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple calculations in the contract involve division operations that could lead to precision loss, especially in the createPair function when calculating tokenAllocated based on floorPrice, in the getPenalty function, and in pairBalance calculations. This is particularly problematic with tokens that have different decimals."",
      ""Impact"": ""Users might receive slightly fewer tokens, incentives, or LP tokens than they should due to rounding errors. This could result in economic loss for users or the issuer."",
      ""Location"": ""createPair function, getPenalty function, pairBalance function""
    },
    {
      ""Issue"": ""Lack of validation for token decimals"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate that the token's decimal places are compatible with the calculations performed, particularly in the createPair function where floorPrice is used with the token's decimals."",
      ""Impact"": ""Tokens with unusual decimal configurations could lead to incorrect price calculations, token allocations, and potentially allowing the floor price mechanism to be bypassed."",
      ""Location"": ""initialize function and createPair function""
    },
    {
      ""Issue"": ""Centralized control by the owner"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant control to the owner of the RocketJoeFactory, allowing them to stop events and enable emergency withdrawals. This creates a centralization risk where a single entity controls critical functions."",
      ""Impact"": ""If the owner's private key is compromised, or if the owner acts maliciously, they could disrupt launchpad operations, causing financial loss to participants."",
      ""Location"": ""allowEmergencyWithdraw function""
    },
    {
      ""Issue"": ""Lack of slippage protection in createPair"",
      ""Severity"": ""Medium"",
      ""Description"": ""When calling router.addLiquidity(), the function sets the minimum amounts to be the same as the actual amounts provided. In volatile markets, this could lead to unfavorable execution or failed transactions."",
      ""Impact"": ""Front-running attacks or price manipulation could affect the initial liquidity provision negatively, leading to the transaction failing or providing liquidity at suboptimal rates."",
      ""Location"": ""createPair function, specifically in the router.addLiquidity() call""
    },
    {
      ""Issue"": ""Unsafe external call in _safeTransferAVAX"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _safeTransferAVAX function uses .call{value: _value}(new bytes(0)) which could potentially allow for reentrancy attacks if the recipient is a malicious contract. It could also consume all gas if the recipient is a contract with a gas-intensive fallback function."",
      ""Impact"": ""Potential reentrancy vulnerabilities when AVAX is transferred to untrusted contracts. Could also lead to gas limit attacks or unintended out-of-gas errors."",
      ""Location"": ""_safeTransferAVAX function""
    },
    {
      ""Issue"": ""No mechanism to recover incorrect tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""While there is a skim function to handle excess tokens, there's no mechanism to recover tokens that were mistakenly sent to the contract other than WAVAX and the specific project token."",
      ""Impact"": ""Any other tokens accidentally sent to the contract may be permanently locked."",
      ""Location"": ""Entire contract - missing recovery function""
    },
    {
      ""Issue"": ""No event emission for important state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't emit events for some important state changes, such as when the initialize function is called or when withdrawIncentives is executed."",
      ""Impact"": ""Reduced transparency and difficulty tracking important contract actions off-chain, making debugging and monitoring more challenging."",
      ""Location"": ""initialize function and withdrawIncentives function""
    },
    {
      ""Issue"": ""Possible block timestamp manipulation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies heavily on block.timestamp for determining phases and penalties. Miners can manipulate block timestamps to a certain extent, potentially affecting the timing of phase transitions."",
      ""Impact"": ""Miners could potentially manipulate timestamps to gain favorable withdrawal penalties or phase transitions, though the impact is limited by the scale of possible timestamp manipulation."",
      ""Location"": ""currentPhase function and getPenalty function""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 11
}",376.0822398662567,85905.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] Users can lose value in emergency state**

**Report Description**:  
In the `LaunchEvent` contract, if `allowEmergencyWithdraw()` is called after `createPair()`, users cannot withdraw their LP tokens or WAVAX reserves because the WAVAX reserve is already used to provide liquidity. This results in users losing their entire deposit.

**Match in Response List**:  
**No match found**. The response list does not address the specific scenario where users lose value due to the emergency withdrawal mechanism.

**Validation**:  
**Incorrect**. The response list does not cover this issue, which is a critical vulnerability leading to potential loss of user funds.

---

#### **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**

**Report Description**:  
The `tokenAllocated` computation in `createPair()` does not account for tokens with decimals other than 18. This leads to incorrect token allocations when the floor price is not reached.

**Match in Response List**:  
Matches with the issue titled **""Lack of validation for token decimals""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with token decimals but does not explicitly address the incorrect computation of `tokenAllocated` when the floor price is not reached.

---

#### **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**

**Report Description**:  
The owner of the token can prevent the creation of a JoePair, which limits access to `withdrawLiquidity()` and `withdrawIncentives()`. This can be used as a DOS attack, especially if the RocketJoe owner enables emergency withdrawals.

**Match in Response List**:  
Matches with the issue titled **""Centralized control by the owner""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk and the potential for the owner to disrupt launchpad operations.

---

#### **[M-05] Failed transfer with low level call could be overlooked**

**Report Description**:  
The `_safeTransferAVAX` function does not check if the recipient address is a non-existent contract, which could lead to silent failures if the `penaltyCollector` address is deleted.

**Match in Response List**:  
Matches with the issue titled **""Unsafe external call in _safeTransferAVAX""**.

**Validation**:  
**Correct**. The response correctly identifies the issue with unsafe external calls and the potential for reentrancy or gas limit attacks.

---

#### **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**

**Report Description**:  
The `withdrawAVAX()` function makes an external call to `msg.sender` without reentrancy protection, allowing for potential reentrancy attacks.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy vulnerability in withdrawAVAX""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in the `withdrawAVAX` function.

---

#### **[M-08] LP Tokens May Be Locked in Contract Due to allowEmergencyWithdraw() in Stage 3**

**Report Description**:  
If `allowEmergencyWithdraw()` is called in Stage 3, LP tokens are locked, and users cannot withdraw their incentives or liquidity.

**Match in Response List**:  
**No match found**. The response list does not address the specific scenario where LP tokens are locked due to emergency withdrawal.

**Validation**:  
**Incorrect**. The response list does not cover this issue, which is a significant vulnerability leading to locked funds.

---

#### **[M-09] createPair() expects zero slippage**

**Report Description**:  
The `createPair()` function calls `router.addLiquidity()` with zero slippage, which could cause the transaction to revert if the zero slippage requirement is not met.

**Match in Response List**:  
Matches with the issue titled **""Lack of slippage protection in createPair""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of slippage protection in the `createPair` function.

---

#### **[M-10] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom**

**Report Description**:  
The contract uses `transfer/transferFrom` without checking return values, which could lead to silent failures in token transfers.

**Match in Response List**:  
Matches with the issue titled **""No validation of token transfer success""**.

**Validation**:  
**Correct**. The response correctly identifies the issue with unchecked token transfers.

---

#### **[M-12] Pair creation can be denied**

**Report Description**:  
A griefer can create a pool for the `WAVAX <> _token` pair before the launch event, preventing the creation of the pair and forcing an emergency state.

**Match in Response List**:  
**No match found**. The response list does not address the specific scenario where pair creation is denied by a griefer.

**Validation**:  
**Incorrect**. The response list does not cover this issue, which is a significant vulnerability leading to potential DOS attacks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**
- **[M-05] Failed transfer with low level call could be overlooked**
- **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**
- **[M-09] createPair() expects zero slippage**
- **[M-10] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom**

**Partially Correct Matches**:

- **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**

**Missed Issues from Issue Report**:

- **[H-01] Users can lose value in emergency state**
- **[M-08] LP Tokens May Be Locked in Contract Due to allowEmergencyWithdraw() in Stage 3**
- **[M-12] Pair creation can be denied**

---

The response list covers several critical issues but misses or partially addresses others, particularly those related to emergency withdrawal mechanisms and pair creation denial. These gaps highlight the need for a more comprehensive review of the contract's vulnerabilities.","```
1. Centralized control by the owner
2. Unsafe external call in _safeTransferAVAX
3. Reentrancy vulnerability in withdrawAVAX
4. Lack of slippage protection in createPair
5. No validation of token transfer success
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Centralized control by the owner"" appears at rank 6.
   - ""Unsafe external call in _safeTransferAVAX"" appears at rank 8.
   - ""Reentrancy vulnerability in withdrawAVAX"" appears at rank 1.
   - ""Lack of slippage protection in createPair"" appears at rank 7.
   - ""No validation of token transfer success"" appears at rank 2.

2. **Calculate the precision at each rank**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 2: \( P@2 = \frac{2}{2} = 1.0 \)
   - For rank 6: \( P@6 = \frac{3}{6} = 0.5 \)
   - For rank 7: \( P@7 = \frac{4}{7} \approx 0.571 \)
   - For rank 8: \( P@8 = \frac{5}{8} = 0.625 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 1.0 + 0.5 + 0.571 + 0.625}{5} = \frac{3.696}{5} \approx 0.739
   \]

**Output**:
```
0.739
```"
RocketJoeStaking.sol,"// SPDX-License-Identifier: None

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";

/// @title Rocket Joe Staking
/// @author Trader Joe
/// @notice Stake JOE to earn rJOE
contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; // How many JOE tokens the user has provided
        uint256 rewardDebt; // Reward debt. See explanation below
        //
        // We do some fancy math here. Basically, any point in time, the amount of JOEs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated
        //   2. User receives the pending reward sent to his/her address
        //   3. User's `amount` gets updated
        //   4. User's `rewardDebt` gets updated
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    /// @dev Accumulated rJOE per share, times PRECISION. See above
    uint256 public accRJoePerShare;
    /// @notice Precision of accRJoePerShare
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    /// @dev Info of each user that stakes LP tokens
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    /// @notice Initialize with needed parameters
    /// @param _joe Address of the JOE token contract
    /// @param _rJoe Address of the rJOE token contract
    /// @param _rJoePerSec Number of rJOE tokens created per second
    /// @param _startTime Timestamp at which rJOE rewards starts
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    /// @notice Get pending rJoe for a given `_user`
    /// @param _user The user to lookup
    /// @return The number of pending rJOE tokens for `_user`
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation
    /// @param _amount Amount of JOE to deposit
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking
    /// @param _amount Amount of JOE to withdraw
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    /// @notice Update emission rate
    /// @param _rJoePerSec The new value for rJoePerSec
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    /// @notice Update reward variables of the given pool with latest data
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs
    /// @param _to Address that wil receive rJoe
    /// @param _amount The amount to send
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}

",1640,191,"[M-01] Improper Upper Bound Definition on the Fee

Submitted by Jujic
The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.
Proof of Concept

https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151
``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
    updatePool();
    rJoePerSec = _rJoePerSec;
    emit UpdateEmissionRate(msg.sender, _rJoePerSec);
}
```  [M-03] createRJLaunchEvent() can be called by anyone with 1 Wei of _token and stop others from creating RJLaunchEvent with the same token anymore

Submitted by WatchPug, also found by p4st13r4
https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L132
 In the current implementation, RocketJoeFactory.sol#createRJLaunchEvent() can be called by anyone with at least 1 Wei of _token.
This allows a malicious user or attacker to call createRJLaunchEvent() with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.
  [M-04] Uninitialized RocketJoeStaking.lastRewardTimestamp can inflate rJoe supply

Submitted by cmichel
The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as updatePool is called before the first deposit and when joeSupply = joe.balanceOf(address(this)) == 0, it is set to the current time.
 However, if a user first directly transfers Joe tokens to the contract before the first updatePool call, the block.timestamp - lastRewardTimestamp = block.timestamp will be a large timestamp value and lots of rJoe will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the rJoe total supply might not be desired.   [M-06] possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking

Submitted by hubble
There is a possibility of the `rJOE` tokens in RocketJoeToken.sol to be minted by original owner without staking any JOE, before the ownership is transferred to RocketJoeStaking
Proof of Concept

Contract : RocketJoeToken.sol Line : 37  ``` function mint(address _to, uint256 _amount) external onlyOwner { _mint(_to, _amount); } ```
  [M-11] Re-enterable Code When Making a Deposit to Stake

Note: this attack requires rJoe to relinquish control during tranfer() which under the current RocketJoeToken it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.
This vulnerability would allow the entire rJoe balance to be drained from the contract.
",5,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";




contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    
    uint256 public accRJoePerShare;
    
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    
    
    
    
    
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    
    
    
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    
    
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    
    
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    
    
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    
    
    
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}",1130,0,5,"Based on the comprehensive analysis of the RocketJoeStaking contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in deposit, withdraw, and emergencyWithdraw functions"",
        ""Check for potential integer overflow/underflow risks in arithmetic operations"",
        ""Audit the _safeRJoeTransfer function for potential transfer vulnerabilities"",
        ""Validate input validation and boundary checks in all external functions""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review the onlyOwner modifier implementation for updateEmissionRate"",
        ""Verify that critical functions have appropriate access restrictions"",
        ""Check the initialization process for potential circumvention of access controls""
      ]
    },
    {
      ""Area"": ""Staking and Rewards Mechanism"",
      ""Tasks"": [
        ""Deeply analyze the reward calculation logic in pendingRJoe and updatePool functions"",
        ""Verify the accuracy of reward debt calculation and distribution"",
        ""Check for potential reward manipulation through emission rate changes"",
        ""Audit the precision scaling mechanism (PRECISION constant)"",
        ""Verify that reward calculations cannot be gamed or exploited""
      ]
    },
    {
      ""Area"": ""Token Interactions"",
      ""Tasks"": [
        ""Verify safe usage of SafeERC20Upgradeable library"",
        ""Check token transfer mechanisms in deposit and withdraw functions"",
        ""Validate the RocketJoeToken's mint functionality and access controls"",
        ""Ensure proper handling of token decimals and transfer amounts""
      ]
    },
    {
      ""Area"": ""Upgradability Considerations"",
      ""Tasks"": [
        ""Review the initialize function for potential initialization vulnerabilities"",
        ""Check for proper implementation of upgradeable contract patterns"",
        ""Verify that storage layout is compatible with future upgrades""
      ]
    },
    {
      ""Area"": ""Economic Risks"",
      ""Tasks"": [
        ""Analyze potential economic attacks through emission rate manipulation"",
        ""Check for risks of sudden large deposits or withdrawals"",
        ""Verify the impact of rJoePerSec changes on the overall token economy"",
        ""Assess potential scenarios of extreme emission rate modifications""
      ]
    },
    {
      ""Area"": ""Emergency Mechanisms"",
      ""Tasks"": [
        ""Thoroughly test the emergencyWithdraw function"",
        ""Verify that emergency withdrawal does not break core contract logic"",
        ""Check for potential abuse of emergency withdrawal mechanism""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of key functions"",
        ""Review the efficiency of reward calculation methods"",
        ""Check for potential gas optimization opportunities"",
        ""Verify that loop-free calculations are used where possible""
      ]
    },
    {
      ""Area"": ""Edge Case Handling"",
      ""Tasks"": [
        ""Test scenarios with zero balance and zero rewards"",
        ""Verify behavior when no tokens are staked"",
        ""Check handling of extremely small or large deposit amounts"",
        ""Test contract behavior with multiple users and varying stake sizes""
      ]
    }
  ]
}

This task list comprehensively covers the key audit areas for the RocketJoeStaking contract, addressing potential vulnerabilities, economic risks, and implementation nuances. Each task is designed to provide a specific, actionable approach to thoroughly examining the contract's security and functionality.

The tasks prioritize critical areas such as security vulnerabilities, access control, and the core staking and rewards mechanism, while also considering upgradability, economic risks, and performance optimization.

Would you like me to elaborate on any specific area or provide more detailed insights into the potential risks and audit approach?","After analyzing the provided smart contract, here's my comprehensive audit:

{
  ""ReviewingTheCode"": ""This is a staking contract called RocketJoeStaking that allows users to deposit JOE tokens and earn rJOE (Rocket Joe) tokens as rewards. It implements a typical farming/staking mechanism where rewards are emitted at a configurable rate per second and are distributed proportionally to stakers based on their share of the total staked tokens."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RocketJoeStaking"",
    ""Purpose"": ""Allows users to stake JOE tokens and earn rJOE tokens as rewards over time, with rewards distributed based on each user's proportional share of the pool."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./RocketJoeToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""UserInfo"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores user-specific staking information including deposited amount and reward debt""
      },
      {
        ""Name"": ""joe"",
        ""Type"": ""IERC20Upgradeable"",
        ""Purpose"": ""Reference to the JOE token contract that users stake""
      },
      {
        ""Name"": ""lastRewardTimestamp"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last reward distribution update""
      },
      {
        ""Name"": ""accRJoePerShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated rJOE tokens per share, scaled by PRECISION""
      },
      {
        ""Name"": ""PRECISION"",
        ""Type"": ""uint256 (private)"",
        ""Purpose"": ""Multiplier (10^18) used to avoid precision loss in reward calculations""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""RocketJoeToken"",
        ""Purpose"": ""Reference to the reward token (rJOE) contract""
      },
      {
        ""Name"": ""rJoePerSec"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Rate at which rJOE tokens are emitted per second""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Maps user addresses to their staking information""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with required parameters (used instead of constructor for upgradeable contracts)"",
        ""Parameters"": [""_joe: IERC20Upgradeable"", ""_rJoe: RocketJoeToken"", ""_rJoePerSec: uint256"", ""_startTime: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""pendingRJoe"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates pending rJOE rewards for a specific user without updating the contract state"",
        ""Parameters"": [""_user: address""],
        ""Returns"": [""uint256: pending reward amount""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to stake JOE tokens, updates pool rewards, and harvests pending rewards"",
        ""Parameters"": [""_amount: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw staked JOE tokens and harvest pending rewards"",
        ""Parameters"": [""_amount: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw all staked tokens without claiming rewards (emergency function)"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateEmissionRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the rewards emission rate"",
        ""Parameters"": [""_rJoePerSec: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward variables for the pool, minting new rJOE tokens as needed"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeRJoeTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers rJOE tokens to users, handling the case where contract balance is insufficient"",
        ""Parameters"": [""_to: address"", ""_amount: uint256""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""Interacts with JOE token using IERC20Upgradeable interface"",
    ""Interacts with RocketJoeToken (rJOE) for minting and transferring reward tokens"",
    ""Uses SafeERC20Upgradeable for safer token transfers""
  ],
  
  ""SpecialMechanisms"": [
    ""Implements a staking reward mechanism using 'rewardDebt' pattern to track accumulated rewards"",
    ""Uses an upgradeable proxy pattern as evidenced by the inheritance from Initializable and use of initializer instead of constructor"",
    ""Implements a rewards-per-second emission model that updates accumulated rewards based on time elapsed"",
    ""Uses precision scaling (PRECISION = 1e18) to handle decimal calculations in a fixed-point manner""
  ],
  
  ""Questions"": [
    ""What is the actual implementation of RocketJoeToken? Specifically, how is the mint function controlled?"",
    ""Are there any checks to prevent the owner from setting rJoePerSec to extremely high values?"",
    ""Is there a maximum cap on the total amount of rJOE tokens that can be minted?"",
    ""What happens if the contract is initialized with a start time that's too far in the future?"",
    ""Is there a withdrawal fee or time-lock mechanism that isn't implemented in this contract but might be expected?"",
    ""In the UserInfo struct, there are several blank lines, which suggests there might have been additional fields planned or removed - was this intentional?""
  ]
}","I'll process the findings data, combine similar issues, and present a consolidated report sorted by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in withdraw and deposit functions"",
      ""Severity"": ""High"",
      ""Description"": ""The deposit(), withdraw(), and emergencyWithdraw() functions lack proper reentrancy protection. These functions update state variables before or after making external calls to transfer tokens, violating the checks-effects-interactions pattern. While SafeERC20 is used for joe token, the rJoe token transfers use direct transfer calls which could enable callbacks during execution."",
      ""Impact"": ""An attacker could potentially reenter the contract and drain funds by exploiting the sequence of operations, particularly if the rJoe token has callbacks or hooks that allow reentrancy during _safeRJoeTransfer calls."",
      ""Location"": ""deposit(), withdraw(), emergencyWithdraw() functions and _safeRJoeTransfer() function""
    },
    {
      ""Issue"": ""Unsafe ERC-20 transfer in _safeRJoeTransfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _safeRJoeTransfer() function uses the standard transfer() method instead of safeTransfer() from SafeERC20 when transferring rJoe tokens. This does not check for the success of the transfer and can lead to silent failures if the token doesn't revert on failure but returns a boolean which is not checked."",
      ""Impact"": ""Failed transfers might not revert, leading to inconsistent state and potential loss of rewards for users. If the rJoe token implementation doesn't revert on failed transfers, users might not receive their rewards while the contract thinks the transfer succeeded."",
      ""Location"": ""_safeRJoeTransfer() function""
    },
    {
      ""Issue"": ""Centralization risk with owner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant control to the owner, who can change emission rates and potentially other parameters through upgrades. The owner's ability to change emission rates is not time-bound or gradually reduced, which creates a centralization risk where users must trust the owner not to make unfavorable changes."",
      ""Impact"": ""Users are required to trust the owner not to manipulate rewards or token minting in ways that could harm their interests. This could potentially lead to economic exploitation if the owner sets rates that disadvantage users."",
      ""Location"": ""updateEmissionRate() function and general contract architecture""
    },
    {
      ""Issue"": ""Lack of input validation for emission rate"",
      ""Severity"": ""Medium"",
      ""Description"": ""The updateEmissionRate() function doesn't validate that the new emission rate (_rJoePerSec) is reasonable or has an upper bound. This could potentially be set to an extremely high value, causing excessive token minting or inflation."",
      ""Impact"": ""A malicious or careless owner could set emission rates so high that they effectively dilute the token value or drain rewards too quickly, leading to rapid inflation of rJoe tokens and devaluing user holdings."",
      ""Location"": ""updateEmissionRate() function""
    },
    {
      ""Issue"": ""Missing zero address validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function doesn't validate that _joe and _rJoe addresses are not the zero address, and that other parameters have reasonable values. If either token address is set to the zero address, the contract would be unusable."",
      ""Impact"": ""Setting token addresses to zero would permanently break contract functionality and potentially lock user funds, requiring contract redeployment and possibly causing loss of funds or trust."",
      ""Location"": ""initialize() function""
    },
    {
      ""Issue"": ""Potential precision loss in reward calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs division operations in reward calculations that could lead to precision loss, especially when joeSupply is large or when calculating small reward amounts. Despite using PRECISION (1e18) as a factor, calculations involving division can still lose precision."",
      ""Impact"": ""Users may receive slightly fewer rewards than they should due to rounding errors accumulated over time, particularly affecting users with small stakes who might not receive their fair share of rewards."",
      ""Location"": ""pendingRJoe(), deposit(), withdraw(), and updatePool() functions""
    },
    {
      ""Issue"": ""Missing contract pause functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a pause mechanism that would allow the owner to halt operations in case of an emergency or discovered vulnerability. This limits the owner's ability to respond to security incidents."",
      ""Impact"": ""In case of a vulnerability discovery, the owner has limited options to protect user funds except through an emergency upgrade or other mitigation strategies."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""No slippage protection in deposit and withdraw"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't implement any slippage protection for users depositing or withdrawing funds. When calculating rewards in updatePool(), the contract does not consider potential changes in token prices or supply, which could lead to unfair reward distributions especially if large deposits or withdrawals occur."",
      ""Impact"": ""Users might receive fewer rewards than expected due to front-running or sandwich attacks in high-traffic periods, or disproportionate rewards if the timing of their transactions coincides with significant changes in the total staked amount."",
      ""Location"": ""deposit() and withdraw() functions""
    },
    {
      ""Issue"": ""Block timestamp dependence"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies on block.timestamp for reward calculations. Miners/validators can manipulate this value slightly (by a few seconds), which could affect reward calculations, especially in high-value transactions."",
      ""Impact"": ""Slight manipulation of rewards distribution timing is possible, though the practical impact is minimal due to the limited ability to manipulate block timestamps."",
      ""Location"": ""updatePool() and pendingRJoe() functions""
    },
    {
      ""Issue"": ""No timelock for critical parameter changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical parameter changes like emission rate take effect immediately without any timelock mechanism, giving users no time to react to changes before they take effect."",
      ""Impact"": ""Users cannot prepare for or react to significant changes in the contract's behavior before they take effect, potentially leading to unexpected consequences."",
      ""Location"": ""updateEmissionRate() function""
    },
    {
      ""Issue"": ""Loss of rewards during emergencyWithdraw"",
      ""Severity"": ""Low"",
      ""Description"": ""The emergencyWithdraw() function allows users to withdraw their staked tokens in case of emergency but silently forfeits all pending rewards by resetting rewardDebt to 0."",
      ""Impact"": ""Users will lose all their pending rewards when using the emergency withdrawal function, which might be unexpected in panic situations."",
      ""Location"": ""emergencyWithdraw() function""
    },
    {
      ""Issue"": ""Missing events for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The updatePool() function doesn't emit an event when rewards are calculated and tokens are minted, making it difficult to track when and how many tokens are minted."",
      ""Impact"": ""Reduced contract transparency and more difficult debugging or monitoring of the contract's activity, particularly for tracking rJoe token minting."",
      ""Location"": ""updatePool() function""
    },
    {
      ""Issue"": ""No admin function to recover wrongly sent tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks functionality to recover tokens other than joe and rJoe that might be accidentally sent to the contract."",
      ""Impact"": ""Tokens sent to the contract by mistake will be permanently locked, leading to loss of funds for users who make transfer errors."",
      ""Location"": ""Throughout the contract""
    }
  ],
  ""IssueNumber"": 64,
  ""OutputList"": 13
}",316.26106119155884,45690.0,32.0,"### **[M-01] Improper Upper Bound Definition on the Fee**

**Report Description**:
The `rJoePerSec` parameter in the `updateEmissionRate` function does not have any upper or lower bounds. If the value is set too high, it could lead to reversions in several critical functions, potentially causing disruptions in the contract's operation.

**Match in Response List**:
Matches with the issue titled **""Lack of input validation for emission rate""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the lack of input validation for the emission rate in the `updateEmissionRate` function. It correctly explains the risks associated with setting an excessively high emission rate, which aligns with the issue described in the report.

---

### **[M-03] createRJLaunchEvent() can be called by anyone with 1 Wei of _token and stop others from creating RJLaunchEvent with the same token anymore**

**Report Description**:
The `createRJLaunchEvent` function in `RocketJoeFactory.sol` can be called by anyone with at least 1 Wei of `_token`. This allows a malicious user to call the function with minimal cost and prevent others, including the platform itself or the rightful issuer of the token, from creating an RJLaunchEvent with the same token.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The vulnerability described in the report is not covered in the response list, indicating a gap in the analysis.

---

### **[M-04] Uninitialized RocketJoeStaking.lastRewardTimestamp can inflate rJoe supply**

**Report Description**:
The `lastRewardTimestamp` in `RocketJoeStaking` is initialized to zero. If a user directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp` will be a large value, leading to the minting of a significant amount of `rJoe` tokens. Although these tokens are not distributed to users, inflating the `rJoe` total supply might not be desired.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The vulnerability described in the report is not covered in the response list, indicating a gap in the analysis.

---

### **[M-06] Possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking**

**Report Description**:
There is a possibility of the `rJOE` tokens in `RocketJoeToken.sol` to be minted by the original owner without staking any `JOE`, before the ownership is transferred to `RocketJoeStaking`. This could lead to an unfair distribution of tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The vulnerability described in the report is not covered in the response list, indicating a gap in the analysis.

---

### **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Report Description**:
The deposit function in the contract is potentially re-enterable if the `rJoe` token relinquishes control during the `transfer` call. Although the current `RocketJoeToken` implementation does not allow this, the code pattern is highly risky and should be avoided. This vulnerability could allow the entire `rJoe` balance to be drained from the contract.

**Match in Response List**:
Matches with the issue titled **""Reentrancy vulnerability in withdraw and deposit functions""**.

**Validation**:
**Correct**. The response accurately identifies the issue with reentrancy in the deposit and withdraw functions. It correctly explains the risks associated with the sequence of operations and the potential for reentrancy, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Improper Upper Bound Definition on the Fee**
- **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-03] createRJLaunchEvent() can be called by anyone with 1 Wei of _token and stop others from creating RJLaunchEvent with the same token anymore**
- **[M-04] Uninitialized RocketJoeStaking.lastRewardTimestamp can inflate rJoe supply**
- **[M-06] Possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking**

---","```
1. Lack of input validation for emission rate
2. Reentrancy vulnerability in withdraw and deposit functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Lack of input validation for emission rate"" appears at rank 4.
   - ""Reentrancy vulnerability in withdraw and deposit functions"" appears at rank 1.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.5}{2} = 0.75 \)

**Average Precision (AP)**: 0.75"
