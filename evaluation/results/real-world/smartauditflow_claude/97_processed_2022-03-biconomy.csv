nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LiquidityPool.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025,434,"[H-01] Can deposit native token for free and steal funds

Submitted by cmichel, also found by CertoraInc
LiquidityPool.sol#L151
The depositErc20 function allows setting tokenAddress = NATIVE and does not throw an error. No matter the amount chosen, the SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount); call will not revert because it performs a low-level call to NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, which is an EOA, and the low-level calls to EOAs always succeed. Because the safe* version is used, the EOA not returning any data does not revert either.
This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same Deposit event as a real depositNative call and the attacker receives the native funds on the other chain.
  [H-03] Wrong formula when add fee incentivePool can lead to loss of funds.

Submitted by minhquanym, also found by cmichel, hickuphh3, and WatchPug
LiquidityPool.sol#L319-L322
The `getAmountToTransfer` function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.
  [M-08] Incentive Pool can be drained without rebalancing the pool

Submitted by kyliek, also found by Ruhum and WatchPug
LiquidityPool.sol#L149-L173 LiquidityPool.sol#L263-L277
`depositErc20()` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.
  [M-18] Possible frontrun on `deposits` on LiquidityPool

Submitted by Cantor_Dust, also found by WatchPug
Rewards are given to a user for depositing either ERC20 tokens or their native token into the LiquidityPool. This reward is used to incentivize users to deposit funds into the liquidity pool when the pool is not in an equilibrium state.
For regular users, this liquidity pool state fluctuates based on the frequency and amount of deposits made to the liquidity pool. If a malicious user can control the state of the liquidity pool before a victim deposits tokens into the liquidity pool, they can gain double rewards.
To gain these double rewards, a malicious user can watch the mempool for transactions that will receive a reward when the deposit occurs. When a malicious user sees that victim deposit, the malicious user can attach a higher fee to their transaction and initiate a deposit. This will allow the malicious user's transaction to front-run before the victim's transaction.
",4,,"pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; 

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; 
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; 

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3573,2,2,"Based on the comprehensive analysis of the LiquidityPool contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly review reentrancy protection in sendFundsToUser and withdrawal functions"",
        ""Validate input validation and sanitization across all external functions"",
        ""Check for potential integer overflow/underflow risks in fee calculations"",
        ""Verify unchecked external calls, especially in transfer and low-level call methods"",
        ""Examine potential attack vectors in getAmountToTransfer and getTransferFee calculations""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyExecutor and onlyLiquidityProviders modifiers for comprehensive permission checks"",
        ""Review owner-only functions for potential centralization risks"",
        ""Verify trusted forwarder implementation for meta-transaction security"",
        ""Validate initialization method for proper access control configuration"",
        ""Check the process of changing critical contract addresses (executorManager, liquidityProviders)""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Analyze processedHash mechanism for comprehensive transaction replay protection"",
        ""Review checkHashStatus method for potential hash collision vulnerabilities"",
        ""Validate cross-chain deposit and withdrawal limits and configurations"",
        ""Examine token and chain-specific configuration management"",
        ""Verify chain ID and token address validation processes""
      ]
    },
    {
      ""Area"": ""Fee and Liquidity Mechanisms"",
      ""Tasks"": [
        ""Comprehensive review of getTransferFee calculation logic"",
        ""Analyze incentive pool distribution mechanism for potential economic attacks"",
        ""Verify getCurrentLiquidity calculation for accuracy and potential manipulation"",
        ""Check getRewardAmount implementation for fairness and economic sustainability"",
        ""Examine gas fee accumulation and withdrawal processes""
      ]
    },
    {
      ""Area"": ""Token Interactions"",
      ""Tasks"": [
        ""Validate ERC20 token interaction safety, especially with safeTransfer and safeTransferFrom"",
        ""Review permit and EIP2612 implementation for security"",
        ""Check handling of different token decimal implementations"",
        ""Verify token configuration checks in tokenChecks modifier"",
        ""Analyze native vs ERC20 token handling differences""
      ]
    },
    {
      ""Area"": ""Gas and Performance Optimization"",
      ""Tasks"": [
        ""Review gas-intensive calculations in fee and liquidity methods"",
        ""Analyze baseGas and gas-related calculations for efficiency"",
        ""Check for potential gas griefing attacks"",
        ""Verify gas price and overhead calculations"",
        ""Examine emergency gas cost management strategies""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Comprehensive review of interactions with IExecutorManager"",
        ""Validate ITokenManager configuration validation"",
        ""Review ILiquidityProviders interface interactions"",
        ""Check error handling in external contract calls"",
        ""Verify address validation for external contract addresses""
      ]
    },
    {
      ""Area"": ""Emergency and Upgradeability"",
      ""Tasks"": [
        ""Review pausable functionality implementation"",
        ""Verify upgrade path and initialization method security"",
        ""Check emergency stop and recovery mechanisms"",
        ""Analyze potential upgrade-related vulnerabilities"",
        ""Validate owner's ability to modify critical contract parameters""
      ]
    }
  ]
}

Key Observations and Recommendations:
1. The contract demonstrates a sophisticated cross-chain liquidity management system with multiple security layers.
2. Complex fee calculation mechanisms require thorough mathematical and security verification.
3. Meta-transaction support adds complexity and requires careful security auditing.
4. The use of upgradeable contract patterns necessitates careful initialization and upgrade path review.

Recommended Next Steps:
- Conduct a formal mathematical review of fee and liquidity calculation algorithms
- Perform comprehensive penetration testing
- Consider third-party security audit
- Develop comprehensive test cases covering edge scenarios

Would you like me to elaborate on any specific area or provide more detailed analysis of the potential vulnerabilities?","After analyzing the provided smart contract, here's the comprehensive audit:

{
  ""ReviewingTheCode"": ""The code represents a LiquidityPool contract that appears to be part of a cross-chain bridge or liquidity management system. It handles the transfer of ERC20 tokens and native currency (ETH) across different blockchain networks. The contract includes features for depositing assets, withdrawal, fee management, and incentive mechanisms to maintain liquidity balance across chains."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityPool"",
    ""Purpose"": ""Manages liquidity across multiple blockchains, facilitates cross-chain token transfers, handles deposits and withdrawals, and implements fee structures with incentive mechanisms to maintain liquidity equilibrium."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ReentrancyGuardUpgradeable"",
        ""Pausable"",
        ""OwnableUpgradeable"",
        ""ERC2771ContextUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/IExecutorManager.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""../interfaces/IERC20Permit.sol"",
        ""./interfaces/ITokenManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address constant"",
        ""Purpose"": ""Address constant representing the native ETH token (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Constant divisor (10000000000) used in fee calculations""
      },
      {
        ""Name"": ""baseGas"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Base gas amount used in fee calculations, initialized to 21000""
      },
      {
        ""Name"": ""executorManager"",
        ""Type"": ""IExecutorManager"",
        ""Purpose"": ""Interface to manage executors who can perform cross-chain transactions""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface to manage supported tokens and their configurations""
      },
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to interact with liquidity providers""
      },
      {
        ""Name"": ""processedHash"",
        ""Type"": ""mapping(bytes32 => bool)"",
        ""Purpose"": ""Tracks processed transaction hashes to prevent duplicate execution""
      },
      {
        ""Name"": ""gasFeeAccumulatedByToken"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks accumulated gas fees by token address""
      },
      {
        ""Name"": ""gasFeeAccumulated"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks accumulated gas fees per executor per token""
      },
      {
        ""Name"": ""incentivePool"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks incentive pool balance per token used to reward providers of needed liquidity""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyExecutor"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function access to authorized executors""
      },
      {
        ""Name"": ""onlyLiquidityProviders"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Restricts function access to liquidity providers contract""
      },
      {
        ""Name"": ""tokenChecks"",
        ""Type"": ""modifier"",
        ""Purpose"": ""Verifies token address is valid and supported""
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract (upgradeable pattern)"",
        ""Parameters"": [""address _executorManagerAddress"", ""address _pauser"", ""address _trustedForwarder"", ""address _tokenManager"", ""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTrustedForwarder"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates trusted forwarder for meta-transactions"",
        ""Parameters"": [""address trustedForwarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates liquidity providers contract address"",
        ""Parameters"": [""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBaseGas"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates base gas value used in fee calculations"",
        ""Parameters"": [""uint128 gas""],
        ""Returns"": []
      },
      {
        ""Name"": ""getCurrentLiquidity"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns current available liquidity for a token"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256 currentLiquidity""]
      },
      {
        ""Name"": ""depositErc20"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles ERC20 token deposits from users for cross-chain transfers"",
        ""Parameters"": [""uint256 toChainId"", ""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""getRewardAmount"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates reward amount for liquidity providers"",
        ""Parameters"": [""uint256 amount"", ""address tokenAddress""],
        ""Returns"": [""uint256 rewardAmount""]
      },
      {
        ""Name"": ""permitAndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Combines ERC20 permit and deposit operations"",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""permitEIP2612AndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Combines EIP2612 permit and deposit operations"",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositNative"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Handles native currency (ETH) deposits for cross-chain transfers"",
        ""Parameters"": [""address receiver"", ""uint256 toChainId"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendFundsToUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers funds to users as part of cross-chain operations"",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash"", ""uint256 tokenGasPrice"", ""uint256 fromChainId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountToTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates amount to transfer after deducting fees"",
        ""Parameters"": [""uint256 initialGas"", ""address tokenAddress"", ""uint256 amount"", ""uint256 tokenGasPrice""],
        ""Returns"": [""uint256 amountToTransfer""]
      },
      {
        ""Name"": ""getTransferFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates transfer fee based on current liquidity levels"",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": [""uint256 fee""]
      },
      {
        ""Name"": ""checkHashStatus"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a transaction hash has been processed already"",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash""],
        ""Returns"": [""bytes32 hashSendTransaction"", ""bool status""]
      },
      {
        ""Name"": ""withdrawErc20GasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows executors to withdraw accumulated ERC20 gas fees"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawNativeGasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows executors to withdraw accumulated native currency gas fees"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers tokens from the contract to a receiver (restricted to liquidity providers)"",
        ""Parameters"": [""address _tokenAddress"", ""address receiver"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the message sender (supports meta-transactions)"",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the message data (supports meta-transactions)"",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      }
    ]
  },

  ""ExternalInteractions"": [
    ""IExecutorManager - Used to validate executor permissions"",
    ""ITokenManager - Manages supported tokens and their configuration"",
    ""ILiquidityProviders - Manages liquidity provider interactions"",
    ""IERC20Permit - For permit functionality to approve token transfers"",
    ""IERC20Upgradeable - For standard ERC20 token interactions"",
    ""SafeERC20Upgradeable - For safe ERC20 token transfers"",
    ""ETH/Native token transfers via low-level calls""
  ],

  ""SpecialMechanisms"": [
    ""Proxy Pattern - Uses OpenZeppelin's upgradeable contracts pattern for upgradeability"",
    ""Meta-transactions - Supports gasless transactions via ERC2771Context"",
    ""Dynamic Fee Calculation - Uses a mathematical formula to adjust fees based on liquidity levels"",
    ""Incentive Pool - Provides rewards to liquidity providers who help maintain equilibrium"",
    ""Gas Fee Tracking - Tracks and reimburses gas costs to executors"",
    ""EIP-2612 Permit - Supports gasless approvals for token transfers"",
    ""Cross-chain Liquidity Management - Coordinates liquidity across multiple chains"",
    ""Reentrancy Protection - Uses ReentrancyGuard for security against reentrancy attacks"",
    ""Pausable Functionality - Allows emergency halt of operations""
  ],

  ""Questions"": [
    ""How is the incentivePool funded initially?"",
    ""What is the exact role of executors in the system?"",
    ""How are the tokenGasPrice parameters determined for cross-chain transactions?"",
    ""What are the security implications of using a constant address for NATIVE (ETH)?"",
    ""How does the contract handle token decimals differences across chains?"",
    ""Is there a mechanism to update the fee calculation formula if needed?"",
    ""Is there a maximum limit for the incentivePool to prevent economic attacks?"",
    ""How are cross-chain message verifications handled (only hash checks are visible)?"",
    ""Are there fallback mechanisms if a cross-chain transaction fails?"",
    ""How does the system ensure liquidity remains balanced across chains over time?""
  ]
}","I've analyzed the findings from multiple security assessments of the LiquidityPool smart contract. After combining similar issues and removing redundancy, here's the consolidated list of security vulnerabilities:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in native token transfers"",
      ""Severity"": ""Critical"",
      ""Description"": ""Despite using the nonReentrant modifier, the contract makes external calls to untrusted addresses after state changes in functions like sendFundsToUser, withdrawNativeGasFee, and other native token transfer functions. The code violates the checks-effects-interactions pattern by updating state before making external calls."",
      ""Impact"": ""Malicious recipients could potentially reenter the contract during native token transfers and exploit the contract's state, potentially draining funds or manipulating contract state between the fund transfer and the event emission."",
      ""Location"": ""sendFundsToUser function, withdrawNativeGasFee function, and other functions involving native token transfers""
    },
    {
      ""Issue"": ""Incentive pool depletion without balance checks"",
      ""Severity"": ""High"",
      ""Description"": ""In depositErc20 and depositNative functions, the incentivePool[tokenAddress] value is reduced without first checking if there are sufficient funds in the pool. If rewardAmount > incentivePool[tokenAddress], this could lead to an underflow if the reward amount exceeds the current incentive pool balance."",
      ""Impact"": ""An underflow could corrupt the incentive pool accounting, potentially leading to financial losses or a system in an invalid state. When the incentive pool runs low, transactions might unexpectedly revert."",
      ""Location"": ""depositErc20 function, depositNative function where they subtract from incentivePool[tokenAddress]""
    },
    {
      ""Issue"": ""Insufficient validation in permit functions"",
      ""Severity"": ""High"",
      ""Description"": ""The permit functions (permitAndDepositErc20 and permitEIP2612AndDepositErc20) don't validate the tokenAddress parameter for token compatibility before passing it to the IERC20Permit interface and directly use user-provided permit data without proper validation. The tokenChecks modifier is only applied in the depositErc20 function which is called afterward."",
      ""Impact"": ""Attackers could potentially bypass authorization checks and approve token transfers without the rightful owner's consent, potentially causing fund loss. It could also result in failed transactions or contract interactions with malicious tokens masquerading as ERC20Permit-compatible tokens."",
      ""Location"": ""permitAndDepositErc20 and permitEIP2612AndDepositErc20 functions""
    },
    {
      ""Issue"": ""Incorrect fee calculation"",
      ""Severity"": ""High"",
      ""Description"": ""In getAmountToTransfer function, the incentivePool calculation appears to have a mathematical error. The division by BASE_DIVISOR is applied to the entire sum rather than to each multiplicand, potentially resulting in incorrect incentive pool calculations."",
      ""Impact"": ""This could lead to incorrect fee distributions, either overpaying or underpaying the incentive pool, affecting the economic model of the protocol."",
      ""Location"": ""getAmountToTransfer function, specifically in the incentivePool calculation""
    },
    {
      ""Issue"": ""Unchecked input validation for tokenGasPrice"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the sendFundsToUser function, the tokenGasPrice parameter is used directly in calculations without any validation. An executor could potentially provide an extremely high gas price to claim an excessive amount of fees."",
      ""Impact"": ""Malicious executors could drain funds from the contract under the guise of gas fees or drain funds from users' transactions by manipulating the gas fee calculation to their advantage."",
      ""Location"": ""sendFundsToUser function, getAmountToTransfer function""
    },
    {
      ""Issue"": ""Precision loss and potential overflow in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions involve complex calculations with division operations that can result in precision loss or potential overflow, especially when handling small amounts or large values. This includes getRewardAmount, getTransferFee, and getAmountToTransfer functions. Division before multiplication in some calculations further exacerbates precision loss issues. The BASE_DIVISOR is very large (10000000000) which could amplify rounding errors."",
      ""Impact"": ""Could lead to incorrect fee calculations, unfair rewards distribution, unexpected economic behavior, or transaction failures due to overflow exceptions. Users might receive slightly less than expected due to rounding issues."",
      ""Location"": ""getRewardAmount, getTransferFee, and getAmountToTransfer functions""
    },
    {
      ""Issue"": ""Missing token decimals handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't account for tokens with different decimal places when calculating fees and rewards, treating all ERC20 tokens uniformly despite potential differences in their implementations."",
      ""Impact"": ""Could lead to inconsistent behavior across different tokens, especially when calculating fees and rewards for tokens with non-standard decimals."",
      ""Location"": ""Throughout the contract, particularly in getTransferFee and getRewardAmount""
    },
    {
      ""Issue"": ""No slippage protection in deposit functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The deposit functions (depositErc20 and depositNative) don't have slippage protection mechanisms. Users have no way to specify a minimum amount of tokens they expect to receive after fees are deducted."",
      ""Impact"": ""In volatile market conditions, users might receive significantly fewer tokens than expected without having the option to cancel the transaction."",
      ""Location"": ""depositErc20 and depositNative functions""
    },
    {
      ""Issue"": ""Potential denial of service in token transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The sendFundsToUser function processes external calls to transfer tokens but doesn't limit the gas consumption for the transfer. If the receiving contract has a malicious fallback function, it could consume all gas and prevent the transaction from completing. Additionally, the function doesn't handle the possibility of permanently failing transfers (e.g., for tokens with blocklists)."",
      ""Impact"": ""Could lead to failed transfers and locked tokens, especially when dealing with smart contract receivers. Funds could become permanently locked if transfers consistently fail for specific accounts or tokens."",
      ""Location"": ""sendFundsToUser function""
    },
    {
      ""Issue"": ""Front-running vulnerability in deposit functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The depositErc20 function could be subject to front-running attacks where attackers observe pending transactions and insert their own transactions with higher gas fees to manipulate the incentive pool or liquidity conditions."",
      ""Impact"": ""Users might receive different reward amounts than expected, as the liquidity conditions could change between the time they submit their transaction and when it's executed."",
      ""Location"": ""depositErc20 function and getRewardAmount function interaction""
    },
    {
      ""Issue"": ""Centralization risks with owner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant control to the owner, who can change critical parameters like the trusted forwarder, liquidity providers, and executor manager addresses without timelock or governance mechanisms. A compromised owner could manipulate these parameters."",
      ""Impact"": ""A compromised owner account could potentially harm the protocol by pointing to malicious contract implementations, redirecting funds, changing rules, or manipulating the contract's behavior in ways that harm users."",
      ""Location"": ""setTrustedForwarder, setLiquidityProviders, setBaseGas, and setExecutorManager functions""
    },
    {
      ""Issue"": ""Inconsistent ETH handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses NATIVE (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) to represent ETH, but implements receive() function that can accept ETH without updating relevant accounting state. This creates inconsistency in ETH accounting."",
      ""Impact"": ""ETH received through the receive() function doesn't update liquidity tracking, potentially causing accounting errors and locked funds."",
      ""Location"": ""receive() function and throughout contract where NATIVE is used""
    },
    {
      ""Issue"": ""Unchecked return values in external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""In functions like depositErc20 and the permit functions, there are external calls to token contracts without proper checking of return values or handling of potential failures. While SafeERC20 handles some cases, additional validation would be beneficial."",
      ""Impact"": ""Some non-compliant ERC20 tokens might fail silently, leading to a situation where tokens are not actually transferred but the function completes successfully. If a permit operation fails silently, the subsequent deposit might execute with unexpected permissions."",
      ""Location"": ""depositErc20 function, permitAndDepositErc20 and permitEIP2612AndDepositErc20 functions""
    },
    {
      ""Issue"": ""Missing validation for dependencies"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the initialize function and other dependency-setting functions, there's inconsistent validation of addresses. For example, the initialize function does not validate the tokenManager address, yet other dependencies like executorManager and trustedForwarder are validated."",
      ""Impact"": ""Could lead to contract initialization with invalid dependencies, causing failures in token validation, fee calculations, or other critical operations."",
      ""Location"": ""initialize function, setExecutorManager function""
    },
    {
      ""Issue"": ""Missing events for critical state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state-changing functions like setExecutorManager, setBaseGas, and initialize don't emit events, making it difficult to track these critical changes off-chain. Other functions updating state variables like incentivePool also lack event emissions."",
      ""Impact"": ""Reduced transparency and more difficult auditing of contract initialization parameters and administrative changes. Makes it harder for users and monitoring systems to track important contract state changes."",
      ""Location"": ""initialize function, setExecutorManager function, setBaseGas function, and functions modifying incentivePool""
    },
    {
      ""Issue"": ""No timelock for important parameter changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical parameters can be changed immediately by the owner without any delay or timelock mechanism, which could lead to unexpected behavior for users if changes are sudden."",
      ""Impact"": ""Users might be caught off-guard by sudden parameter changes, potentially leading to transaction failures or unexpected economic outcomes without giving users time to adapt."",
      ""Location"": ""setBaseGas, setTrustedForwarder, setLiquidityProviders, and setExecutorManager functions""
    },
    {
      ""Issue"": ""Inconsistent error handling"",
      ""Severity"": ""Low"",
      ""Description"": ""Different error messages and handling approaches are used across the contract for similar operations. For example, some functions use require(success, \""Native Transfer Failed\"") while others use require(success, \""ERR__NATIVE_TRANSFER_FAILED\"")."",
      ""Impact"": ""Inconsistent error messages can make debugging harder and create confusion for users and developers."",
      ""Location"": ""sendFundsToUser, transfer, and other functions with error handling""
    }
  ],
  ""IssueNumber"": 72,
  ""OutputList"": 17
}",456.8891019821167,83659.0,36.0,"### **Comparison and Evaluation**

---

#### **[H-01] Can deposit native token for free and steal funds**

**Report Description**:  
The `depositErc20` function allows setting `tokenAddress = NATIVE` without throwing an error. The `SafeERC20Upgradeable.safeTransferFrom` call does not revert when `tokenAddress = NATIVE` because it performs a low-level call to an EOA (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), which always succeeds. This allows an attacker to deposit infinite native tokens without paying anything, leading to fund theft.

**Match in Response List**:  
No direct match found. The closest related issue is **""Inconsistent ETH handling""**, which mentions the use of `NATIVE` but does not address the specific vulnerability of depositing native tokens for free.

**Validation**:  
**Incorrect**. The response does not address the core issue of allowing free deposits of native tokens. The ""Inconsistent ETH handling"" issue focuses on accounting inconsistencies but does not identify the exploitability of the `depositErc20` function.

---

#### **[H-03] Wrong formula when add fee in incentivePool can lead to loss of funds**

**Report Description**:  
The `getAmountToTransfer` function incorrectly updates `incentivePool[tokenAddress]` by dividing the entire sum by `BASE_DIVISOR` (10000000000) each time. This causes the `incentivePool` value to rapidly decrease to zero, locking funds in the contract.

**Match in Response List**:  
Matches with the issue titled **""Incorrect fee calculation""**.

**Validation**:  
**Correct**. The response accurately identifies the mathematical error in the `getAmountToTransfer` function and explains the impact of incorrect fee calculations, which aligns with the issue report.

---

#### **[M-08] Incentive Pool can be drained without rebalancing the pool**

**Report Description**:  
The `depositErc20` function allows an attacker to specify the destination chain as the same as the source chain and the receiver account as the caller account. This enables draining the incentive pool without rebalancing the pool to its equilibrium state.

**Match in Response List**:  
No direct match found. The closest related issue is **""Incentive pool depletion without balance checks""**, which discusses underflow risks but does not address the specific exploit of draining the pool without rebalancing.

**Validation**:  
**Incorrect**. The response does not address the core issue of draining the incentive pool without rebalancing. The ""Incentive pool depletion without balance checks"" issue focuses on underflow risks but misses the specific exploit described in the issue report.

---

#### **[M-18] Possible frontrun on deposits on LiquidityPool**

**Report Description**:  
Rewards for depositing tokens into the LiquidityPool can be manipulated through front-running. A malicious user can observe pending transactions and attach a higher fee to their transaction to front-run the victim's deposit, gaining double rewards.

**Match in Response List**:  
Matches with the issue titled **""Front-running vulnerability in deposit functions""**.

**Validation**:  
**Correct**. The response accurately identifies the front-running vulnerability in the `depositErc20` function and explains the impact of manipulating rewards, which aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-03] Wrong formula when add fee in incentivePool can lead to loss of funds**
- **[M-18] Possible frontrun on deposits on LiquidityPool**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] Can deposit native token for free and steal funds**
- **[M-08] Incentive Pool can be drained without rebalancing the pool**

---

### **Conclusion**

The `response_list` covers some issues accurately, such as the incorrect fee calculation and front-running vulnerability. However, it misses critical vulnerabilities like the ability to deposit native tokens for free and drain the incentive pool without rebalancing. These gaps indicate a need for more comprehensive analysis and coverage of potential exploits in the `LiquidityPool` contract.","```
1. Incorrect fee calculation
2. Front-running vulnerability in deposit functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - ""Incorrect fee calculation"" appears at rank 4.
   - ""Front-running vulnerability in deposit functions"" appears at rank 10.

2. **Calculate the precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 10: \( P@10 = \frac{2}{10} = 0.2 \)

3. **Average the precision values**:
   - \( AP = \frac{0.25 + 0.2}{2} = 0.225 \)

**Average Precision (AP)**: 0.225"
LiquidityProviders.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555,475,"[H-02] LiquidityProviders.sol The share price of the LP can be manipulated and making future liquidityProviders unable to removeLiquidity()

Submitted by WatchPug
LiquidityProviders.sol#L345-L362
function removeLiquidity(uint256 _nftId, uint256 _amount)
    external
    nonReentrant
    onlyValidLpToken(_nftId, _msgSender())
    whenNotPaused
{
    (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
    require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

    require(_amount != 0, ""ERR__INVALID_AMOUNT"");
    require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
    whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
    // Claculate how much shares represent input amount
    uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

    // Calculate rewards accumulated
    uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
  [M-01] Unsupported tokens cannot be withdrawn

Submitted by cmichel, also found by kyliek, pedroais, and PPrieditis
LiquidityProviders.sol#L273
Supported tokens can be turned off again by calling TokenManager.removeSupportedToken. Users won't be able to withdraw their liquidity anymore because of this check in removeLiquidity.
  [M-11] LiquidityProviders: Setting new liquidity pool will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L171
Owners can change the liquidityPool variable any time with the setLiquidityPool function. If a liquidity pool was already set and users added liquidity with addTokenLiquidity, the tokens are directly transferred to the liquidity pool and not kept in the LiquidityProviders contract. Changing the liquidityPool to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity because the tokens are still in the old liquidityPool and cannot be retrieved.
  [M-12] LiquidityProviders: Setting new LP token will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L116
Owners can change the lpToken variable at any time with the setLpToken function. If an LP token was already set and users added liquidity with addTokenLiquidity and were minted a lpToken NFT, changing the lpToken to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity.
All users will lose their funds.

[M-17] wrong condition checking in price calculation

Submitted by CertoraInc
LiquidityProviders.sol#L180-L186
The getTokenPriceInLPShares function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return BASE_DIVISOR if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.
Proof of Concept
  [M-19] sharesToTokenAmount: Division by zero

Submitted by cmichel, also found by cccz and CertoraInc
LiquidityProviders.sol#L192
The public sharesToTokenAmount function does not check if the denominator totalSharesMinted[_tokenAddress] is zero. Neither do the callers of this function. The function will revert. Calling functions like getFeeAccumulatedOnNft and sharesToTokenAmount from another contract should never revert.
 [M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state

Submitted by kyliek
LiquidityProviders.sol#L388 LiquidityProviders.sol#L392
LP token holders can not redeem their tokens when the pool is in the deficit state, i.e. currentLiquidity << providedLiquidity. This is due to that LP shares are computed based on providedLiquidity and the actual available pool balance is based on currentLiquidity.
",7,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    
    mapping(address => uint256) public totalReserve; 
    mapping(address => uint256) public totalLiquidity; 
    mapping(address => uint256) public currentLiquidity; 
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3709,1,6,"Based on the comprehensive analysis of the LiquidityProviders contract, here's a detailed audit task list addressing key areas of concern:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct a thorough reentrancy analysis, especially in removeLiquidity() and claimFee() functions"",
        ""Verify integer overflow/underflow protection in share and liquidity calculations"",
        ""Check for potential unauthorized access through inherited contract methods"",
        ""Validate that all external calls are properly guarded and use safe transfer patterns"",
        ""Review the implementation of _burnSharesFromNft() for potential manipulation risks""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the scope and implementation of onlyOwner, onlyLiquidityPool, and onlyValidLpToken modifiers"",
        ""Ensure no critical functions can be called by unauthorized addresses"",
        ""Check the initialization process for potential privilege escalation vulnerabilities"",
        ""Review the _msgSender() and _msgData() overrides for meta-transaction security""
      ]
    },
    {
      ""Area"": ""Liquidity Management"",
      ""Tasks"": [
        ""Analyze the token price calculation in getTokenPriceInLPShares() for potential manipulation"",
        ""Verify the accuracy of liquidity tracking across totalReserve, totalLiquidity, and currentLiquidity"",
        ""Check the fee distribution mechanism for fairness and precision"",
        ""Evaluate the minimum liquidity requirements and dust attack prevention"",
        ""Review the handling of different token types (native vs ERC20)""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interactions with ILPToken, ILiquidityPool, ITokenManager, and IWhiteListPeriodManager interfaces"",
        ""Verify the security of token transfers using SafeERC20Upgradeable"",
        ""Check the robustness of token support validation in _isSupportedToken()"",
        ""Evaluate the whitelist period manager's impact on liquidity operations""
      ]
    },
    {
      ""Area"": ""Mathematical Precision"",
      ""Tasks"": [
        ""Perform detailed analysis of share calculation methods"",
        ""Check for potential precision loss in sharesToTokenAmount()"",
        ""Verify the BASE_DIVISOR usage in share and token amount conversions"",
        ""Analyze edge cases in liquidity addition and removal calculations""
      ]
    },
    {
      ""Area"": ""Upgradability and Initialization"",
      ""Tasks"": [
        ""Review the initialize() method for potential initialization vulnerabilities"",
        ""Check the implementation of setter methods for critical contract addresses"",
        ""Verify proper initialization of inherited upgradeable contracts"",
        ""Ensure no critical state can be modified post-initialization""
      ]
    },
    {
      ""Area"": ""Event and Logging"",
      ""Tasks"": [
        ""Verify all critical state changes are properly logged with events"",
        ""Check the comprehensiveness of event emissions in key functions"",
        ""Ensure events capture sufficient context for off-chain tracking""
      ]
    },
    {
      ""Area"": ""Emergency and Pause Mechanisms"",
      ""Tasks"": [
        ""Verify the implementation of the Pausable mechanism"",
        ""Check the scope of functions affected by pause"",
        ""Ensure critical functions can be paused in emergency scenarios"",
        ""Review the owner's ability to pause/unpause contract operations""
      ]
    },
    {
      ""Area"": ""Token Support and Compatibility"",
      ""Tasks"": [
        ""Analyze handling of non-standard ERC20 tokens (rebasing, fee-on-transfer)"",
        ""Verify support for different token decimal representations"",
        ""Check the robustness of token address validation"",
        ""Evaluate the flexibility of token support through TokenManager""
      ]
    },
    {
      ""Area"": ""Meta-Transaction Support"",
      ""Tasks"": [
        ""Verify the implementation of ERC2771 meta-transaction support"",
        ""Check for potential replay attack vulnerabilities"",
        ""Ensure proper forwarding of meta-transaction context"",
        ""Validate the security of trusted forwarder implementation""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the LiquidityProviders contract, covering critical areas of security, functionality, and potential vulnerabilities. Each area includes specific, actionable tasks that dive deep into the contract's implementation, addressing both technical and economic security considerations.

The tasks are designed to systematically examine the contract's design, focusing on preventing potential exploits, ensuring mathematical accuracy, and maintaining the integrity of liquidity management operations.

Would you like me to elaborate on any specific area or provide more detailed guidance on approaching these audit tasks?","After a thorough review of the provided smart contract code, I've prepared the following comprehensive audit analysis:

{
  ""ReviewingTheCode"": ""This contract implements a liquidity provider system for a DeFi protocol, managing liquidity deposits and withdrawals, fee distribution, and NFT representation of LP positions. It uses upgradeable patterns and incorporates security features like reentrancy guards and pausability."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityProviders"",
    ""Purpose"": ""Manages liquidity provision to a liquidity pool, tracks liquidity provider positions via NFTs, and distributes fees to LPs based on their share of the pool."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ReentrancyGuardUpgradeable"",
        ""ERC2771ContextUpgradeable"",
        ""OwnableUpgradeable"",
        ""Pausable""
      ],
      ""Imports"": [
        ""OpenZeppelin upgradeable contracts (Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, IERC20Upgradeable, SafeERC20Upgradeable)"",
        ""Custom ERC2771ContextUpgradeable (meta-transactions support)"",
        ""Pausable security contract"",
        ""ILPToken interface (NFT representation of LP positions)"",
        ""ITokenManager interface (supported tokens validation)"",
        ""IWhiteListPeriodManager interface (whitelist control)"",
        ""ILiquidityPool interface (actual liquidity pool operations)""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address constant"",
        ""Purpose"": ""Represents the native token (ETH) with a special address""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Precision divisor (10^18) for calculations""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface to the NFT token representing LP positions""
      },
      {
        ""Name"": ""liquidityPool"",
        ""Type"": ""ILiquidityPool"",
        ""Purpose"": ""Interface to the liquidity pool contract that holds tokens""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface to verify supported tokens""
      },
      {
        ""Name"": ""whiteListPeriodManager"",
        ""Type"": ""IWhiteListPeriodManager"",
        ""Purpose"": ""Interface to control whitelisted users during special periods""
      },
      {
        ""Name"": ""totalReserve"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks total reserve of each token (liquidity + accumulated fees)""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks total user-supplied liquidity per token (excluding fees)""
      },
      {
        ""Name"": ""currentLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks actual available liquidity (not locked/used in operations)""
      },
      {
        ""Name"": ""totalLPFees"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks accumulated fees per token""
      },
      {
        ""Name"": ""totalSharesMinted"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks total shares minted per token (LP shares)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyValidLpToken"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures operation is performed by the owner of a valid LP NFT token"",
        ""Parameters"": [""uint256 _tokenId"", ""address _transactor""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLiquidityPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the liquidity pool contract only"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates token address is non-zero and supported"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the upgradeable contract with required dependencies"",
        ""Parameters"": [""address _trustedForwarder"", ""address _lpToken"", ""address _tokenManager"", ""address _pauser""],
        ""Returns"": []
      },
      {
        ""Name"": ""addTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to add ERC20 token liquidity to the pool"",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addNativeLiquidity"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to add native token (ETH) liquidity to the pool"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases ERC20 token liquidity for an existing NFT position"",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseNativeLiquidity"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Increases native token liquidity for an existing NFT position"",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes liquidity (including accumulated fees) from an NFT position"",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims accumulated fees for an NFT position without removing base liquidity"",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLPFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the liquidity pool to add fees for distribution to LPs"",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokenPriceInLPShares"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the LP share price for a given token"",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""uint256 price""]
      },
      {
        ""Name"": ""sharesToTokenAmount"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Converts LP shares to the corresponding token amount"",
        ""Parameters"": [""uint256 _shares"", ""address _tokenAddress""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""getFeeAccumulatedOnNft"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates accumulated fees for a specific NFT position"",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": [""uint256 feeAmount""]
      },
      {
        ""Name"": ""increaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increases the current available liquidity for a token (called by liquidity pool)"",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Decreases the current available liquidity for a token (called by liquidity pool)"",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""ILPToken - NFT token representing LP positions with metadata"",
    ""ILiquidityPool - Contract that holds user funds and executes actual transfers"",
    ""ITokenManager - Validates supported tokens"",
    ""IWhiteListPeriodManager - Controls whitelisting during specific periods"",
    ""ERC20 token transfers using SafeERC20"",
    ""Meta-transaction support through ERC2771Context""
  ],
  
  ""SpecialMechanisms"": [
    ""Upgradeable proxy pattern implementation"",
    ""NFT representation of LP positions (tokenized liquidity)"",
    ""LP share calculation system to track proportional ownership"",
    ""Fee distribution mechanism based on LP ownership shares"",
    ""Native token (ETH) support alongside ERC20 tokens"",
    ""Meta-transaction support for gasless transactions"",
    ""Current liquidity tracking for potential external use"",
    ""Two-step liquidity removal process (can claim fees separately)""
  ],
  
  ""Questions"": [
    ""How is the share price calculation handled during high volatility periods?"",
    ""What safeguards exist for extreme scenarios like total liquidity withdrawal?"",
    ""How are precision losses handled in the share calculations?"",
    ""Is there a minimum liquidity requirement to prevent dust attacks?"",
    ""How does the whiteListPeriodManager influence the protocol behavior?"",
    ""What happens if a token becomes unsupported after liquidity is added?"",
    ""Are there any potential reentrancy risks in the removeLiquidity function?"",
    ""How does the contract handle rebasing or fee-on-transfer tokens?"",
    ""Is there a maximum cap on the totalSharesMinted to prevent overflow?""
  ]
}

Based on my audit, this is a relatively complex liquidity management contract that implements a tokenized LP position system using NFTs. The contract handles both native ETH and ERC20 tokens, distributes fees to LPs proportionally, and incorporates various security features.

The most notable aspect is how it tracks liquidity positions using NFTs with metadata instead of traditional fungible LP tokens. This allows for more granular control of individual LP positions.

Several security considerations should be carefully evaluated, particularly around the share price calculations, handling of fee distributions, and the interaction between totalReserve, totalLiquidity, and currentLiquidity tracking mechanisms.","I've analyzed all the input data containing security issues from the LiquidityProviders contract. I've consolidated similar issues, organized them by severity, and removed redundancy while preserving the core information.

{
  ""Findings"": [
    {
      ""Issue"": ""Fee Calculation Vulnerability"",
      ""Severity"": ""Critical"",
      ""Description"": ""In the removeLiquidity function, lpFeeAccumulated is calculated as 'eligibleLiquidity - nftSuppliedLiquidity' within an unchecked block, assuming no underflow will occur. While there's a conditional check, this implementation is flawed and doesn't properly account for cases where nftSuppliedLiquidity might exceed eligibleLiquidity."",
      ""Impact"": ""In certain market conditions or after system state changes, this could potentially lead to incorrect fee calculations, allowing users to claim more fees than they should or causing underflows that lead to massive incorrect withdrawals."",
      ""Location"": ""removeLiquidity function and getFeeAccumulatedOnNft function""
    },
    {
      ""Issue"": ""Vulnerability to Price Manipulation"",
      ""Severity"": ""High"",
      ""Description"": ""The liquidity addition mechanism uses the current ratio of totalSharesMinted to totalReserve to determine new share issuance. A malicious actor could manipulate this ratio by donating small amounts of tokens directly to the contract, thereby diluting the value of LP shares."",
      ""Impact"": ""Users could receive fewer LP shares than they should when adding liquidity, effectively having their value stolen by the manipulator."",
      ""Location"": ""_increaseLiquidity function's share calculation logic""
    },
    {
      ""Issue"": ""Potential Reentrancy in Liquidity Operations"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract uses ReentrancyGuardUpgradeable and nonReentrant modifier, the logic in removeLiquidity, addNativeLiquidity, and claimFee may update state after external calls, potentially allowing reentrancy attacks. The order of operations could be exploited if the liquidityPool contract has vulnerabilities."",
      ""Impact"": ""If the liquidity pool contract is compromised or malicious, it might be able to reenter and manipulate state in unexpected ways, potentially draining funds through multiple calls before state updates are finalized."",
      ""Location"": ""removeLiquidity, addNativeLiquidity, increaseNativeLiquidity, and claimFee functions""
    },
    {
      ""Issue"": ""Arithmetic Issues in Fee Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""The calculation of accumulated LP fees in getFeeAccumulatedOnNft, claimFee, and removeLiquidity functions has potential arithmetic issues. There's an unchecked subtraction (eligibleLiquidity - nftSuppliedLiquidity) that assumes eligibleLiquidity is always greater than nftSuppliedLiquidity, which could lead to underflow in some situations."",
      ""Impact"": ""This could prevent legitimate fee claims from being processed, leading to locked funds that users cannot access, or could allow claiming more fees than entitled."",
      ""Location"": ""claimFee, getFeeAccumulatedOnNft, and removeLiquidity functions""
    },
    {
      ""Issue"": ""Improper Liquidity Accounting"",
      ""Severity"": ""High"",
      ""Description"": ""The contract maintains several liquidity-tracking state variables (totalReserve, totalLiquidity, currentLiquidity) but their relationships and updates are not always consistent. For example, in removeLiquidity, totalReserve is decreased by (amount + lpFeeAccumulated) but currentLiquidity is only decreased by amount."",
      ""Impact"": ""This can lead to accounting inconsistencies where the sum of all liquidity values doesn't accurately represent the actual state of the contract, potentially leading to users being able to withdraw more funds than they should."",
      ""Location"": ""removeLiquidity function and other functions modifying liquidity state variables""
    },
    {
      ""Issue"": ""Unchecked External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""When transferring native tokens to the liquidity pool in addNativeLiquidity and increaseNativeLiquidity, the contract uses low-level .call{value: amount}(\""\"") without properly handling all potential failure scenarios. This pattern appears in multiple places with insufficient validation of external call outcomes."",
      ""Impact"": ""If the liquidity pool contract has issues accepting funds or if transactions fail due to gas issues, users might lose their ETH without a clear understanding of why the transaction failed."",
      ""Location"": ""addNativeLiquidity, increaseNativeLiquidity functions, and other functions making external calls""
    },
    {
      ""Issue"": ""Missing Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""When users add or remove liquidity, there's no slippage protection mechanism. The amount of shares minted or burned is calculated at execution time without allowing users to specify minimum acceptable amounts, leaving them vulnerable to front-running and MEV attacks."",
      ""Impact"": ""Users might receive less value than anticipated when removing liquidity, especially in volatile market conditions. Front-running attacks are possible where an attacker can manipulate the price just before a user's transaction."",
      ""Location"": ""_increaseLiquidity, removeLiquidity, and other liquidity-related functions""
    },
    {
      ""Issue"": ""Centralization Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract gives significant control to the owner, who can change critical components like tokenManager, lpToken, liquidityPool, and whiteListPeriodManager. These setter functions have no timelock or governance control, creating centralization risks if the owner account is compromised."",
      ""Impact"": ""A malicious or compromised owner could replace legitimate contract addresses with malicious ones, potentially draining all user funds or manipulating the system."",
      ""Location"": ""setLpToken, setTokenManager, setWhiteListPeriodManager, setLiquidityPool functions""
    },
    {
      ""Issue"": ""Precision Loss in Share Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Integer division is performed in functions like getTokenPriceInLPShares and sharesToTokenAmount without accounting for precision loss. This can lead to significant rounding errors, especially with small values or values that don't divide evenly."",
      ""Impact"": ""Incorrect pricing of LP shares can lead to unfair distribution of tokens, allowing users to gain more tokens than they should or receive fewer tokens than expected when removing liquidity."",
      ""Location"": ""getTokenPriceInLPShares, sharesToTokenAmount functions""
    },
    {
      ""Issue"": ""Division by Zero Risk"",
      ""Severity"": ""Medium"",
      ""Description"": ""In sharesToTokenAmount function and getTokenPriceInLPShares, there's no check if totalSharesMinted[_tokenAddress] or totalReserve is zero before dividing by it. This could lead to a division by zero error."",
      ""Impact"": ""Function calls would revert if totalSharesMinted for a token is zero or if other divisors are zero, potentially blocking certain operations."",
      ""Location"": ""sharesToTokenAmount, getTokenPriceInLPShares functions""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setter functions (_setLPToken, _setTokenManager, setWhiteListPeriodManager, setLiquidityPool) don't validate if the provided addresses are valid contract addresses or check for zero addresses. Similarly, amount validation is missing in some functions."",
      ""Impact"": ""Setting incorrect addresses could break core functionality of the contract, potentially leading to locked funds or unusable features. Invalid input in other functions could cause unnecessary gas consumption or misleading events."",
      ""Location"": ""setLpToken, setTokenManager, setWhiteListPeriodManager, setLiquidityPool, and other input-processing functions""
    },
    {
      ""Issue"": ""Improper Fee Distribution Model"",
      ""Severity"": ""Medium"",
      ""Description"": ""The fee distribution logic in removeLiquidity and claimFee functions uses complex share calculations that may not accurately represent user entitlements. The formula assumes a specific growth model that might not scale fairly across different liquidity providers."",
      ""Impact"": ""LPs might not receive fair compensation proportional to their provided liquidity and duration, potentially discouraging long-term liquidity provision."",
      ""Location"": ""removeLiquidity and claimFee functions""
    },
    {
      ""Issue"": ""Risk of Dust Shares in LP Tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""When burning shares from an NFT or removing liquidity, there's insufficient validation to ensure that the remaining shares meet minimum requirements or to handle dust amounts properly. When removing liquidity, if the shares to burn calculation leaves the NFT with less than BASE_DIVISOR shares, all shares are burned regardless of the user's intention."",
      ""Impact"": ""Users attempting to withdraw partial liquidity might unexpectedly withdraw all of it. Could lead to dust amounts of shares that are not economically viable to claim or manage, effectively creating locked or unusable small amounts of liquidity."",
      ""Location"": ""_burnSharesFromNft function and removeLiquidity function's share burning logic""
    },
    {
      ""Issue"": ""Floating Pragma"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a floating pragma (0.8.0) which means it can be compiled with any 0.8.x version. This could lead to inconsistent behavior as different compiler versions may have different bug fixes or optimizations."",
      ""Impact"": ""Potential for unexpected behavior or vulnerabilities if compiled with a different compiler version than intended."",
      ""Location"": ""Line 1: pragma solidity 0.8.0;""
    },
    {
      ""Issue"": ""Inconsistent Error Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a mix of require statements with different error messages and formatting conventions (e.g., 'ERR__SOMETHING_FAILED' vs 'Something cannot be something'). This inconsistency makes error handling and debugging more difficult."",
      ""Impact"": ""Makes contract maintenance and error diagnosis more challenging, potentially leading to slower response times for fixing issues."",
      ""Location"": ""Throughout the contract""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes, like setting the liquidity pool, token manager, or whiteListPeriodManager, do not emit events. This makes it harder to track critical administrative actions off-chain."",
      ""Impact"": ""Reduced transparency and auditability of contract administration, making it harder for users to monitor important contract configuration changes."",
      ""Location"": ""setLiquidityPool, setTokenManager, setWhiteListPeriodManager functions""
    },
    {
      ""Issue"": ""Inconsistent Pausing Implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a whenNotPaused modifier for most external functions, but it's not applied consistently. For example, view functions and some administrative functions don't have this protection. There's also no mechanism to pause operations for specific tokens that might be experiencing issues without pausing the entire contract."",
      ""Impact"": ""In an emergency situation requiring pausing, some contract functionality might still be accessible. If one token has an issue, the entire contract must be paused to address it, impacting all users."",
      ""Location"": ""Various functions missing the whenNotPaused modifier""
    }
  ],
  ""IssueNumber"": 67,
  ""OutputList"": 17
}",414.79800510406494,86297.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**

**Report Description**:  
The share price of the LP tokens in `LiquidityProviders.sol` can be manipulated, potentially preventing future liquidity providers from removing their liquidity. This issue arises due to the calculation of LP shares and the lack of safeguards against manipulation, which could lead to unfair pricing and locked funds.

**Match in Response List**:  
Matches with the issue titled **""Vulnerability to Price Manipulation""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of price manipulation in the liquidity addition mechanism. It explains how a malicious actor could manipulate the ratio of `totalSharesMinted` to `totalReserve`, leading to unfair share issuance. This aligns with the reported issue of share price manipulation and its potential impact on liquidity providers.

---

#### **[M-01] Unsupported tokens cannot be withdrawn**

**Report Description**:  
When supported tokens are turned off using `TokenManager.removeSupportedToken`, users cannot withdraw their liquidity due to a check in the `removeLiquidity` function. This creates a situation where users' funds are locked in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of unsupported tokens being locked in the contract. This is a critical oversight, as it directly impacts users' ability to withdraw their funds.

---

#### **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**

**Report Description**:  
The `setLiquidityPool` function allows the owner to change the liquidity pool address. If users have already added liquidity to the old pool, changing the pool address will make it impossible for them to withdraw their liquidity, as the tokens remain in the old pool.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risks""**.

**Validation**:  
**Partially Correct**. The response identifies the centralization risk of the owner being able to change critical components like the liquidity pool. However, it does not explicitly mention the specific impact of changing the liquidity pool address on users' ability to withdraw their funds. This critical detail is missing from the response.

---

#### **[M-12] LiquidityProviders: Setting new LP token will break contract**

**Report Description**:  
The `setLpToken` function allows the owner to change the LP token address. If users have already added liquidity and received LP tokens, changing the LP token address will make it impossible for them to withdraw their liquidity, resulting in a loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risks""**.

**Validation**:  
**Partially Correct**. Similar to [M-11], the response identifies the centralization risk of the owner changing critical components but does not explicitly mention the specific impact of changing the LP token address on users' ability to withdraw their funds. This critical detail is missing from the response.

---

#### **[M-17] Wrong condition checking in price calculation**

**Report Description**:  
The `getTokenPriceInLPShares` function checks the wrong condition—it returns `BASE_DIVISOR` if `totalSharesMinted` is zero instead of checking if `totalReserve` is zero. This could lead to incorrect price calculations or division by zero errors.

**Match in Response List**:  
Matches with the issue titled **""Division by Zero Risk""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of division by zero in the `sharesToTokenAmount` and `getTokenPriceInLPShares` functions. However, it does not explicitly mention the incorrect condition check in `getTokenPriceInLPShares`, which is a critical part of the reported issue.

---

#### **[M-19] sharesToTokenAmount: Division by zero**

**Report Description**:  
The `sharesToTokenAmount` function does not check if `totalSharesMinted[_tokenAddress]` is zero before dividing by it. This could lead to division by zero errors, causing the function to revert.

**Match in Response List**:  
Matches with the issue titled **""Division by Zero Risk""**.

**Validation**:  
**Correct**. The response accurately identifies the division by zero risk in the `sharesToTokenAmount` function. It correctly explains the potential impact of this issue, which aligns with the reported vulnerability.

---

#### **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

**Report Description**:  
LP token holders cannot redeem their tokens when the pool is in a deficit state (i.e., `currentLiquidity << providedLiquidity`). This is because LP shares are computed based on `providedLiquidity`, while the actual available pool balance is based on `currentLiquidity`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of liquidity providers being unable to remove liquidity when the pool is in a deficit state. This is a significant oversight, as it directly impacts users' ability to withdraw their funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**
- **[M-19] sharesToTokenAmount: Division by zero**

**Partially Correct Matches**:
- **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**
- **[M-12] LiquidityProviders: Setting new LP token will break contract**
- **[M-17] Wrong condition checking in price calculation**

**Missed Issues from Issue Report**:
- **[M-01] Unsupported tokens cannot be withdrawn**
- **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

---

### **Conclusion**
The response list covers some of the reported issues but misses critical vulnerabilities such as unsupported tokens being locked and liquidity providers being unable to withdraw funds in a deficit state. Additionally, some responses are partially correct, as they identify the general issue but miss specific details or impacts. To improve, the response list should address these gaps and provide more detailed explanations of the vulnerabilities and their impacts.","```
1. Vulnerability to Price Manipulation
2. Division by Zero Risk
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Vulnerability to Price Manipulation"" appears at rank 2.
   - ""Division by Zero Risk"" appears at rank 10.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 10: \( P@10 = \frac{2}{10} = 0.2 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.2}{2} = 0.35 \)

**Average Precision (AP)**: 0.35"
LiquidityFarming.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691,373,"[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased
 In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.
However, at L244, the whole nftInfo is being deleted, so that nft.unpaidRewards will also get erased.
There is no way for the user to get back this unpaidRewards anymore
  [H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss

Submitted by WatchPug, also found by hyh
LiquidityFarming.sol#L265-L291
function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) 
  [M-04] Owners have absolute control over protocol

Submitted by throttle, also found by cccz, cmichel, danb, defsec, hickuphh3, IllIllI, pedroais, and Ruhum
LiquidityFarming.sol#L174-L192
Owners have full control over the protocol.

[M-06] DoS by gas limit

Submitted by danb, also found by benk10 and pedroais
LiquidityFarming.sol#L220 LiquidityFarming.sol#L233
In `deposit` function it is possible to push to nftIdsStaked of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.
 [M-10] Call to non-existing contracts returns success

Submitted by CertoraInc, also found by kenta and wuwe1
LiquidityFarming.sol#L140 LiquidityFarming.sol#L145 LiquidityFarming.sol#L187
Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed).
This makes a user be able to send his funds to non-existing addresses.
 [M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases

Submitted by WatchPug
In the current implementation of withdraw(), it calls _sendRewardsForNft() at L243 which calls updatePool() at L129 which calls getUpdatedAccTokenPerShare() at L319.
getUpdatedAccTokenPerShare() will loop over rewardRateLog to calculate an up to date value of accTokenPerShare.
LiquidityFarming.sol#L270-L285
",6,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    
    mapping(address => PoolInfo) public poolInfo;

    
    mapping(uint256 => NFTInfo) public nftInfo;

    
    

    
    mapping(address => address) public rewardTokens;

    
    mapping(address => uint256[]) public nftIdsStaked;

    
    mapping(address => uint256) public totalSharesStaked;

    
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    
    
    
    
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    
    
    
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    
    
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    
    
    
    
    
    
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    
    
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    
    
    
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    
    
    
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    
    
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        
        
        
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    
    
    
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    
    
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    
    
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3032,2,4,"Based on the detailed analysis of the HyphenLiquidityFarming contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the _sendRewardsForNft function for potential reentrancy risks"",
        ""Verify all external calls are protected with nonReentrant modifier"",
        ""Check for potential integer overflow/underflow in reward calculations (despite Solidity 0.8.0 protections)"",
        ""Validate input validation and sanitization in critical functions like deposit, withdraw, and extractRewards"",
        ""Review native token transfer mechanisms for potential send/transfer vulnerabilities""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the scope and implementation of onlyOwner modifier in critical functions"",
        ""Audit the initialize function for potential initialization vulnerabilities"",
        ""Check for potential privilege escalation risks in owner-only functions"",
        ""Validate the meta-transaction (_msgSender) implementation for potential spoofing""
      ]
    },
    {
      ""Area"": ""Reward Mechanism"",
      ""Tasks"": [
        ""Deeply analyze the getUpdatedAccTokenPerShare function for precision and accuracy"",
        ""Verify the correctness of reward distribution calculations"",
        ""Check for potential economic attacks in reward rate changes"",
        ""Validate the handling of edge cases in reward calculations (zero shares, minimal rewards)"",
        ""Review the historical reward rate logging mechanism for potential manipulation""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit interactions with ILPToken and ILiquidityProviders interfaces"",
        ""Verify safe handling of different ERC20 token implementations"",
        ""Check compatibility with non-standard ERC20 tokens"",
        ""Validate external contract call security and error handling""
      ]
    },
    {
      ""Area"": ""NFT Staking Mechanism"",
      ""Tasks"": [
        ""Review the NFT staking and unstaking process for potential vulnerabilities"",
        ""Validate the correctness of NFT ID tracking and management"",
        ""Check for potential issues with staking multiple NFTs"",
        ""Verify the integrity of NFT ownership and transfer checks""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze gas consumption in critical functions"",
        ""Review loop structures for potential gas-related vulnerabilities"",
        ""Check for unnecessary storage reads and writes"",
        ""Validate the efficiency of reward calculation mechanisms""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency Mechanisms"",
      ""Tasks"": [
        ""Verify the implementation of pause/unpause functionality"",
        ""Check the scope and impact of pausable functions"",
        ""Validate emergency withdrawal or token reclaim mechanisms"",
        ""Review the reclaimTokens function for potential misuse""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify ERC721Receiver implementation"",
        ""Check compliance with ERC2771 meta-transaction standard"",
        ""Validate upgradeable contract pattern implementation"",
        ""Review event emission for completeness and accuracy""
      ]
    },
    {
      ""Area"": ""Economic Attack Vectors"",
      ""Tasks"": [
        ""Analyze potential flash loan or economic manipulation risks"",
        ""Check for potential ways to game the reward distribution"",
        ""Verify protection against reward rate manipulation"",
        ""Review the impact of sudden reward rate changes""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the HyphenLiquidityFarming contract, covering multiple critical aspects of smart contract security and functionality. Each area is broken down into specific, actionable tasks that target potential vulnerabilities and ensure the contract's robustness.

The tasks are designed to:
1. Identify potential security risks
2. Verify the correctness of complex mechanisms
3. Ensure proper access control
4. Check for economic attack vectors
5. Validate external interactions
6. Assess gas efficiency
7. Ensure compliance with standards

An auditor would systematically work through these tasks, documenting findings, potential vulnerabilities, and recommended mitigations.","I've reviewed the provided smart contract code, and here is my detailed analysis:

{
  ""ReviewingTheCode"": ""This is a staking/farming contract called HyphenLiquidityFarming that allows users to stake NFTs (liquidity provider tokens) and earn rewards over time. The contract supports multiple reward pools for different base tokens, with rewards distributed proportionally to staked amounts."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""HyphenLiquidityFarming"",
    ""Purpose"": ""An upgradeable contract that provides a staking mechanism for NFT tokens (LP tokens) with time-based rewards in various tokens. Users can deposit NFTs, withdraw them, and claim accumulated rewards."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC2771ContextUpgradeable"",
        ""OwnableUpgradeable"",
        ""Pausable"",
        ""ReentrancyGuardUpgradeable"",
        ""IERC721ReceiverUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/ILPToken.sol"",
        ""./interfaces/ILiquidityProviders.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface to interact with the LP Token contract which is an NFT (ERC721)""
      },
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to interact with the LiquidityProviders contract""
      },
      {
        ""Name"": ""poolInfo"",
        ""Type"": ""mapping(address => PoolInfo)"",
        ""Purpose"": ""Stores reward pool information by base token address""
      },
      {
        ""Name"": ""nftInfo"",
        ""Type"": ""mapping(uint256 => NFTInfo)"",
        ""Purpose"": ""Maps NFT ID to staking information""
      },
      {
        ""Name"": ""rewardTokens"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps base token address to reward token address""
      },
      {
        ""Name"": ""nftIdsStaked"",
        ""Type"": ""mapping(address => uint256[])"",
        ""Purpose"": ""Tracks which NFT IDs are staked by each address""
      },
      {
        ""Name"": ""totalSharesStaked"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Total amount of shares staked per base token""
      },
      {
        ""Name"": ""rewardRateLog"",
        ""Type"": ""mapping(address => RewardsPerSecondEntry[])"",
        ""Purpose"": ""Historical log of reward rates per base token""
      },
      {
        ""Name"": ""ACC_TOKEN_PRECISION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Precision multiplier for reward calculations (1e12)""
      },
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address constant"",
        ""Purpose"": ""Identifier for native token (ETH) with value 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with dependencies (used instead of constructor for upgradeable contracts)"",
        ""Parameters"": [""_trustedForwarder"", ""_pauser"", ""_liquidityProviders"", ""_lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""initalizeRewardPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes a reward pool for a specific base token with a reward token and rate"",
        ""Parameters"": [""_baseToken"", ""_rewardToken"", ""_rewardPerSecond""],
        ""Returns"": []
      },
      {
        ""Name"": ""_sendErc20AndGetSentAmount"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function to transfer ERC20 tokens and verify the amount actually sent"",
        ""Parameters"": [""_token"", ""_amount"", ""_to""],
        ""Returns"": [""uint256 (amount sent)""]
      },
      {
        ""Name"": ""_sendRewardsForNft"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and sends accumulated rewards for a specific NFT"",
        ""Parameters"": [""_nftId"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRewardPerSecond"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward rate for a specific base token"",
        ""Parameters"": [""_baseToken"", ""_rewardPerSecond""],
        ""Returns"": []
      },
      {
        ""Name"": ""reclaimTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to recover tokens sent to the contract"",
        ""Parameters"": [""_token"", ""_amount"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Stakes an NFT token to earn rewards"",
        ""Parameters"": [""_nftId"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws a staked NFT and claims rewards"",
        ""Parameters"": [""_nftId"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""extractRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims rewards for a staked NFT without withdrawing it"",
        ""Parameters"": [""_nftId"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""getUpdatedAccTokenPerShare"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the updated accumulated tokens per share for a base token"",
        ""Parameters"": [""_baseToken""],
        ""Returns"": [""uint256 (updated accumulator)""]
      },
      {
        ""Name"": ""pendingToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the pending reward tokens for a specific NFT"",
        ""Parameters"": [""_nftId""],
        ""Returns"": [""uint256 (pending rewards)""]
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward pool state for a base token"",
        ""Parameters"": [""_baseToken""],
        ""Returns"": [""PoolInfo memory pool""]
      },
      {
        ""Name"": ""getNftIdsStaked"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the NFT IDs staked by a user"",
        ""Parameters"": [""_user""],
        ""Returns"": [""uint256[] memory nftIds""]
      },
      {
        ""Name"": ""getRewardRatePerSecond"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the current reward rate for a base token"",
        ""Parameters"": [""_baseToken""],
        ""Returns"": [""uint256 (reward rate)""]
      },
      {
        ""Name"": ""onERC721Received"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows contract to receive ERC721 tokens"",
        ""Parameters"": [""operator"", ""from"", ""tokenId"", ""data""],
        ""Returns"": [""bytes4 (interface selector)""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overridden to support meta-transactions"",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overridden to support meta-transactions"",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows contract to receive native tokens (ETH)"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""max"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Utility function to get the maximum of two numbers"",
        ""Parameters"": [""_a"", ""_b""],
        ""Returns"": [""uint256 (maximum value)""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ILPToken - The contract interacts with the LP token contract which is likely an ERC721 token"",
    ""ILiquidityProviders - Used to get the BASE_DIVISOR value"",
    ""IERC20Upgradeable - Used to interact with ERC20 tokens for rewards"",
    ""Native ETH transfers through call{value: amount}()"",
    ""Meta-transactions through ERC2771ContextUpgradeable for gasless transactions""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Pattern: Uses OpenZeppelin's upgradeable contracts pattern with initializer instead of constructor"",
    ""Meta-transactions: Implements ERC-2771 for gasless transactions"",
    ""Time-Based Reward Distribution: Uses a sophisticated reward calculation based on time and stake amount"",
    ""NFT Staking: Implements a mechanism for staking ERC721 tokens"",
    ""Historical Reward Rates: Maintains a log of historical reward rates with timestamps to calculate accurate rewards"",
    ""Native and ERC20 rewards: Supports both native blockchain currency (ETH) and ERC20 tokens as rewards""
  ],
  ""Questions"": [
    ""Are there any bounds checks on the reward rates to prevent potential economic issues?"",
    ""How does the contract handle rounding errors in reward calculations?"",
    ""Is there any mechanism to handle a situation where an NFT's metadata changes after it's staked?"",
    ""What happens if the reward token contract has transfer fees or non-standard behavior?"",
    ""Is there a way to migrate staked positions if the contract needs to be upgraded?"",
    ""How does the contract handle potential DoS attacks if there are many historical reward rate entries?""
  ]
}","I've analyzed all the security findings for the HyphenLiquidityFarming contract, consolidated similar issues, and sorted them by severity. Here's the processed output:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in External Calls"",
      ""Severity"": ""Critical"",
      ""Description"": ""Despite using ReentrancyGuard, the _sendRewardsForNft function makes external calls to transfer ETH before updating state variables (like nft.unpaidRewards and nft.rewardDebt). While the nonReentrant modifier protects parent functions, reentrancy within this internal function remains possible. When sending native tokens via low-level call to user-controlled addresses, malicious contracts could potentially exploit this to drain funds."",
      ""Impact"": ""An attacker could potentially exploit this to drain funds from the contract by re-entering and claiming rewards multiple times through a malicious fallback function."",
      ""Location"": ""_sendRewardsForNft function, particularly the ETH transfer section""
    },
    {
      ""Issue"": ""Reward Calculation Vulnerability - Division by Zero"",
      ""Severity"": ""High"",
      ""Description"": ""The getUpdatedAccTokenPerShare function fails to properly check if totalSharesStaked[_baseToken] is zero before dividing by it. This could lead to a division by zero error, causing the function to revert unexpectedly."",
      ""Impact"": ""This vulnerability could cause the updatePool function to revert, effectively blocking reward distributions and causing core functionality like deposit, withdraw, and extractRewards to fail."",
      ""Location"": ""getUpdatedAccTokenPerShare() function""
    },
    {
      ""Issue"": ""Unchecked NFT Ownership in withdraw Function"",
      ""Severity"": ""High"",
      ""Description"": ""The withdraw function allows withdrawing any NFT that's in the nftIdsStaked array of the caller. However, it doesn't verify that the caller is actually the staker of the NFT that's being withdrawn. It only checks if the NFT ID exists in the caller's nftIdsStaked array."",
      ""Impact"": ""If the nftIdsStaked mapping is ever incorrectly updated or manipulated, an attacker could potentially withdraw NFTs belonging to other users, leading to loss of assets for legitimate stakers."",
      ""Location"": ""withdraw function""
    },
    {
      ""Issue"": ""Potential Denial of Service in withdraw and getUpdatedAccTokenPerShare"",
      ""Severity"": ""High"",
      ""Description"": ""Both functions contain loops that could potentially hit gas limits: 1) withdraw iterates through all NFTs staked by a user to find the one being withdrawn, 2) getUpdatedAccTokenPerShare uses a while loop that iterates through the rewardRateLog array which grows with each rate change."",
      ""Impact"": ""Users with many staked NFTs might be unable to withdraw their NFTs due to gas limitations, effectively locking their assets in the contract. Similarly, if there are too many entries in the rewardRateLog array, core functions could fail due to exceeding gas limits."",
      ""Location"": ""withdraw function's for loop and getUpdatedAccTokenPerShare function's while loop""
    },
    {
      ""Issue"": ""Error in Loop Logic in getUpdatedAccTokenPerShare"",
      ""Severity"": ""High"",
      ""Description"": ""In getUpdatedAccTokenPerShare, the loop iterates through rewardRateLog entries starting from the end. If lastUpdatedTime is greater than all timestamps in the log (which could happen after a token is resumed following a pause), the calculation might be incorrect. There's also a potential off-by-one error when iterating backwards through timestamps."",
      ""Impact"": ""Incorrect reward calculations could lead to users receiving more or fewer rewards than they are entitled to."",
      ""Location"": ""getUpdatedAccTokenPerShare function's while loop""
    },
    {
      ""Issue"": ""Possible Integer Overflow in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses 'unchecked' blocks in getUpdatedAccTokenPerShare and _sendRewardsForNft functions, bypassing Solidity's built-in overflow protection. There's potential for overflow in reward calculations, especially if rewardsPerSecond values are very high or if the time difference is extremely large, particularly when multiplied by ACC_TOKEN_PRECISION (1e12)."",
      ""Impact"": ""Could result in incorrect reward calculations, potentially leading to excess rewards being distributed or rewards being set to unexpected values, possibly draining the contract."",
      ""Location"": ""getUpdatedAccTokenPerShare and _sendRewardsForNft functions with unchecked blocks""
    },
    {
      ""Issue"": ""Missing Validation for Reward Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setRewardPerSecond and initalizeRewardPool functions allow the owner to set arbitrary reward rates without any upper bound check or validation that the rate is reasonable. Additionally, there's no verification that _baseToken exists in the system when setting reward rates."",
      ""Impact"": ""If set too high, rewards could deplete contract funds faster than expected, potentially causing a situation where users cannot claim their rightful rewards. If set too low or to zero, this would effectively disable rewards, wasting gas for users who deposit expecting rewards."",
      ""Location"": ""setRewardPerSecond and initalizeRewardPool functions""
    },
    {
      ""Issue"": ""Lack of Token Balance Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate if it has sufficient reward tokens before initializing reward pools or setting reward rates. If the contract doesn't hold enough tokens to pay the promised rewards, users will be unable to claim their full rewards."",
      ""Impact"": ""Users may not receive their expected rewards if the contract doesn't have sufficient funds, leading to loss of trust in the protocol."",
      ""Location"": ""initalizeRewardPool and setRewardPerSecond functions""
    },
    {
      ""Issue"": ""Precision Loss in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs division operations in reward calculations that could lead to precision loss, particularly when dealing with small amounts. For example, in pendingToken() and _sendRewardsForNft(), the reward calculation uses division (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION which could result in rounding down. The contract also divides by totalSharesStaked[_baseToken] before multiplying by ACC_TOKEN_PRECISION in some calculations."",
      ""Impact"": ""Users might receive slightly fewer rewards than expected due to rounding errors, especially for tokens with high decimal places or users with small stakes."",
      ""Location"": ""getUpdatedAccTokenPerShare, pendingToken, and _sendRewardsForNft functions""
    },
    {
      ""Issue"": ""Insufficient Handling of Reward Token Balance"",
      ""Severity"": ""Medium"",
      ""Description"": ""When there are insufficient reward tokens to pay users, the contract tracks unpaid rewards but provides no mechanism or event emission to ensure these will be paid later when funds are available. Users must manually call extractRewards() again after the contract is funded."",
      ""Impact"": ""Users might not receive their full rewards if they're unaware they need to call extractRewards() again after the contract is funded, leading to loss of expected returns."",
      ""Location"": ""_sendRewardsForNft function""
    },
    {
      ""Issue"": ""Centralization Risk in reclaimTokens and setRewardPerSecond"",
      ""Severity"": ""Medium"",
      ""Description"": ""The reclaimTokens function allows the owner to withdraw any token from the contract, including reward tokens that are meant for users. Similarly, setRewardPerSecond allows the owner to change reward rates at any time without constraints or time delays, creating high centralization risk."",
      ""Impact"": ""The owner could potentially drain user rewards or operational funds, or manipulate reward rates to benefit certain users, undermining trust in the protocol."",
      ""Location"": ""reclaimTokens and setRewardPerSecond functions""
    },
    {
      ""Issue"": ""Missing Zero Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack zero address validation: 1) initialize() doesn't validate that _liquidityProviders and _lpToken addresses are non-zero, 2) withdraw() doesn't check if '_to' is the zero address before sending rewards."",
      ""Impact"": ""If initialized with zero addresses, the contract would be unusable and would need to be redeployed. User funds could be permanently lost if tokens are sent to the zero address during withdrawals."",
      ""Location"": ""initialize() and withdraw() functions""
    },
    {
      ""Issue"": ""Reward Calculation Manipulation via updatePool Timing"",
      ""Severity"": ""Medium"",
      ""Description"": ""The updatePool function only updates the pool state when called. Between calls, the accTokenPerShare value is not updated. This allows strategic timing of transactions to manipulate rewards."",
      ""Impact"": ""Malicious actors could time their transactions to maximize rewards at the expense of other users by manipulating when the pool state is updated."",
      ""Location"": ""updatePool function""
    },
    {
      ""Issue"": ""Inconsistent Reward Distribution in Low Liquidity Scenarios"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the getUpdatedAccTokenPerShare function, if totalSharesStaked[_baseToken] is very small, the division operation could result in very large values for accumulator, potentially causing unexpected behavior or even overflow in certain scenarios."",
      ""Impact"": ""Pools with very low staked liquidity could experience unexpected reward distributions, favoring early stakers or creating incentive imbalances."",
      ""Location"": ""getUpdatedAccTokenPerShare function, division by totalSharesStaked[_baseToken]""
    },
    {
      ""Issue"": ""No Check for Successful NFT Transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""In the withdraw function, there's no verification that the NFT was successfully transferred back to the user before updating state variables."",
      ""Impact"": ""If the NFT transfer fails but state variables are updated, it could lead to inconsistent state and loss of assets."",
      ""Location"": ""withdraw function""
    },
    {
      ""Issue"": ""No Time Delay for Critical Parameter Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical parameter changes like initializing reward pools and setting reward rates take effect immediately without time delays or notifications to users."",
      ""Impact"": ""Sudden changes to reward parameters could disadvantage users who made staking decisions based on previous parameters."",
      ""Location"": ""initalizeRewardPool and setRewardPerSecond functions""
    },
    {
      ""Issue"": ""Inefficient Reward Rate History Management"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract stores all historical reward rates in the rewardRateLog mapping array, which grows indefinitely over time. Each lookup of the current reward rate requires accessing the last element of this array."",
      ""Impact"": ""As the protocol operates over time, gas costs for reward calculations will gradually increase, potentially leading to higher transaction costs for users."",
      ""Location"": ""rewardRateLog mapping and its usage in getUpdatedAccTokenPerShare""
    },
    {
      ""Issue"": ""Unsafe Type Casting in LP Token Amount Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract divides the LP token amount by liquidityProviders.BASE_DIVISOR() without checking for potential overflow in the original amount or division by zero."",
      ""Impact"": ""Potential unexpected behavior if BASE_DIVISOR is set to zero or if the LP token metadata returns extremely large values."",
      ""Location"": ""deposit(), withdraw(), and _sendRewardsForNft() functions""
    },
    {
      ""Issue"": ""Lack of Events for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some important state changes don't emit events, making it difficult to track these changes off-chain. For example, when a user's rewards are updated in _sendRewardsForNft(), no event is emitted for unpaid rewards updates."",
      ""Impact"": ""Reduced transparency and difficulty in tracking contract activity off-chain."",
      ""Location"": ""Throughout the contract, particularly in _sendRewardsForNft""
    },
    {
      ""Issue"": ""Typo in function name 'initalizeRewardPool'"",
      ""Severity"": ""Informational"",
      ""Description"": ""The function name 'initalizeRewardPool' contains a typo (should be 'initializeRewardPool'). While this doesn't affect functionality, it could cause confusion in documentation or for developers."",
      ""Impact"": ""No direct security impact, but could cause confusion or integration issues for developers working with the contract."",
      ""Location"": ""initalizeRewardPool function name""
    }
  ],
  ""IssueNumber"": 59,
  ""OutputList"": 20
}",393.8632278442383,78572.0,32.0,"### **[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased**

**Report Description**:  
In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` is recorded, allowing the user to claim it later. However, at L244, the entire `nftInfo` is deleted, including `nft.unpaidRewards`. This erases the user's unpaid rewards permanently, with no mechanism to recover them.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. The deletion of `nftInfo` and the permanent loss of `nft.unpaidRewards` is a critical oversight that is not covered in the response list.

---

### **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Report Description**:  
In `getUpdatedAccTokenPerShare()`, precision loss occurs when the amount of total shares is too large. This can result in users losing a majority or even all of their rewards due to rounding errors in the calculations.

**Match in Response List**:  
Matches with the issue titled **""Precision Loss in Reward Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of precision loss in reward calculations, which aligns with the reported issue. It correctly explains the impact of rounding errors on user rewards.

---

### **[M-04] Owners have absolute control over protocol**

**Report Description**:  
Owners have full control over the protocol, including the ability to manipulate reward rates and withdraw funds. This centralization risk undermines trust in the protocol.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risk in reclaimTokens and setRewardPerSecond""**.

**Validation**:  
**Correct**. The response correctly identifies the centralization risk posed by the owner's control over critical functions like `reclaimTokens` and `setRewardPerSecond`. This aligns with the reported issue.

---

### **[M-06] DoS by gas limit**

**Report Description**:  
In the `deposit` function, an attacker can deposit too many NFTs to another user's `nftIdsStaked` array. When the user tries to withdraw an NFT at the end of the list, the iteration over the array may exceed the gas limit, causing a DoS.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service in withdraw and getUpdatedAccTokenPerShare""**.

**Validation**:  
**Correct**. The response accurately identifies the DoS risk caused by unbounded loops in the `withdraw` function, which aligns with the reported issue.

---

### **[M-10] Call to non-existing contracts returns success**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, and `staticcall`) return success if the called contract doesn’t exist (not deployed or destructed). This allows users to send funds to non-existing addresses.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. The behavior of low-level calls returning success for non-existing contracts is a critical oversight that is not covered in the response list.

---

### **[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**

**Report Description**:  
In `withdraw()`, the function calls `_sendRewardsForNft()`, which in turn calls `updatePool()` and `getUpdatedAccTokenPerShare()`. The latter contains a loop over `rewardRateLog`, which can grow indefinitely, potentially freezing users' funds due to gas limits.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service in withdraw and getUpdatedAccTokenPerShare""**.

**Validation**:  
**Correct**. The response accurately identifies the DoS risk caused by unbounded loops in `getUpdatedAccTokenPerShare`, which aligns with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**
- **[M-04] Owners have absolute control over protocol**
- **[M-06] DoS by gas limit**
- **[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased**
- **[M-10] Call to non-existing contracts returns success**

---","```
1. Precision Loss in Reward Calculations
2. Centralization Risk in reclaimTokens and setRewardPerSecond
3. Potential Denial of Service in withdraw and getUpdatedAccTokenPerShare
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Precision Loss in Reward Calculations"" appears at rank 9.
   - ""Centralization Risk in reclaimTokens and setRewardPerSecond"" appears at rank 11.
   - ""Potential Denial of Service in withdraw and getUpdatedAccTokenPerShare"" appears at rank 4.

2. **Calculate the precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 9: \( P@9 = \frac{2}{9} \approx 0.222 \)
   - For rank 11: \( P@11 = \frac{3}{11} \approx 0.273 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.25 + 0.222 + 0.273}{3} \approx \frac{0.745}{3} \approx 0.248
   \]

**Output**:
```
0.248
```"
WhitelistPeriodManager.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}

",2422,291,"[M-05] Frontrunning of setPerTokenWalletCap edge case

The `setPerTokenWalletCap()` function in WhitelistPeriodManager.sol contains a comment stating:
Special care must be taken when calling this function
There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it should be >= max lp provided by an lp.
Checking this on chain will probably require implementing a bbst, which needs more bandwidth
Call the view function getMaxCommunityLpPositon() separately before changing this value

Even if the manual step of calling the getMaxCommunityLpPositon() function is properly performed, it is possible for a user to add liquidity to increase the maxLp value in between when the getMaxCommunityLpPositon() function is called and when the setPerTokenWalletCap() function is called. Because this process is manual, this doesn't need to be bot frontrunning in the same block as when the setPerTokenWalletCap() function is called, but can be cause by poor timing of an innocent unknowing user adding liquidity to the protocol. If this condition occurs, the liquidity provider will have provided more liquidity than the perTokenWalletCap limit, breaking the assumptions for this variable and leading to some denial of service conditions.
  [M-15] WhitelistPeriodManager: Improper state handling of exclusion removals

Submitted by hickuphh3, also found by throttle
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L115-L125
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is removed from the isExcludedAddress mapping. While this affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.
In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.
  [M-16] WhitelistPeriodManager: Improper state handling of exclusion additions

Submitted by hickuphh3
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L83-L99
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is added to the isExcludedAddress mapping. This affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, which implicitly assumes that whitelisted addresses will have 0 liquidity, for addresses with non-zero liquidity at the time of addition to the whitelist.
",3,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    
    
    mapping(address => bool) public isExcludedAddress;
    
    mapping(address => uint256) private totalLiquidity;
    
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    
    
    mapping(address => uint256) public perTokenTotalCap;
    
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        
        _beforeLiquidityRemoval(_from, _token, _amount);

        
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",1958,0,3,"Based on the comprehensive analysis of the WhitelistPeriodManager contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in liquidity addition and removal functions"",
        ""Check for potential integer underflow/overflow in liquidity calculations (_beforeLiquidityRemoval)"",
        ""Validate input sanitization for address and uint256 parameters"",
        ""Review the ifEnabled() method for potential bypass of security restrictions""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the implementation of onlyOwner, onlyLiquidityPool, and onlyLpNft modifiers"",
        ""Verify the initialization process and ensure proper access control setup"",
        ""Review the setIsExcludedAddressStatus method for potential privilege escalation"",
        ""Validate the meta-transaction (_msgSender) implementation for potential spoofing""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze the interfaces (ILiquidityProviders, ITokenManager, ILPToken) for potential external call vulnerabilities"",
        ""Verify the _isSupportedToken method's reliability and token validation process"",
        ""Check for proper error handling in external contract interactions"",
        ""Review the getMaxCommunityLpPositon method for potential gas DOS or manipulation""
      ]
    },
    {
      ""Area"": ""Liquidity Management"",
      ""Tasks"": [
        ""Validate the logic for total and per-wallet liquidity cap enforcement"",
        ""Check the beforeLiquidityTransfer method for complete state update accuracy"",
        ""Review the mechanism for handling liquidity when whitelist restrictions are disabled"",
        ""Verify the setCaps method for multi-token cap setting logic""
      ]
    },
    {
      ""Area"": ""Upgradability and Initialization"",
      ""Tasks"": [
        ""Audit the initialize method for complete and secure contract setup"",
        ""Verify that all critical parameters can be updated securely"",
        ""Check for potential initialization vulnerabilities"",
        ""Validate the proxy pattern implementation""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency Mechanisms"",
      ""Tasks"": [
        ""Review the pausability implementation and its interaction with liquidity operations"",
        ""Verify the emergency stop mechanisms"",
        ""Check the setAreWhiteListRestrictionsEnabled method for potential misuse""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of key methods like beforeLiquidityAddition and beforeLiquidityRemoval"",
        ""Review loop operations in getMaxCommunityLpPositon for potential gas DOS"",
        ""Check for unnecessary storage reads and writes"",
        ""Evaluate the efficiency of mapping usage""
      ]
    },
    {
      ""Area"": ""Edge Cases and Error Handling"",
      ""Tasks"": [
        ""Test scenarios with zero amounts and zero addresses"",
        ""Verify behavior when total liquidity approaches or exceeds caps"",
        ""Check handling of unexpected token manager responses"",
        ""Test liquidity operations with excluded addresses""
      ]
    },
    {
      ""Area"": ""Governance and Ownership"",
      ""Tasks"": [
        ""Review the owner's ability to modify critical contract parameters"",
        ""Validate the transfer of ownership mechanism"",
        ""Check for potential centralization risks in admin functions""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, functional, and performance aspects.
2. Tasks are structured to address specific concerns identified in the initial analysis.
3. The approach considers both technical vulnerabilities and potential misuse scenarios.
4. Each area includes tasks that dig into implementation details and potential attack vectors.

Recommendations for Audit Execution:
- Prioritize security vulnerability and access control tasks
- Use comprehensive test cases to validate each task
- Consider automated tools and manual code review
- Engage with contract developers to understand design rationales
- Document findings with clear severity and remediation recommendations

This task list provides a structured approach to auditing the WhitelistPeriodManager contract, ensuring a thorough examination of its security, functionality, and performance characteristics.","I've conducted a thorough review of the provided smart contract. Here's my analysis:

{
  ""ReviewingTheCode"": ""The code is a WhitelistPeriodManager contract that manages whitelisting restrictions for liquidity providers. It controls caps on total and per-wallet liquidity for different tokens, tracking liquidity additions and removals, with special handling for excluded addresses."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""WhitelistPeriodManager"",
    ""Purpose"": ""Manages whitelisting restrictions for liquidity providers by enforcing token-specific caps on total and per-wallet liquidity contributions during a controlled phase"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable"", ""Pausable"", ""ERC2771ContextUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""./interfaces/ITokenManager.sol"",
        ""./interfaces/ILPToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to interact with the liquidity providers contract""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface to interact with the token manager contract""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface to interact with the LP token contract""
      },
      {
        ""Name"": ""areWhiteListRestrictionsEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable or disable whitelist restrictions""
      },
      {
        ""Name"": ""isExcludedAddress"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks addresses excluded from whitelist restrictions""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks total liquidity per token""
      },
      {
        ""Name"": ""totalLiquidityByLp"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks liquidity per LP per token""
      },
      {
        ""Name"": ""perTokenTotalCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maximum total liquidity allowed per token""
      },
      {
        ""Name"": ""perTokenWalletCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maximum liquidity per wallet per token""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyLiquidityPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the liquidity providers contract only""
      },
      {
        ""Name"": ""onlyLpNft"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the LP token contract only""
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates that a token address is non-zero and supported""
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with required addresses"",
        ""Parameters"": [""_trustedForwarder"", ""_liquidityProviders"", ""_tokenManager"", ""_lpToken"", ""_pauser""]
      },
      {
        ""Name"": ""_isSupportedToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a token is supported by the token manager"",
        ""Parameters"": [""_token""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_beforeLiquidityAddition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Logic to execute before liquidity is added"",
        ""Parameters"": [""_lp"", ""_token"", ""_amount""]
      },
      {
        ""Name"": ""beforeLiquidityAddition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by liquidity pool before liquidity is added"",
        ""Parameters"": [""_lp"", ""_token"", ""_amount""]
      },
      {
        ""Name"": ""_beforeLiquidityRemoval"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Logic to execute before liquidity is removed"",
        ""Parameters"": [""_lp"", ""_token"", ""_amount""]
      },
      {
        ""Name"": ""beforeLiquidityRemoval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by liquidity pool before liquidity is removed"",
        ""Parameters"": [""_lp"", ""_token"", ""_amount""]
      },
      {
        ""Name"": ""beforeLiquidityTransfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called before liquidity is transferred between wallets"",
        ""Parameters"": [""_from"", ""_to"", ""_token"", ""_amount""]
      },
      {
        ""Name"": ""setTokenManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the token manager address"",
        ""Parameters"": [""_tokenManager""]
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the liquidity providers address"",
        ""Parameters"": [""_liquidityProviders""]
      },
      {
        ""Name"": ""setLpToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the LP token address"",
        ""Parameters"": [""_lpToken""]
      },
      {
        ""Name"": ""setIsExcludedAddressStatus"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets exclusion status for multiple addresses"",
        ""Parameters"": [""_addresses"", ""_status""]
      },
      {
        ""Name"": ""setTotalCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets total cap for a token"",
        ""Parameters"": [""_token"", ""_totalCap""]
      },
      {
        ""Name"": ""setPerTokenWalletCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets per-wallet cap for a token"",
        ""Parameters"": [""_token"", ""_perTokenWalletCap""]
      },
      {
        ""Name"": ""setCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets both total and per-wallet caps for a token"",
        ""Parameters"": [""_token"", ""_totalCap"", ""_perTokenWalletCap""]
      },
      {
        ""Name"": ""setCaps"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets caps for multiple tokens at once"",
        ""Parameters"": [""_tokens"", ""_totalCaps"", ""_perTokenWalletCaps""]
      },
      {
        ""Name"": ""setAreWhiteListRestrictionsEnabled"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables or disables whitelist restrictions"",
        ""Parameters"": [""_status""]
      },
      {
        ""Name"": ""getMaxCommunityLpPositon"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the maximum LP position for a token"",
        ""Parameters"": [""_token""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""ifEnabled"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Conditional check that passes if whitelist restrictions are disabled or the condition is true"",
        ""Parameters"": [""_cond""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Override to support meta-transactions"",
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Override to support meta-transactions"",
        ""Returns"": [""bytes calldata""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ILiquidityProviders - Interacts with liquidity provider contract"",
    ""ITokenManager - Used to check if tokens are supported"",
    ""ILPToken - Used for LP token operations and ownership checks""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable proxy pattern - Contract is designed to be upgradeable"",
    ""Meta-transactions support - Uses ERC2771ContextUpgradeable for gasless transactions"",
    ""Cap management - Enforces token-specific caps on total and per-wallet liquidity"",
    ""Whitelist exemption - Allows certain addresses to bypass restrictions"",
    ""Conditional enforcement - Can enable/disable whitelist restrictions globally""
  ],
  ""Questions"": [
    ""What is the purpose of the imported ReentrancyGuardUpgradeable if it's not being used in the contract?"",
    ""Could there be a potential underflow in _beforeLiquidityRemoval if totalLiquidityByLp[_token][_lp] < _amount?"",
    ""How does the contract handle the situation when a token's supported status changes in the TokenManager?"",
    ""What happens if a wallet has more than perTokenWalletCap when the cap is lowered?"",
    ""Is there a mechanism to validate LP token IDs in getMaxCommunityLpPositon beyond just checking totalSupply?""
  ]
}

Based on my analysis, this contract implements a whitelisting mechanism for liquidity providers, enforcing limits on how much liquidity can be provided per token during a controlled phase. It tracks liquidity movements, enforces caps, and allows certain addresses to be excluded from these restrictions.

The contract is designed as an upgradeable contract using OpenZeppelin's upgradeable patterns and includes meta-transaction functionality. It serves as a gatekeeper before liquidity operations, working in conjunction with the LiquidityProviders contract and tracking token support through TokenManager.","I've analyzed the provided issues for the `WhitelistPeriodManager` contract and consolidated similar findings. Here is the result:

{
  ""Findings"": [
    {
      ""Issue"": ""Potential arithmetic underflow in _beforeLiquidityRemoval"",
      ""Severity"": ""High"",
      ""Description"": ""The _beforeLiquidityRemoval function subtracts _amount from totalLiquidityByLp[_token][_lp] and totalLiquidity[_token] without checking if the values are sufficient to prevent underflow. While Solidity 0.8.0 has built-in overflow/underflow protection that would cause a revert, this indicates a logical error in token accounting that could lead to transactions failing unexpectedly."",
      ""Impact"": ""Could lead to transaction failures if accounting is out of sync, preventing legitimate liquidity removals. This suggests a potential flaw in the liquidity tracking system that might allow users to remove more liquidity than they've added."",
      ""Location"": ""_beforeLiquidityRemoval() function""
    },
    {
      ""Issue"": ""Lack of validation for critical parameters during initialization"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function accepts address parameters without validating that they're not the zero address and doesn't verify that the provided addresses for critical components (_liquidityProviders, _tokenManager, _lpToken, _pauser) are actual contracts with expected interfaces."",
      ""Impact"": ""Contract could be deployed with invalid addresses, requiring redeployment or potentially leading to locked funds if users interact with a misconfigured contract. If incorrect addresses are provided during initialization, the contract could be permanently broken or function incorrectly."",
      ""Location"": ""initialize() function""
    },
    {
      ""Issue"": ""Inefficient iteration in getMaxCommunityLpPositon"",
      ""Severity"": ""Medium"",
      ""Description"": ""The getMaxCommunityLpPositon function iterates through all LP token IDs from 1 to totalSupply() to find the maximum liquidity position, making external calls for each token. This approach is inefficient and could consume excessive gas or even reach block gas limits as the number of LP tokens grows."",
      ""Impact"": ""Function may become unusable due to high gas costs or timeouts as the system scales, potentially preventing operations that depend on this information. This could render the function unusable if there are many LP tokens."",
      ""Location"": ""getMaxCommunityLpPositon() function""
    },
    {
      ""Issue"": ""Centralization risk with owner privileges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract owner has extensive powers including the ability to set caps, exclude addresses from restrictions, toggle whitelist restrictions, and update critical contract dependencies. While this may be intended for the protocol design, it represents a centralization risk."",
      ""Impact"": ""A compromised owner account could manipulate whitelist restrictions to favor certain users, completely disable the protective measures, or point to malicious contract implementations, potentially leading to fund loss or system manipulation."",
      ""Location"": ""setIsExcludedAddressStatus(), setTotalCap(), setPerTokenWalletCap(), setCap(), setCaps(), setAreWhiteListRestrictionsEnabled(), setTokenManager(), setLiquidityProviders(), and setLpToken() functions""
    },
    {
      ""Issue"": ""Potential front-running and cap enforcement vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like setTotalCap and setPerTokenWalletCap can be front-run by users adding liquidity before caps are lowered. Additionally, the ifEnabled() function creates conditional enforcement of caps based on areWhiteListRestrictionsEnabled, which could lead to inconsistent enforcement if toggled frequently."",
      ""Impact"": ""Users could bypass intended restrictions by monitoring pending transactions and quickly adding liquidity before restrictions are tightened. An attacker could also monitor the state of areWhiteListRestrictionsEnabled and time their transactions to bypass caps when restrictions are temporarily disabled."",
      ""Location"": ""setTotalCap(), setPerTokenWalletCap(), setCap(), setCaps() functions and ifEnabled() function""
    },
    {
      ""Issue"": ""Overly permissive excluded address mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""Excluded addresses completely bypass all cap validations in both liquidity addition and removal. This creates a privileged class of users who can manipulate the market without restrictions, potentially undermining the purpose of the whitelist period."",
      ""Impact"": ""Excluded addresses could potentially manipulate markets or disrupt tokenomics by adding/removing unlimited liquidity, potentially causing centralization issues."",
      ""Location"": ""_beforeLiquidityAddition and _beforeLiquidityRemoval functions""
    },
    {
      ""Issue"": ""Insufficient validation in cap setting functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setCap functions don't verify that the input values are reasonable (e.g., not excessively large or zero). While there are some checks in setCap functions (e.g., requiring that _perTokenWalletCap <= perTokenTotalCap), there's no validation that the caps are reasonable."",
      ""Impact"": ""An owner could accidentally or maliciously set caps to extremely high values, essentially removing the cap protection that's expected by users of the system. Conversely, setting caps to extremely low values could effectively prevent legitimate users from adding liquidity."",
      ""Location"": ""setTotalCap, setPerTokenWalletCap, and setCap functions""
    },
    {
      ""Issue"": ""Incomplete token validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract only checks if a token is 'supported' before setting caps, but doesn't verify other important token attributes like transfer mechanics or potential fee-on-transfer mechanisms. The tokenChecks modifier calls _isSupportedToken to verify if a token is supported, but this function only checks if the token is marked as supported in the tokenManager."",
      ""Impact"": ""Incompatible or malicious tokens could cause accounting issues in the liquidity tracking system. This could allow setting caps for invalid tokens or cause unexpected behavior when interacting with non-standard tokens."",
      ""Location"": ""tokenChecks modifier and _isSupportedToken() function""
    },
    {
      ""Issue"": ""Inadequate validation in contract address setting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions to set contract addresses (_setLiquidityProviders, _setTokenManager, _setLpToken) don't validate that the provided addresses are actually the correct contract types, potentially allowing incorrect implementations."",
      ""Impact"": ""Setting an incorrect contract address could break core functionality or introduce vulnerabilities if the substitute contract has malicious logic."",
      ""Location"": ""_setLiquidityProviders(), _setTokenManager(), and _setLpToken() functions""
    },
    {
      ""Issue"": ""Lack of event emission for critical parameter changes"",
      ""Severity"": ""Low"",
      ""Description"": ""When the owner changes critical addresses like tokenManager, liquidityProviders, or lpToken, no events are emitted. This makes it difficult to track important contract configuration changes off-chain."",
      ""Impact"": ""Reduced transparency and auditability of contract changes, making it harder for users and monitoring systems to track critical contract updates."",
      ""Location"": ""setTokenManager(), setLiquidityProviders(), and setLpToken() functions""
    },
    {
      ""Issue"": ""Logic vulnerability in ifEnabled function"",
      ""Severity"": ""Low"",
      ""Description"": ""The ifEnabled function uses a complex boolean logic pattern that could be error-prone. The function returns true if whitelist restrictions are disabled OR if restrictions are enabled AND the condition is true. This could be simplified to (!areWhiteListRestrictionsEnabled || _cond)."",
      ""Impact"": ""While not causing immediate issues, the overly complex logic increases the potential for errors in future updates and makes code review more difficult."",
      ""Location"": ""ifEnabled() function""
    },
    {
      ""Issue"": ""Inconsistent error messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses 'ERR__LENGTH_MISMACH' (misspelled) instead of 'ERR__LENGTH_MISMATCH' which is used elsewhere in the contract. Additionally, error messages like 'ERR__LIQUIDITY_EXCEEDS_PTTC' and 'ERR__LIQUIDITY_EXCEEDS_PTWC' are abbreviated and not very descriptive."",
      ""Impact"": ""Reduced code quality and confusion during error handling or debugging. Makes it harder to debug issues for users and developers."",
      ""Location"": ""setCaps() function and _beforeLiquidityAddition function""
    },
    {
      ""Issue"": ""Lack of zero amount validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't validate that liquidity amounts are greater than zero in beforeLiquidityAddition and beforeLiquidityRemoval functions. This could potentially allow zero-amount transactions that waste gas and pollute the event logs."",
      ""Impact"": ""Allows unnecessary transactions that could increase blockchain bloat and might be used to create misleading transaction history."",
      ""Location"": ""beforeLiquidityAddition and beforeLiquidityRemoval functions""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 13
}",368.7993450164795,61040.0,32.0,"### **[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Report Description**:
The `setPerTokenWalletCap()` function in `WhitelistPeriodManager.sol` lacks checks for `_perTokenWalletCap`, which should be greater than or equal to the maximum liquidity provided by any liquidity provider (LP). Although the function is `onlyOwner`, there is a manual step to call `getMaxCommunityLpPositon()` before setting the cap. However, a user could add liquidity between the time `getMaxCommunityLpPositon()` is called and `setPerTokenWalletCap()` is executed, leading to a situation where the `perTokenWalletCap` is exceeded. This could result in denial of service conditions and break the assumptions for this variable.

**Match in Response List**:
Matches with the issue titled **""Potential front-running and cap enforcement vulnerabilities""**.

**Validation**:
**Correct**. The response accurately identifies the issue of front-running in cap-setting functions, including `setPerTokenWalletCap`. It correctly explains the risks associated with users adding liquidity before caps are lowered, which aligns with the issue described in the report. The response also highlights the potential for inconsistent enforcement of caps, which is relevant to the described scenario.

---

### **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**

**Report Description**:
When an address is removed from the `isExcludedAddress` mapping, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function. The worst impact is that users may be prevented from withdrawing their staked LP tokens due to subtraction overflow, especially if the address becomes non-excluded.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper state handling when an address is removed from the `isExcludedAddress` mapping. This is a critical oversight, as it directly impacts the contract's ability to enforce cap limits and could lead to denial of service conditions for users attempting to withdraw their staked LP tokens.

---

### **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

**Report Description**:
When an address is added to the `isExcludedAddress` mapping, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function, which assumes that whitelisted addresses will have zero liquidity. If an address with non-zero liquidity is added to the whitelist, this assumption is violated, leading to incorrect enforcement of cap limits.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper state handling when an address is added to the `isExcludedAddress` mapping. This is a significant oversight, as it directly impacts the contract's ability to enforce cap limits and could lead to incorrect enforcement of liquidity restrictions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**
- **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

---

### **Conclusion**

The response list effectively addresses the issue of front-running in cap-setting functions but fails to cover the critical issues related to improper state handling when addresses are added to or removed from the `isExcludedAddress` mapping. These missed issues represent significant vulnerabilities that could lead to denial of service conditions and incorrect enforcement of cap limits. It is recommended to update the response list to include these issues and provide appropriate mitigation strategies.","```
1. Potential front-running and cap enforcement vulnerabilities
```",0.2
TokenManager.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169,146,"[M-09] Improper Upper Bound Definition on the Fee
 function changeFee()
Submitted by defsec, also found by catchup, danb, Dravee, gzeon, hickuphh3, hubble, peritoflores, Ruhum, and throttle
The equilibriumFee and maxFee does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.
Proof of Concept

Navigate to the following contract.
TokenManager.sol#L52
Owner can identify fee amount. That directly affect to LP management. LiquidityPool.sol#L352
Here you can see there is no upper bound has been defined.
",1,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1066,0,1,"Based on the comprehensive analysis of the TokenManager contract, I'll generate a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify that all onlyOwner functions have comprehensive access restrictions"",
        ""Check the constructor's initialization of trusted forwarder for potential vulnerabilities"",
        ""Validate the override of _msgSender() and _msgData() for meta-transaction security"",
        ""Ensure no critical functions can be called by unauthorized parties""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Audit the tokenChecks modifier for potential bypass mechanisms"",
        ""Verify input validation in all external functions, especially in changeFee and addSupportedToken"",
        ""Check for potential reentrancy risks in state modification functions"",
        ""Validate the logic preventing zero-address token configurations"",
        ""Review array length checks in setDepositConfig for potential out-of-bounds access""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Analyze the depositConfig mapping for potential cross-chain manipulation"",
        ""Verify the safety of chain ID-based configurations"",
        ""Check the integrity of token transfer configurations across different chains"",
        ""Ensure no unauthorized token transfers can occur between chains""
      ]
    },
    {
      ""Area"": ""Fee and Token Configuration"",
      ""Tasks"": [
        ""Validate the fee change mechanism for potential economic attacks"",
        ""Review the logic behind equilibriumFee and maxFee calculations"",
        ""Check the constraints on token transfer overhead and cap limits"",
        ""Analyze the risk of fee manipulation by contract owner""
      ]
    },
    {
      ""Area"": ""Meta-Transaction Security"",
      ""Tasks"": [
        ""Thoroughly audit the ERC2771Context implementation"",
        ""Verify the trusted forwarder mechanism for potential spoofing"",
        ""Check the override of _msgSender() and _msgData() for complete meta-transaction support"",
        ""Ensure no unauthorized meta-transactions can be executed""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency Mechanisms"",
      ""Tasks"": [
        ""Verify the comprehensive coverage of the pause functionality"",
        ""Check if critical functions are properly protected when contract is paused"",
        ""Ensure the pause mechanism cannot be abused"",
        ""Validate the emergency stop capabilities""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Review the efficiency of multiple mappings and their storage usage"",
        ""Check for potential gas optimizations in array-based functions"",
        ""Analyze the gas overhead mechanism for token transfers"",
        ""Verify the gas efficiency of configuration update functions""
      ]
    },
    {
      ""Area"": ""Compliance and Standard Adherence"",
      ""Tasks"": [
        ""Verify compliance with the ITokenManager interface"",
        ""Check alignment with ERC-2771 meta-transaction standard"",
        ""Ensure proper implementation of OpenZeppelin base contracts"",
        ""Validate token support and configuration mechanisms""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list comprehensively covers multiple critical audit areas specific to this contract.
2. Each area has multiple specific, actionable tasks that directly address potential vulnerabilities.
3. The tasks focus on both security risks and operational integrity.
4. The breakdown allows for a systematic and thorough audit approach.

Recommended Next Steps:
- Conduct a detailed review following these task categories
- Use static analysis tools to complement manual review
- Perform thorough testing of each function with various input scenarios
- Consider formal verification for complex logic paths

The tasks are designed to provide a comprehensive security assessment, covering technical, economic, and operational risks inherent in the token management contract.","I've conducted a thorough analysis of the TokenManager contract. Here's my audit in the requested format:

{
  ""ReviewingTheCode"": ""The TokenManager contract manages token configurations, fees, and transfer parameters in what appears to be a cross-chain token management system. It inherits from OpenZeppelin's Ownable and Pausable contracts, and implements a meta-transaction pattern through ERC2771Context. The contract allows the owner to add/remove supported tokens, set transaction fees, and define constraints for token transfers."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""TokenManager"",
    ""Purpose"": ""Manages token configurations, fees, and transfer parameters for a cross-chain token transfer system"",
    
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ERC2771Context"", ""Ownable"", ""Pausable"", ""ITokenManager""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/security/Pausable.sol"",
        ""../metatx/ERC2771Context.sol"",
        ""../interfaces/ITokenManager.sol""
      ]
    },
    
    ""StateVariables"": [
      {
        ""Name"": ""tokensInfo"",
        ""Type"": ""mapping(address => TokenInfo)"",
        ""Purpose"": ""Stores detailed information about supported tokens""
      },
      {
        ""Name"": ""depositConfig"",
        ""Type"": ""mapping(uint256 => mapping(address => TokenConfig))"",
        ""Purpose"": ""Configuration for token deposits per chain ID and token address""
      },
      {
        ""Name"": ""transferConfig"",
        ""Type"": ""mapping(address => TokenConfig)"",
        ""Purpose"": ""Configuration for token transfers per token address""
      }
    ],
    
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates that a token address is non-zero and supported"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with a trusted forwarder for meta-transactions"",
        ""Parameters"": [""address trustedForwarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""getEquilibriumFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the equilibrium fee for a token"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getMaxFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the maximum fee for a token"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""changeFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates equilibrium and max fees for a token"",
        ""Parameters"": [""address tokenAddress"", ""uint256 _equilibriumFee"", ""uint256 _maxFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenTransferOverhead"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the gas overhead for token transfers"",
        ""Parameters"": [""address tokenAddress"", ""uint256 gasOverhead""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDepositConfig"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Configures deposit parameters for multiple tokens across multiple chains"",
        ""Parameters"": [""uint256[] memory toChainId"", ""address[] memory tokenAddresses"", ""TokenConfig[] memory tokenConfig""],
        ""Returns"": []
      },
      {
        ""Name"": ""addSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new token to the list of supported tokens"",
        ""Parameters"": [""address tokenAddress"", ""uint256 minCapLimit"", ""uint256 maxCapLimit"", ""uint256 equilibriumFee"", ""uint256 maxFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes a token from the list of supported tokens"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTokenCap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the minimum and maximum cap limits for a token"",
        ""Parameters"": [""address tokenAddress"", ""uint256 minCapLimit"", ""uint256 maxCapLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokensInfo"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns detailed information about a token"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""TokenInfo memory""]
      },
      {
        ""Name"": ""getDepositConfig"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns deposit configuration for a token on a specific chain"",
        ""Parameters"": [""uint256 toChainId"", ""address tokenAddress""],
        ""Returns"": [""TokenConfig memory""]
      },
      {
        ""Name"": ""getTransferConfig"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns transfer configuration for a token"",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""TokenConfig memory""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Overrides ERC2771Context and Context to get the correct message sender for meta-transactions"",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Overrides ERC2771Context and Context to get the correct message data for meta-transactions"",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""The contract inherits from OpenZeppelin's Ownable and Pausable contracts"",
    ""The contract inherits from a custom ERC2771Context which implements EIP-2771 for meta-transactions"",
    ""The contract implements the ITokenManager interface which is not shown in the snippet""
  ],
  
  ""SpecialMechanisms"": [
    ""Meta-transaction support through ERC2771Context"",
    ""Access control through OpenZeppelin's Ownable"",
    ""Function pausing capability through OpenZeppelin's Pausable"",
    ""Cross-chain token management through TokenConfig mappings""
  ],
  
  ""Questions"": [
    ""What is the structure of the TokenInfo and TokenConfig structs? They are not defined in the provided code snippet."",
    ""How is the fee calculation mechanism intended to work? The contract stores equilibriumFee and maxFee but there's no logic showing how they're applied."",
    ""Is there a reason why depositConfig requires setDepositConfig to update multiple tokens at once, while regular transferConfig can be updated per token?"",
    ""Is there any functionality to pause specific token operations rather than the entire contract?"",
    ""What's the purpose of the transferOverhead parameter in TokenInfo? Is it used for gas refunds or fee calculations?""
  ]
}

Based on my review, this appears to be a token management contract for a cross-chain bridge or transfer system. It handles configurations for supported tokens, including fee parameters and transfer limits for different chains. The contract implements proper access control through Ownable and has support for meta-transactions via ERC2771Context.

Critical functions are properly restricted with onlyOwner modifiers, and there are appropriate validations for token addresses and limits. The contract seems well-structured with clear separation of concerns between different configuration aspects.","I've analyzed the provided TokenManager contract findings and consolidated similar issues. Here's my summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Missing validation for equilibriumFee and maxFee relationship"",
      ""Severity"": ""Medium"",
      ""Description"": ""In both changeFee and addSupportedToken functions, there is no validation to ensure that equilibriumFee <= maxFee. While the changeFee function checks that these values are non-zero, addSupportedToken lacks even this basic validation. This inconsistency could lead to illogical fee configurations where the equilibrium fee exceeds the maximum fee."",
      ""Impact"": ""Could lead to unexpected fee behavior, logical inconsistencies in the token fee structure, and potentially cause issues in dependent contracts that assume equilibriumFee <= maxFee. This may disrupt fee calculations or create economic imbalances in the protocol."",
      ""Location"": ""changeFee function and addSupportedToken function""
    },
    {
      ""Issue"": ""Redundant and inconsistent token configuration storage"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract stores token configuration data redundantly in both transferConfig mapping and within the TokenInfo struct in the tokensInfo mapping. In addSupportedToken(), both are updated, but in updateTokenCap(), only transferConfig is updated, not tokensInfo[tokenAddress].tokenConfig. This creates potential for data inconsistency if one storage location is updated but not the other."",
      ""Impact"": ""May lead to inconsistent state and unexpected behavior if the redundant storage locations get out of sync. The getTokensInfo() function might return stale or inconsistent data compared to getTransferConfig(), causing confusion or incorrect behavior in dependent systems."",
      ""Location"": ""addSupportedToken function, updateTokenCap function, and getTokensInfo function""
    },
    {
      ""Issue"": ""Lack of validation in deposit configuration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The setDepositConfig function doesn't validate that max > min for token configurations, unlike the updateTokenCap function. It also doesn't check if the tokens are supported or if the token addresses exist. This could lead to setting invalid deposit configurations where the maximum deposit limit is less than or equal to the minimum."",
      ""Impact"": ""Could result in unusable deposit configurations where valid deposits are impossible because min >= max. May also allow configurations with invalid tokens, potentially breaking deposit functionality."",
      ""Location"": ""setDepositConfig function""
    },
    {
      ""Issue"": ""Incomplete token removal process"",
      ""Severity"": ""Medium"",
      ""Description"": ""The removeSupportedToken function only sets the supportedToken flag to false but doesn't clean up other associated data like transferConfig, depositConfig, or fee settings. This leaves orphaned data in the contract that could cause issues if the token is re-added later."",
      ""Impact"": ""Storage bloat and potential confusion about the status of removed tokens. If a token is re-added later, stale configuration data might still exist, potentially leading to unexpected behavior."",
      ""Location"": ""removeSupportedToken function""
    },
    {
      ""Issue"": ""Centralization risk with single owner"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from Ownable which provides a single owner address with significant privileges including adding/removing tokens and setting fees. There is no timelock or multi-signature mechanism for these sensitive operations, and the owner can set arbitrarily high fees with no upper limit constraints."",
      ""Impact"": ""If the owner key is compromised, an attacker could change fees, add malicious tokens, or remove legitimate tokens from the system. Users are entirely dependent on the owner's goodwill not to set exploitative fees, creating a significant centralization risk."",
      ""Location"": ""Throughout the contract - reliance on onlyOwner modifier""
    },
    {
      ""Issue"": ""No validation of token existence"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract validates that tokens are supported but doesn't check if the token address is actually a contract or a token that implements expected interfaces (e.g., ERC20). This could allow non-token contracts to be registered as supported tokens."",
      ""Impact"": ""Non-token contracts could be registered as supported tokens, potentially leading to unexpected behavior or failed interactions in dependent systems that assume registered addresses are valid tokens."",
      ""Location"": ""addSupportedToken function""
    },
    {
      ""Issue"": ""Potential front-running vulnerability in fee changes"",
      ""Severity"": ""Medium"",
      ""Description"": ""The changeFee function can be front-run. When the owner submits a transaction to change fees, users could potentially observe this in the mempool and quickly execute transactions before the fee change takes effect."",
      ""Impact"": ""This could allow users to exploit soon-to-be-increased fees, potentially leading to economic losses for the protocol."",
      ""Location"": ""changeFee function""
    },
    {
      ""Issue"": ""Inconsistent use of pausable functionality"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits from Pausable but only the changeFee function uses the whenNotPaused modifier. Other critical functions like addSupportedToken, removeSupportedToken, and setDepositConfig don't implement this safety measure. Additionally, there are no exposed functions to pause/unpause the contract, making the whenNotPaused modifier on changeFee redundant."",
      ""Impact"": ""In the event of an emergency where the contract needs to be paused, most critical functions would still be executable, potentially exacerbating issues. The pausing functionality cannot be used as intended, reducing the contract's ability to respond to emergencies."",
      ""Location"": ""Throughout the contract - inconsistent use of whenNotPaused modifier and missing pause/unpause functions""
    },
    {
      ""Issue"": ""No event emission for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several important state-changing functions like addSupportedToken, removeSupportedToken, updateTokenCap, and setDepositConfig do not emit events. Only the changeFee function emits a FeeChanged event. This makes it difficult to track these critical changes off-chain and reduces transparency of admin actions."",
      ""Impact"": ""Reduces auditability and transparency of contract administration. Makes it harder for users and off-chain systems to track changes to token support status, deposit configurations, and other important parameters."",
      ""Location"": ""addSupportedToken, removeSupportedToken, updateTokenCap, and setDepositConfig functions""
    },
    {
      ""Issue"": ""No validation for transferOverhead parameter"",
      ""Severity"": ""Low"",
      ""Description"": ""The setTokenTransferOverhead function allows setting any value for the gasOverhead without any bounds checking. This could potentially allow setting unreasonably high gas overhead values that might disrupt gas calculations elsewhere in the system."",
      ""Impact"": ""An owner could accidentally or maliciously set excessively high transfer overhead values, which might disrupt the economics of the system or cause gas-related calculation errors. Could lead to transactions running out of gas if transfer overhead is set too high."",
      ""Location"": ""setTokenTransferOverhead function""
    },
    {
      ""Issue"": ""Inefficient array handling in setDepositConfig"",
      ""Severity"": ""Low"",
      ""Description"": ""The setDepositConfig function loops through arrays without checking for duplicates. If the same token and chainId combination appears multiple times in the input arrays, the last entry would overwrite previous ones without warning."",
      ""Impact"": ""Potential for accidental misconfiguration and increased gas costs due to redundant operations."",
      ""Location"": ""setDepositConfig function""
    },
    {
      ""Issue"": ""Incomplete initialization in constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor only initializes the ERC2771Context but doesn't set up any initial state for the contract. There's no clear initialization of the contract owner or validation that the trustedForwarder address is not the zero address."",
      ""Impact"": ""While Ownable likely sets msg.sender as owner, the lack of explicit initialization could cause confusion or issues if deployment procedures change. If the trustedForwarder is the zero address, meta-transactions functionality could be compromised."",
      ""Location"": ""constructor function""
    },
    {
      ""Issue"": ""No function to update transfer overhead for multiple tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""Unlike setDepositConfig which supports batch operations, the setTokenTransferOverhead function only works for a single token, making it inefficient to update multiple tokens."",
      ""Impact"": ""Administrative overhead and increased gas costs when needing to update transfer overhead for multiple tokens."",
      ""Location"": ""setTokenTransferOverhead function""
    }
  ],
  ""IssueNumber"": 56,
  ""OutputList"": 13
}",343.5737810134888,45476.0,32.0,"### **[M-09] Improper Upper Bound Definition on the Fee**

**Report Description**:  
The `changeFee()` function in the `TokenManager.sol` contract does not define any upper or lower bounds for the `equilibriumFee` and `maxFee` values. This lack of validation can lead to critical issues:  
1. **Reversions**: If the fee values are set too high, several critical functions may revert, disrupting the protocol's functionality.  
2. **Fund Loss**: Liquidity providers (LPs) could lose all their funds when paying excessively high fees.  
The issue is particularly concerning because the owner can set arbitrary fee amounts, directly impacting LP management.  

**Match in Response List**:  
The issue partially matches with the response titled **""Centralization risk with single owner""**.  

**Validation**:  
**Partially Correct**. The response identifies the centralization risk associated with the owner's ability to set arbitrary fees without upper limits, which aligns with the core concern of the issue. However, the response does not explicitly address the specific risks of reversions or fund loss for LPs due to excessively high fees. Additionally, it does not mention the lack of lower bounds, which is another critical aspect of the issue. While the response correctly highlights the centralization risk, it misses the detailed impact and broader implications of the improper fee bounds.  

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*  

**Partially Correct Matches**:  
- **[M-09] Improper Upper Bound Definition on the Fee**  

**Missed Issues from Issue Report**:  
- *None*  

--- 

**Analysis**:  
The response list partially addresses the issue by identifying the centralization risk associated with the owner's ability to set arbitrary fees. However, it does not fully capture the specific risks of reversions and fund loss for LPs, nor does it mention the lack of lower bounds. To improve the response, it should explicitly discuss the potential for critical function failures and the economic impact on LPs due to improperly defined fee bounds.","```
None.
```",0.0
