nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
IdleYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";

/// @title An pooltogether yield source for Idle token
/// @author Sunny Radadiya
contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    /// @notice Emitted when the yield source is initialized
    event IdleYieldSourceInitialized(address indexed idleToken);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    /// @notice Initializes the yield source with Idle Token
    /// @param _idleToken Idle Token address
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Calculates the balance of Total idle Tokens Contract hasv
    /// @return balance of Idle Tokens
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw
    /// @param tokens Amount of tokens
    /// return Number of shares
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    /// @notice Calculates the number of tokens a user has in the yield source
    /// @param shares Amount of shares
    /// return Number of tokens
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    /// @notice Deposit asset tokens to Idle
    /// @param mintAmount The amount of asset tokens to be deposited
    /// @return 0 if successful 
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param mintAmount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.
    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address
    /// @dev This function is only callable by the owner or asset manager
    /// @param erc20Token The ERC20 token to transfer
    /// @param to The recipient of the tokens
    /// @param amount The amount of tokens to transfer
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1555,160,"[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource
The `redeemToken` function in IdleYieldSource uses redeemedShare instead of redeemAmount as the input parameter when calling redeemIdleToken of the Idle yield source. As a result, users could get fewer underlying tokens than they should.
When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected.
 [H-05] IdleYieldSource doesn't use mantissa calculations
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.
For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalUnderlyingAssets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.
Recommend implementing mantissa calculations like in the contract for the AAVE yield.
  [M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits
Function `timelockDepositTo` The contract uses _msgSender() to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.
While the code handles this separation of role in most cases, it misses doing so in timelockDepositTo() function where it accounts the _timelockBalances to the operator address instead of the user specified to address. It assumes they are the same. The corresponding usage in _mintTimelock() which is called from withdrawWithTimelockFrom() uses the user specified 'from' address and not the _msgSender(). Therefore the corresponding usage in timelockDepositTo() should be the same.
In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of _timelockBalances.
",3,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";



contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    
    event IdleYieldSourceInitialized(address indexed idleToken);

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    
    
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    
    
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    
    
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    
    
    
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    
    
    
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    
    
    
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    
    
    
    
    
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    
    
    
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1010,2,1,"Based on the comprehensive review of the IdleYieldSource contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in supplyTokenTo and redeemToken methods"",
        ""Analyze potential integer overflow/underflow risks in share calculation methods (_tokenToShares, _sharesToToken)"",
        ""Check for potential unauthorized access in external method calls"",
        ""Validate SafeERC20Upgradeable usage and approval mechanisms"",
        ""Review potential edge cases in token conversion logic""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Fully analyze the AssetManager contract's access control implementation"",
        ""Verify the scope of onlyOwnerOrAssetManager modifier permissions"",
        ""Check transferERC20 method's access control and restriction logic"",
        ""Validate initialize method's access and initialization protection""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Thoroughly review Idle Finance protocol integration risks"",
        ""Validate IIdleToken interface interactions (mintIdleToken, redeemIdleToken)"",
        ""Check for potential oracle manipulation or dependency risks"",
        ""Analyze token approval mechanism with max uint256 value for security implications""
      ]
    },
    {
      ""Area"": ""Mathematical Precision"",
      ""Tasks"": [
        ""Audit _tokenToShares and _sharesToToken methods for potential rounding errors"",
        ""Verify total supply and asset tracking mechanisms"",
        ""Check division operations for potential precision loss"",
        ""Validate share calculation under various deposit/withdrawal scenarios""
      ]
    },
    {
      ""Area"": ""Error Handling & Failure Scenarios"",
      ""Tasks"": [
        ""Identify and document potential failure modes in token deposits and withdrawals"",
        ""Verify error handling in external contract calls"",
        ""Check for appropriate error messages and revert conditions"",
        ""Assess contract's behavior during unexpected token transfer scenarios""
      ]
    },
    {
      ""Area"": ""Governance & Emergency Controls"",
      ""Tasks"": [
        ""Review lack of emergency withdrawal mechanism"",
        ""Analyze owner's capabilities in managing contract assets"",
        ""Check for potential centralization risks in contract design"",
        ""Validate sponsor method's potential abuse vectors""
      ]
    },
    {
      ""Area"": ""Performance & Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in key methods (supplyTokenTo, redeemToken)"",
        ""Review storage variable usage and optimization opportunities"",
        ""Check for redundant computations or inefficient algorithms"",
        ""Evaluate method complexity and potential optimization strategies""
      ]
    },
    {
      ""Area"": ""Compliance & Standard Adherence"",
      ""Tasks"": [
        ""Verify full ERC20 standard implementation"",
        ""Check compatibility with IProtocolYieldSource interface"",
        ""Validate upgradeable contract pattern implementation"",
        ""Ensure proper event emissions for critical state changes""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive audit dimensions, prioritizing security and functional correctness.
2. Tasks are specific, actionable, and directly address potential vulnerabilities identified in the initial analysis.
3. The approach systematically breaks down complex contract interactions and potential risk areas.
4. Each task is designed to provide clear guidance for an in-depth, methodical audit process.

Recommended Next Steps:
- Conduct a detailed review following these task categories
- Document findings, potential vulnerabilities, and recommended mitigations
- Provide a comprehensive report with actionable improvement suggestions

Would you like me to elaborate on any specific task or provide more detailed insights into the audit approach?","After analyzing the provided smart contract code, here's my comprehensive audit:

{
  ""ReviewingTheCode"": ""This contract, IdleYieldSource, appears to be a yield aggregator that integrates with the Idle Finance protocol. It allows users to deposit tokens into Idle's yield-generating strategies while providing an ERC20-like interface for representing their shares. The contract is upgradeable and implements various security features including reentrancy protection."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""IdleYieldSource"",
    ""Purpose"": ""To serve as a yield source for PoolTogether by interacting with Idle Finance, allowing users to deposit tokens, earn yield, and redeem their tokens with accrued interest."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IProtocolYieldSource"",
        ""Initializable"",
        ""ReentrancyGuardUpgradeable"",
        ""ERC20Upgradeable"",
        ""AssetManager""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""./interfaces/pooltogether/IProtocolYieldSource.sol"",
        ""./interfaces/idle/IIdleToken.sol"",
        ""./interfaces/idle/IIdleTokenHelper.sol"",
        ""./access/AssetManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""idleToken"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Idle Finance yield-generating token""
      },
      {
        ""Name"": ""underlyingAsset"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the underlying token that is deposited (e.g., DAI, USDC)""
      },
      {
        ""Name"": ""totalUnderlyingAssets"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the total amount of underlying assets deposited""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the Idle token address and sets up approvals"",
        ""Parameters"": [""_idleToken: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the address of the underlying token"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""balanceOfToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the token balance of a user by converting their shares to tokens"",
        ""Parameters"": [""addr: address""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_totalShare"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Gets the total Idle tokens held by the contract"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_tokenToShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts token amount to share amount"",
        ""Parameters"": [""tokens: uint256""],
        ""Returns"": [""shares: uint256""]
      },
      {
        ""Name"": ""_sharesToToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts share amount to token amount"",
        ""Parameters"": [""shares: uint256""],
        ""Returns"": [""tokens: uint256""]
      },
      {
        ""Name"": ""_depositToIdle"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits tokens to Idle Finance and returns the minted Idle tokens"",
        ""Parameters"": [""mintAmount: uint256""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""supplyTokenTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to deposit tokens and assign shares to a specified address"",
        ""Parameters"": [""mintAmount: uint256"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemToken"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to redeem their shares for the underlying token"",
        ""Parameters"": [""redeemAmount: uint256""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""transferERC20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner or asset manager to transfer ERC20 tokens from the contract"",
        ""Parameters"": [""erc20Token: address"", ""to: address"", ""amount: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""sponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to deposit tokens without receiving shares (sponsorship)"",
        ""Parameters"": [""amount: uint256""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IIdleToken - Used to interact with the Idle Finance protocol for depositing tokens and minting/redeeming Idle tokens"",
    ""IERC20Upgradeable - Used for standard ERC20 token operations like transfer, approve, and transferFrom"",
    ""AssetManager - Custom contract that likely provides role-based access control""
  ],
  
  ""SpecialMechanisms"": [
    ""Upgradeable Proxy Pattern - Uses OpenZeppelin's upgradeable contracts pattern with initializer instead of constructor"",
    ""Share-based accounting - Uses a share model to track user deposits and proportional ownership of the yield-bearing assets"",
    ""Reentrancy Protection - Uses OpenZeppelin's ReentrancyGuard to prevent reentrancy attacks""
  ],
  
  ""Questions"": [
    ""What is the implementation of the AssetManager contract and what roles/permissions does it define?"",
    ""The onlyOwnerOrAssetManager modifier is used but not defined in this contract - it's likely in the AssetManager contract"",
    ""Does the contract properly handle the scenario where Idle token's value decreases (e.g., due to a hack or loss in the underlying protocol)?"",
    ""The _tokenToShares and _sharesToToken functions may have rounding issues that could be exploited - needs further analysis"",
    ""Is there a specific reason why the contract does not implement an emergencyWithdraw function?"",
    ""How does the contract handle accrued rewards from the Idle protocol?"",
    ""The contract uses approve with max uint256 value which is generally not recommended - what's the reasoning behind this approach?""
  ]
}

In summary, this contract serves as a yield source adapter for PoolTogether by integrating with Idle Finance's yield-generating tokens. It allows users to deposit underlying tokens (like stablecoins) which are then invested into Idle's strategies. The contract mints shares to users representing their proportional ownership of the pooled assets, and allows them to redeem these shares for their original tokens plus any accrued yield. The contract includes security features like reentrancy protection and access control mechanisms, but there are several aspects that warrant closer examination, particularly around share calculations, external interactions, and emergency handling scenarios.","I'll analyze the provided findings, combine similar issues, and present them in the requested format.

{
  ""Findings"": [
    {
      ""Issue"": ""Inconsistent accounting in redeemToken and sponsor functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The redeemToken function reduces totalUnderlyingAssets by the requested amount rather than the actual redeemed amount. If redeemedUnderlyingAsset differs from redeemAmount, the contract's accounting becomes inaccurate. Similarly, the sponsor function calls _depositToIdle but doesn't update totalUnderlyingAssets, creating a discrepancy between actual and tracked assets."",
      ""Impact"": ""These discrepancies lead to incorrect totalUnderlyingAssets values, affecting all subsequent token-to-shares conversions. This enables potential exploitation where users can deposit and immediately withdraw more than they put in, draining funds or allowing value extraction. Early depositors may be disadvantaged while later users benefit unfairly."",
      ""Location"": ""redeemToken function, sponsor function""
    },
    {
      ""Issue"": ""Incorrect Asset Accounting and Yield Distribution"",
      ""Severity"": ""High"",
      ""Description"": ""The contract doesn't properly update totalUnderlyingAssets to account for yield accrued in Idle Finance. The functions _tokenToShares and _sharesToToken use totalUnderlyingAssets for calculations, but this value only tracks deposits and withdrawals, not the actual value of underlying assets that increases over time due to interest."",
      ""Impact"": ""Users receive incorrect share calculations, potentially leading to value extraction. Early withdrawers could receive less than their fair share of yield, while later withdrawers receive more. This creates an incentive for users to time their withdrawals after yield accrual but before totalUnderlyingAssets is updated."",
      ""Location"": ""Functions _tokenToShares, _sharesToToken, supplyTokenTo, redeemToken""
    },
    {
      ""Issue"": ""Potential Price Manipulation"",
      ""Severity"": ""High"",
      ""Description"": ""The contract calculates share prices based on totalUnderlyingAssets and _totalShare(). An attacker could manipulate these values by being the first depositor with a small amount, then donating tokens directly to the contract to artificially inflate the share price."",
      ""Impact"": ""This could allow the attacker to extract value from subsequent depositors, as their deposits would receive fewer shares than they should."",
      ""Location"": ""Functions _tokenToShares() and _sharesToToken()""
    },
    {
      ""Issue"": ""Integer Overflow Vulnerability in _tokenToShares"",
      ""Severity"": ""High"",
      ""Description"": ""The _tokenToShares function performs division after multiplication which can lead to precision loss. More importantly, when calculating (tokens * _totalShare()) / totalUnderlyingAssets, if tokens * _totalShare() is large enough, it could cause an overflow before the division occurs, despite using Solidity 0.8.4 which has built-in overflow protection. This risk is particularly present when totalUnderlyingAssets is very small compared to _totalShare()."",
      ""Impact"": ""This could lead to incorrect share calculations, potentially allowing users to mint more shares than they should receive, leading to theft of funds from other users."",
      ""Location"": ""Function _tokenToShares()""
    },
    {
      ""Issue"": ""Reentrancy Risk in redeemToken Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the redeemToken function uses the nonReentrant modifier, it performs state changes before external calls. The function first updates totalUnderlyingAssets and then calls the external redeemIdleToken function before transferring tokens. If the external calls fail after state changes, the state could be left inconsistent."",
      ""Impact"": ""If the IIdleToken contract behaves maliciously or has vulnerabilities, an attacker might be able to exploit the state changes in redeemToken, potentially leading to theft of funds or inconsistent state. If the external calls fail, the contract's accounting would be incorrect."",
      ""Location"": ""redeemToken function""
    },
    {
      ""Issue"": ""Missing slippage protection in deposit and redeem operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""When depositing tokens via supplyTokenTo or redeeming via redeemToken, there's no minimum expected output parameter to protect users from slippage. The functions call IIdleToken.mintIdleToken and redeemIdleToken without any slippage protection, which could result in front-running attacks or sandwich attacks."",
      ""Impact"": ""Users might receive fewer shares or tokens than expected due to front-running, market manipulation, or high slippage during the minting/redemption process, potentially leading to financial loss."",
      ""Location"": ""supplyTokenTo, redeemToken, and _depositToIdle functions""
    },
    {
      ""Issue"": ""Precision Loss and Rounding Errors in Share Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions _tokenToShares and _sharesToToken perform division operations that could result in precision loss due to integer division. In particular, when users deposit or withdraw small amounts, they might receive slightly fewer shares than expected or get back slightly less tokens than they should."",
      ""Impact"": ""Users may lose small amounts of value due to rounding. Over time, these rounding errors could accumulate, potentially benefiting either the protocol or certain users at the expense of others. This could lead to loss of funds or the contract gradually leaking value."",
      ""Location"": ""Functions _tokenToShares and _sharesToToken""
    },
    {
      ""Issue"": ""Missing Validation for Zero Address in initialize Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function does not validate that the _idleToken parameter is not the zero address or that it's a contract that adheres to the expected interface. This could lead to the contract being initialized with an invalid idleToken address."",
      ""Impact"": ""If the contract is initialized with a zero address or incorrect contract, it would render the contract unusable and funds could be permanently locked due to the initializer pattern preventing reinitialization."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Lack of input validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate inputs in several functions. For example, it doesn't check if mintAmount or redeemAmount is greater than zero in supplyTokenTo and redeemToken respectively, or that addresses are non-zero in functions like supplyTokenTo and transferERC20."",
      ""Impact"": ""This could lead to unnecessary gas consumption, confusing transaction results, or even locked funds if critical contract addresses are set to zero."",
      ""Location"": ""supplyTokenTo function, redeemToken function, transferERC20 function""
    },
    {
      ""Issue"": ""No Emergency Withdrawal Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks an emergency withdrawal mechanism that could be used if the underlying IdleToken contract has an issue or is compromised."",
      ""Impact"": ""If the IdleToken contract is compromised or experiences operational issues, user funds could be locked in this contract with no way to recover them."",
      ""Location"": ""General contract design""
    },
    {
      ""Issue"": ""No timelock or delay mechanism for ownership transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from AssetManager and Ownable (through __Ownable_init()) but doesn't implement a timelock or delay for ownership transfers. If the owner's private key is compromised, an attacker could immediately transfer ownership."",
      ""Impact"": ""A compromised owner account could immediately transfer ownership to an attacker, who could then exploit privileged functions like transferERC20."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Inadequate initialization of ERC20Upgradeable and ReentrancyGuard"",
      ""Severity"": ""Medium"",
      ""Description"": ""The initialize function does not call __ERC20_init to set token name and symbol, despite inheriting from ERC20Upgradeable. Similarly, it never calls __ReentrancyGuard_init() which is required for proper upgradeable contracts initialization."",
      ""Impact"": ""Lack of proper token metadata can cause issues with blockchain explorers, wallets, and other applications. The reentrancy protection might not work as expected, potentially leaving the contract vulnerable to reentrancy attacks despite having the nonReentrant modifier."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Permanent approval to IdleToken contract"",
      ""Severity"": ""Low"",
      ""Description"": ""In the initialize function, the contract approves the maximum possible uint256 amount to the idleToken contract. While this saves gas by reducing the need for repeated approvals, it represents a permanent approval that cannot be revoked if the IdleToken contract is compromised."",
      ""Impact"": ""If the IdleToken contract is compromised, an attacker could drain all approved underlying assets from this contract."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Missing return value check for token operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't validate the return values from IdleToken operations. For example, in _depositToIdle, there's no check that the returned amount is reasonable. Similarly, in the initialize function, the contract uses safeApprove but doesn't check the return value."",
      ""Impact"": ""Users could receive significantly fewer shares or tokens than expected without any warning or reversion of the transaction. If the approval fails silently, the contract would not be able to interact properly with the Idle protocol."",
      ""Location"": ""_depositToIdle function, initialize function""
    },
    {
      ""Issue"": ""Missing event emission in initialize function"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract emits an IdleYieldSourceInitialized event, it doesn't emit events for the ERC20Upgradeable and ReentrancyGuardUpgradeable initializations."",
      ""Impact"": ""Lack of complete initialization events makes it harder to track the contract's initialization state, though it doesn't directly impact security."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""No mechanism to update idleToken address"",
      ""Severity"": ""Low"",
      ""Description"": ""Once initialized, there's no function to update the idleToken address if needed, such as in case of protocol upgrades or migrations."",
      ""Impact"": ""If the Idle protocol upgrades its tokens or contracts, this yield source would be unable to migrate, potentially leading to stuck funds or reduced yields."",
      ""Location"": ""Contract-wide""
    },
    {
      ""Issue"": ""Missing access control for sponsor function"",
      ""Severity"": ""Low"",
      ""Description"": ""The sponsor function is publicly accessible and allows anyone to sponsor the yield source. This may not be a vulnerability per se, but it should be noted that any user can increase the value of the pool without receiving shares in return."",
      ""Impact"": ""Users might accidentally call the sponsor function instead of supplyTokenTo, effectively donating their tokens without receiving any shares."",
      ""Location"": ""sponsor function""
    },
    {
      ""Issue"": ""No implementation of important ERC20 functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits from ERC20Upgradeable but doesn't override important functions like transfer, transferFrom to properly update totalUnderlyingAssets. If users transfer shares directly using ERC20 functions, the accounting of totalUnderlyingAssets remains unchanged."",
      ""Impact"": ""Direct transfers of shares between users would not update the totalUnderlyingAssets, potentially leading to accounting inconsistencies."",
      ""Location"": ""Throughout the contract (missing implementations)""
    },
    {
      ""Issue"": ""No Functionality to Handle Rewards"",
      ""Severity"": ""Low"",
      ""Description"": ""Idle Finance typically provides governance token rewards, but the contract lacks explicit functionality to claim and handle these rewards."",
      ""Impact"": ""Rewards may accumulate without a mechanism to distribute them to users or reinvest them, potentially reducing overall yield."",
      ""Location"": ""Throughout the contract - missing functionality""
    },
    {
      ""Issue"": ""No Events for Key State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't emit events for important state changes like totalUnderlyingAssets updates, making it harder to track the contract's state off-chain."",
      ""Impact"": ""Reduced transparency and difficulty in monitoring contract state, which can complicate auditing and user trust."",
      ""Location"": ""Throughout the contract, particularly in functions that modify totalUnderlyingAssets""
    }
  ],
  ""IssueNumber"": 52,
  ""OutputList"": 20
}",403.1323239803314,48333.0,32.0,"### **Output**

---

**[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Report Description**:
The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should. When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.

**Match in Response List**:
Matches with the issue titled **""Inconsistent accounting in redeemToken and sponsor functions""**.

**Validation**:
**Partially Correct**. The response identifies the issue of inconsistent accounting in the `redeemToken` function but focuses on the discrepancy between `totalUnderlyingAssets` and the actual redeemed amount. While this is related, it does not explicitly address the core issue of using `redeemedShare` instead of `redeemAmount`, which directly impacts user token redemption. The response partially covers the issue but misses the critical detail of the incorrect parameter usage.

---

**[H-05] IdleYieldSource doesn't use mantissa calculations**

**Report Description**:
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given. For example, say I deposit 1 token, expecting 1 share in return. On L95, if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares. Recommend implementing mantissa calculations like in the contract for the AAVE yield.

**Match in Response List**:
Matches with the issue titled **""Precision Loss and Rounding Errors in Share Calculations""**.

**Validation**:
**Correct**. The response accurately identifies the issue of precision loss and rounding errors in share calculations, which aligns with the reported issue of missing mantissa calculations. The response explains the impact of integer division and how it can lead to incorrect share calculations, which is consistent with the report's concerns.

---

**[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

**Report Description**:
Function `timelockDepositTo`. The contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be. While the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified `to` address. It assumes they are the same. The corresponding usage in `_mintTimelock()` which is called from `withdrawWithTimelockFrom()` uses the user specified 'from' address and not the `_msgSender()`. Therefore the corresponding usage in `timelockDepositTo()` should be the same. In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of `_timelockBalances`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue at all. The issue involves a critical assumption in the `timelockDepositTo` function that could lead to failed deposits in meta-transaction scenarios. This is a significant oversight in the response list, as it directly impacts the functionality and security of the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] IdleYieldSource doesn't use mantissa calculations**

**Partially Correct Matches**:

- **[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Missed Issues from Issue Report**:

- **[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

---","```
1. Precision Loss and Rounding Errors in Share Calculations
```",0.05
YearnV2YieldSource.sol,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";


/// @title Yield source for a PoolTogether prize pool that generates yield by depositing into Yearn Vaults.
/// @dev This contract inherits from the ERC20 implementation to keep track of users deposits
/// @dev This is a generic contract that will work with main Yearn Vaults. Vaults using v0.3.2 to v0.3.4 included
/// @dev are not compatible, as they had dips in shareValue due to a small miscalculation
/// @notice Yield Source Prize Pools subclasses need to implement this interface so that yield can be generated.
contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    /// @notice Yearn Vault which manages `token` to generate yield
    IYVaultV2 public vault;
    /// @dev Deposit Token contract address
    IERC20Upgradeable internal token; 
    /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS
    uint256 public maxLosses = 0; // 100% would be 10_000

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    /// @notice Emitted when the yield source is initialized
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    /// @notice Emitted when the Max Losses accepted when withdrawing from yVault are changed
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Initializes the yield source with 
    /// @param _vault YearnV2 Vault in which the Yield Source will deposit `token` to generate Yield
    /// @param _token Underlying Token / Deposit Token
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    /// @notice Returns the ERC20 asset token used for deposits
    /// @return The ERC20 asset token address
    function depositToken() external view override returns (address) {
        return address(token);
    }

    /// @notice Returns user total balance (in asset tokens). This includes the deposits and interest.
    /// @param addr User address
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Supplies asset tokens to the yield source
    /// @dev Shares corresponding to the number of tokens supplied are mint to the user's balance
    /// @dev Asset tokens are supplied to the yield source, then deposited into Aave
    /// @param _amount The amount of asset tokens to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        // NOTE: we have to deposit after calculating shares to mint
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    /// @notice Redeems asset tokens from the yield source
    /// @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance
    /// @dev Asset tokens are withdrawn from Yearn's Vault, then transferred from the yield source to the user's wallet
    /// @param amount The amount of asset tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    // ************************ INTERNAL FUNCTIONS ************************

    /// @notice Deposits full balance (or max available deposit) into Yearn's Vault
    /// @dev if deposit limit is reached, tokens will remain in the Yield Source and
    /// @dev they will be queued for retries in subsequent deposits
    /// @return The actual amount of shares that were received for the deposited tokens
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; // NOTE: for gas usage
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        // this will deposit full balance (for cases like not enough room in Vault)
        return v.deposit();
    }

    /// @notice Withdraws requested amount from Vault
    /// @dev Vault withdrawal function required amount of shares to be redeemed
    /// @dev Losses are accepted by the Yield Source to avoid funds being locked in the Vault if something happened
    /// @param amount amount of asset tokens to be redeemed
    /// @return Tokens received from the Vault
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        // we accept losses to avoid being locked in the Vault (if losses happened for some reason)
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    /// @notice Returns the amount of shares of yearn's vault that the Yield Source holds
    /// @return Balance of vault's shares holded by Yield Source
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    /// @notice Ratio between yShares and underlying token
    /// @dev use this to convert from shares to deposit tokens and viceversa
    /// @dev (see _tokenToYShares & _ySharesToToken)
    /// @return Price per vault's share
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    /// @notice Balance of deposit token held in the Yield Source
    /// @return balance of deposit token
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    /// @notice Total Assets under Management by Yield Source, denominated in Deposit Token
    /// @dev amount of deposit token held in Yield Source + investment (amount held in Yearn's Vault)
    /// @return Total AUM denominated in deposit Token
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    /// @notice Support function to retrieve used by Vault
    /// @dev used to correctly scale prices 
    /// @return decimals of vault's shares (and underlying token)
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    // ************************ CALCS ************************

    /// @notice Converter from deposit token to yShares (yearn vault's shares)
    /// @param tokens Amount of tokens to be converted
    /// @return yShares to redeem to receive `tokens` deposit token
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    /// @notice Converter from deposit yShares (yearn vault's shares) to token 
    /// @param yShares Vault's shares to be converted
    /// @return tokens that will be received if yShares shares are redeemed
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    /// @notice Function to calculate the amount of Yield Source shares equivalent to a deposit tokens amount
    /// @param tokens amount of tokens to be converted
    /// @return shares number of shares equivalent to the amount of tokens
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    /// @notice Function to calculate the amount of Deposit Tokens equivalent to a Yield Source shares amount
    /// @param shares amount of Yield Source shares to be converted
    /// @dev used to calculate how many shares to mint / burn when depositing / withdrawing
    /// @return tokens number of tokens equivalent (in value) to the amount of Yield Source shares
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    /// @notice Pure support function to compare strings
    /// @param a One string
    /// @param b Another string
    /// @return Whether or not the strings are the same or not
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
",2782,280,"[H-02] YearnV2YieldSource wrong subtraction in withdraw
When withdrawing function `_withdrawFromVault` from the vault, one redeems yTokens for tokens, thus the token balance of the contract should increase after withdrawal. But the contract subtracts the currentBalance from the previousBalance:
``` uint256 yShares = _tokenToYShares(amount);
uint256 previousBalance = token.balanceOf(address(this));
// we accept losses to avoid being locked in the Vault (if losses happened for some reason)
if(maxLosses != 0) {
    vault.withdraw(yShares, address(this), maxLosses);
} else {
    vault.withdraw(yShares);
}
uint256 currentBalance = token.balanceOf(address(this));
// @audit-issue this seems wrong
return previousBalance.sub(currentBalance);
```
All vault withdrawals fail due to the integer underflow as the previousBalance is less than currentBalance. Users won't be able to get back their investment.
  [M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS

The `_depositInVault()` function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.
However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function:
“// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'""
If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible. See similar Medium-severity finding M03.
",2,"pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";







contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    
    IYVaultV2 public vault;
    
    IERC20Upgradeable internal token; 
    
    uint256 public maxLosses = 0; 

    
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    
    
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    
    
    function depositToken() external view override returns (address) {
        return address(token);
    }

    
    
    
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    
    
    
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    
    
    
    
    
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    
    
    
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    

    
    
    
    
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; 
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        
        return v.deposit();
    }

    
    
    
    
    
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    
    
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    
    
    
    
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    
    
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    
    
    
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    
    
    
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    

    
    
    
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    
    
    
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    
    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    
    
    
    
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",1523,1,1,"Based on the detailed analysis, here's a comprehensive audit task list for the YearnV2YieldSource contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in supplyTokenTo, redeemToken, and sponsor functions"",
        ""Check for potential integer overflow/underflow in mathematical calculations"",
        ""Validate SafeMath library usage across all arithmetic operations"",
        ""Audit token approval mechanisms, especially in _depositInVault method"",
        ""Examine potential attack vectors in share calculation methods (_tokenToShares, _sharesToToken)""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review onlyOwner modifier implementation for setMaxLosses function"",
        ""Verify initialization process prevents multiple initializations"",
        ""Check for potential privilege escalation risks in owner-controlled functions"",
        ""Validate ownership transfer mechanisms and potential centralization risks""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit Yearn vault interaction methods for potential external call vulnerabilities"",
        ""Verify vault API version compatibility check logic"",
        ""Examine token transfer and approval mechanisms"",
        ""Check maxLosses parameter implementation for potential manipulation""
      ]
    },
    {
      ""Area"": ""Token Economics & Accounting"",
      ""Tasks"": [
        ""Validate share calculation logic in _tokenToShares and _sharesToToken methods"",
        ""Verify total supply and balance calculations under different scenarios"",
        ""Check handling of tokens with different decimal implementations"",
        ""Audit sponsor function for potential economic exploit vectors""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Test initialize function with various vault and token configurations"",
        ""Verify behavior with zero balance and zero total supply scenarios"",
        ""Check handling of tokens with transfer fees or unusual ERC20 implementations"",
        ""Test maximum loss parameter boundary conditions""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review internal view function gas efficiency"",
        ""Analyze repeated calculations and potential optimization opportunities"",
        ""Check token approval mechanism for unnecessary repeated approvals"",
        ""Evaluate computational complexity of share conversion methods""
      ]
    },
    {
      ""Area"": ""Upgrade and Proxy Compatibility"",
      ""Tasks"": [
        ""Verify OpenZeppelin upgradeable contract implementation"",
        ""Check for potential storage layout conflicts in future upgrades"",
        ""Validate initialization pattern and constructor logic"",
        ""Ensure proper use of initializer modifier""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify ERC20 standard compliance in inherited implementation"",
        ""Check IYieldSource interface adherence"",
        ""Validate event emission for critical state changes"",
        ""Review token interaction standards and compatibility""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list comprehensively covers potential vulnerabilities identified in the initial analysis.
2. Each area targets specific risks observed in the contract's implementation.
3. Tasks are designed to be specific, actionable, and directly related to the contract's unique characteristics.
4. The breakdown considers both technical implementation details and potential economic attack vectors.

Recommended Next Steps:
- Use this task list as a structured approach to conducting a thorough smart contract audit
- Prioritize high-risk areas like security vulnerabilities and external interactions
- Perform systematic testing for each identified task
- Document findings, potential improvements, and recommended remediation strategies

The task list provides a robust framework for a comprehensive security review of the YearnV2YieldSource contract.","After reviewing the smart contract carefully, here's my detailed analysis:

{
  ""ReviewingTheCode"": ""I've analyzed a YearnV2YieldSource contract which serves as a yield source for funds using Yearn Finance V2 vaults. The contract allows users to deposit tokens, which are then invested in a Yearn V2 vault to earn yield. The contract tracks user shares and handles deposits and withdrawals, applying the specified maximum acceptable loss parameter during withdrawals."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""YearnV2YieldSource"",
    ""Purpose"": ""Provides an integration with Yearn Finance V2 vaults to earn yield on deposited tokens, implementing the IYieldSource interface and managing token deposits, withdrawals, and yield distribution"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IYieldSource"", ""ERC20Upgradeable"", ""OwnableUpgradeable"", ""ReentrancyGuardUpgradeable""],
      ""Imports"": [
        ""IYieldSource"",
        ""IYVaultV2"",
        ""SafeMathUpgradeable"",
        ""OwnableUpgradeable"",
        ""ERC20Upgradeable"",
        ""IERC20Upgradeable"",
        ""SafeERC20Upgradeable"",
        ""ReentrancyGuardUpgradeable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""vault"",
        ""Type"": ""IYVaultV2"",
        ""Purpose"": ""Reference to the Yearn V2 vault where funds are deposited""
      },
      {
        ""Name"": ""token"",
        ""Type"": ""IERC20Upgradeable"",
        ""Purpose"": ""The underlying token that users deposit and withdraw""
      },
      {
        ""Name"": ""maxLosses"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum acceptable loss during withdrawals (in basis points, 0-10000)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with a specified vault and token"",
        ""Parameters"": [""IYVaultV2 _vault"", ""IERC20Upgradeable _token""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxLosses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the maximum acceptable loss parameter"",
        ""Parameters"": [""uint256 _maxLosses""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositToken"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the address of the underlying token"",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""balanceOfToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the token balance of a user based on their shares"",
        ""Parameters"": [""address addr""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""supplyTokenTo"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to deposit tokens and assign shares to a specified address"",
        ""Parameters"": [""uint256 _amount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to redeem their shares for tokens"",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""sponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows external sponsorship (donations) to increase the value for all shareholders"",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_depositInVault"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits all available tokens in the Yearn vault"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_withdrawFromVault"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws tokens from the Yearn vault with optional maxLosses parameter"",
        ""Parameters"": [""uint amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_balanceOfYShares"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the contract's balance of Yearn vault shares"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_pricePerYShare"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the current price per share from the Yearn vault"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_balanceOfToken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the contract's balance of the underlying token"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_totalAssetsInToken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the total assets controlled by the contract in terms of the underlying token"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_vaultDecimals"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns the number of decimals used by the vault"",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_tokenToYShares"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Converts token amount to equivalent Yearn vault shares"",
        ""Parameters"": [""uint256 tokens""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_ySharesToToken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Converts Yearn vault shares to equivalent token amount"",
        ""Parameters"": [""uint256 yShares""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_tokenToShares"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Converts token amount to contract shares"",
        ""Parameters"": [""uint256 tokens""],
        ""Returns"": [""uint256 shares""]
      },
      {
        ""Name"": ""_sharesToToken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Converts contract shares to token amount"",
        ""Parameters"": [""uint256 shares""],
        ""Returns"": [""uint256 tokens""]
      },
      {
        ""Name"": ""areEqualStrings"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Utility function to compare strings"",
        ""Parameters"": [""string memory a"", ""string memory b""],
        ""Returns"": [""bool""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IYVaultV2 - Interacts with Yearn V2 vault for deposits and withdrawals"",
    ""IERC20Upgradeable - Interacts with the underlying ERC20 token for transfers and approvals""
  ],
  
  ""SpecialMechanisms"": [
    ""Proxy Pattern - Uses OpenZeppelin's upgradeable contracts"",
    ""Share-based accounting - Uses internal share calculations to track user ownership of the pool"",
    ""Yearn integration - Specific handling of Yearn V2 vaults including maxLosses parameter"",
    ""Vault API version checking - Ensures compatibility with specific vault versions"",
    ""ReentrancyGuard - Prevents reentrancy attacks on critical functions""
  ],
  
  ""Questions"": [
    ""Why does the contract check for vault API version compatibility by explicitly excluding versions 0.3.2, 0.3.3, and 0.3.4? What about newer versions?"",
    ""In the _withdrawFromVault function, the return statement appears to subtract the current balance from the previous balance, which seems inverted. Should this be currentBalance.sub(previousBalance) instead?"",
    ""The balanceOfToken function is marked as external with 'override' but is not view or pure, even though it seems to only read state and not modify it. Was this intentional?"",
    ""In the initialize function, the contract approves the maximum uint256 value to the vault. Is there a risk if the token has non-standard behavior with approvals?""
  ]
}","I've analyzed the input data containing various security issues found in the `YearnV2YieldSource` contract. I've consolidated similar issues and organized them by severity. Here's the result:

{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect Return Value Calculation in _withdrawFromVault"",
      ""Severity"": ""High"",
      ""Description"": ""The function _withdrawFromVault calculates the withdrawn amount by subtracting the current balance from the previous balance (previousBalance.sub(currentBalance)), which is the inverse of what should happen. It should return the difference between current and previous balance (currentBalance.sub(previousBalance)) to represent the actual amount withdrawn."",
      ""Impact"": ""Users will receive incorrect amounts when redeeming tokens. In most cases, the function will return 0 or revert due to underflow in the SafeMath subtraction operation, leading to significant financial loss for users and breaking the core redemption functionality."",
      ""Location"": ""_withdrawFromVault function""
    },
    {
      ""Issue"": ""Incorrect API Version Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract checks for incompatible API versions by explicitly blocking versions 0.3.2, 0.3.3, and 0.3.4. This approach is brittle as new incompatible versions would require contract updates. The validation also uses negative logic (!areEqualStrings) which might be confusing and could lead to accepting incompatible vaults that weren't explicitly blacklisted."",
      ""Impact"": ""If Yearn releases new incompatible vault versions, the contract may interact with them inappropriately unless manually updated. Contract initialization might fail with compatible vault versions or succeed with specifically incompatible versions."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Lack of Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract has a maxLosses parameter for limiting vault withdrawal losses, it doesn't provide proper slippage protection, especially for deposits. The supplyTokenTo function calculates shares before depositing tokens in the vault, but doesn't verify that the expected number of shares was actually received after the deposit."",
      ""Impact"": ""Users might receive fewer shares or tokens than expected, especially during volatile market conditions or under attack scenarios like front-running, leading to unexpected losses."",
      ""Location"": ""supplyTokenTo and _depositInVault functions""
    },
    {
      ""Issue"": ""Reentrancy Risk in Vault Interactions"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract uses ReentrancyGuard for external functions, the interactions with the Yearn vault could potentially be vulnerable to reentrancy attacks if the vault implementation allows callbacks during deposit/withdrawal operations."",
      ""Impact"": ""If the vault contract executes callbacks during transactions or is compromised, it could potentially lead to reentrancy attacks despite the nonReentrant modifiers on the external functions."",
      ""Location"": ""_depositInVault and _withdrawFromVault functions""
    },
    {
      ""Issue"": ""Unchecked Return Value from vault.deposit()"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function _depositInVault calls vault.deposit() but doesn't check or use the return value, which is supposed to be the amount of shares received from the deposit."",
      ""Impact"": ""The contract won't detect if deposits fail or return fewer shares than expected, potentially leading to accounting errors."",
      ""Location"": ""_depositInVault function""
    },
    {
      ""Issue"": ""Potential Token Decimals Mismatch"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses the vault's decimals for calculations but doesn't verify that these match the underlying token's decimals during initialization."",
      ""Impact"": ""If there's a mismatch between token and vault decimals, calculations in _tokenToYShares and _ySharesToToken will be incorrect, leading to wrong amounts being deposited or withdrawn."",
      ""Location"": ""initialize function, _tokenToYShares and _ySharesToToken functions""
    },
    {
      ""Issue"": ""Rounding Errors in Token-Share Conversions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The conversions between tokens and shares in _tokenToShares and _sharesToToken involve division operations that can lead to rounding errors, especially with small amounts. The contract performs division operations before multiplication in several conversion functions, which can lead to precision loss due to integer division truncation."",
      ""Impact"": ""Users might receive slightly fewer tokens or shares than expected, leading to small but cumulative value loss over time, particularly for small amounts."",
      ""Location"": ""_tokenToShares, _sharesToToken, _tokenToYShares, and _ySharesToToken functions""
    },
    {
      ""Issue"": ""No Emergency Withdrawal Functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks emergency withdrawal functions or a pause mechanism that would allow users to exit positions or halt operations in case of critical vulnerabilities or if the Yearn vault becomes compromised."",
      ""Impact"": ""In emergency situations or when vulnerabilities are discovered in the underlying Yearn vault, there's no way to quickly protect user funds, potentially leading to fund loss."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Unlimited Token Approval to Vault"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract approves the vault to spend the maximum possible amount of tokens (type(uint256).max) during initialization and potentially in _depositInVault if the allowance is insufficient. While this is a common pattern, it creates a perpetual approval that can't be revoked and might not work with all ERC20 tokens."",
      ""Impact"": ""If the vault contract is exploited, it could drain all tokens held by this contract. Additionally, some tokens require setting approval to 0 before changing to a new value, which might cause failures with such tokens."",
      ""Location"": ""initialize function and _depositInVault function""
    },
    {
      ""Issue"": ""Missing Events for Critical Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The _depositInVault and _withdrawFromVault functions don't emit events, making it difficult to track these critical operations off-chain. Additionally, the RedeemedToken event emits the requested amount parameter, not the actual amount withdrawn."",
      ""Impact"": ""Reduced transparency and auditability of the contract's operation, making troubleshooting more difficult. It's also harder to track actual withdrawal values, which could lead to confusion when auditing transactions."",
      ""Location"": ""_depositInVault and _withdrawFromVault functions, redeemToken event emission""
    },
    {
      ""Issue"": ""Missing Input Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks validation for certain parameters. For example, there's no check that the amount is non-zero in supplyTokenTo and redeemToken functions, or that addresses are not zero in the initialize function."",
      ""Impact"": ""Users could execute transactions with zero amounts, wasting gas. If zero addresses are provided during initialization, the contract would become unusable."",
      ""Location"": ""supplyTokenTo, redeemToken, and initialize functions""
    },
    {
      ""Issue"": ""No Way to Recover Stuck Tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks functionality to recover ERC20 tokens accidentally sent to it (other than the deposit token) or ETH that might be received when interacting with the vault."",
      ""Impact"": ""Any tokens accidentally sent to the contract or ETH received would be permanently lost as there's no mechanism to retrieve them."",
      ""Location"": ""Entire contract""
    }
  ],
  ""IssueNumber"": 56,
  ""OutputList"": 12
}",378.9364740848541,52510.0,32.0,"### **Output**

---

**[H-02] YearnV2YieldSource wrong subtraction in withdraw**

**Report Description**:
The `_withdrawFromVault` function in the `YearnV2YieldSource` contract incorrectly calculates the withdrawn amount by subtracting the `currentBalance` from the `previousBalance`. This should be the other way around (`currentBalance.sub(previousBalance)`) to represent the actual amount withdrawn. The incorrect subtraction leads to integer underflow, causing withdrawals to fail and preventing users from retrieving their investments.

**Match in Response List**:
Matches with the issue titled **""Incorrect Return Value Calculation in _withdrawFromVault""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect subtraction in the `_withdrawFromVault` function. It correctly explains the impact of this error, which aligns with the reported issue and Solidity best practices for arithmetic operations.

---

**[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

**Report Description**:
The `_depositInVault` function uses `safeApprove()` from OpenZeppelin's SafeERC20 library to set the allowance for the Yearn Vault. However, `safeApprove()` reverts if the allowance is changed between non-zero values, which can occur if the previous allowance was not fully utilized. This can lead to a denial-of-service (DoS) scenario where users are unable to deposit tokens. The recommended approach is to use `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue with `safeApprove()` in the `_depositInVault` function. This is a missed issue that could lead to significant user impact, as described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] YearnV2YieldSource wrong subtraction in withdraw**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

---

### **Conclusion**

The response list effectively addresses the high-severity issue related to the incorrect subtraction in the `_withdrawFromVault` function. However, it misses the medium-severity issue concerning the use of `safeApprove()` in the `_depositInVault` function, which could lead to a denial-of-service scenario. This gap should be addressed to ensure comprehensive coverage of the reported vulnerabilities.","```
1. Incorrect Return Value Calculation in _withdrawFromVault
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is: ""Incorrect Return Value Calculation in _withdrawFromVault"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the total number of items up to rank 1.
   - \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the average precision is simply the precision at rank 1.
   - \( AP = 1.0 \).

**Output**:
```
1.0
```"
BagerYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";

/// @title A pooltogether yield source for badger sett
/// @author Steffel Fenix, 0xkarl
contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}
",830,83,"[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong
Function `balanceOfToken` When suppling to the BadgerYieldSource, some amount of badger is deposited to badgerSett and one receives badgerSett share tokens in return which are stored in the balances mapping of the user. So far this is correct.
The balanceOfToken function should then return the redeemable balance in badger for the user's badgerSett balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of badgerSett) on the badger in the vault:
balances[addr].mul(
  badger.balanceOf(address(badgerSett))
).div(
  badgerSett.totalSupply()
)

However, badger.balanceOf(address(badgerSett)) is only a small amount of badger that is deployed in the vault (""Sett"") due to most of the capital being deployed to the strategies. Therefore, it under-reports the actual balance:
Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. Badger Docs
Any contract or user calling the balanceOf function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.
 [M-02] Return values of ERC20 transfer and transferFrom are unchecked
In the contracts BadgerYieldSource and SushiYieldSource, the return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant (e.g., BADGER). In that case, the transfer fails without being noticed by the calling contract.
If warden's understanding of the BadgerYieldSource is correct, the badger variable should be the BADGER token at address 0x3472a5a71965499acd81997a54bba8d852c6e53d. However, this implementation of BADGER is not ERC20-compliant, which returns false when the sender does not have enough token to transfer (both for transfer and transferFrom). See the source code on Etherscan (at line 226) for more details.
 [M-03] SafeMath not completely used in yield source contracts (overflow) SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 	line 67 in BadgerYieldSource
(amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            )
",3,"pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";



contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    
    
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    
    
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    
    
    
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    
    
    
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",624,1,2,"{'task_list': [{'Area': 'Arithmetic and Calculation Accuracy', 'Tasks': ['Analyze the `requiredShares` calculation in `redeemToken` (`((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)`) to confirm its intended behavior (ceiling division or other).', 'Simulate scenarios in `redeemToken` with different values for `amount`, `totalShares`, and `badgerSettBadgerBalance` to understand the impact of `requiredShares.sub(1)` on the withdrawn amount.', 'Compare the values returned by `badgerSett.balance()` (used in `redeemToken`) and `badger.balanceOf(address(badgerSett))` (used in `balanceOfToken`) under different conditions to verify their consistency. Review the code of `badgerSett` to understand how `balance()` is implemented.', 'Assess the potential for precision loss in the integer division within `balanceOfToken` and `redeemToken`.  Calculate the maximum possible loss in realistic scenarios and determine if it is acceptable.', 'Write unit tests to check edge cases and boundary conditions for the calculation of `requiredShares` and the subsequent share withdrawal in `redeemToken`.']}, {'Area': 'Share Accounting and Balance Consistency', 'Tasks': ['Verify that the `balances` mapping accurately reflects the shares owned by each user within the `BadgerYieldSource` contract. Trace the flow of shares from deposit to redemption.', ""Analyze the impact of the potentially incorrect `requiredSharesBalance` calculation in `redeemToken` on the user's `balances[msg.sender]`. Write a test case to demonstrate the scenario where user ends up with incorrect `balances[msg.sender]`"", 'Audit the `supplyTokenTo` function to ensure that the `balanceDiff` calculation and subsequent update to `balances[to]` are accurate, especially considering potential rounding errors during the deposit into the Sett.', 'Check for any potential inconsistencies between the total supply of the `badgerSett` and the sum of the `balances` mapping in the `BadgerYieldSource` contract.', 'Explore scenarios where a user might manipulate deposits and withdrawals to exploit vulnerabilities in the share accounting mechanism.']}, {'Area': 'External Interactions and Trust Assumptions', 'Tasks': ['Review the interfaces `IBadgerSett` and `IBadger` to fully understand the functions being called and their potential side effects.', 'Evaluate the trust assumptions made regarding the behavior of the `badgerSett` and `badger` contracts. Consider scenarios where these contracts might behave unexpectedly.', 'Check if the contract adequately handles errors or reverts that might occur during calls to `badger.transferFrom`, `badger.approve`, `badgerSett.deposit`, and `badgerSett.withdraw`.', 'Assess the potential impact of changes to the `badgerSett` or `badger` contracts on the functionality of the `BadgerYieldSource` contract.', 'Consider the impact of reentrancy attacks when interacting with external contracts. Analyze the need for reentrancy guards, even if deemed not necessary due to external contracts protecting themselves. Document justification for the final decision.']}, {'Area': 'Security Vulnerabilities', 'Tasks': ['Verify that the use of `SafeMath` is sufficient to prevent arithmetic overflows and underflows in all calculations.', 'Analyze the contract for potential reentrancy vulnerabilities, especially in the `supplyTokenTo` and `redeemToken` functions when interacting with external contracts.', 'Check for any potential denial-of-service (DoS) vulnerabilities, such as those that could arise from extremely large values or unexpected states in the `badgerSett` or `badger` contracts.', ""Assess the contract's vulnerability to front-running attacks, particularly in the `supplyTokenTo` and `redeemToken` functions, and implement mitigation strategies if necessary."", 'Ensure proper input validation for all parameters, especially `amount` in `supplyTokenTo` and `redeemToken`, to prevent unexpected behavior.']}, {'Area': 'Gas Optimization', 'Tasks': ['Identify and eliminate redundant calculations or state variable reads.', 'Optimize the order of operations to minimize gas consumption.', 'Consider using more gas-efficient data types where appropriate.', 'Review the use of immutable variables and constants to reduce storage costs.', 'Assess the gas costs of different execution paths and prioritize optimization efforts accordingly.']}, {'Area': 'Code Quality and Best Practices', 'Tasks': ['Remove the `hardhat/console.sol` import and any associated `console.log` statements before deployment to production.', 'Ensure that the code is well-documented and easy to understand.', 'Follow established Solidity coding conventions and best practices.', 'Write comprehensive unit tests to cover all functionalities and edge cases.', 'Conduct a static analysis of the code using tools like Slither to identify potential vulnerabilities and code quality issues.']}]}","{'ReviewingTheCode': 'The contract `BadgerYieldSource` acts as an adapter for a Badger Sett vault (`IBadgerSett`), making it compliant with the `IYieldSource` interface, likely for integration with systems like PoolTogether. It allows users to deposit Badger tokens (`IBadger`) into the Sett via this contract, tracks their respective shares internally, and allows redemption of the underlying Badger tokens. It uses SafeMath for arithmetic operations.', 'IdentifyingKeyComponents': {'ContractName': 'BadgerYieldSource', 'Purpose': 'To wrap a Badger Sett vault (`IBadgerSett`) and expose it as an `IYieldSource`, allowing deposits and withdrawals of the underlying Badger token (`IBadger`) while tracking user shares.', 'InheritanceAndImports': {'InheritsFrom': ['IYieldSource'], 'Imports': ['IYieldSource', 'SafeMath', 'IBadgerSett', 'IBadger', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'badgerSett', 'Type': 'IBadgerSett private immutable', 'Purpose': 'Reference to the Badger Sett contract where assets are deposited.'}, {'Name': 'badger', 'Type': 'IBadger private immutable', 'Purpose': 'Reference to the Badger ERC20 token contract, which is the deposit asset.'}, {'Name': 'balances', 'Type': 'mapping(address => uint256) private', 'Purpose': 'Tracks the amount of Badger Sett shares owned by each user *through this contract*.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the immutable references to the Badger Sett and Badger token contracts.', 'Parameters': ['address badgerSettAddr', 'address badgerAddr'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'public view override', 'Purpose': 'Returns the address of the underlying token that can be deposited (Badger token). Implements IYieldSource.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'public override', 'Purpose': 'Calculates the amount of underlying Badger token corresponding to the shares held by a user within this contract. Implements IYieldSource.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'public override', 'Purpose': 'Receives Badger tokens from the caller, deposits them into the Badger Sett, and updates the internal share balance for the specified recipient (`to`). Implements IYieldSource.', 'Parameters': ['uint256 amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'public override', 'Purpose': ""Calculates the required shares for a given amount of underlying Badger token, withdraws those shares from the Badger Sett, updates the caller's internal share balance, and transfers the withdrawn Badger tokens to the caller. Implements IYieldSource."", 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}]}, 'ExternalInteractions': ['IBadgerSett: Calls `totalSupply()`, `balanceOf(address)`, `deposit(uint256)`, `withdraw(uint256)`, `balance()`.', 'IBadger (ERC20): Calls `balanceOf(address)`, `transferFrom(address,address,uint256)`, `approve(address,uint256)`, `transfer(address,uint256)`.', 'SafeMath: Used for uint256 arithmetic.', 'hardhat/console.sol: Potentially used for debugging via `console.log` (should be removed in production).'], 'SpecialMechanisms': ['Adapter Pattern: Adapts `IBadgerSett` to the `IYieldSource` interface.', 'Internal Share Tracking: Uses the `balances` mapping to attribute shares held by this contract in the Badger Sett to individual users.', 'Immutable State Variables: `badgerSett` and `badger` addresses are set once at deployment.', 'SafeMath Usage: Protects against arithmetic overflow/underflow (standard for Solidity < 0.8.0).'], 'Questions': ['The calculation for `requiredShares` in `redeemToken` `((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` seems unusual. Is this intended ceiling division or a potential miscalculation? It appears different from standard ceiling division patterns and might calculate shares for `amount + 1`.', 'In `redeemToken`, why is `requiredSharesBalance` calculated as `requiredShares.sub(1)` before calling `badgerSett.withdraw()`? Subtracting 1 seems likely to result in withdrawing fewer shares than necessary, potentially causing the user to receive less than the requested `amount`.', 'What is the difference between `badgerSett.balance()` used in `redeemToken` and `badger.balanceOf(address(badgerSett))` used in `balanceOfToken`? Do they return the same value (total underlying Badger tokens held by the Sett)? Consistency should be ensured.', 'Could precision loss due to integer division in `balanceOfToken` and `redeemToken` calculations be significant?', ""Is there a risk of the user's internal share balance (`balances[msg.sender]`) becoming inaccurate in `redeemToken` due to the potentially incorrect calculation of `requiredSharesBalance`?"", 'The import and potential usage of `hardhat/console.sol` should be removed for production deployment.']}","{'Findings': [{'Issue': 'Incorrect Calculation and Rounding Error in `redeemToken` Leading to Potential Fund Loss or Drain', 'Severity': 'High', 'Description': ""The `redeemToken` function calculates `requiredShares` using `((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` and then calculates `requiredSharesBalance` as `requiredShares.sub(1)`. This logic is flawed: the addition before division is an incorrect way to handle rounding, and the subsequent subtraction of 1 significantly underestimates the shares needed. This can cause users to receive fewer underlying tokens than expected (loss of funds). More critically, if the initial calculation results in `requiredShares` being 0 (possible in edge cases or due to manipulation), the `requiredShares.sub(1)` operation will cause an integer underflow, wrapping to a massive value. Although there's a check `if (requiredShares == 0) return 0;`, the subtraction happens *after* this check in some reported versions, potentially allowing a user to withdraw an extremely large amount, draining the contract. The calculation should accurately determine shares without unnecessary additions or subtractions that introduce errors and vulnerabilities."", 'Impact': ""Users may lose funds by receiving fewer tokens than entitled upon redemption due to rounding errors. A potential integer underflow vulnerability could allow an attacker to drain the contract's funds entirely. Incorrect logic leaves dust amounts."", 'Location': 'BadgerYieldSource.sol: redeemToken function'}, {'Issue': 'Potential Integer Overflow in `redeemToken` Calculation', 'Severity': 'Medium', 'Description': 'In the `redeemToken` function, the calculation `amount.mul(totalShares)` could potentially overflow if both `amount` and `totalShares` are very large. If `amount.mul(totalShares)` overflows, the subsequent addition of `totalShares` might still result in a small number, leading to an incorrect and underestimated `requiredShares` value. This could allow a user to withdraw more badger tokens than they are entitled to based on their actual share.', 'Impact': 'An overflow could lead to users withdrawing more tokens than their share allows, causing losses for other users and potentially enabling theft of funds from the contract.', 'Location': 'BadgerYieldSource.sol: redeemToken function - Calculation of requiredShares'}, {'Issue': 'Unnecessary/Unsafe Approval in `supplyTokenTo` Function', 'Severity': 'Medium', 'Description': 'The `supplyTokenTo` function first transfers tokens from the user, then approves the `badgerSett` contract address for the full `amount`. This approval is unnecessary because the subsequent `badgerSett.deposit(amount)` call typically handles the token transfer into the sett. While the `transferFrom` happens first, mitigating some front-running risks related to the approval itself, granting an explicit approval to the `badgerSett` address is redundant and could pose a security risk if the `badgerSett` contract address were ever compromised or contained a vulnerability related to approvals. It also increases gas costs slightly.', 'Impact': ""Slightly increased gas costs. Introduces a potential (though perhaps unlikely given immutability) attack vector if the `badgerSett` contract were compromised, potentially allowing draining of the `BadgerYieldSource`'s badger balance up to the approved amount."", 'Location': 'BadgerYieldSource.sol: supplyTokenTo function'}, {'Issue': 'Missing Zero Address Validation in Constructor', 'Severity': 'Medium', 'Description': 'The constructor accepts `badgerSettAddr` and `badgerAddr` but does not validate that these addresses are not the zero address (0x00...00). Deploying the contract with a zero address for either dependency would likely render the contract non-functional or lead to unexpected reverts during operation, potentially causing issues for users or locking funds if interactions are attempted.', 'Impact': 'Contract may be deployed in a non-functional state, leading to failed transactions, wasted gas, or inability to use the yield source as intended. Potential for unexpected behavior if operations are attempted on a zero address.', 'Location': 'BadgerYieldSource.sol: Constructor'}, {'Issue': 'Potential Reentrancy Vulnerability via External Calls', 'Severity': 'Medium', 'Description': 'The `supplyTokenTo` and `redeemToken` functions make external calls to `badgerSett.deposit()` and `badgerSett.withdraw()` respectively. If the `BadgerSett` contract is malicious or contains a vulnerability allowing reentrancy, an attacker could potentially call back into the `BadgerYieldSource` contract before the state updates (like balance changes) are complete. This could lead to inconsistent states and potential exploits like draining funds.', 'Impact': 'If the external `BadgerSett` contract is vulnerable to reentrancy, an attacker could potentially steal funds or manipulate the state of the `BadgerYieldSource` contract during deposit or redemption.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions (external calls to badgerSett)'}, {'Issue': 'Potential Front-Running Vulnerability in `supplyTokenTo` and `redeemToken`', 'Severity': 'Medium', 'Description': ""The `supplyTokenTo` and `redeemToken` functions interact with the external `badgerSett` contract. An attacker could observe pending deposit or redeem transactions in the mempool and execute their own transaction (front-running) to manipulate the state of the `badgerSett` (e.g., its share price or balance) just before the user's transaction executes. This could result in the user receiving fewer shares on deposit or fewer underlying tokens on redemption than expected."", 'Impact': 'Users may experience unfavorable exchange rates when depositing or redeeming due to front-running, leading to potential loss of value.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions'}, {'Issue': 'Balance Calculation Susceptible to Manipulation', 'Severity': 'Medium', 'Description': ""The `balanceOfToken` function calculates the underlying token balance represented by shares based on `badgerSett.totalSupply()` and `badger.balanceOf(address(badgerSett))`. If an attacker can manipulate either of these values (e.g., through flash loans affecting the Sett's balance or supply, or manipulating an underlying oracle if the Sett relies on one), they could temporarily inflate or deflate the perceived value of shares. This could be exploited during redemption or potentially in other interacting contracts relying on this view function."", 'Impact': 'An attacker could manipulate the reported share value, potentially allowing them to claim more underlying assets than they are entitled to during redemption, or causing other protocols interacting with this view function to behave incorrectly.', 'Location': 'BadgerYieldSource.sol: balanceOfToken function'}, {'Issue': 'Lack of Slippage Control in `redeemToken`', 'Severity': 'Medium', 'Description': ""The `redeemToken` function calculates the amount of shares to withdraw based on the current state but does not include a parameter for minimum output amount expected. If the state of the `badgerSett` changes significantly (e.g., due to large deposits/withdrawals or underlying asset volatility) between transaction submission and execution, the `badgerSett.withdraw()` call might succeed but return fewer underlying tokens than the user anticipated, or it could revert if the Sett's balance changes unfavorably."", 'Impact': 'Users might receive significantly fewer tokens than expected upon redemption without warning, or their transactions might revert frequently in volatile conditions, leading to poor user experience.', 'Location': 'BadgerYieldSource.sol: redeemToken function'}, {'Issue': 'Potential Division by Zero in `balanceOfToken`', 'Severity': 'Low', 'Description': ""The `balanceOfToken` function performs division by `totalShares` (`badgerSett.totalSupply()`). While it checks if the user's balance (`balances[addr]`) is zero, it does not explicitly check if `totalShares` is zero before the division. If `totalShares` becomes zero (e.g., if all shares are redeemed), subsequent calls to `balanceOfToken` for any address would revert due to division by zero."", 'Impact': 'The `balanceOfToken` view function could become temporarily unusable, causing reverts for callers if the total supply of the badgerSett ever reaches zero.', 'Location': 'BadgerYieldSource.sol: balanceOfToken function'}, {'Issue': 'Lack of Access Control on Public Functions', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` and `redeemToken` functions are public as required by the `IYieldSource` interface and lack specific access control modifiers. While intended for general use, this design assumes that any caller is legitimate. In complex integrations, ensuring that only intended actors (users or specific contracts) interact with these functions might require checks within the functions themselves or in the calling contracts.', 'Impact': 'No direct vulnerability, but increases the attack surface. If the contract were intended to be restricted within a larger system, the lack of explicit access control could lead to unintended interactions or misuse.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions'}, {'Issue': 'Missing Event Emissions for Key State Changes', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical operations like depositing (`supplyTokenTo`) and redeeming (`redeemToken`). Events are essential for off-chain services (like block explorers, analytics platforms, and user interfaces) to monitor contract activity, track user balances, and index historical data efficiently.', 'Impact': 'Reduced transparency and auditability. Makes it harder for users and external tools to track deposits, withdrawals, and balance changes related to this yield source.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo, redeemToken functions'}, {'Issue': 'Inconsistent Use of Balance Reporting Methods', 'Severity': 'Low', 'Description': 'The contract uses `badger.balanceOf(address(badgerSett))` in `balanceOfToken` to get the underlying balance, but `badgerSett.balance()` in `redeemToken`. While these should ideally return the same value representing the total underlying tokens held by the Sett, relying on two different methods introduces potential inconsistency if the `BadgerSett` implementation has nuances between these two functions. Best practice suggests using a single consistent method.', 'Impact': 'Potential for minor discrepancies or unexpected behavior if `badgerSett.balance()` and `badger.balanceOf(address(badgerSett))` do not behave identically in all scenarios.', 'Location': 'BadgerYieldSource.sol: balanceOfToken and redeemToken functions'}], 'IssueNumber': 27, 'OutputList': 12}",199.9503960609436,,,"### **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Report Description**:
The `balanceOfToken` function in `BadgerYieldSource` calculates the redeemable balance of `badger` tokens based on the user's `badgerSett` balance. However, it uses `badger.balanceOf(address(badgerSett))`, which only reflects the small amount of `badger` held in the vault (Sett) and not the majority of funds deployed in strategies. This leads to an under-reporting of the actual balance, causing users to receive incorrect values when querying their balance. This can lead to errors in integrations and computations based on this value.

**Match in Response List**:
Matches with the issue titled **""Balance Calculation Susceptible to Manipulation""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `balanceOfToken` function and correctly notes that the calculation is based on `badger.balanceOf(address(badgerSett))` and `badgerSett.totalSupply()`. However, the response focuses on the susceptibility to manipulation rather than the core issue of under-reporting due to the majority of funds being deployed in strategies. While the response touches on the calculation, it misses the critical detail that the function does not account for funds in strategies, which is the primary concern in the issue report.

---

### **[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

**Report Description**:
In `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked. This could lead to silent failures if the tokens are not ERC20-compliant (e.g., `BADGER`). Specifically, the `BADGER` token returns `false` when the sender does not have enough tokens to transfer, but this return value is not checked, allowing transfers to fail without notice.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked return values for `transfer` and `transferFrom` in `BadgerYieldSource` and `SushiYieldSource`. This is a critical oversight, as it directly impacts the security and reliability of token transfers in these contracts.

---

### **[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Report Description**:
In `BadgerYieldSource`, `SafeMath` is not used consistently, particularly in the calculation of `requiredShares` in the `redeemToken` function. The formula `(amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` could potentially cause arithmetic overflow or underflow, leading to incorrect calculations and potential vulnerabilities.

**Match in Response List**:
Matches with the issue titled **""Potential Integer Overflow in `redeemToken` Calculation""**.

**Validation**:
**Correct**. The response accurately identifies the potential for integer overflow in the `redeemToken` function, specifically in the calculation `amount.mul(totalShares)`. It correctly explains the risks associated with this calculation, which aligns with the issue report's concern about the inconsistent use of `SafeMath` and the potential for arithmetic errors.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Partially Correct Matches**:

- **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Missed Issues from Issue Report**:

- **[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

---

This analysis highlights that while some issues in the `issue` report are partially or fully addressed in the `response_list`, there are significant gaps, particularly in the handling of unchecked ERC20 return values. The response list could be improved by addressing these missed issues and providing more detailed explanations for partially matched issues.","```
1. Potential Integer Overflow in `redeemToken` Calculation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is `Potential Integer Overflow in `redeemToken` Calculation`.
   - This issue appears at **rank 2** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by the rank itself.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Average the precision values**:
   - Since there is only one true positive, the **Average Precision (AP)** is simply the precision at rank 2, which is \( 0.5 \).

**Output**:
```
0.5
```"
PrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";

/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.
/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  /// @dev Emitted when an instance is initialized
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  /// @dev Event emitted when controlled token is added
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  /// @dev Emitted when reserve is captured.
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  /// @dev Event emitted when assets are deposited
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  /// @dev Event emitted when timelocked funds are re-deposited
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when interest is awarded to a winner
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are awarded to a winner
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are transferred out
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC721s are awarded to a winner
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  /// @dev Event emitted when assets are withdrawn instantly
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  /// @dev Event emitted upon a withdrawal with timelock
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  /// @dev Event emitted when timelocked funds are swept back to a user
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  /// @dev Event emitted when the Liquidity Cap is set
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  /// @dev Event emitted when the Credit plan is set
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  /// @dev Event emitted when the Prize Strategy is set
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  /// @dev Emitted when credit is minted
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  /// @dev Emitted when credit is burned
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  /// @dev Reserve to which reserve fees are sent
  RegistryInterface public reserveRegistry;

  /// @dev A linked list of all the controlled tokens
  MappedSinglyLinkedList.Mapping internal _tokens;

  /// @dev The Prize Strategy that this Prize Pool is bound to.
  TokenListenerInterface public prizeStrategy;

  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.
  /// For example, if the maxExitFeeMantissa is ""0.1 ether"", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai
  uint256 public maxExitFeeMantissa;

  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).
  uint256 public maxTimelockDuration;

  /// @dev The total funds that are timelocked.
  uint256 public timelockTotalSupply;

  /// @dev The total funds that have been allocated to the reserve
  uint256 public reserveTotalSupply;

  /// @dev The total amount of funds that the prize pool can hold.
  uint256 public liquidityCap;

  /// @dev the The awardable balance
  uint256 internal _currentAwardBalance;

  /// @dev The timelocked balances for each user
  mapping(address => uint256) internal _timelockBalances;

  /// @dev The unlock timestamps for each user
  mapping(address => uint256) internal _unlockTimestamps;

  /// @dev Stores the credit plan for each token.
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  /// @dev Stores each users balance of credit per token.
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  /// @notice Initializes the Prize Pool
  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.
  /// @param _maxExitFeeMantissa The maximum exit fee size
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  /// @dev Returns the address of the underlying ERC20 asset
  /// @return The address of the asset
  function token() external override view returns (address) {
    return address(_token());
  }

  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.
  /// @return The underlying balance of assets
  function balance() external returns (uint256) {
    return _balance();
  }

  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.
  /// @param to The address receiving the tokens
  /// @param amount The amount of timelocked assets to re-deposit
  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  /// @notice Deposit assets into the Prize Pool in exchange for tokens
  /// @param to The address receiving the newly minted tokens
  /// @param amount The amount of assets to deposit
  /// @param controlledToken The address of the type of token the user is minting
  /// @param referrer The referrer of the deposit
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
  /// @param from The address to redeem tokens from.
  /// @param amount The amount of tokens to redeem for assets.
  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)
  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.
  /// @return The actual exit fee paid
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    // burn the credit
    _burnCredit(from, controlledToken, burnedCredit);

    // burn the tickets
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    // redeem the tickets less the fee
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  /// @notice Limits the exit fee to the maximum as hard-coded into the contract
  /// @param withdrawalAmount The amount that is attempting to be withdrawn
  /// @param exitFee The exit fee to check against the limit
  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.
  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.
  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.
  /// If the existing timelocked funds are still locked, then the incoming
  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.
  /// @param from The address to withdraw from
  /// @param amount The amount to withdraw
  /// @param controlledToken The type of token being withdrawn
  /// @return The timestamp from which the funds can be swept
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.
  /// Note that this will overwrite the previous unlock timestamp.
  /// @param user The user whose timelock balance should increase
  /// @param amount The amount to increase by
  /// @param timestamp The new unlock timestamp
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  /// @notice Updates the Prize Strategy when tokens are transferred between holders.
  /// @param from The address the tokens are being transferred from (0 if minting)
  /// @param to The address the tokens are being transferred to (0 if burning)
  /// @param amount The amount of tokens being trasferred
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      // first accrue credit for their old balance
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    // if we aren't minting
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  /// @notice Returns the balance that is available to award.
  /// @dev captureAwardBalance() should be called first
  /// @return The total amount of assets to be awarded for the current prize
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  /// @notice Captures any available interest as award balance.
  /// @dev This function also captures the reserve fees.
  /// @return The total amount of assets to be awarded for the current prize
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  /// @notice Called by the prize strategy to award prizes.
  /// @dev The amount awarded must be less than the awardBalance()
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of assets to be awarded
  /// @param controlledToken The address of the asset token being awarded
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  /// @notice Called by the Prize-Strategy to award external ERC20 prizes
  /// @dev Used to award any arbitrary tokens held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
  /// @param to The user who is receiving the tokens
  /// @param amount The amount of tokens they are receiving
  /// @param controlledToken The token that is going to be minted
  /// @param referrer The user who referred the minting
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  /// @notice Called by the prize strategy to award external ERC721 prizes
  /// @dev Used to award any arbitrary NFTs held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param externalToken The address of the external NFT token being awarded
  /// @param tokenIds An array of NFT Token IDs to be transferred
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.
  /// @param amount The prize amount
  /// @return The size of the reserve portion of the prize
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts
  /// @param users An array of account addresses to sweep balances for
  /// @return The total amount of assets swept from the Prize Pool
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.
  /// @param users An array of owner addresses
  /// @return The total amount of assets swept from the Prize Pool
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  /// @notice Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  /// @dev Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  /// @return burnedCredit The credit that was burned
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  /// @notice Calculates the early exit fee for the given amount
  /// @param from The user who is withdrawing
  /// @param controlledToken The type of collateral being withdrawn
  /// @param amount The amount of collateral to be withdrawn
  /// @return exitFee The exit fee
  /// @return burnedCredit The user's credit that was burned
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  /// @dev Calculates the early exit fee for the given amount
  /// @param amount The amount of collateral to be withdrawn
  /// @return Exit fee
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  /// @notice Burns a users credit.
  /// @param user The user whose credit should be burned
  /// @param credit The amount of credit to burn
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.
  /// @param user The user for whom to accrue credit
  /// @param controlledToken The controlled token whose balance we are checking
  /// @param controlledTokenBalance The balance to use for the user
  /// @param extra Additional credit to be added
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)
  /// @param creditBalance The new credit balance to be checked
  /// @return The users new credit balance.  Will not exceed the credit limit.
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  /// @notice Calculates the accrued interest for a user
  /// @param user The user whose credit should be calculated.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The user's current balance of the controlled tokens.
  /// @return The credit that has accrued since the last credit update.
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.
  /// @param user The user whose credit balance should be returned
  /// @return The balance of the users credit
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).
  /// @param _controlledToken The controlled token for whom to set the credit plan
  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).
  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  /// @notice Returns the credit rate of a controlled token
  /// @param controlledToken The controlled token to retrieve the credit rates for
  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.
  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.
  /// @param from The user who is withdrawing
  /// @param controlledToken The token they are withdrawing
  /// @param amount The amount of funds they are withdrawing
  /// @return earlyExitFee The additional exit fee that should be charged.
  /// @return creditBurned The amount of credit that will be burned
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    /*
    The credit is used *last*.  Always charge the fees up-front.

    How to calculate:

    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.

    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.
    */

    // Determine available usable credit based on withdraw amount
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    // Determine amount of credit to burn and amount of fees required
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
  /// @param _liquidityCap The new liquidity cap for the prize pool
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  /// @notice Adds a new controlled token
  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)
  /// @return An array of controlled token addresses
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  /// @dev Gets the current time as represented by the current block
  /// @return The timestamp of the current block
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep
  /// @param user The address of an account with timelocked assets
  /// @return The timestamp at which the locked assets will be made available
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  /// @notice The balance of timelocked assets for an account
  /// @param user The address of an account with timelocked assets
  /// @return The amount of assets that have been timelocked
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
  /// @param compLike The COMP-like token held by the prize pool that should be delegated
  /// @param to The address to delegate to 
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
  /// @param _amount The amount of liquidity to be added to the Prize Pool
  /// @return True if the Prize Pool can receive the specified amount of liquidity
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  /// @dev Checks if a specific token is controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  /// @return True if the token is a controlled token, false otherwise
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return The ERC20 asset token
  function _token() internal virtual view returns (IERC20Upgradeable);

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal virtual returns (uint256);

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal virtual;

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  /// @dev Function modifier to ensure caller is the prize-strategy
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}

",10191,1131,"[H-04] withdraw timelock can be circumvented
One can withdraw the entire PrizePool deposit by circumventing the timelock. Assume the user has no credits for ease of computation:
user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This ""mints"" an equivalent amount of timelock and resets _unlockTimestamps[user] = timestamp = blockTime + lockDuration.
user calls withdrawWithTimelockFrom(user, amount=0) again but this time withdrawing 0 amount. This will return a lockDuration of 0 and thus unlockTimestamp = blockTime. The inner _mintTimelock now resets _unlockTimestamps[user] = unlockTimestamp
As if (timestamp <= _currentTime())  is true, the full users amount is now transferred out to the user in the _sweepTimelockBalances call.
Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.
 [M-07] Using transferFrom on ERC721 tokens
In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of safeTransferFrom. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",2,"pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";




abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  
  RegistryInterface public reserveRegistry;

  
  MappedSinglyLinkedList.Mapping internal _tokens;

  
  TokenListenerInterface public prizeStrategy;

  
  
  uint256 public maxExitFeeMantissa;

  
  uint256 public maxTimelockDuration;

  
  uint256 public timelockTotalSupply;

  
  uint256 public reserveTotalSupply;

  
  uint256 public liquidityCap;

  
  uint256 internal _currentAwardBalance;

  
  mapping(address => uint256) internal _timelockBalances;

  
  mapping(address => uint256) internal _unlockTimestamps;

  
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  
  
  
  
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  
  
  function token() external override view returns (address) {
    return address(_token());
  }

  
  
  function balance() external returns (uint256) {
    return _balance();
  }

  
  
  
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  
  
  
  
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  
  
  
  
  
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  
  
  
  
  
  
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    
    _burnCredit(from, controlledToken, burnedCredit);

    
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  
  
  
  
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  
  
  
  
  
  
  
  
  
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    
    return unlockTimestamp;
  }

  
  
  
  
  
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  
  
  
  
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  
  
  
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  
  
  
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  
  
  
  
  
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  
  
  
  
  
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  
  
  
  
  
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  
  
  
  
  
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  
  
  
  
  
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  
  
  
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  
  
  
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  
  
  
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  
  
  
  
  
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  
  
  
  
  
  
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  
  
  
  
  
  
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  
  
  
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  
  
  
  
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  
  
  
  
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    
    
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  
  
  
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  
  
  
  
  
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  
  
  
  
  
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  
  
  
  
  
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  
  
  
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  
  
  
  
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  
  
  
  
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  
  
  
  
  
  
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    

    
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  
  
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  
  
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  
  
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  
  
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  
  
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  
  
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  
  
  
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  
  
  
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  
  
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  
  
  
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  
  
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  
  
  
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  
  
  
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  
  
  
  
  
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  
  
  function _token() internal virtual view returns (IERC20Upgradeable);

  
  
  function _balance() internal virtual returns (uint256);

  
  
  function _supply(uint256 mintAmount) internal virtual;

  
  
  
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  
  
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",6300,1,1,"{'task_list': [{'Area': 'Access Control and Authorization', 'Tasks': ['Verify that only the owner can call `setCreditPlanOf`, `setLiquidityCap`, and `setPrizeStrategy` functions.', 'Confirm that `onlyControlledToken` modifier correctly restricts access to functions based on the `_isControlled` check.', 'Ensure the `onlyPrizeStrategy` modifier accurately restricts access to functions intended only for the prize strategy contract.', 'Verify that the `onlyReserve` modifier restricts access to the `withdrawReserve` function to the address returned by `reserveRegistry.lookup()`.', 'Analyze the `compLikeDelegate` function to determine if owner-only access is appropriate and if any restrictions should be added.']}, {'Area': 'Credit System and Early Exit Fees', 'Tasks': ['Analyze the `_calculateEarlyExitFeeLessBurnedCredit` function to ensure the correct calculation of early exit fees and burned credits, especially considering edge cases where `availableCredit > totalExitFee` and the subtraction order.', 'Verify that `_estimateCreditAccrualTime` function correctly calculates the time required to accrue a certain amount of credit and is resistant to division by zero.', 'Investigate potential rounding errors or precision loss in the `FixedPoint` calculations used within the credit system, especially related to `creditRateMantissa` and `creditLimitMantissa`.', 'Analyze the logic in `_calculateCreditBalance` and `_updateCreditBalance` to ensure credits are correctly accrued and burned based on the balance, timestamp, and configured rates.', 'Simulate scenarios where users deposit and withdraw frequently to assess the long-term behavior of the credit system and prevent unintended consequences.']}, {'Area': 'Timelocked Withdrawals and Sweep Functionality', 'Tasks': ['Analyze the `_sweepTimelockBalances` function to ensure that it correctly transfers tokens to users whose timelocks have expired and handles edge cases where the total withdrawal amount is zero.', 'Assess the gas cost of the `_sweepTimelockBalances` function, especially with large user arrays. Consider implementing pagination or other gas optimization techniques to prevent denial-of-service.', 'Verify that the `_mintTimelock` function correctly sets the `unlockTimestamp` and updates the `timelockTotalSupply`.', 'Confirm that the `_calculateTimelockDuration` function accurately calculates the required timelock duration and respects the `maxTimelockDuration` limit.', 'Analyze the interaction between timelocked withdrawals and the credit system to prevent users from exploiting the timelock mechanism to gain unfair advantages.']}, {'Area': 'Liquidity Cap and Deposit/Withdrawal Mechanics', 'Tasks': ['Ensure the `canAddLiquidity` modifier accurately enforces the `liquidityCap` during deposits and timelock deposits.', ""Verify that `depositTo` and `timelockDepositTo` functions correctly mint controlled tokens and update the pool's total supply."", 'Analyze the `withdrawInstantlyFrom` function to prevent users from withdrawing more than their balance and to ensure that exit fees are correctly calculated and applied.', 'Check for potential reentrancy vulnerabilities in the deposit and withdrawal functions, even though `nonReentrant` modifier is used, due to external calls.', 'Confirm that the `_supply` and `_redeem` abstract functions are implemented correctly in derived contracts to maintain accurate accounting of the underlying token balance.']}, {'Area': 'External Interactions and Prize Strategy', 'Tasks': ['Verify that the `reserveRegistry` contract correctly resolves to a valid `ReserveInterface` and that the `calculateReserveFee` function calculates the fee accurately.', 'Assess the trust assumptions and security implications of using an external `prizeStrategy` contract, as it has significant permissions within the PrizePool.', 'Ensure that the `award`, `awardExternalERC20`, `transferExternalERC20`, and `awardExternalERC721` functions can only be called by the `prizeStrategy` contract.', 'Analyze the `beforeTokenTransfer` hook to ensure that it correctly updates credit balances and notifies the prize strategy without introducing vulnerabilities related to token transfers.', 'Examine the implementation of `_canAwardExternal` in derived contracts to prevent awarding of malicious or unintended tokens.', 'Confirm the usage of `safeTransfer` and `safeTransferFrom` from SafeERC20 library to avoid stuck tokens.']}, {'Area': 'Accounting and Award Balance', 'Tasks': ['Verify that the `captureAwardBalance` function correctly calculates yield earned and allocates the reserve fee before updating the `_currentAwardBalance`.', 'Ensure that the `awardBalance` function returns the correct amount of tokens available for awards.', 'Check for potential integer overflow/underflow issues in the calculation of total interest and unaccounted prize balance within the `captureAwardBalance` function.', 'Confirm the correct implementation of `_tokenTotalSupply` in derived contracts and verify the total supply is accounted for across controlled tokens, timelocks, and reserve.']}, {'Area': 'Upgradability Considerations', 'Tasks': ['Review the initialization logic in the `initialize` function to ensure proper setup of state variables and prevent re-initialization vulnerabilities.', 'Verify that all state variables are properly initialized and that the contract is compatible with upgradeable contract patterns.', ""Ensure that the contract's logic can be seamlessly upgraded without disrupting existing user deposits or timelocked withdrawals.""]}]}","{'ReviewingTheCode': ""The contract `PrizePool` is an abstract base contract designed to manage deposits, withdrawals (both instant and timelocked), prize distribution, and associated mechanics like exit fees and credits within a PoolTogether-like system. It interacts with 'controlled' tokens (representing user deposits in the pool), an underlying asset token, a reserve mechanism, and a separate prize strategy contract. It leverages OpenZeppelin upgradeable contracts for ownership, reentrancy protection, safe math, and safe ERC20/721 interactions. Key features include a credit system to potentially offset early withdrawal fees, timelocked withdrawals, prize capture from yield, and management of external token awards."", 'IdentifyingKeyComponents': {'ContractName': 'PrizePool (abstract)', 'Purpose': 'To serve as the core logic for a prize savings pool, managing user deposits, calculating and distributing yield-generated prizes, handling withdrawals with potential fees or timelocks, and interacting with controlled deposit tokens and external reward tokens.', 'InheritanceAndImports': {'InheritsFrom': ['PrizePoolInterface', 'OwnableUpgradeable', 'ReentrancyGuardUpgradeable', 'TokenControllerInterface'], 'Imports': ['@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol', '@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@pooltogether/fixed-point/contracts/FixedPoint.sol', '../external/compound/ICompLike.sol', '../reserve/RegistryInterface.sol', '../reserve/ReserveInterface.sol', '../token/TokenListenerInterface.sol', '../token/TokenListenerLibrary.sol', '../token/ControlledToken.sol', '../token/TokenControllerInterface.sol', '../utils/MappedSinglyLinkedList.sol', './PrizePoolInterface.sol']}, 'StateVariables': [{'Name': 'reserveRegistry', 'Type': 'RegistryInterface', 'Purpose': 'Points to a contract registry to find the current reserve address.'}, {'Name': '_tokens', 'Type': 'MappedSinglyLinkedList.Mapping', 'Purpose': ""Stores the addresses of the 'controlled tokens' managed by this prize pool.""}, {'Name': 'prizeStrategy', 'Type': 'TokenListenerInterface', 'Purpose': 'Address of the contract responsible for prize distribution logic.'}, {'Name': 'maxExitFeeMantissa', 'Type': 'uint256', 'Purpose': 'Maximum percentage (as mantissa) charged as an early withdrawal fee.'}, {'Name': 'maxTimelockDuration', 'Type': 'uint256', 'Purpose': 'Maximum duration (in seconds) a withdrawal can be timelocked.'}, {'Name': 'timelockTotalSupply', 'Type': 'uint256', 'Purpose': 'Total amount of underlying tokens currently locked in timelock withdrawals.'}, {'Name': 'reserveTotalSupply', 'Type': 'uint256', 'Purpose': 'Total amount of underlying tokens accumulated as reserve fees, available for withdrawal by the reserve.'}, {'Name': 'liquidityCap', 'Type': 'uint256', 'Purpose': 'Maximum total supply (deposits + timelocks + reserve) allowed in the pool.'}, {'Name': '_currentAwardBalance', 'Type': 'uint256', 'Purpose': 'Amount of underlying tokens currently available to be awarded as prizes.'}, {'Name': '_timelockBalances', 'Type': 'mapping(address => uint256)', 'Purpose': 'Tracks the amount of tokens each user has in a timelocked state.'}, {'Name': '_unlockTimestamps', 'Type': 'mapping(address => uint256)', 'Purpose': ""Tracks the timestamp when each user's timelocked balance becomes available for sweeping.""}, {'Name': '_tokenCreditPlans', 'Type': 'mapping(address => CreditPlan)', 'Purpose': 'Stores the credit rate and limit configuration for each controlled token.'}, {'Name': '_tokenCreditBalances', 'Type': 'mapping(address => mapping(address => CreditBalance))', 'Purpose': 'Tracks the accrued credit balance for each user per controlled token.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract state (for upgradeable contracts).', 'Parameters': ['_reserveRegistry', '_controlledTokens', '_maxExitFeeMantissa', '_maxTimelockDuration'], 'Returns': []}, {'Name': 'token', 'Visibility': 'external override view', 'Purpose': 'Returns the address of the underlying deposit token (abstract).', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balance', 'Visibility': 'external', 'Purpose': 'Returns the current balance of the underlying token held by the contract (abstract).', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'canAwardExternal', 'Visibility': 'external view', 'Purpose': 'Checks if a specific external token can be awarded (abstract).', 'Parameters': ['_externalToken'], 'Returns': ['bool']}, {'Name': 'timelockDepositTo', 'Visibility': 'external', 'Purpose': ""Allows depositing into the pool by transferring from a user's timelock balance."", 'Parameters': ['to', 'amount', 'controlledToken'], 'Returns': []}, {'Name': 'depositTo', 'Visibility': 'external override', 'Purpose': 'Deposits underlying tokens into the pool, minting controlled tokens for the recipient.', 'Parameters': ['to', 'amount', 'controlledToken', 'referrer'], 'Returns': []}, {'Name': 'withdrawInstantlyFrom', 'Visibility': 'external override', 'Purpose': 'Withdraws underlying tokens immediately, potentially incurring an exit fee (reduced by credits).', 'Parameters': ['from', 'amount', 'controlledToken', 'maximumExitFee'], 'Returns': ['uint256 exitFee']}, {'Name': 'withdrawWithTimelockFrom', 'Visibility': 'external override', 'Purpose': 'Initiates a timelocked withdrawal, burning controlled tokens and setting an unlock timestamp.', 'Parameters': ['from', 'amount', 'controlledToken'], 'Returns': ['uint256 unlockTimestamp']}, {'Name': 'sweepTimelockBalances', 'Visibility': 'external override', 'Purpose': 'Transfers underlying tokens to users whose timelocks have expired.', 'Parameters': ['users'], 'Returns': ['uint256 totalSwept']}, {'Name': 'beforeTokenTransfer', 'Visibility': 'external override', 'Purpose': 'Hook called by controlled tokens before a transfer, used to update credit balances and notify the prize strategy.', 'Parameters': ['from', 'to', 'amount'], 'Returns': []}, {'Name': 'captureAwardBalance', 'Visibility': 'external override', 'Purpose': 'Calculates yield earned (interest), allocates reserve fee, and updates the awardable balance.', 'Parameters': [], 'Returns': ['uint256 currentAwardBalance']}, {'Name': 'withdrawReserve', 'Visibility': 'external override', 'Purpose': 'Allows the reserve address to withdraw accumulated reserve fees.', 'Parameters': ['to'], 'Returns': ['uint256 redeemedAmount']}, {'Name': 'award', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award prizes by minting controlled tokens to the winner.', 'Parameters': ['to', 'amount', 'controlledToken'], 'Returns': []}, {'Name': 'awardExternalERC20', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award external ERC20 tokens.', 'Parameters': ['to', 'externalToken', 'amount'], 'Returns': []}, {'Name': 'transferExternalERC20', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to transfer external ERC20 tokens (e.g., for operational costs).', 'Parameters': ['to', 'externalToken', 'amount'], 'Returns': []}, {'Name': 'awardExternalERC721', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award external ERC721 tokens.', 'Parameters': ['to', 'externalToken', 'tokenIds'], 'Returns': []}, {'Name': 'calculateReserveFee', 'Visibility': 'public view', 'Purpose': 'Calculates the reserve fee based on an amount and the current reserve rate.', 'Parameters': ['amount'], 'Returns': ['uint256 fee']}, {'Name': 'calculateTimelockDuration', 'Visibility': 'external override', 'Purpose': 'Calculates the required timelock duration for a given withdrawal amount based on potential exit fees and credits.', 'Parameters': ['from', 'controlledToken', 'amount'], 'Returns': ['durationSeconds', 'burnedCredit']}, {'Name': 'calculateEarlyExitFee', 'Visibility': 'external override', 'Purpose': 'Calculates the early exit fee and the amount of credit that would be burned for an instant withdrawal.', 'Parameters': ['from', 'controlledToken', 'amount'], 'Returns': ['exitFee', 'burnedCredit']}, {'Name': 'estimateCreditAccrualTime', 'Visibility': 'external override view', 'Purpose': 'Estimates the time needed to accrue a certain amount of credit (interest) on a principal.', 'Parameters': ['_controlledToken', '_principal', '_interest'], 'Returns': ['durationSeconds']}, {'Name': 'balanceOfCredit', 'Visibility': 'external override', 'Purpose': 'Returns the current credit balance of a user for a specific controlled token after accruing.', 'Parameters': ['user', 'controlledToken'], 'Returns': ['uint256']}, {'Name': 'setCreditPlanOf', 'Visibility': 'external override', 'Purpose': 'Sets the credit rate and limit for a controlled token (Owner only).', 'Parameters': ['_controlledToken', '_creditRateMantissa', '_creditLimitMantissa'], 'Returns': []}, {'Name': 'creditPlanOf', 'Visibility': 'external override view', 'Purpose': 'Returns the credit rate and limit for a controlled token.', 'Parameters': ['controlledToken'], 'Returns': ['creditLimitMantissa', 'creditRateMantissa']}, {'Name': 'setLiquidityCap', 'Visibility': 'external override', 'Purpose': 'Sets the maximum liquidity cap for the pool (Owner only).', 'Parameters': ['_liquidityCap'], 'Returns': []}, {'Name': 'setPrizeStrategy', 'Visibility': 'external override', 'Purpose': 'Sets the prize strategy contract address (Owner only).', 'Parameters': ['_prizeStrategy'], 'Returns': []}, {'Name': 'tokens', 'Visibility': 'external override view', 'Purpose': 'Returns an array of all controlled token addresses.', 'Parameters': [], 'Returns': ['address[]']}, {'Name': 'timelockBalanceAvailableAt', 'Visibility': 'external override view', 'Purpose': ""Returns the timestamp when a user's timelocked balance unlocks."", 'Parameters': ['user'], 'Returns': ['uint256 timestamp']}, {'Name': 'timelockBalanceOf', 'Visibility': 'external override view', 'Purpose': 'Returns the amount of tokens a user has in the timelock state.', 'Parameters': ['user'], 'Returns': ['uint256 balance']}, {'Name': 'accountedBalance', 'Visibility': 'external override view', 'Purpose': 'Returns the total balance accounted for by the pool (controlled tokens + timelocks + reserve).', 'Parameters': [], 'Returns': ['uint256 total']}, {'Name': 'compLikeDelegate', 'Visibility': 'external', 'Purpose': 'Allows the owner to delegate voting power of COMP-like tokens held by the contract.', 'Parameters': ['compLike', 'to'], 'Returns': []}, {'Name': 'onlyControlledToken', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions requiring a valid controlled token address.', 'Parameters': ['controlledToken'], 'Returns': []}, {'Name': 'onlyPrizeStrategy', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions that should only be called by the prize strategy contract.', 'Parameters': [], 'Returns': []}, {'Name': 'canAddLiquidity', 'Visibility': 'modifier', 'Purpose': 'Checks if adding a certain amount would exceed the liquidity cap.', 'Parameters': ['_amount'], 'Returns': []}, {'Name': 'onlyReserve', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions that should only be called by the reserve address.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['ControlledTokenInterface (ERC20-like): Calls `controllerMint`, `controllerBurnFrom`, `balanceOf`, `totalSupply`.', 'Underlying Token (IERC20Upgradeable, via abstract `_token()`): Calls `safeTransferFrom`, `safeTransfer`, potentially `balanceOf` (indirectly via `_balance()`).', 'ReserveRegistryInterface: Calls `lookup()` to find the reserve address.', 'ReserveInterface: Calls `reserveRateMantissa()` to calculate reserve fees.', 'PrizeStrategy (TokenListenerInterface): Calls `beforeTokenMint`, `beforeTokenTransfer`. Is called *by* the prize strategy for awarding.', 'External ERC20 Tokens (IERC20Upgradeable): Calls `safeTransfer` for awards/transfers.', 'External ERC721 Tokens (IERC721Upgradeable): Calls `transferFrom` for awards.', 'Compound-like Governance Token (ICompLike): Calls `balanceOf`, `delegate`.', 'OpenZeppelin Libraries/Contracts: Utilizes SafeMath, SafeERC20, Ownable, ReentrancyGuard logic.'], 'SpecialMechanisms': ['Upgradeable Contract Pattern: Uses OpenZeppelin Upgradeable contracts and `initialize` pattern.', 'Abstract Contract: Defines an interface and shared logic, requiring concrete implementations for `_token()`, `_balance()`, `_supply()`, `_redeem()`, `_canAwardExternal()`.', 'Credit System: Accrues credits over time based on deposit balance and rate, which can be used to offset instant withdrawal fees. Involves `CreditPlan`, `CreditBalance`, time-based calculations (`_currentTime`, `timestamp`), and fixed-point math.', 'Timelocked Withdrawals: Allows users to withdraw without fees by locking funds for a calculated duration. Managed via `_timelockBalances`, `_unlockTimestamps`, and `sweepTimelockBalances`.', 'Prize Strategy Separation: Delegates prize calculation and distribution logic to an external `prizeStrategy` contract.', 'Reserve Fee Mechanism: Captures a percentage of the generated yield/interest for a reserve.', 'Liquidity Cap: Enforces a maximum total value locked in the pool.', 'Reentrancy Protection: Uses `ReentrancyGuardUpgradeable`.', 'Token Controller Pattern: The PrizePool acts as the controller for the `ControlledToken`s, authorizing minting and burning.', 'MappedSinglyLinkedList: Used for managing the list of controlled tokens.', 'Fixed-Point Math: Uses `@pooltogether/fixed-point` library for mantissa-based calculations (fees, rates, credits).'], 'Questions': ['What is the exact mechanism for yield generation? The contract calculates yield (`captureAwardBalance`) based on `_balance()` exceeding `_tokenTotalSupply()`, but the source of yield (e.g., lending protocol integration) is implemented in the concrete contract via abstract methods like `_supply()` and `_redeem()`.', 'How are the abstract methods (`_token`, `_balance`, `_supply`, `_redeem`, `_canAwardExternal`) intended to be implemented in derived contracts? Understanding their specifics is crucial.', 'What are the trust assumptions regarding the `prizeStrategy` contract? It has significant permissions (awarding tokens, transferring external assets).', 'How is the `reserveRegistry` and the associated `ReserveInterface` contract managed and secured?', 'Are there potential precision issues or edge cases with the `FixedPoint` math used for credits, fees, and timelock calculations, especially concerning division or time differences?', 'What prevents potential griefing attacks where someone repeatedly triggers `sweepTimelockBalances` with large user arrays, causing high gas costs?', 'The `beforeTokenTransfer` hook updates credit based on balances *before* the transfer completes. Is this interaction robust against potential race conditions or complex transfer scenarios (e.g., flash loans if applicable to controlled tokens)?', 'How does the `compLikeDelegate` function integrate with the overall system purpose? Is it just for managing governance tokens earned passively?', 'Are there limits on the number of controlled tokens that can be added via `_addControlledToken` due to gas costs associated with iterating the list (e.g., in `_tokenTotalSupply`)?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `sweepTimelockBalances` Function', 'Severity': 'High', 'Description': 'The `_sweepTimelockBalances` function iterates through users, transferring tokens via an external call (`safeTransfer`). If a recipient is a malicious contract, it can call back into the PrizePool before the loop finishes or state updates are complete. Although the function has a `nonReentrant` modifier, this external call can bypass it, allowing manipulation of state (e.g., `timelockTotalSupply`) or multiple withdrawals, potentially draining funds.', 'Impact': 'An attacker could potentially drain the PrizePool by re-entering the contract during the sweeping process, manipulating state, leading to loss of funds for other users.', 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Unbounded Loop in `sweepTimelockBalances` function can cause out of gas', 'Severity': 'High', 'Description': 'The `_sweepTimelockBalances` function iterates through a user-provided array (`users`) without bounds checks. If this array is excessively large, the gas cost can exceed the block limit, causing the transaction to revert. This results in a Denial of Service (DoS), preventing users (including potentially the caller) from sweeping their timelocked balances. Malicious actors or even legitimate high usage could trigger this.', 'Impact': 'Denial of service; Users might not be able to claim their timelocked balances due to out-of-gas errors. Malicious users or a Prize Pool Owner could potentially grief the contract by intentionally providing large arrays.', 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Potential Reentrancy Vulnerability in `withdrawInstantlyFrom` Function', 'Severity': 'High', 'Description': 'The `withdrawInstantlyFrom` function transfers redeemed tokens to the user via an external call (`safeTransfer`). If the recipient (`from`) is a malicious contract, it can call back into the PrizePool after receiving tokens but before the function completes internal state updates. This reentrancy, occurring despite the `nonReentrant` modifier on the entry point, could allow manipulation of balances or withdrawal of more funds than entitled.', 'Impact': 'An attacker could potentially drain the PrizePool by re-entering the contract during the withdrawal process, leading to loss of funds for other users.', 'Location': 'PrizePool.sol:withdrawInstantlyFrom'}, {'Issue': 'Potential Reentrancy Attack in `captureAwardBalance` via Reserve Callback', 'Severity': 'High', 'Description': 'The `captureAwardBalance` function calculates fees by calling `calculateReserveFee`, which may involve an external call to `reserve.reserveRateMantissa`. If the configured Reserve contract is malicious or exploited, this external call could re-enter the PrizePool, potentially manipulating state variables during the fee calculation, leading to incorrect award amounts and potential fund loss.', 'Impact': 'Incorrect calculation of award balance and reserve fee, potential loss of funds, and manipulation of PrizePool state due to reentrancy via the reserve contract.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Potential Overflow/Underflow in Credit Calculation Logic', 'Severity': 'Medium', 'Description': ""Credit calculations involve `uint128` for balances/limits and `uint32` for timestamps. While `SafeMathUpgradeable` is used for basic operations, intermediate calculations (like `deltaTime * creditPerSecond` or summing credits) within functions like `_calculateAccruedCredit` and `_calculateCreditBalance` can exceed `uint256`'s maximum value before being truncated down to `uint128` or `uint192`. This truncation of an already overflowed value leads to incorrect results. Large time deltas or high rates exacerbate this. This can result in inaccurate credit balances, affecting withdrawal fees, timelock durations, and potentially allowing users to bypass intended mechanisms."", 'Impact': 'Incorrect credit calculation, potentially leading to users receiving less credit than they should, underflowing balances, or bypassing fees/timelocks, affecting fairness and fund integrity.', 'Location': 'PrizePool.sol:_calculateAccruedCredit, PrizePool.sol:_updateCreditBalance, PrizePool.sol:_calculateCreditBalance, PrizePool.CreditBalance Struct, PrizePool.CreditPlan Struct'}, {'Issue': 'Reliance on Block Timestamp for Time-Sensitive Operations', 'Severity': 'Medium', 'Description': 'The contract uses `block.timestamp` for critical time-sensitive operations like calculating timelock durations, credit accrual, and checking unlock times in functions such as `_currentTime`, `_sweepTimelockBalances`, `_calculateTimelockDuration`, and `withdrawWithTimelockFrom`. Miners have limited ability to manipulate `block.timestamp`, potentially allowing slight alterations to timelock periods or affecting when balances can be swept.', 'Impact': 'Minor manipulation of timelock durations or credit accrual periods is possible, potentially leading to minor discrepancies or unfairness.', 'Location': 'PrizePool.sol:_currentTime, PrizePool.sol:_sweepTimelockBalances, PrizePool.sol:_calculateTimelockDuration, PrizePool.sol:withdrawWithTimelockFrom, PrizePool.sol:_mintTimelock'}, {'Issue': 'Potential Front-Running Vulnerability in `sweepTimelockBalances`', 'Severity': 'Medium', 'Description': ""The `sweepTimelockBalances` function can be front-run. A malicious actor monitoring the mempool can see a pending sweep transaction for a user (or multiple users) and submit their own transaction with higher gas to sweep the target user's balance first. This could be used to steal funds if sweeping for others is possible, or simply allow the attacker to receive their own funds slightly earlier than others in a batch sweep."", 'Impact': ""Minor inconvenience for users whose balances are swept later in a batch transaction, or potential loss of funds if an attacker can front-run and sweep another user's balance to themselves."", 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Unbounded Loop in `awardExternalERC721` can lead to DoS', 'Severity': 'Medium', 'Description': 'The `awardExternalERC721` function iterates through a `tokenIds` array, performing an external `transferFrom` call for each ID. If the array is very large, the cumulative gas cost, especially due to external calls in each iteration, can exceed the block gas limit, causing the transaction to fail and resulting in a Denial of Service (DoS) for awarding these NFTs.', 'Impact': 'Potential denial-of-service (DoS) attack due to high gas consumption when awarding a large number of ERC721 tokens, preventing recipients from receiving NFTs.', 'Location': 'PrizePool.sol:awardExternalERC721'}, {'Issue': 'Lack of Input Validation in `setCreditPlanOf` for Mantissa Values', 'Severity': 'Medium', 'Description': 'The `setCreditPlanOf` function (callable by the owner) sets `creditRateMantissa` and `creditLimitMantissa` without validating if these values are within reasonable bounds (e.g., mantissas typically represent fractions less than or equal to 1, i.e., 1e18). Setting extremely high values could lead to excessive credit accrual or limits, distorting intended mechanics like exit fees and potentially creating economic exploits or breaking core functionality.', 'Impact': ""Setting unreasonable credit parameters could lead to unexpected behavior, potential exploitation of the credit system (e.g., near-zero exit fees or excessively high fees), and disruption of the prize pool's economic balance."", 'Location': 'PrizePool.sol:setCreditPlanOf'}, {'Issue': 'Potential Front-Running Vulnerability in `captureAwardBalance`', 'Severity': 'Medium', 'Description': ""The `captureAwardBalance` function's outcome depends on the current pool state (e.g., `tokenTotalSupply`). A malicious actor could front-run this transaction by making a large deposit or withdrawal just before it executes, manipulating the calculated `unaccountedPrizeBalance` and thus affecting the amount of prize awarded, potentially reducing the captured amount to the detriment of prize winners."", 'Impact': 'Unfair prize distribution, where large depositors or malicious actors can influence and potentially reduce the overall prize pool amount captured.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Potential Loss of Funds in `withdrawReserve` due to Redemption Rate', 'Severity': 'Medium', 'Description': 'The `withdrawReserve` function redeems the entire `reserveTotalSupply` using `_redeem(amount)`. If the underlying redemption mechanism implemented in `_redeem` results in a rate where the amount of underlying token received is less than the `amount` of prize pool tokens redeemed (rate < 1:1), the recipient will receive fewer underlying tokens than the `reserveTotalSupply` value implies, leading to a loss of funds intended for the reserve.', 'Impact': 'The receiver of reserve funds may receive less than the intended amount if the redemption rate is unfavorable, resulting in a loss of funds belonging to the reserve.', 'Location': 'PrizePool.sol:withdrawReserve'}, {'Issue': 'Potential Division by Zero in `_estimateCreditAccrualTime`', 'Severity': 'Medium', 'Description': 'The `_estimateCreditAccrualTime` function calculates `accruedPerSecond` based on principal and credit rate. If either the `_principal` or the `creditRateMantissa` for the token is zero, `accruedPerSecond` becomes zero. The function then attempts to divide by `accruedPerSecond`, leading to a division-by-zero error, causing the transaction (and any function calling it, like withdrawal estimations) to revert.', 'Impact': 'Potential denial of service (DoS) if a user attempts an operation (like estimating timelock withdrawal time) under conditions where principal or credit rate is zero, leading to transaction failure.', 'Location': 'PrizePool.sol:_estimateCreditAccrualTime'}, {'Issue': 'Liquidity Cap Can Be Bypassed By Awards', 'Severity': 'Medium', 'Description': 'While the `depositTo` function checks against a `liquidityCap` via the `canAddLiquidity` modifier, the `award` and `awardExternalERC20` functions, used by the prize strategy, can mint new prize pool tokens or transfer external ERC20s into the pool without respecting this cap. This allows the total liquidity to exceed the intended limit set by the owner.', 'Impact': 'The intended liquidity cap can be bypassed by the prize strategy awarding mechanisms, potentially leading to the pool growing larger than desired or configured.', 'Location': 'PrizePool.sol:award, PrizePool.sol:awardExternalERC20'}, {'Issue': 'Lack of checks-effects-interactions pattern in `captureAwardBalance`', 'Severity': 'Low', 'Description': 'The `captureAwardBalance` function updates state (`reserveTotalSupply`) before potentially interacting with external contracts (currently a read call `reserve.reserveRateMantissa`). While not currently exploitable due to `nonReentrant` and the nature of the call, it deviates from the Checks-Effects-Interactions (CEI) pattern. Modifying this function later without adhering to CEI could introduce vulnerabilities if state-modifying external calls were added after effects.', 'Impact': 'Potential for future vulnerabilities if the function is modified incorrectly. Adhering to CEI is a best practice that enhances code safety and maintainability.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Lack of slippage control in `withdrawReserve`', 'Severity': 'Low', 'Description': 'The `withdrawReserve` function calls `_redeem(amount)` to convert prize pool tokens to the underlying asset before transferring. This redemption process might be subject to price changes (slippage) between transaction submission and execution. The function lacks a parameter for the reserve recipient to specify acceptable slippage, potentially resulting in receiving fewer underlying tokens than expected during volatile market conditions.', 'Impact': 'The reserve recipient may receive less underlying token than anticipated due to slippage, especially for large withdrawals or during market volatility.', 'Location': 'PrizePool.sol:withdrawReserve'}, {'Issue': 'Possible rounding errors in calculations', 'Severity': 'Low', 'Description': 'Functions like `_calculateEarlyExitFeeLessBurnedCredit` and `_calculateTimelockDuration` use `FixedPoint` math, which involves approximations and potential truncation. This can lead to minor rounding errors, causing users to pay slightly different exit fees or experience slightly different timelock durations than theoretically calculated.', 'Impact': 'Small discrepancies in exit fees and timelock durations due to rounding, potentially leading to minor user dissatisfaction or negligible financial differences.', 'Location': 'PrizePool.sol:_calculateEarlyExitFeeLessBurnedCredit, PrizePool.sol:_calculateTimelockDuration'}, {'Issue': 'Lack of Input Validation in `initialize` for Max Values', 'Severity': 'Low', 'Description': 'The `initialize` function sets `maxExitFeeMantissa` and `maxTimelockDuration` but lacks validation to ensure these owner-set values are within reasonable bounds. Extremely high or zero values could lead to unexpected behavior or render parts of the protocol unusable (e.g., an extremely high exit fee effectively blocking withdrawals).', 'Impact': 'Setting inappropriate maximum values during initialization could disrupt the normal operation of the PrizePool or lead to unintended economic consequences.', 'Location': 'PrizePool.initialize'}, {'Issue': 'Potential Front-Running Vulnerability in Timelock Withdrawals', 'Severity': 'Low', 'Description': 'The `withdrawWithTimelockFrom` function calculates the `unlockTimestamp` based on `block.timestamp`. A miner or sophisticated user could potentially influence the timestamp slightly when mining the transaction, thereby slightly manipulating the resulting timelock duration.', 'Impact': 'Slight manipulation of timelock duration is theoretically possible, although the impact is limited by `maxTimelockDuration`.', 'Location': 'PrizePool.sol:withdrawWithTimelockFrom'}, {'Issue': 'Lack of check for address(0) in `_addControlledToken`', 'Severity': 'Low', 'Description': 'The internal `_addControlledToken` function does not check if the `_controlledToken` address being added is the zero address (`address(0)`). Adding the zero address could cause errors in subsequent functions that interact with the list of controlled tokens or rely on it being a valid contract address.', 'Impact': 'Potential for unexpected behavior and transaction failures if the zero address is inadvertently added as a controlled token.', 'Location': 'PrizePool.sol:_addControlledToken'}, {'Issue': '`beforeTokenTransfer` Hook Logic Might Cause Unexpected Behaviour', 'Severity': 'Low', 'Description': ""The `beforeTokenTransfer` hook attempts to update credit balances based on token transfers. It uses `IERC20Upgradeable(msg.sender).balanceOf(...)` to fetch balances. `msg.sender` here is the token contract calling the hook. This logic might misinterpret balance changes or fetch incorrect balances if the token contract address is not what's expected, potentially leading to inaccurate credit updates (minting/burning)."", 'Impact': 'Potentially inaccurate credit calculation and minting/burning due to flawed logic in the token transfer hook.', 'Location': 'PrizePool.sol:beforeTokenTransfer'}, {'Issue': 'Potential DoS in `captureAwardBalance` due to division by zero in FixedPoint Math', 'Severity': 'Low', 'Description': 'The `captureAwardBalance` function uses `FixedPoint` math involving multiplications and potentially divisions when calculating reserve fees (`FixedPoint.multiplyUintByMantissa`). If edge cases in the reserve rate or balances lead to internal division by zero within the `FixedPoint` library operations, the transaction could revert.', 'Impact': 'The `captureAwardBalance` function might fail unexpectedly due to division by zero within the FixedPoint library, potentially hindering the distribution of awards.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Inconsistent Use of `_msgSender()` vs `msg.sender`', 'Severity': 'Low', 'Description': ""The contract codebase inconsistently uses both `_msgSender()` (from OpenZeppelin's Context) and the native `msg.sender`. While functionally similar in standard contexts, using one consistently improves readability and maintainability."", 'Impact': 'Reduced code clarity and consistency. May cause confusion for developers and auditors.', 'Location': 'PrizePool.sol (Throughout contract)'}], 'IssueNumber': 43, 'OutputList': 22}",287.5870521068573,,,"### **Output**

---

**[H-04] withdraw timelock can be circumvented**

**Report Description**:
The `withdrawWithTimelockFrom` function in the `PrizePool` contract allows users to circumvent the timelock mechanism. By first calling `withdrawWithTimelockFrom(user, amount=userBalance)` and then calling `withdrawWithTimelockFrom(user, amount=0)`, a user can reset the `_unlockTimestamps[user]` to the current block timestamp, effectively bypassing the timelock. This allows users to withdraw their entire balance immediately, without waiting for the timelock duration. This behavior undermines the protocol's intended mechanics, as users can join before awards and leave immediately after without contributing to the prize pool, leading to significant issues for the protocol.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of timelock circumvention in the `withdrawWithTimelockFrom` function. While the response list includes several issues related to the `PrizePool` contract, none of them specifically identify or describe the vulnerability of bypassing the timelock mechanism. This is a critical oversight, as the issue directly impacts the protocol's security and fairness.

---

**[M-07] Using `transferFrom` on ERC721 tokens**

**Report Description**:
In the `awardExternalERC721` function of the `PrizePool` contract, the `transferFrom` keyword is used instead of `safeTransferFrom` when transferring ERC721 tokens to winners. If a winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be permanently locked, as `transferFrom` does not check if the recipient can handle ERC721 tokens. This could lead to loss of assets and user dissatisfaction.

**Match in Response List**:
Matches with the issue titled **""Unbounded Loop in `awardExternalERC721` can lead to DoS""**.

**Validation**:
**Partially Correct**. The response identifies the `awardExternalERC721` function and mentions the potential for a Denial of Service (DoS) due to unbounded loops. However, it does not address the core issue of using `transferFrom` instead of `safeTransferFrom`, which is the primary vulnerability described in the issue report. While the response partially overlaps with the issue, it misses the critical detail of the insecure token transfer method.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- *None*

**Partially Correct Matches**:

- **[M-07] Using `transferFrom` on ERC721 tokens**

**Missed Issues from Issue Report**:

- **[H-04] withdraw timelock can be circumvented**

---

### **Conclusion**

The response list partially addresses one of the issues ([M-07]) but misses the critical vulnerability of timelock circumvention ([H-04]). The response list focuses on other aspects of the `PrizePool` contract, such as reentrancy and unbounded loops, but does not adequately cover the specific issues described in the report. This indicates a gap in the response list's coverage of the vulnerabilities, particularly in the context of timelock mechanisms and ERC721 token handling.","```
None.
```",0.0
