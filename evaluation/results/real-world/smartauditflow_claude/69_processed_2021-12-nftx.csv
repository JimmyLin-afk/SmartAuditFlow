nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}

",5808,615,"[H-01] buyAndSwap1155WETH() function may cause loss of user assets

Submitted by cccz
In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap

Submitted by p4st13r4, also found by cmichel, GreyArt, hyh, jayjonah8, leastwood, pauliax, shenwilly, and WatchPug
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");

A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to

function `buyAndSwap721WETH` 
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249
  [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address

Submitted by hyh
transferFromERC721(address assetAddr, uint256 tokenId, address to) should transfer from msg.sender to to. It transfers to address(this) instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] buyAndSwap1155WETH Does Not Work As Intended

Submitted by leastwood
The `buyAndSwap1155WETH` function in NFTXMarketplaceZap aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the msg.sender account and use these tokens in purchasing vault tokens. However, the _buyVaultToken call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873,2,4,"Based on the comprehensive analysis of the NFTXMarketplaceZap contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in all external and payable functions"",
        ""Check for potential integer overflow/underflow in mathematical operations"",
        ""Validate input validation and sanity checks in all public/external functions"",
        ""Examine transfer and approval mechanisms for potential vulnerabilities"",
        ""Review error handling and revert conditions for comprehensive protection""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the Ownable implementation for potential ownership transfer risks"",
        ""Verify that critical functions have appropriate access modifiers"",
        ""Check for potential privilege escalation vulnerabilities"",
        ""Ensure owner can't perform malicious actions that could harm contract functionality""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify safe interactions with NFTX vault contracts"",
        ""Check SushiSwap router interaction for potential manipulation"",
        ""Validate handling of non-standard ERC721 tokens (CryptoKitties, CryptoPunks)"",
        ""Review slippage protection in swap functions"",
        ""Examine token approval and transfer mechanisms""
      ]
    },
    {
      ""Area"": ""Token and Liquidity Handling"",
      ""Tasks"": [
        ""Audit fee calculation mechanisms"",
        ""Verify token balance calculations and precision"",
        ""Check WETH deposit and withdrawal processes"",
        ""Review path-based token swapping logic"",
        ""Examine handling of different token standards (ERC721, ERC1155)""
      ]
    },
    {
      ""Area"": ""Transaction and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of complex functions"",
        ""Check for redundant computations"",
        ""Verify efficient use of storage and memory"",
        ""Review potential optimization opportunities"",
        ""Examine the impact of multiple token transfers and approvals""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test handling of zero-value inputs"",
        ""Verify behavior with extreme token amounts"",
        ""Check handling of failed external calls"",
        ""Review edge cases in swap and mint functions"",
        ""Examine potential scenarios of partial token transfers""
      ]
    },
    {
      ""Area"": ""Cryptographic and Swap Security"",
      ""Tasks"": [
        ""Verify SushiSwap pair address calculation logic"",
        ""Check token sorting mechanism"",
        ""Examine potential front-running vulnerabilities"",
        ""Review deadline and slippage protection mechanisms"",
        ""Validate path-based token swap security""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify ERC721 and ERC1155 token standard compliance"",
        ""Check interface implementations"",
        ""Review method signatures and return values"",
        ""Ensure compatibility with different token implementations""
      ]
    },
    {
      ""Area"": ""Advanced Vulnerability Assessment"",
      ""Tasks"": [
        ""Conduct thorough threat modeling"",
        ""Analyze potential flash loan attack vectors"",
        ""Review complex mathematical operations for precision issues"",
        ""Examine emergency stop or circuit breaker mechanisms"",
        ""Verify merkle proof or signature verification (if applicable)""
      ]
    }
  ]
}

This task list provides a comprehensive, structured approach to auditing the NFTXMarketplaceZap contract. It covers critical areas of concern identified in the initial analysis, ensuring a thorough examination of security, functionality, and potential vulnerabilities.

The tasks are designed to be:
- Specific to the contract's unique implementation
- Focused on identifying potential risks
- Actionable for the auditor
- Covering multiple dimensions of smart contract security

Would you like me to elaborate on any of these tasks or provide additional context for the audit approach?","After analyzing the provided Solidity smart contract, here's a thorough audit:

{
  ""ReviewingTheCode"": ""This contract is part of the NFTX ecosystem and serves as a marketplace zap contract that facilitates various operations involving NFTs, ERC20 tokens, and liquidity pools. It provides functionality for buying, selling, swapping, and redeeming NFTs using the NFTX protocol."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXMarketplaceZap"",
    ""Purpose"": ""Provide one-step operations for NFT trading, including minting NFTs into NFTX vaults, selling vault tokens for ETH/WETH, buying vault tokens with ETH/WETH, and redeeming vault tokens for NFTs."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""INFTXVault"", ""INFTXVaultFactory"", ""INFTXFeeDistributor"", ""INFTXLPStaking"",
        ""ITimelockRewardDistributionToken"", ""IUniswapV2Router01"", ""IERC721"", ""IERC1155Upgradeable"",
        ""IERC20Upgradeable"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable"", ""OwnableUpgradeable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Interface for interacting with Wrapped Ether contract""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Interface for interacting with NFTX LP staking contract""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Interface for interacting with the NFTX vault factory""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Interface for interacting with SushiSwap router""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Base unit constant (10^18) for calculations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initialize contract with required addresses and set infinite approvals for WETH to SushiSwap router"",
        ""Parameters"": [""_nftxFactory: address"", ""_sushiRouter: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mint ERC721 tokens into NFTX vault and sell resulting vault tokens for ETH"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]"", ""minWethOut: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell721WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mint ERC721 tokens into NFTX vault and sell resulting vault tokens for WETH"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]"", ""minWethOut: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with ETH and use them to swap for specific ERC721 tokens"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""specificIds: uint256[]"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap721WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with WETH and use them to swap for specific ERC721 tokens"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""specificIds: uint256[]"", ""maxWethIn: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with ETH and use them to swap for specific ERC1155 tokens"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""amounts: uint256[]"", ""specificIds: uint256[]"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap1155WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with WETH and use them to swap for specific ERC1155 tokens"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""amounts: uint256[]"", ""specificIds: uint256[]"", ""maxWethIn: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndRedeem"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with ETH and redeem them for NFTs"",
        ""Parameters"": [""vaultId: uint256"", ""amount: uint256"", ""specificIds: uint256[]"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndRedeemWETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buy vault tokens with WETH and redeem them for NFTs"",
        ""Parameters"": [""vaultId: uint256"", ""amount: uint256"", ""specificIds: uint256[]"", ""maxWethIn: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mint ERC1155 tokens into NFTX vault and sell resulting vault tokens for ETH"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]"", ""amounts: uint256[]"", ""minWethOut: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell1155WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mint ERC1155 tokens into NFTX vault and sell resulting vault tokens for WETH"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]"", ""amounts: uint256[]"", ""minWethOut: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mint ERC721 tokens into an NFTX vault"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]""],
        ""Returns"": [""address: vault address"", ""uint256: token balance received""]
      },
      {
        ""Name"": ""_swap721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swap in ERC721 tokens for specific ERC721 tokens from a vault"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""idsOut: uint256[]"", ""to: address""],
        ""Returns"": [""address: vault address""]
      },
      {
        ""Name"": ""_swap1155"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swap in ERC1155 tokens for specific tokens from a vault"",
        ""Parameters"": [""vaultId: uint256"", ""idsIn: uint256[]"", ""amounts: uint256[]"", ""idsOut: uint256[]"", ""to: address""],
        ""Returns"": [""address: vault address""]
      },
      {
        ""Name"": ""_redeem"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Redeem vault tokens for NFTs"",
        ""Parameters"": [""vaultId: uint256"", ""amount: uint256"", ""specificIds: uint256[]"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint1155"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mint ERC1155 tokens into an NFTX vault"",
        ""Parameters"": [""vaultId: uint256"", ""ids: uint256[]"", ""amounts: uint256[]""],
        ""Returns"": [""address: vault address"", ""uint256: token balance received""]
      },
      {
        ""Name"": ""_buyVaultToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Buy vault tokens through SushiSwap"",
        ""Parameters"": [""vault: address"", ""minTokenOut: uint256"", ""maxWethIn: uint256"", ""path: address[]""],
        ""Returns"": [""uint256[]: token amounts""]
      },
      {
        ""Name"": ""_sellVaultTokenWETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sell vault tokens for WETH through SushiSwap"",
        ""Parameters"": [""vault: address"", ""minWethOut: uint256"", ""maxTokenIn: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": [""uint256[]: token amounts""]
      },
      {
        ""Name"": ""_sellVaultTokenETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sell vault tokens for ETH through SushiSwap"",
        ""Parameters"": [""vault: address"", ""minWethOut: uint256"", ""maxTokenIn: uint256"", ""path: address[]"", ""to: address""],
        ""Returns"": [""uint256[]: token amounts""]
      },
      {
        ""Name"": ""transferFromERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfer ERC721 tokens with special handling for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr: address"", ""tokenId: uint256"", ""to: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Approve ERC721 tokens with special handling for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr: address"", ""to: address"", ""tokenId: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""pairFor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate SushiSwap pair address for two tokens"",
        ""Parameters"": [""tokenA: address"", ""tokenB: address""],
        ""Returns"": [""address: pair address""]
      },
      {
        ""Name"": ""sortTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sort tokens for SushiSwap pair calculation"",
        ""Parameters"": [""tokenA: address"", ""tokenB: address""],
        ""Returns"": [""address: token0"", ""address: token1""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""WETH contract for wrapped ether operations"",
    ""NFTXVault contracts for NFT operations"",
    ""NFTXVaultFactory for creating and managing vaults"",
    ""SushiSwap router for token swaps"",
    ""ERC721 and ERC1155 NFT contracts"",
    ""Special handling for CryptoKitties and CryptoPunks""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuard to prevent reentrancy attacks"",
    ""Special handling for non-standard ERC721 tokens (CryptoKitties, CryptoPunks)"",
    ""SushiSwap integration for token swapping"",
    ""Fee calculations for NFTX operations"",
    ""Address calculation for SushiSwap pairs""
  ],
  ""Questions"": [
    ""In buyAndSwap1155WETH, msg.value is used in _buyVaultToken despite the function taking WETH via transferFrom - this may be incorrect."",
    ""There's no slippage protection in many of the swap operations which could lead to MEV attacks."",
    ""There's a shadowing of the variable 'amounts' in mintAndSell1155 and mintAndSell1155WETH - both the parameter and return value from _sellVaultTokenETH use the same name."",
    ""Error checking on the return values of external token transfers could be more robust."",
    ""Potential precision issues when calculating fees and token amounts.""
  ]
}","I've analyzed the provided findings from different assessments of the NFTXMarketplaceZap contract. After processing and consolidating similar issues, here's my summary:

{
  ""Findings"": [
    {
      ""Issue"": ""Wrong use of msg.value in buyAndSwap1155WETH"",
      ""Severity"": ""Critical"",
      ""Description"": ""The buyAndSwap1155WETH function uses msg.value in its call to _buyVaultToken, but it should be using maxWethIn since this is the WETH version of the function that doesn't accept ETH. This is inconsistent with the function's logic, as it pulls WETH tokens from the user but then ignores the transferred amount when calling the internal function."",
      ""Impact"": ""This will cause the function to use an incorrect amount for token swaps, potentially leading to transaction failures, economic losses, or unexpected behavior."",
      ""Location"": ""buyAndSwap1155WETH function""
    },
    {
      ""Issue"": ""Reentrancy vulnerability in ETH transfers"",
      ""Severity"": ""High"",
      ""Description"": ""Even though the contract uses ReentrancyGuard, the pattern of sending ETH after all other operations (in functions like buyAndSwap721) could be vulnerable if the recipient is a malicious contract that re-enters the marketplace zap in unexpected ways. While the nonReentrant modifier prevents direct reentrant calls, the ETH transfers could still allow cross-function reentrancy attacks."",
      ""Impact"": ""Could potentially lead to theft of funds, manipulation of contract state, or exploitation through callback functions in recipient contracts."",
      ""Location"": ""buyAndSwap721, buyAndRedeem, and other functions making external calls with ETH""
    },
    {
      ""Issue"": ""Unsafe external calls to arbitrary ERC721 contracts"",
      ""Severity"": ""High"",
      ""Description"": ""The transferFromERC721 and approveERC721 functions make low-level calls to external contracts. While there's special handling for certain known contracts (Cryptokitties and CryptoPunks), this approach is risky for unknown contracts that could behave maliciously. The contract has inconsistent error handling for these external calls, which might not properly propagate errors for all token implementations."",
      ""Impact"": ""Calling unknown contracts can lead to reentrancy attacks, missing or misleading error messages, or other unexpected behaviors that could compromise the contract's security."",
      ""Location"": ""transferFromERC721 and approveERC721 functions""
    },
    {
      ""Issue"": ""Improper return value validation in _sellVaultTokenWETH function"",
      ""Severity"": ""High"",
      ""Description"": ""The function _sellVaultTokenWETH ignores return values from token approvals and doesn't properly validate that the token swap was successful. This also applies to unchecked ERC20 transfers throughout the contract, where some tokens might return false instead of reverting on failure."",
      ""Impact"": ""This could lead to incorrect event emissions, potential loss of funds, or silent failures in token transfers without any error being thrown, leading to accounting issues."",
      ""Location"": ""_sellVaultTokenWETH function and other functions using token transfers""
    },
    {
      ""Issue"": ""Missing input validation for path parameter"",
      ""Severity"": ""High"",
      ""Description"": ""Functions accepting a Uniswap path parameter (like mintAndSell721, buyAndSwap721) don't validate that the path starts with the appropriate token and ends with WETH (or vice versa for sells). An attacker could potentially provide a malicious path that routes through manipulated pools to extract value."",
      ""Impact"": ""Users could experience failed swaps, unexpected transaction outcomes, or loss of funds through unintended routes, price manipulation, or sandwich attacks."",
      ""Location"": ""All functions accepting the 'path' parameter (_buyVaultToken, _sellVaultTokenWETH, _sellVaultTokenETH, etc.)""
    },
    {
      ""Issue"": ""Variable shadowing in mintAndSell1155 functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""In mintAndSell1155 and mintAndSell1155WETH functions, the variable 'amounts' is declared twice - once as a parameter and again when calling _sellVaultTokenETH/_sellVaultTokenWETH. This creates confusion and potential bugs in the code."",
      ""Impact"": ""The shadowing could cause incorrect values to be used in calculations or event emissions, potentially leading to accounting errors, logical bugs, or misleading event data."",
      ""Location"": ""mintAndSell1155 and mintAndSell1155WETH functions""
    },
    {
      ""Issue"": ""Lack of slippage protection in token swaps"",
      ""Severity"": ""Medium"",
      ""Description"": ""While some functions have minWethOut or maxWethIn parameters for slippage protection, the swap functions don't properly implement minimum output value protection. Additionally, the contract uses block.timestamp as the deadline for SushiSwap router calls, which means transactions will not expire until they're mined, potentially exposing users to MEV attacks and unfavorable trades."",
      ""Impact"": ""Users could receive much less value than expected from their trades due to front-running, sandwich attacks, or other MEV attacks, especially in volatile market conditions or when transactions are delayed."",
      ""Location"": ""buyAndSwap721, buyAndSwap1155, _buyVaultToken, _sellVaultTokenWETH, and _sellVaultTokenETH functions""
    },
    {
      ""Issue"": ""Missing input validation in mint functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several mint functions like mintAndSell1155WETH don't validate that the ids and amounts arrays have the same length, which could lead to out-of-bounds access. Additionally, there's no validation that amounts are greater than zero, and no verification that NFT tokens actually exist or are owned by the sender."",
      ""Impact"": ""Could lead to transaction reversion, unexpected behavior, wasted gas, or confusing error messages if arrays of different lengths or invalid token IDs are provided."",
      ""Location"": ""mintAndSell1155WETH, _mint1155, and other mint functions""
    },
    {
      ""Issue"": ""Unbounded loop execution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract contains multiple functions with loops over input arrays (_mint721, _mint1155, etc.) without limiting array sizes. This could lead to out-of-gas errors if too many tokens are processed in a single transaction."",
      ""Impact"": ""Transactions with large arrays might fail due to reaching the block gas limit, potentially leading to denial of service for legitimate operations."",
      ""Location"": ""_mint721(), _mint1155(), _swap721(), and other functions that iterate over input arrays""
    },
    {
      ""Issue"": ""Incorrect fee calculation in _mint1155"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _mint1155 function, the balance calculation subtracts the mintFee multiplied by count. This assumes all mints cost the same fee, but if different NFTs in the batch have different fees, the calculation would be incorrect. Additionally, complex fee calculations in functions like buyAndSwap721 and buyAndRedeem are not validated against any expected range."",
      ""Impact"": ""Incorrect accounting could lead to transaction failures, unintended token retention in the contract, or incorrect fee calculations resulting in users paying too much or the contract not collecting enough fees."",
      ""Location"": ""_mint1155 function and other fee calculation functions""
    },
    {
      ""Issue"": ""Permanent approval to Sushiswap router"",
      ""Severity"": ""Low"",
      ""Description"": ""In the constructor, the contract approves the Sushiswap router to spend the maximum possible amount of WETH (type(uint256).max). While common practice, this represents a security risk if the router is compromised. Additionally, this creates redundant approvals as the contract also approves exact amounts before swaps."",
      ""Impact"": ""If the Sushiswap router is ever compromised, an attacker could drain all WETH held by this contract. The redundant approvals also waste gas."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Hardcoded token addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract contains hard-coded addresses for tokens like CryptoKitties and CryptoPunks, which creates maintenance challenges if these implementations change or if interacting with forks."",
      ""Impact"": ""The contract might fail to work correctly with alternative implementations or on different networks where these contracts have different addresses."",
      ""Location"": ""transferFromERC721() and approveERC721()""
    },
    {
      ""Issue"": ""Lack of event emissions for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract does emit events for main operations (Buy, Sell, Swap), it lacks granular event emissions for other important operations, making it difficult to track and audit contract activity."",
      ""Impact"": ""Reduced transparency and difficulty in tracking contract operations and troubleshooting issues."",
      ""Location"": ""Throughout the contract""
    },
    {
      ""Issue"": ""Inconsistent error handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract has inconsistent error handling patterns. Some functions use custom error messages while others rely on default revert messages. This creates an inconsistent user experience."",
      ""Impact"": ""This inconsistency makes debugging more difficult and may lead to unclear error messages for users when transactions fail."",
      ""Location"": ""Throughout the contract""
    }
  ],
  ""IssueNumber"": 48,
  ""OutputList"": 14
}",403.0663638114929,100867.0,32.0,"### **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**

**Report Description**:  
In the `NFTXMarketplaceZap.sol` contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken. However, when executing the `_buyVaultToken` method, `msg.value` is used instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, potentially causing loss of user assets or transaction failures.

**Match in Response List**:  
Matches with the issue titled **""Wrong use of msg.value in buyAndSwap1155WETH""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect use of `msg.value` instead of `maxWethIn` in the `buyAndSwap1155WETH` function. It correctly explains the potential impact, including transaction failures and economic losses, which aligns with the issue report.

---

### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is due to a check in the contract that requires the balance of vTokens to match the expected balance. A malicious user can transfer any amount > 0 of a vault’s vToken to the marketplace or staking zap contracts, making the vault functionality unavailable for all users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which is a significant vulnerability that could lead to denial of service for the entire marketplace and staking functionalities.

---

### **[M-01] Missing non reentrancy modifier**

**Report Description**:  
Several functions in the contract are missing the `nonReentrant` modifier, even though other public/external functions use it. While no direct exploit was found, the absence of the modifier in these functions could potentially lead to reentrancy vulnerabilities.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy vulnerability in ETH transfers""**.

**Validation**:  
**Partially Correct**. The response identifies a reentrancy vulnerability but focuses on ETH transfers rather than the broader issue of missing `nonReentrant` modifiers across multiple functions. The response does not fully cover the scope of the issue.

---

### **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**

**Report Description**:  
The `buyAndSwap721WETH` function and similar functions in `NFTXMarketplaceZap.sol` should return unused WETH/ETH back to `msg.sender` instead of the `to` address. This could lead to confusion or loss of funds if the `to` address is not the original sender.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which could lead to user confusion or unintended loss of funds.

---

### **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function in `NFTXStakingZap` and `NFTXMarketplaceZap` incorrectly transfers Cryptokitties to `address(this)` instead of the intended `to` address. This leads to incorrect NFT accounting and potential loss of assets.

**Match in Response List**:  
Matches with the issue titled **""Unsafe external calls to arbitrary ERC721 contracts""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with unsafe external calls but does not specifically address the incorrect transfer of Cryptokitties to `address(this)`. The response is broader and misses the specific vulnerability described in the issue.

---

### **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` does not work as intended because it uses `msg.value` instead of `maxWethIn` in the `_buyVaultToken` call. This requires users to supply both WETH and native ETH, which is inconsistent with the function's logic.

**Match in Response List**:  
Matches with the issue titled **""Wrong use of msg.value in buyAndSwap1155WETH""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect use of `msg.value` instead of `maxWethIn` in the `buyAndSwap1155WETH` function. It correctly explains the potential impact, including transaction failures and economic losses, which aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**
- **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

**Partially Correct Matches**:

- **[M-01] Missing non reentrancy modifier**
- **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Missed Issues from Issue Report**:

- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**
- **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**

--- 

The response list covers some critical issues but misses significant vulnerabilities like the vault locking issue and the incorrect return of unused WETH/ETH. Additionally, some responses are broader and do not fully address the specific vulnerabilities described in the issue report.","```
1. Wrong use of msg.value in buyAndSwap1155WETH
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Wrong use of msg.value in buyAndSwap1155WETH"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at rank 1 (P@1)**:
   - Since there is only one true positive and it appears at rank 1, the precision at rank 1 is:
     \[
     P@1 = \frac{1}{1} = 1.0
     \]

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at rank 1:
     \[
     AP = 1.0
     \]

**Output**:
```
1.0
```"
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
} 
",1672,172,"[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees

Submitted by cccz, also found by WatchPug
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.
function distribute(uint256 vaultId) external override virtual nonReentrant {
  require(nftxVaultFactory != address(0));
  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

  if (distributionPaused || allocTotal == 0) {
    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
    return;
  }

  uint256 length = feeReceivers.length;
  uint256 leftover;
  for (uint256 i = 0; i <length; i++) {
    FeeReceiver memory _feeReceiver = feeReceivers[i];
    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;
    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
    if (!complete) {
      leftover = amountToSend;
    } else {
      leftover = 0;
    }
  }

In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..

[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver

Submitted by GreyArt
The addReceiver() function fails to check if the _receiver already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
   [M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract

Submitted by hyh
Double spending of fees being distributed will happen in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. As _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in _sendForReceiver

Submitted by sirhashalot, also found by pauliax
The _sendForReceiver() function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
   [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function 
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605,1,5,"Based on the comprehensive analysis, here's a detailed task list for auditing the NFTXSimpleFeeDistributor contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in distribute() and external functions"",
        ""Analyze low-level call mechanism in _sendForReceiver() for potential security risks"",
        ""Check for potential integer overflow/underflow in fee distribution calculations"",
        ""Validate input validation and sanitization in setter functions"",
        ""Review approve-then-call pattern for potential token approval vulnerabilities""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit onlyOwner modifier implementation and ownership transfer mechanism"",
        ""Verify that critical functions like addReceiver(), removeReceiver() have proper access controls"",
        ""Check for potential centralization risks in owner-controlled functions"",
        ""Validate that pausing mechanisms cannot be abused""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify all external contract interactions (VaultFactory, LPStaking, InventoryStaking)"",
        ""Analyze error handling in cross-contract calls, especially in initializeVaultReceivers()"",
        ""Check interface compatibility and potential mismatches in external function calls"",
        ""Validate the safety of dynamic contract address updates""
      ]
    },
    {
      ""Area"": ""Fee Distribution Mechanism"",
      ""Tasks"": [
        ""Analyze precision loss in fee allocation calculations"",
        ""Verify the correctness of the distribute() function's token distribution logic"",
        ""Check handling of edge cases in fee distribution (dust amounts, rounding)"",
        ""Validate the mechanism for managing multiple fee receivers"",
        ""Review the fallback to treasury when distribution fails""
      ]
    },
    {
      ""Area"": ""State Management"",
      ""Tasks"": [
        ""Check the initialization process and ensure proper contract setup"",
        ""Validate state variable updates in setter functions"",
        ""Verify the correctness of allocTotal management when changing receivers"",
        ""Audit the removeReceiver() method for potential state manipulation""
      ]
    },
    {
      ""Area"": ""Economic Security"",
      ""Tasks"": [
        ""Verify there are no ways to manipulate allocation points unfairly"",
        ""Check for potential economic attacks on the fee distribution mechanism"",
        ""Validate the rescueTokens() function against potential misuse"",
        ""Review the pauseFeeDistribution() mechanism for potential economic exploitation""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas costs of critical functions like distribute() and addReceiver()"",
        ""Check for unnecessary storage reads/writes"",
        ""Verify the efficiency of array manipulation in receiver management"",
        ""Review the use of memory vs. storage in function implementations""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify compliance with ERC-20 token interaction standards"",
        ""Check implementation against INFTXSimpleFeeDistributor interface"",
        ""Validate the use of SafeERC20Upgradeable for token transfers"",
        ""Ensure proper upgradeable contract pattern implementation""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, functional, and economic aspects of the contract.
2. Each area focuses on specific potential vulnerabilities identified in the initial analysis.
3. Tasks are designed to be actionable and specific to the contract's unique implementation.
4. The audit approach considers both technical security and economic game theory aspects.

Recommended Next Steps:
- Conduct a systematic review following these task categories
- Use static analysis tools to complement manual review
- Perform detailed code walkthrough and potential exploit scenario testing
- Consider formal verification for critical mathematical operations

The task list provides a structured approach to thoroughly audit the NFTXSimpleFeeDistributor contract, addressing potential risks and ensuring robust implementation.","I've thoroughly analyzed the provided smart contract code. Here's my comprehensive audit:

{
  ""ReviewingTheCode"": ""This is a fee distribution contract for the NFTX protocol that manages how fees collected from NFTX vaults are distributed to various receivers. The contract allows for configurable allocation of fees to different stakeholders in the system, with special handling for the LP staking contract and an inventory staking mechanism."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXSimpleFeeDistributor"",
    ""Purpose"": ""Manages the distribution of fees collected from NFTX vaults to various stakeholders based on configurable allocation points"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""INFTXSimpleFeeDistributor"",
        ""ReentrancyGuardUpgradeable"",
        ""PausableUpgradeable""
      ],
      ""Imports"": [
        ""INFTXLPStaking"",
        ""INFTXSimpleFeeDistributor"",
        ""INFTXInventoryStaking"",
        ""INFTXVaultFactory"",
        ""IERC20Upgradeable"",
        ""SafeERC20Upgradeable"",
        ""SafeMathUpgradeable"",
        ""PausableUpgradeable"",
        ""ReentrancyGuardUpgradeable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""distributionPaused"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate if fee distribution is currently paused""
      },
      {
        ""Name"": ""nftxVaultFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the NFTX vault factory contract""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the LP staking contract that receives fees""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the treasury that receives fees when distribution is paused or there is leftover""
      },
      {
        ""Name"": ""allocTotal"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Sum of all allocation points for fee receivers""
      },
      {
        ""Name"": ""feeReceivers"",
        ""Type"": ""FeeReceiver[]"",
        ""Purpose"": ""Array of fee receivers with their allocation points""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the inventory staking contract""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""__SimpleFeeDistributor__init__"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializer function that sets up the contract with initial parameters"",
        ""Parameters"": [""_lpStaking: address"", ""_treasury: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""distribute"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes fees collected from a specific vault to fee receivers based on allocation points"",
        ""Parameters"": [""vaultId: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReceiver"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new fee receiver with specified allocation points"",
        ""Parameters"": [""_allocPoint: uint256"", ""_receiver: address"", ""_isContract: bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""initializeVaultReceivers"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes receivers for a new vault, adding pools in LP staking and deploying XTokens"",
        ""Parameters"": [""_vaultId: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeReceiverAlloc"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Changes the allocation points for an existing fee receiver"",
        ""Parameters"": [""_receiverIdx: uint256"", ""_allocPoint: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeReceiverAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Changes the address of an existing fee receiver"",
        ""Parameters"": [""_receiverIdx: uint256"", ""_address: address"", ""_isContract: bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeReceiver"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes a fee receiver from the list"",
        ""Parameters"": [""_receiverIdx: uint256""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTreasuryAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the treasury address"",
        ""Parameters"": [""_treasury: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLPStakingAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the LP staking address"",
        ""Parameters"": [""_lpStaking: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setInventoryStakingAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the inventory staking address"",
        ""Parameters"": [""_inventoryStaking: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setNFTXVaultFactory"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the NFTX vault factory address"",
        ""Parameters"": [""_factory: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""pauseFeeDistribution"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Pauses or unpauses fee distribution"",
        ""Parameters"": [""pause: bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""rescueTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to rescue tokens accidentally sent to the contract"",
        ""Parameters"": [""_address: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addReceiver"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to add a new fee receiver"",
        ""Parameters"": [""_allocPoint: uint256"", ""_receiver: address"", ""_isContract: bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""_sendForReceiver"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to send tokens to a fee receiver, with special handling for contract receivers"",
        ""Parameters"": [""_receiver: FeeReceiver"", ""_vaultId: uint256"", ""_vault: address"", ""amountToSend: uint256""],
        ""Returns"": [""success: bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20Upgradeable for token transfers and approvals"",
    ""INFTXVaultFactory to get vault addresses"",
    ""INFTXLPStaking for receiving rewards and adding pools"",
    ""INFTXInventoryStaking for deploying XTokens""
  ],
  ""SpecialMechanisms"": [
    ""Fee distribution mechanism with configurable allocation points"",
    ""Special handling for contract receivers vs. regular address receivers"",
    ""Low-level call to contract receivers using abi.encodeWithSelector"",
    ""Upgradeability pattern using initializer instead of constructor"",
    ""Reentrancy protection on the distribute function"",
    ""Fallback mechanism to send undistributed tokens to treasury""
  ],
  ""Questions"": [
    ""Is there validation to ensure that the allocation points are reasonable values?"",
    ""What happens if _sendForReceiver fails for a contract receiver but doesn't revert?"",
    ""How is the contract handling potential precision loss when calculating amounts based on allocation points?"",
    ""Is there a maximum limit on the number of fee receivers that can be added?"",
    ""What safeguards are in place to ensure the LP staking contract correctly implements the receiveRewards function?"",
    ""Could the approve-then-call pattern in _sendForReceiver create potential risks if the receiver contract is malicious?"",
    ""Is the ownership model secure, and who has the ability to call onlyOwner functions?""
  ]
}","I've analyzed the input data, which contains multiple assessments of security issues in the NFTXSimpleFeeDistributor contract. I've combined similar issues and structured them by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Unsafe External Call Pattern in _sendForReceiver"",
      ""Severity"": ""High"",
      ""Description"": ""The _sendForReceiver function uses a low-level call to interact with external receiver contracts but doesn't properly validate the execution results. It approves tokens before making the call and only checks if the call succeeded and if the allowance is zero afterward. This doesn't guarantee that tokens were actually processed correctly, and doesn't follow the checks-effects-interactions pattern."",
      ""Impact"": ""A malicious receiver contract could exploit this pattern by partially using the allowance, making the function incorrectly determine success/failure, or executing additional unwanted operations. This could lead to token theft, improper distribution of funds, or reentrancy attacks despite the nonReentrant modifier."",
      ""Location"": ""_sendForReceiver function at the end of the contract""
    },
    {
      ""Issue"": ""Reentrancy Risk in distribute Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""Although the distribute function uses the nonReentrant modifier, there is still a potential reentrancy vulnerability in the interaction with external contracts through _sendForReceiver. The contract updates state after making external calls which could be exploited by a malicious receiver contract."",
      ""Impact"": ""A malicious receiver contract could potentially re-enter the contract during execution and manipulate the distribution process for other receivers in the same transaction, potentially leading to fund loss or unintended distribution patterns."",
      ""Location"": ""distribute function and its interaction with _sendForReceiver""
    },
    {
      ""Issue"": ""Centralization Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has significant centralization risks with the owner having extensive control over fee distribution parameters, receiver configurations, and the ability to rescue (withdraw) any tokens. The owner can add/remove/modify fee receivers, change critical addresses like treasury and staking addresses, pause distributions, and withdraw tokens without any timelock or delay mechanisms."",
      ""Impact"": ""If the owner account is compromised, an attacker could redirect fees to malicious addresses, modify allocation points, withdraw funds, or disrupt the fee distribution mechanism to benefit themselves at the expense of other participants."",
      ""Location"": ""Throughout the contract, particularly in admin functions like addReceiver, changeReceiverAlloc, changeReceiverAddress, removeReceiver, setTreasuryAddress, setLPStakingAddress, pauseFeeDistribution, rescueTokens, etc.""
    },
    {
      ""Issue"": ""Missing Zero Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions including __SimpleFeeDistributor__init__, _addReceiver, and changeReceiverAddress lack validation to ensure that addresses are not set to the zero address. While some setter functions like setTreasuryAddress check for zero addresses, others don't, creating inconsistent validation patterns throughout the contract."",
      ""Impact"": ""Tokens could be permanently lost if a receiver, treasury, or other critical address is accidentally set to the zero address. The contract could also be initialized with invalid parameters, requiring additional transactions to fix."",
      ""Location"": ""__SimpleFeeDistributor__init__, _addReceiver, changeReceiverAddress functions""
    },
    {
      ""Issue"": ""No Validation for Allocation Points"",
      ""Severity"": ""Medium"",
      ""Description"": ""When adding or updating fee receivers, there is no validation of the allocPoint values. The contract does not check if allocation points are reasonable values or follow any specific rules, potentially allowing extremely large values that could distort distribution ratios."",
      ""Impact"": ""Improperly set allocation points could cause some receivers to get virtually nothing or nearly all distributed tokens. Extremely large allocation points could potentially cause calculation issues or overflow in extreme cases. Small allocation points might result in receivers never receiving tokens due to rounding errors."",
      ""Location"": ""_addReceiver and changeReceiverAlloc functions""
    },
    {
      ""Issue"": ""Initialization Without Factory Set"",
      ""Severity"": ""Medium"",
      ""Description"": ""The __SimpleFeeDistributor__init__ function sets up the contract but doesn't require nftxVaultFactory to be set, yet the distribute function requires it to be non-zero. This could lead to a situation where the contract is initialized but cannot distribute fees."",
      ""Impact"": ""The contract could be deployed in a state where core functionality doesn't work until additional configuration is performed."",
      ""Location"": ""__SimpleFeeDistributor__init__ function""
    },
    {
      ""Issue"": ""Unbounded Array Growth Risk"",
      ""Severity"": ""Low"",
      ""Description"": ""There is no limit to how many fee receivers can be added to the feeReceivers array. As this array grows, the gas costs for distributing fees increase, potentially causing transactions to exceed block gas limits."",
      ""Impact"": ""If too many receivers are added, the distribute function might become too gas-expensive to execute, effectively freezing the fee distribution system."",
      ""Location"": ""_addReceiver and removeReceiver functions""
    },
    {
      ""Issue"": ""Improper Array Manipulation in removeReceiver"",
      ""Severity"": ""Low"",
      ""Description"": ""The removeReceiver function swaps the removed receiver with the last element in the array and then pops the array. While this is gas-efficient, it changes the indices of receivers, which might cause confusion if indices are stored off-chain or used in subsequent calls."",
      ""Impact"": ""Changed indices could lead to operational errors if external systems rely on specific receiver indices."",
      ""Location"": ""removeReceiver function""
    },
    {
      ""Issue"": ""Integer Division Rounding in Fee Distribution"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation of fees to distribute uses integer division which could lead to precision loss and small amounts of tokens being left in the contract when dividing the token balance according to allocation points."",
      ""Impact"": ""Small amounts of tokens might accumulate in the contract over time due to rounding errors, not being properly distributed to receivers. Over time, some tokens may be trapped in the contract or disproportionately sent to the treasury."",
      ""Location"": ""distribute function, calculation of amountToSend""
    },
    {
      ""Issue"": ""Potentially Redundant Token Approval"",
      ""Severity"": ""Low"",
      ""Description"": ""In _sendForReceiver, the contract approves tokens before each call without first resetting allowances to zero, which is a recommended pattern when dealing with certain ERC20 tokens. Some older ERC20 tokens require setting allowance to zero before changing it to a non-zero value."",
      ""Impact"": ""Some non-standard ERC20 tokens might behave unexpectedly with this approval pattern, potentially causing transactions to fail."",
      ""Location"": ""_sendForReceiver function""
    },
    {
      ""Issue"": ""Lack of Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions don't emit events for important state changes. The rescueTokens function doesn't emit events when tokens are withdrawn, and the distribute function doesn't emit events when distributions occur. The initialize function also doesn't emit appropriate events for initial state setup."",
      ""Impact"": ""Reduced transparency and difficulty tracking emergency actions, distribution activities, and contract initialization state changes off-chain."",
      ""Location"": ""rescueTokens function, distribute function, __SimpleFeeDistributor__init__ function""
    },
    {
      ""Issue"": ""No Access Control for distribute Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The distribute function can be called by anyone, potentially allowing attackers to front-run distribution or trigger distributions at suboptimal times."",
      ""Impact"": ""Potential gas griefing or manipulation of distribution timing through front-running."",
      ""Location"": ""distribute function""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 12
}",412.22037982940674,54561.0,36.0,"### **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**

**Report Description**:
In the `NFTXSimpleFeeDistributor.sol` contract, the `distribute` function uses the `_sendForReceiver` function to distribute fees. The `_sendForReceiver` function does not return a value when the receiver is not a contract, causing the `distribute` function to incorrectly assume the transfer failed. This results in the same fee amount being sent multiple times, leading to overpayment to some receivers and underpayment to others. This issue is exacerbated by the implicit return of `false` in Solidity when no value is explicitly returned.

**Match in Response List**:
Matches with the issue titled **""Unsafe External Call Pattern in _sendForReceiver""**.

**Validation**:
**Partially Correct**. The response identifies the issue with unsafe external calls in the `_sendForReceiver` function but does not specifically address the problem of the missing return value when the receiver is not a contract. The response focuses on the broader risks of external calls and allowance manipulation but misses the critical detail of the implicit return value causing double payments.

---

### **[M-01] Missing non reentrancy modifier**

**Report Description**:
Several functions in the contract are missing the `nonReentrant` modifier, even though other public/external functions use it. While no direct exploit path was identified, the absence of the modifier in these functions could potentially lead to reentrancy vulnerabilities, especially if the contract interacts with untrusted external contracts.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Risk in distribute Function""**.

**Validation**:
**Correct**. The response accurately identifies the reentrancy risk in the `distribute` function, which interacts with external contracts through `_sendForReceiver`. While the response focuses on the `distribute` function, it correctly highlights the broader reentrancy risks associated with external calls, aligning with the issue report.

---

### **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**

**Report Description**:
The `addReceiver` function does not check if a receiver already exists in the `feeReceivers` array. This oversight could lead to the same receiver being added multiple times, resulting in erroneous fee distributions. The duplicate entries would cause the receiver to receive more fees than intended until the duplicate is removed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The absence of a check for existing receivers is a significant oversight that could lead to incorrect fee distributions, but it is not covered in the response list.

---

### **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**

**Report Description**:
The `_sendForReceiver` function does not return a success value when the receiver is not a contract, leading to double payments of fees. This issue causes the first receivers in the `feeReceivers` list to receive more fees at the expense of the last ones, as the `distribute` function incorrectly assumes the transfer failed and retries the payment.

**Match in Response List**:
Matches with the issue titled **""Unsafe External Call Pattern in _sendForReceiver""**.

**Validation**:
**Partially Correct**. The response identifies the broader issue of unsafe external calls in `_sendForReceiver` but does not specifically address the problem of the missing return value when the receiver is not a contract. The response misses the critical detail of the implicit return value causing double payments.

---

### **[M-14] Return variable can remain unassigned in _sendForReceiver**

**Report Description**:
The `_sendForReceiver` function only sets a return value in the ""if"" block but not in the ""else"" block. If the ""else"" block is executed (e.g., when the receiver is not a contract), no value is returned, and Solidity implicitly returns `false`. This causes the `distribute` function to incorrectly assume the transfer failed, leading to double payments and potential token loss to the treasury.

**Match in Response List**:
Matches with the issue titled **""Unsafe External Call Pattern in _sendForReceiver""**.

**Validation**:
**Partially Correct**. The response identifies the broader issue of unsafe external calls in `_sendForReceiver` but does not specifically address the problem of the unassigned return variable in the ""else"" block. The response misses the critical detail of the implicit return value causing double payments.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:
A malicious receiver can exploit the `distribute` function by causing it to revert, leading to a denial of service. This could be achieved by manipulating the `_sendForReceiver` function, which is called by `distribute`, to fail or revert under certain conditions.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Risk in distribute Function""**.

**Validation**:
**Correct**. The response accurately identifies the reentrancy risk in the `distribute` function, which could be exploited by a malicious receiver to cause a denial of service. The response correctly highlights the broader risks associated with external calls, aligning with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Missing non reentrancy modifier**
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**Partially Correct Matches**:

- **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**
- **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**
- **[M-14] Return variable can remain unassigned in _sendForReceiver**

**Missed Issues from Issue Report**:

- **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**

---","```
1. Reentrancy Risk in distribute Function
2. Reentrancy Risk in distribute Function
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives**:
   - The true positives are ""Reentrancy Risk in distribute Function"".
   - This issue appears twice in the ranked list of predictions, at rank 2 and rank 3.

2. **Calculate the precision at each rank**:
   - At rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.6667}{2} = \frac{1.1667}{2} \approx 0.5833 \)

**Output**:
```
0.5833
```"
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750,561,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users

Submitted by pedroais
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Proof of Concept

Considering: The pool manager is the creator of the pool. Anyone can create a pool. Manager is not a trusted actor.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock

Submitted by gzeon
The default value of inventoryLockTime in NFTXStakingZap is 7 days while DEFAULT_LOCKTIME in NFTXInventoryStaking is 2 ms. These timelock value are used in NFTXInventoryStaking to eventually call _timelockMint in XTokenUpgradeable.
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74
function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {
  uint256 timelockFinish = block.timestamp + timelockLength;
  timelock[account] = timelockFinish;
  emit Timelocked(account, timelockFinish);
  _mint(account, amount);
}

The applicable timelock is calculated by block.timestamp + timelockLength, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling deposit in NFTXInventoryStaking
",2,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033,0,2,"Based on the comprehensive initial analysis, here's a detailed audit task list targeting key areas of concern:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the random number generation (getRandomTokenIdFromVault) for potential manipulation or predictability"",
        ""Verify reentrancy protection mechanisms in critical functions like mint, redeem, and swap"",
        ""Check for potential integer overflow/underflow in mathematical operations, especially in fee calculations"",
        ""Validate input validation and bounds checking in all external and public functions"",
        ""Review special transfer methods for ERC721 tokens (transferERC721 and transferFromERC721) for potential security gaps""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyPrivileged() and onlyOwnerIfPaused() access control mechanisms"",
        ""Verify the manager and owner role separation and potential privilege escalation risks"",
        ""Review the assignDefaultFeatures() function with its hardcoded address for potential centralization risks"",
        ""Analyze the conditions and implications of setting the manager to address(0)""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate all external contract calls, especially to vaultFactory, eligibilityStorage, and feeDistributor"",
        ""Check the safety of cross-contract interactions in deployEligibilityStorage()"",
        ""Review special handling for CryptoKitties and CryptoPunks transfers for potential vulnerabilities"",
        ""Verify error handling and return value checks in external calls""
      ]
    },
    {
      ""Area"": ""Eligibility and NFT Handling"",
      ""Tasks"": [
        ""Analyze the allValidNFTs() method for comprehensive eligibility checking"",
        ""Review the implementation of ERC1155 and ERC721 token handling for potential edge cases"",
        ""Check the afterRedeemHook() method for potential vulnerabilities in eligibility storage interactions"",
        ""Verify the quantity tracking mechanism for ERC1155 tokens""
      ]
    },
    {
      ""Area"": ""Fee Mechanism"",
      ""Tasks"": [
        ""Audit the fee calculation and distribution logic in _chargeAndDistributeFees()"",
        ""Verify the exclusion mechanism for fees (vaultFactory.excludedFromFees())"",
        ""Check the precision and potential rounding issues in fee calculations"",
        ""Review the impact of disableVaultFees() on the contract's economic model""
      ]
    },
    {
      ""Area"": ""Upgradability and Initialization"",
      ""Tasks"": [
        ""Verify the initialization process in __NFTXVault_init()"",
        ""Check for potential reinitializability issues"",
        ""Review the usage of upgradeable contract patterns"",
        ""Validate the initialization of inherited upgradeable contracts""
      ]
    },
    {
      ""Area"": ""Flash Loan Security"",
      ""Tasks"": [
        ""Thoroughly review the inherited flash loan implementation"",
        ""Check for potential flash loan-based attack vectors"",
        ""Verify the security of the flashLoan() method override""
      ]
    },
    {
      ""Area"": ""Randomness and Entropy"",
      ""Tasks"": [
        ""Deeply analyze the getRandomTokenIdFromVault() method for entropy quality"",
        ""Check the randomness generation using block properties for potential manipulation"",
        ""Verify the randNonce increment mechanism and its effectiveness""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption in core functions like mint, redeem, and swap"",
        ""Review the efficiency of EnumerableSetUpgradeable usage"",
        ""Check for potential gas optimization opportunities in loops and storage operations""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify full compliance with ERC20, ERC721, and ERC1155 standards"",
        ""Check implementation of required interfaces and methods"",
        ""Review the version() method and ensure it reflects the current contract version""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the NFTXVaultUpgradeable contract, covering critical security, functional, and performance aspects. Each area is broken down into specific, actionable tasks that target potential vulnerabilities and design considerations identified in the initial analysis.

The tasks are designed to:
1. Systematically examine security risks
2. Validate access control mechanisms
3. Ensure robust external interactions
4. Verify complex logic implementations
5. Check economic and fee mechanisms
6. Assess upgradability and initialization
7. Validate randomness and entropy
8. Optimize performance
9. Ensure standards compliance

Auditors should methodically work through these tasks, documenting findings, potential vulnerabilities, and recommended improvements.","After thoroughly reviewing the code, I've prepared the following audit analysis:

{
  ""ReviewingTheCode"": ""This code implements an NFT vault system as part of the NFTX protocol. The NFTXVaultUpgradeable contract serves as a core component that allows users to deposit NFTs (both ERC721 and ERC1155) in exchange for fungible ERC20 tokens, and later redeem these tokens for NFTs. It also supports swapping NFTs and features like random redemption and targeted redemption."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXVaultUpgradeable"",
    ""Purpose"": ""A token vault that locks NFT assets and mints ERC20 tokens representing fractional ownership. It enables users to mint tokens by depositing NFTs, redeem tokens for NFTs, and swap NFTs directly."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""OwnableUpgradeable"",
        ""ERC20FlashMintUpgradeable"",
        ""ReentrancyGuardUpgradeable"",
        ""ERC721SafeHolderUpgradeable"",
        ""ERC1155SafeHolderUpgradeable"",
        ""INFTXVault""
      ],
      ""Imports"": [
        ""INFTXVault"",
        ""INFTXVaultFactory"",
        ""INFTXEligibility"",
        ""INFTXEligibilityManager"",
        ""INFTXLPStaking"",
        ""INFTXFeeDistributor"",
        ""IERC165Upgradeable"",
        ""ERC20FlashMintUpgradeable"",
        ""ERC721SafeHolderUpgradeable"",
        ""ERC1155SafeHolderUpgradeable"",
        ""IERC721Upgradeable"",
        ""IERC1155Upgradeable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuardUpgradeable"",
        ""EnumerableSetUpgradeable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""base"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Base unit for token calculations (10^18)""
      },
      {
        ""Name"": ""vaultId"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Unique identifier for this vault""
      },
      {
        ""Name"": ""manager"",
        ""Type"": ""address"",
        ""Purpose"": ""Address with management permissions for the vault""
      },
      {
        ""Name"": ""assetAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the NFT contract that this vault accepts""
      },
      {
        ""Name"": ""vaultFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Reference to the factory that created this vault""
      },
      {
        ""Name"": ""eligibilityStorage"",
        ""Type"": ""INFTXEligibility"",
        ""Purpose"": ""Contract that determines which NFTs are eligible for deposit""
      },
      {
        ""Name"": ""randNonce"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Nonce for generating random numbers for NFT selection""
      },
      {
        ""Name"": ""is1155"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if the vault accepts ERC1155 tokens (vs ERC721)""
      },
      {
        ""Name"": ""allowAllItems"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if all NFTs are accepted without eligibility check""
      },
      {
        ""Name"": ""enableMint"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag controlling if minting is enabled""
      },
      {
        ""Name"": ""enableRandomRedeem"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag controlling if random redemption is enabled""
      },
      {
        ""Name"": ""enableTargetRedeem"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag controlling if targeted redemption is enabled""
      },
      {
        ""Name"": ""enableRandomSwap"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag controlling if random swapping is enabled""
      },
      {
        ""Name"": ""enableTargetSwap"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag controlling if targeted swapping is enabled""
      },
      {
        ""Name"": ""holdings"",
        ""Type"": ""EnumerableSetUpgradeable.UintSet"",
        ""Purpose"": ""Set that tracks all NFT IDs held by the vault""
      },
      {
        ""Name"": ""quantity1155"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Tracks quantity of each ERC1155 token ID held""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""__NFTXVault_init"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializer function that sets up the vault with initial configuration"",
        ""Parameters"": [""_name"", ""_symbol"", ""_assetAddress"", ""_is1155"", ""_allowAllItems""],
        ""Returns"": []
      },
      {
        ""Name"": ""finalizeVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes the manager role by setting it to address(0)"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setVaultMetadata"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the name and symbol of the ERC20 token"",
        ""Parameters"": [""name_"", ""symbol_""],
        ""Returns"": []
      },
      {
        ""Name"": ""setVaultFeatures"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures which features are enabled in the vault"",
        ""Parameters"": [""_enableMint"", ""_enableRandomRedeem"", ""_enableTargetRedeem"", ""_enableRandomSwap"", ""_enableTargetSwap""],
        ""Returns"": []
      },
      {
        ""Name"": ""assignDefaultFeatures"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets swap features to match redeem features (admin function)"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the fee rates for various operations"",
        ""Parameters"": [""_mintFee"", ""_randomRedeemFee"", ""_targetRedeemFee"", ""_randomSwapFee"", ""_targetSwapFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""disableVaultFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Disables all fees for the vault"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""deployEligibilityStorage"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deploys and sets the eligibility contract for the vault"",
        ""Parameters"": [""moduleIndex"", ""initData""],
        ""Returns"": [""address of deployed eligibility contract""]
      },
      {
        ""Name"": ""setManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the manager address"",
        ""Parameters"": [""_manager""],
        ""Returns"": []
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits NFTs and mints tokens to the sender"",
        ""Parameters"": [""tokenIds"", ""amounts""],
        ""Returns"": [""uint256 amount of tokens minted""]
      },
      {
        ""Name"": ""mintTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits NFTs and mints tokens to a specified address"",
        ""Parameters"": [""tokenIds"", ""amounts"", ""to""],
        ""Returns"": [""uint256 amount of tokens minted""]
      },
      {
        ""Name"": ""redeem"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns tokens to redeem NFTs to the sender"",
        ""Parameters"": [""amount"", ""specificIds""],
        ""Returns"": [""uint256[] ids of redeemed NFTs""]
      },
      {
        ""Name"": ""redeemTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns tokens to redeem NFTs to a specified address"",
        ""Parameters"": [""amount"", ""specificIds"", ""to""],
        ""Returns"": [""uint256[] ids of redeemed NFTs""]
      },
      {
        ""Name"": ""swap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Swaps provided NFTs for other NFTs in the vault"",
        ""Parameters"": [""tokenIds"", ""amounts"", ""specificIds""],
        ""Returns"": [""uint256[] ids of received NFTs""]
      },
      {
        ""Name"": ""swapTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Swaps provided NFTs for other NFTs in the vault to a specified address"",
        ""Parameters"": [""tokenIds"", ""amounts"", ""specificIds"", ""to""],
        ""Returns"": [""uint256[] ids of received NFTs""]
      },
      {
        ""Name"": ""flashLoan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Provides flash loan functionality from ERC20FlashMintUpgradeable"",
        ""Parameters"": [""receiver"", ""token"", ""amount"", ""data""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""mintFee/randomRedeemFee/targetRedeemFee/randomSwapFee/targetSwapFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Retrieves the current fee rates from the factory"",
        ""Parameters"": [],
        ""Returns"": [""uint256 fee amount""]
      },
      {
        ""Name"": ""allValidNFTs"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if an array of NFT IDs are eligible for the vault"",
        ""Parameters"": [""tokenIds""],
        ""Returns"": [""bool validity""]
      },
      {
        ""Name"": ""receiveNFTs"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles the receipt of NFTs into the vault"",
        ""Parameters"": [""tokenIds"", ""amounts""],
        ""Returns"": [""uint256 count of NFTs received""]
      },
      {
        ""Name"": ""withdrawNFTsTo"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Manages withdrawal of NFTs from the vault"",
        ""Parameters"": [""amount"", ""specificIds"", ""to""],
        ""Returns"": [""uint256[] ids of withdrawn NFTs""]
      },
      {
        ""Name"": ""getRandomTokenIdFromVault"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Selects a random NFT from the vault's holdings"",
        ""Parameters"": [],
        ""Returns"": [""uint256 tokenId""]
      },
      {
        ""Name"": ""onlyPrivileged"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Modifier-like function that restricts access to owner or manager"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwnerIfPaused"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Enforces that only owner can call when specific functionality is paused"",
        ""Parameters"": [""lockId""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""INFTXVaultFactory - Interacts with the factory contract to manage fees and configuration"",
    ""INFTXEligibility - Checks eligibility of NFTs for the vault"",
    ""INFTXEligibilityManager - Deploys new eligibility modules"",
    ""INFTXFeeDistributor - Distributes collected fees"",
    ""IERC721Upgradeable/IERC1155Upgradeable - Interacts with the underlying NFT contracts"",
    ""Special handling for CryptoKitties and CryptoPunks through direct contract calls""
  ],
  ""SpecialMechanisms"": [
    ""Random NFT selection using block data for entropy"",
    ""Fee management system with different fees for different operations"",
    ""Eligibility system for filtering which NFTs can be deposited"",
    ""Upgradeable pattern using initializers instead of constructors"",
    ""Flash loan capability inherited from ERC20FlashMintUpgradeable"",
    ""Special handling for legacy NFTs like CryptoKitties and CryptoPunks that don't fully conform to ERC721"",
    ""Multi-level privilege system with owner and manager roles"",
    ""Functionality for both ERC721 and ERC1155 token standards""
  ],
  ""Questions"": [
    ""The randomness mechanism relies on block properties. Could this be susceptible to manipulation by miners or validators?"",
    ""What's the purpose of the UNUSED_FEE1, UNUSED_FEE2, UNUSED_FEE3 variables?"",
    ""The assignDefaultFeatures function can only be called by a hardcoded address. What's the reasoning for this design decision?"",
    ""When transferFromERC721 is called, there's a check to see if the contract already owns the token - what scenario is this handling?"",
    ""How are the fees actually distributed after they're collected through the FeeDistributor?"",
    ""What safeguards exist if the eligibility contract has errors or becomes non-functional?""
  ]
}

In conclusion, this contract serves as a core component of the NFTX protocol, creating tokenized vaults for NFT collections. It allows users to deposit their NFTs to mint fungible ERC20 tokens, redeem those tokens for NFTs (either randomly or specifically targeted), and directly swap NFTs. 

The contract has sophisticated fee mechanisms, eligibility controls for NFT deposits, and specialized handling for different NFT standards. It implements necessary security features like reentrancy protection and careful access controls. The contract is designed as an upgradeable proxy with initializers instead of constructors.

The most complex aspects include the random NFT selection process, the fee management system, and the special handling for legacy NFT standards. Any security review should pay special attention to these areas as well as the randomness implementation which relies on block properties for entropy.","I've analyzed the provided security findings from multiple sources and consolidated similar issues. Here's the combined report:

{
  ""Findings"": [
    {
      ""Issue"": ""Vulnerable Random Number Generation"",
      ""Severity"": ""High"",
      ""Description"": ""The getRandomTokenIdFromVault() function uses predictable on-chain data (blockhash, block.coinbase, block.difficulty, block.timestamp) for randomness. These sources are manipulable by miners/validators and can be predicted, making the random selection vulnerable to exploitation."",
      ""Impact"": ""Malicious actors (especially miners) can manipulate or predict the randomness to influence which NFTs will be selected during random redemption or swaps, potentially extracting the most valuable NFTs from the vault while leaving less valuable ones behind. This undermines the fairness of the random redemption mechanism."",
      ""Location"": ""getRandomTokenIdFromVault() function""
    },
    {
      ""Issue"": ""Hardcoded Address with Special Privileges"",
      ""Severity"": ""High"",
      ""Description"": ""The assignDefaultFeatures() function contains a hardcoded address (0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a) that has special privileges to modify core vault features. This creates a centralization risk and a permanent backdoor to vault configuration that cannot be changed even if ownership is transferred."",
      ""Impact"": ""If the hardcoded address is compromised, an attacker could modify vault features across multiple vaults without proper authorization. Additionally, if the address is lost, this functionality becomes permanently inaccessible."",
      ""Location"": ""assignDefaultFeatures() function""
    },
    {
      ""Issue"": ""Insufficient ERC721 Transfer Validation"",
      ""Severity"": ""High"",
      ""Description"": ""The transferERC721() and transferFromERC721() functions use low-level calls to handle transfers of ERC721 tokens with special cases for CryptoKitties and CryptoPunks. These implementations lack comprehensive error handling and don't fully validate transfer success for all possible NFT implementations. The contract only checks if the call was successful but doesn't verify if the transfer was actually completed."",
      ""Impact"": ""This could lead to silent failures where transfers might appear successful when they've actually failed, potentially leading to loss of NFTs, tokens being locked in the contract, or inconsistent state between the contract's internal accounting and actual token ownership."",
      ""Location"": ""transferERC721() and transferFromERC721() functions""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract uses ReentrancyGuardUpgradeable for public functions, the internal functions that handle NFT transfers make external calls to NFT contracts which could introduce reentrancy vulnerabilities. Of particular concern is that state changes (modifying holdings and quantity mappings) occur before external calls in some functions."",
      ""Impact"": ""If an NFT contract is malicious or vulnerable, it could potentially exploit callbacks during safeTransfer to re-enter the contract and manipulate the vault's state, potentially allowing double-spending or theft of assets."",
      ""Location"": ""withdrawNFTsTo() function and NFT transfer functions""
    },
    {
      ""Issue"": ""Centralization Risks in Access Control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract implements a dual owner/manager model where both have privileged access to critical functions through onlyPrivileged(). This creates multiple attack vectors and centralization risks. The contract also uses onlyOwnerIfPaused() which allows normal operation if the vault is not locked, but only permits the owner to execute functions if the vault is locked."",
      ""Impact"": ""If either the owner or manager address is compromised, an attacker can modify vault settings, change fees, or alter eligibility criteria. This centralization could lead to user distrust or potential for abuse by the contract owner."",
      ""Location"": ""onlyPrivileged() function, onlyOwnerIfPaused() function, and all functions using these modifiers""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions like mintTo(), swapTo(), and receiveNFTs() don't validate that arrays (tokenIds and amounts) have the same length when handling ERC1155 tokens. Additionally, the setFees() function doesn't validate fee values, potentially allowing fees to be set at extremely high values."",
      ""Impact"": ""If arrays have mismatched lengths, it could lead to unexpected behavior, out-of-bounds array access, or potential loss of tokens. For fees, a malicious manager or owner could set predatory fees, effectively blocking vault usage or draining user funds during operations."",
      ""Location"": ""mintTo(), swapTo(), receiveNFTs() functions and setFees() function""
    },
    {
      ""Issue"": ""Special Handling for Specific NFT Collections"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has special handling for CryptoKitties and CryptoPunks with hardcoded addresses. If these projects migrate to new contracts or change their interfaces, the vault would be unable to handle them correctly. Additionally, there's no mechanism to add new special cases without upgrading the entire contract."",
      ""Impact"": ""If the targeted projects undergo contract upgrades or interface changes, the vault may fail to process these tokens correctly. The vault might not work correctly with other non-standard NFT collections that require special handling, potentially leading to locked assets."",
      ""Location"": ""transferERC721() and transferFromERC721() functions""
    },
    {
      ""Issue"": ""Fee Distribution Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _chargeAndDistributeFees() function calls distribute() on the fee distributor without validating the return value or using a try/catch mechanism. Additionally, fees are sent to a feeDistributor contract controlled by the vault factory, creating a centralization point for fee collection."",
      ""Impact"": ""If the fee distribution mechanism encounters an issue, users might be unable to mint, redeem, or swap tokens, effectively locking the vault's functionality. If the fee distributor contract is compromised or has flaws, collected fees could be lost or misdirected."",
      ""Location"": ""_chargeAndDistributeFees() function""
    },
    {
      ""Issue"": ""Lack of Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The mint, redeem, and swap functions do not include deadline parameters or slippage protection. This makes transactions vulnerable to sandwich attacks and other MEV-related issues."",
      ""Impact"": ""Users might receive fewer tokens or less valuable NFTs than expected due to front-running or other MEV exploitation."",
      ""Location"": ""mint(), redeem(), and swap() functions""
    },
    {
      ""Issue"": ""Missing Event Emission for Security-Critical Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several security-critical functions like disableVaultFees() don't emit events, making it difficult to track certain administrative actions off-chain."",
      ""Impact"": ""The lack of event emissions for certain operations reduces contract transparency and makes it harder to monitor administrative actions, leading to reduced transparency and more difficult auditing of vault state changes over time."",
      ""Location"": ""disableVaultFees() function and other administrative functions""
    },
    {
      ""Issue"": ""Potential Flash Loan Attack Vector"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits ERC20FlashMintUpgradeable and allows flash loans. While flash loans themselves aren't vulnerabilities, they can amplify other vulnerabilities by providing large amounts of capital without upfront costs."",
      ""Impact"": ""If other vulnerabilities exist in the protocol, flash loans could be used to exploit them at a larger scale."",
      ""Location"": ""flashLoan() function and inheritance from ERC20FlashMintUpgradeable""
    },
    {
      ""Issue"": ""No Circuit Breaker for Emergency Situations"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract uses a pause mechanism through vaultFactory.isLocked(), it doesn't implement a complete circuit breaker pattern that would allow halting all operations in case of a critical vulnerability."",
      ""Impact"": ""In the event of a discovered vulnerability, there may not be adequate measures to immediately halt all contract operations, potentially leading to continued exploitation."",
      ""Location"": ""function onlyOwnerIfPaused() and pause mechanisms""
    }
  ],
  ""IssueNumber"": 61,
  ""OutputList"": 12
}",408.6044280529022,90773.0,32.0,"### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:
The Pool Manager, who is the creator of the pool, can front-run user deposits by setting the entry fee to the maximum value (100%). Since the manager is not a trusted actor, this allows them to exploit users by stealing their deposits. The issue arises because anyone can create a pool, and the manager can manipulate the fee structure to their advantage, especially when large deposits are made.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of a pool manager front-running user deposits to set fees to 100%. While the response list includes issues related to centralization risks and fee distribution, it does not cover the scenario where a manager can exploit the fee mechanism to steal user funds. This is a significant oversight, as the described vulnerability poses a direct financial risk to users.

---

### **[M-09] Bypass zap timelock**

**Report Description**:
The `inventoryLockTime` in `NFTXStakingZap` is set to 7 days by default, while the `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is set to 2 ms. The `_timelockMint` function in `XTokenUpgradeable` calculates the timelock finish time as `block.timestamp + timelockLength`, even if an existing timelock is further in the future. This allows users to reduce their long timelock (e.g., 7 days) to 2 ms by calling the `deposit` function in `NFTXInventoryStaking`, effectively bypassing the intended timelock mechanism.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of bypassing the timelock mechanism. While the response list includes issues related to access control and reentrancy vulnerabilities, it does not cover the specific scenario where users can reduce their timelock duration by exploiting the `deposit` function. This is a critical oversight, as the described vulnerability undermines the security of the timelock mechanism.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**
- **[M-09] Bypass zap timelock**

---

### **Conclusion**
The response list does not adequately address the issues reported in the `issue` list. Both **[M-05]** and **[M-09]** describe significant vulnerabilities that are not covered in the response list. This indicates a gap in the analysis and highlights the need for a more comprehensive review of the smart contract's security mechanisms.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and thus the average precision is also zero."
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}

",4828,479,"[M-08] Low-level call return value not checked

Submitted by cmichel
The NFTXStakingZap.addLiquidity721ETHTo function performs a low-level .call in payable(to).call{value: msg.value-amountEth} but does not check the return value if the call succeeded.
",1,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,0,1,"Based on the initial analysis, here's a comprehensive audit task list for the NFTXStakingZap contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly review the reentrancy guard implementation for potential bypass vulnerabilities"",
        ""Verify that all external calls are protected against reentrancy attacks"",
        ""Check for potential integer overflow/underflow risks in mathematical operations"",
        ""Validate input validation and sanitization across all public and external functions"",
        ""Examine the transfer mechanisms for ERC721 tokens, especially for special cases like CryptoKitties and CryptoPunks""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the ownership transfer and renouncement mechanisms"",
        ""Verify that sensitive functions like setLPLockTime and setInventoryLockTime have proper access controls"",
        ""Check the completeness of the onlyOwner modifier implementation"",
        ""Review the rescue function for potential misuse""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze the safety of interactions with NFTX Vault Factory, LP Staking, and Inventory Staking contracts"",
        ""Verify the correctness of SushiSwap router interactions"",
        ""Check for potential issues in the pairFor and sortTokens custom implementations"",
        ""Validate the WETH deposit and withdrawal mechanisms"",
        ""Review the error handling for external contract calls""
      ]
    },
    {
      ""Area"": ""Liquidity Provision"",
      ""Tasks"": [
        ""Verify the correctness of liquidity addition mechanisms for both ERC721 and ERC1155 tokens"",
        ""Check slippage protection and minimum amount checks in liquidity functions"",
        ""Analyze the token balance verification logic in _addLiquidity functions"",
        ""Review the timelock mechanisms for LP and inventory tokens""
      ]
    },
    {
      ""Area"": ""Token Handling"",
      ""Tasks"": [
        ""Verify the approval and transfer mechanisms for different token standards (ERC721, ERC1155)"",
        ""Check the handling of tokens with non-standard implementations"",
        ""Review the token minting and burning processes"",
        ""Validate the token balance calculations and verifications""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of complex functions"",
        ""Check for unnecessary storage operations"",
        ""Review the efficiency of loop implementations"",
        ""Verify the use of immutable and constant variables""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Identify and test potential edge cases in token transfers"",
        ""Verify error message clarity and informativeness"",
        ""Check handling of unexpected input values"",
        ""Review the receive() function for potential issues""
      ]
    },
    {
      ""Area"": ""Staking Mechanisms"",
      ""Tasks"": [
        ""Verify the correctness of timelockMintFor and timelockDepositFor implementations"",
        ""Check the lock time calculations and enforcements"",
        ""Review the stake distribution logic"",
        ""Validate the event emissions for staking operations""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify ERC721 and ERC1155 token standard compliance"",
        ""Check implementation of required interface methods"",
        ""Review adherence to NFTX protocol standards"",
        ""Validate cross-contract interactions""
      ]
    },
    {
      ""Area"": ""Economic Security"",
      ""Tasks"": [
        ""Analyze potential economic attack vectors"",
        ""Check for possible flash loan or price manipulation risks"",
        ""Review the economic incentives in the liquidity provision mechanism"",
        ""Validate the fairness of token minting and staking processes""
      ]
    }
  ]
}

This task list provides a comprehensive approach to auditing the NFTXStakingZap contract, covering multiple critical aspects of smart contract security and functionality. Each area includes specific, actionable tasks that will help thoroughly examine the contract's implementation, security, and potential vulnerabilities.

The tasks are designed to be:
- Relevant to the specific contract implementation
- Specific in their scope
- Actionable for an auditor
- Covering a wide range of potential security and functional concerns

Would you like me to elaborate on any of these audit areas or provide more detailed guidance on how to approach these tasks?","After reviewing the provided code, here's my analysis:

{
  ""ReviewingTheCode"": ""The NFTXStakingZap contract is designed to facilitate providing liquidity and staking for NFTX vaults. It integrates with SushiSwap for liquidity provision and with NFTX's staking systems for both inventory and LP tokens. The contract serves as a user-friendly way to convert NFTs (both ERC721 and ERC1155) into liquidity positions which are then automatically staked in NFTX's staking contracts."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXStakingZap"",
    ""Purpose"": ""This contract facilitates the minting of NFTX tokens from NFTs, providing liquidity on SushiSwap, and automatically staking the resulting LP tokens or inventory in the NFTX staking contracts with time locks."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""INFTXVault"", ""INFTXVaultFactory"", ""INFTXSimpleFeeDistributor"", 
        ""INFTXLPStaking"", ""INFTXInventoryStaking"", ""ITimelockRewardDistributionToken"", 
        ""IUniswapV2Router01"", ""IERC721"", ""IERC1155Upgradeable"", ""IERC20Upgradeable"",
        ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable"", ""OwnableUpgradeable""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Reference to the Wrapped Ether contract used for ETH/WETH conversions""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Reference to the NFTX LP staking contract""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""INFTXInventoryStaking"",
        ""Purpose"": ""Reference to the NFTX inventory staking contract""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Reference to the NFTX vault factory contract""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Reference to the SushiSwap router for liquidity operations""
      },
      {
        ""Name"": ""lpLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time duration for which LP tokens are locked when staked (default 48 hours)""
      },
      {
        ""Name"": ""inventoryLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time duration for which inventory tokens are locked when staked (default 7 days)""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Base unit multiplier (10^18) for calculations""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with NFTX Factory and SushiRouter addresses"",
        ""Parameters"": [""_nftxFactory"", ""_sushiRouter""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLPLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to set the lock time for LP tokens"",
        ""Parameters"": [""newLPLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""setInventoryLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to set the lock time for inventory tokens"",
        ""Parameters"": [""newInventoryLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits ERC721 tokens into inventory staking"",
        ""Parameters"": [""vaultId"", ""tokenIds""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits ERC1155 tokens into inventory staking"",
        ""Parameters"": [""vaultId"", ""tokenIds"", ""amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLiquidity721ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to ERC721 vault pairs using ETH"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity721ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to ERC721 vault pairs using ETH and assigns to a specified address"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""to""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to ERC1155 vault pairs using ETH"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minEthIn""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to ERC1155 vault pairs using ETH and assigns to a specified address"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minEthIn"", ""to""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to ERC721 vault pairs using WETH"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity721To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to ERC721 vault pairs using WETH and assigns to a specified address"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to ERC1155 vault pairs using WETH"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to ERC1155 vault pairs using WETH and assigns to a specified address"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""liquidity""]
      },
      {
        ""Name"": ""_addLiquidity721WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to process ERC721 token deposits and add liquidity"",
        ""Parameters"": [""vaultId"", ""ids"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""amountToken"", ""amountEth"", ""liquidity""]
      },
      {
        ""Name"": ""_addLiquidity1155WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to process ERC1155 token deposits and add liquidity"",
        ""Parameters"": [""vaultId"", ""ids"", ""amounts"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""amountToken"", ""amountEth"", ""liquidity""]
      },
      {
        ""Name"": ""_addLiquidityAndLock"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Adds liquidity using SushiSwap and locks the resulting LP tokens"",
        ""Parameters"": [""vaultId"", ""vault"", ""minTokenIn"", ""minWethIn"", ""wethIn"", ""to""],
        ""Returns"": [""amountToken"", ""amountEth"", ""liquidity""]
      },
      {
        ""Name"": ""transferFromERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles transfers of ERC721 tokens with special cases for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr"", ""tokenId"", ""to""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Approves ERC721 tokens with special cases for CryptoKitties and CryptoPunks"",
        ""Parameters"": [""assetAddr"", ""to"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""pairFor"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Computes the address of a SushiSwap pair without making an external call"",
        ""Parameters"": [""tokenA"", ""tokenB""],
        ""Returns"": [""pair""]
      },
      {
        ""Name"": ""sortTokens"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Sorts token addresses for consistent pair creation"",
        ""Parameters"": [""tokenA"", ""tokenB""],
        ""Returns"": [""token0"", ""token1""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive ETH"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""rescue"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows owner to rescue tokens accidentally sent to the contract"",
        ""Parameters"": [""token""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""NFTX Vault Factory (nftxFactory)"",
    ""NFTX LP Staking (lpStaking)"",
    ""NFTX Inventory Staking (inventoryStaking)"",
    ""SushiSwap Router (sushiRouter)"",
    ""Wrapped ETH (WETH)"",
    ""ERC721 tokens (including special cases for CryptoKitties and CryptoPunks)"",
    ""ERC1155 tokens"",
    ""NFTX vault tokens"",
    ""SushiSwap LP tokens""
  ],
  
  ""SpecialMechanisms"": [
    ""Integration with NFTX protocol for NFT vault tokens"",
    ""Special handling for legacy NFT tokens (CryptoPunks and CryptoKitties)"",
    ""Custom implementation of SushiSwap pair address computation"",
    ""Timelock mechanisms for both inventory and LP token staking"",
    ""Reentrancy protection for critical functions"",
    ""ETH/WETH conversions for various liquidity provision operations""
  ],
  
  ""Questions"": [
    ""Is there a need for additional slippage protection in the liquidity provision functions?"",
    ""Are there any risks associated with the permanent token approvals given to the SushiSwap router in the constructor?"",
    ""Is the order of operations in the _addLiquidityAndLock function optimal to prevent potential issues?"",
    ""How does the contract handle failed NFT transfers or approvals for non-standard ERC721 implementations?"",
    ""Is the rescue function sufficient for recovering all types of assets that might get stuck in the contract?"",
    ""Are the timelock durations appropriate for the use case and have they been reviewed for security implications?""
  ]
}","I've analyzed the provided findings about the NFTXStakingZap contract and have consolidated similar issues. Here's the structured output:

{
  ""Findings"": [
    {
      ""Issue"": ""Unchecked return values in ETH transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses .call{value: x}() to send ETH refunds without checking the return value. This occurs in functions like addLiquidity721ETHTo and addLiquidity1155ETHTo. If the ETH transfer fails, the transaction will still complete successfully as if the refund was processed."",
      ""Impact"": ""Failed ETH transfers could result in funds being locked in the contract instead of returned to users, leading to permanent loss of funds."",
      ""Location"": ""Functions addLiquidity721ETHTo and addLiquidity1155ETHTo where payable(to).call{value: msg.value-amountEth} is used""
    },
    {
      ""Issue"": ""Reentrancy vulnerabilities in ETH refund logic"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract uses ReentrancyGuard for protection, there are external calls to untrusted addresses after state changes, particularly in functions that refund ETH. Even with the nonReentrant modifier, complex attack vectors might still exploit the order of operations."",
      ""Impact"": ""An attacker could potentially drain the contract or manipulate token balances by exploiting the reentrancy vulnerability, especially in interactions with multiple external contracts."",
      ""Location"": ""Functions addLiquidity721ETHTo and addLiquidity1155ETHTo where ETH is refunded after operations""
    },
    {
      ""Issue"": ""Rescue function allows arbitrary token withdrawal"",
      ""Severity"": ""High"",
      ""Description"": ""The rescue() function allows the owner to withdraw any ERC20 token from the contract. This could be misused to extract tokens that should be locked or that belong to users whose transactions are in progress."",
      ""Impact"": ""If used while user funds are temporarily held in the contract, the owner could extract those funds, resulting in loss of user assets, creating a centralization risk."",
      ""Location"": ""rescue() function""
    },
    {
      ""Issue"": ""Lack of slippage protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses block.timestamp as the deadline for transactions and lacks comprehensive slippage protection. While it accepts minWethIn for some functions, it doesn't allow users to specify a transaction deadline, making it vulnerable to front-running attacks."",
      ""Impact"": ""Users might receive unfavorable exchange rates or fewer LP tokens than expected if their transactions are delayed in the mempool or if market conditions change between submission and execution."",
      ""Location"": ""In _addLiquidityAndLock function where sushiRouter.addLiquidity is called with block.timestamp as the deadline parameter""
    },
    {
      ""Issue"": ""Permanent approval to external contracts"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract approves the maximum possible amount (type(uint256).max) for WETH to the router in the constructor, which creates a security risk if the router is compromised. This infinite approval is never revoked."",
      ""Impact"": ""If the SushiSwap router is compromised, all WETH in the contract could be at risk of being drained without additional transactions needed."",
      ""Location"": ""Constructor: IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max)""
    },
    {
      ""Issue"": ""Lack of input validation for arrays"",
      ""Severity"": ""Medium"",
      ""Description"": ""In functions like provideInventory1155 and addLiquidity1155WETH, there's no validation that tokenIds and amounts arrays have the same length, that arrays aren't empty, or that token IDs exist and are owned by the sender. This could lead to out-of-bounds access or unexpected behavior."",
      ""Impact"": ""Array index out of bounds errors, incorrect token transfers, or failed transactions if arrays of mismatched lengths are provided. Users might also pay gas for transactions that will inevitably fail."",
      ""Location"": ""Functions provideInventory1155, addLiquidity1155WETH, addLiquidity1155ETH and other functions handling array inputs""
    },
    {
      ""Issue"": ""Tight coupling with external contracts"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract depends heavily on external contracts like NFTX Vaults, LP Staking, and SushiSwap, with many assumptions about their behavior. It relies on the state and behavior of these external contracts, and if any of them change their implementation or have bugs, it would directly affect this contract."",
      ""Impact"": ""Changes or vulnerabilities in dependent contracts could lead to unexpected behavior or security issues in this contract. If SushiSwap changes their router or factory address, this contract might interact with outdated contracts or become unusable."",
      ""Location"": ""Throughout the contract, particularly in constructor and functions interacting with external contracts""
    },
    {
      ""Issue"": ""Potential DOS in batch operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has several loops that could potentially hit the gas limit if a large number of tokens are provided, especially in provideInventory721 and _addLiquidity721WETH. Functions handling batch operations process arrays without gas limits."",
      ""Impact"": ""Transactions could revert due to out-of-gas errors when processing large numbers of tokens, effectively denying service to users with many NFTs."",
      ""Location"": ""Loops in provideInventory721, _addLiquidity721WETH, and other functions handling arrays""
    },
    {
      ""Issue"": ""Insufficient checks for token minting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract assumes that a specific amount of tokens will be minted when calling vault.mint, but doesn't handle cases where the actual minted amount differs from expected. If vault behavior changes or if fees are introduced, the contract might proceed with incorrect token amounts."",
      ""Impact"": ""If vault behavior changes or if fees are introduced, the contract might proceed with incorrect token amounts, potentially causing loss of funds."",
      ""Location"": ""_addLiquidity721WETH and _addLiquidity1155WETH functions""
    },
    {
      ""Issue"": ""Hardcoded addresses for special NFTs"",
      ""Severity"": ""Low"",
      ""Description"": ""The transferFromERC721 and approveERC721 functions use hardcoded addresses for CryptoKitties and CryptoPunks. This approach is brittle and could lead to issues if there are changes to these protocols or if the contract needs to support other non-standard NFTs."",
      ""Impact"": ""Limited flexibility and potential for broken functionality if the special NFT contracts change or if new non-standard NFTs need to be supported. The contract may not work correctly on networks where these special NFTs have different addresses."",
      ""Location"": ""Functions transferFromERC721 and approveERC721 with hardcoded addresses for CryptoKitties and CryptoPunks""
    },
    {
      ""Issue"": ""Use of hardcoded SushiSwap pair initialization code hash"",
      ""Severity"": ""Low"",
      ""Description"": ""The pairFor function uses a hardcoded initialization code hash for SushiSwap pairs. If SushiSwap were to update their implementation, this would break the contract's functionality."",
      ""Impact"": ""LP token addresses might be incorrectly calculated if SushiSwap changes its pair initialization code. If SushiSwap changes their contract deployment mechanism or init code, this contract will fail to correctly identify liquidity pairs."",
      ""Location"": ""Function pairFor""
    },
    {
      ""Issue"": ""Centralized control of lock times"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract owner has significant privileges including the ability to change lock times. While there are upper bounds (7 days for LP and 14 days for inventory), the owner could still reduce these times to very short periods."",
      ""Impact"": ""Users may stake expecting a certain lock period, only to have it changed by the contract owner. A malicious or compromised owner could manipulate lock times to disadvantage users."",
      ""Location"": ""Functions setLPLockTime and setInventoryLockTime""
    },
    {
      ""Issue"": ""Lack of events for critical operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Many critical operations like setting lock times and rescue operations don't emit events, making it hard to track contract activity off-chain."",
      ""Impact"": ""Reduced transparency and difficulty monitoring important contract state changes, which could hide malicious actions."",
      ""Location"": ""setLPLockTime(), setInventoryLockTime(), and rescue() functions""
    },
    {
      ""Issue"": ""No mechanism to handle stuck tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""While there is a rescue function for ERC20 tokens, there's no mechanism to rescue accidentally sent ERC721 or ERC1155 tokens that aren't part of the intended operations."",
      ""Impact"": ""NFTs sent to this contract by mistake would be permanently locked."",
      ""Location"": ""The rescue function only handles ERC20 tokens""
    },
    {
      ""Issue"": ""Unused receive() function"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract includes an empty receive() function which could potentially accept ETH without proper accounting or purpose."",
      ""Impact"": ""This could lead to ETH being trapped in the contract or accounting discrepancies between operations."",
      ""Location"": ""receive() external payable {}""
    }
  ],
  ""IssueNumber"": 71,
  ""OutputList"": 15
}",433.1790080070496,88112.0,34.0,"### **[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value to determine if the call succeeded. This oversight could allow the transaction to complete successfully even if the ETH transfer fails, potentially leading to discrepancies in token balances or locked funds.

**Match in Response List**:  
Matches with the issue titled **""Unchecked return values in ETH transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked return values in ETH transfers, specifically in the `addLiquidity721ETHTo` function. It correctly explains the risks associated with not validating the return value of the `.call` operation, which aligns with Solidity best practices for secure contract interactions. The impact described (funds being locked in the contract) is also consistent with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-08] Low-level call return value not checked**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation confirms that the response list adequately addresses the reported issue, providing a correct and sufficient explanation of the vulnerability and its potential impact.","```
1. Unchecked return values in ETH transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked return values in ETH transfers"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
