nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTMarketReserveAuction.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797,677,"[H-01] NFT owner can create multiple auctions

  function `createReserveAuction()`
NFTMarketReserveAuction.sol#L325-L349 NFTMarketReserveAuction.sol#L596-L599
NFT owner can permanently lock funds of bidders.
Proof of Concept

Alice (the attacker) calls createReserveAuction, and creates one like normal. let this be auction id 1.
Alice calls createReserveAuction again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because _transferToEscrow doesn't revert if there's an existing auction. let this be Auction id 2.
Since nftContractToTokenIdToAuctionId[nftContract][tokenId] will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).
  [M-04] adminAccountMigration() Does Not Update buyPrice.seller

Submitted by leastwood, also found by cccz
NFTMarketReserveAuction.sol#L263-L292 NFTMarketBuyPrice.sol#L125-L141
The adminAccountMigration() function is called by the operator role to update all sellers' auctions. The auction.seller account is updated to the new address, however, the protocol fails to update buyPrice.seller. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then cancelBuyPrice() is called before migrating back.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();

error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);

error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();

error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);

error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();

error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);

error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();

error NFTMarketReserveAuction_Not_Matching_Seller(address seller);

error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();


abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  
  struct ReserveAuction {
    
    address nftContract;
    
    uint256 tokenId;
    
    address payable seller;
    
    uint256 duration;
    
    uint256 extensionDuration;
    
    
    uint256 endTime;
    
    
    address payable bidder;
    
    
    uint256 amount;
  }

  
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  
  
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  
  uint256[5] private __gap_was_config;

  
  uint256 private immutable DURATION;

  
  
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          

          if (auction.seller != originalAddress) {
            
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    
    _transferToEscrow(nftContract, tokenId);

    
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, 
      payable(0), 
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  
  
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;

        
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      

      if (auction.amount > amount) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      
      unchecked {
        
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        
        
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        

        if (auction.seller != seller) {
          
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        
        _finalizeReserveAuction(auctionId, false);

        
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      
      _finalizeReserveAuction(auctionId, true);
    }
  }

  
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  
  uint256[1000] private __gap;
}",3541,1,1,"Based on the comprehensive review of the NFTMarketReserveAuction contract, here's a detailed task list for the audit:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in all external and public functions, especially those handling fund transfers"",
        ""Analyze the implementation of ReentrancyGuardUpgradeable to ensure complete protection"",
        ""Check for potential integer overflow/underflow risks in arithmetic operations, especially in bid amount calculations"",
        ""Review the unchecked blocks for potential arithmetic vulnerabilities"",
        ""Validate input validation and sanitization in all external function parameters""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Audit the onlyFoundationAdmin and onlyFoundationOperator modifiers for proper access control"",
        ""Review the account migration mechanism for potential unauthorized address changes"",
        ""Verify the security of admin-only functions like adminCancelReserveAuction"",
        ""Check the signature-based account migration process for potential bypass vulnerabilities""
      ]
    },
    {
      ""Area"": ""Fund Management & Transfers"",
      ""Tasks"": [
        ""Thoroughly review the _sendValueWithFallbackWithdraw mechanism for potential fund transfer attacks"",
        ""Analyze the fee distribution logic in _distributeFunds function"",
        ""Verify the handling of ETH and FETH token interactions in placeBidOf function"",
        ""Check for potential reentrancy or race conditions in bid refund mechanisms"",
        ""Validate the escrow transfer logic to ensure NFTs cannot be stolen or locked""
      ]
    },
    {
      ""Area"": ""Auction Mechanism"",
      ""Tasks"": [
        ""Review the auction extension logic to prevent last-minute sniping"",
        ""Verify the minimum bid increment calculation for potential manipulation"",
        ""Check the auction creation, bidding, and finalization workflows for logical vulnerabilities"",
        ""Analyze the conditions for auction cancellation and invalidation"",
        ""Validate the handling of auction states (not started, in progress, ended)""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review interactions with external FETH token contract"",
        ""Verify the security of NFT transfer mechanisms in _transferToEscrow and _transferFromEscrow"",
        ""Check for potential issues with NFT approvals and transfers"",
        ""Analyze the interaction with the underlying NFT contracts""
      ]
    },
    {
      ""Area"": ""Gas Optimization & Efficiency"",
      ""Tasks"": [
        ""Identify potential gas optimization opportunities in loop structures"",
        ""Review the use of unchecked blocks for gas efficiency"",
        ""Analyze the storage and memory usage in complex functions"",
        ""Check for redundant computations or unnecessary storage operations""
      ]
    },
    {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Review all custom error definitions for comprehensive error handling"",
        ""Test edge cases in auction lifecycle (e.g., zero bids, max duration)"",
        ""Verify handling of unexpected or malformed inputs"",
        ""Check the robustness of error conditions in complex functions""
      ]
    },
    {
      ""Area"": ""Front-Running & Transaction Ordering"",
      ""Tasks"": [
        ""Analyze potential front-running risks in the bidding mechanism"",
        ""Review the bid placement logic for transaction ordering vulnerabilities"",
        ""Check for potential MEV (Miner Extractable Value) attack vectors""
      ]
    }
  ]
}

Key Observations and Recommendations:
1. The contract demonstrates a sophisticated auction mechanism with multiple layers of security.
2. There's a comprehensive use of OpenZeppelin's security libraries.
3. The implementation includes advanced features like auction extension and account migration.
4. Careful attention is needed to the complex interaction between ETH and FETH tokens.

Recommended Next Steps:
- Conduct a detailed line-by-line code review
- Perform comprehensive testing covering all identified scenarios
- Consider formal verification of critical mathematical operations
- Develop a comprehensive test suite that covers all identified potential vulnerabilities

The task list provides a structured approach to auditing this complex NFT marketplace reserve auction contract, focusing on security, functionality, and potential edge cases.","I'll perform a comprehensive audit of this smart contract code. Let me carefully analyze it section by section.

{
  ""ReviewingTheCode"": ""This contract implements a reserve auction functionality for NFT sales. It allows sellers to create auctions with a reserve price, where bidders can place bids, and the highest bidder at the end of the auction period wins the NFT. The contract includes mechanisms for extending auction duration to prevent sniping, handles bid refunds, and calculates fee distribution among stakeholders."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketReserveAuction"",
    ""Purpose"": ""Manages reserve auctions for NFTs, including creation, bidding, cancellation, and finalization with proper fund distribution"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"", 
        ""FoundationTreasuryNode"", 
        ""NFTMarketCore"", 
        ""ReentrancyGuardUpgradeable"", 
        ""SendValueWithFallbackWithdraw"",
        ""NFTMarketFees"",
        ""NFTMarketAuction""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol"",
        ""../libraries/AccountMigrationLibrary.sol"",
        ""./Constants.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketAuction.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketFees.sol"",
        ""./SendValueWithFallbackWithdraw.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""nftContractToTokenIdToAuctionId"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Maps from NFT contract + tokenId to the corresponding auction ID""
      },
      {
        ""Name"": ""auctionIdToAuction"",
        ""Type"": ""mapping(uint256 => ReserveAuction)"",
        ""Purpose"": ""Maps auction IDs to their ReserveAuction struct data""
      },
      {
        ""Name"": ""DURATION"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""Default auction duration, set during contract initialization""
      },
      {
        ""Name"": ""EXTENSION_DURATION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Time added to auction when a bid is placed near the end (15 minutes)""
      },
      {
        ""Name"": ""MAX_MAX_DURATION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Maximum possible auction duration (1000 days)""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyValidAuctionConfig"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures reserve price is not zero for auction creation or updates"",
        ""Parameters"": [""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the default auction duration and validates it against constraints"",
        ""Parameters"": [""uint256 duration""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminCancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to cancel an auction with a reason"",
        ""Parameters"": [""uint256 auctionId"", ""string calldata reason""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminAccountMigration"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Migrates seller addresses for multiple auctions"",
        ""Parameters"": [""uint256[] calldata listedAuctionIds"", ""address originalAddress"", ""address payable newAddress"", ""bytes memory signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows seller to cancel their auction before any bids are placed"",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""createReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates new auction with reserve price for an NFT"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""finalizeReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Finalizes an ended auction, transferring NFT and distributing funds"",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBid"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Places a bid using the sent ETH"",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBidOf"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Places a bid using both ETH and FETH balance if needed"",
        ""Parameters"": [""uint256 auctionId"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the reserve price of an auction that hasn't received bids yet"",
        ""Parameters"": [""uint256 auctionId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""_finalizeReserveAuction"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to finalize auction, handle transfers and payments"",
        ""Parameters"": [""uint256 auctionId"", ""bool keepInEscrow""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrow"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Overrides base function to handle NFT transfers from escrow with auction logic"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient"", ""address seller""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrowIfAvailable"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Transfers NFT if it's not in an active auction"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferToEscrow"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Handles transfer of NFT to escrow with auction-specific logic"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinBidAmount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns minimum bid amount for a given auction"",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""uint256 minimum""]
      },
      {
        ""Name"": ""getReserveAuction"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns auction details for a given auction ID"",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""ReserveAuction memory auction""]
      },
      {
        ""Name"": ""getReserveAuctionIdFor"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns auction ID for a given NFT contract and token ID"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""uint256 auctionId""]
      },
      {
        ""Name"": ""_getSellerFor"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Returns the seller for a given NFT, checking auctions first"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""address payable seller""]
      },
      {
        ""Name"": ""_isInActiveAuction"",
        ""Visibility"": ""internal view override"",
        ""Purpose"": ""Checks if an NFT is in an active auction that hasn't ended"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""bool""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""feth.marketWithdrawFrom() - Withdraws FETH tokens to cover bid amounts"",
    ""Inherits from multiple contracts like NFTMarketCore that handles NFT transfers"",
    ""Uses ReentrancyGuardUpgradeable for protecting against reentrancy attacks"",
    ""Uses _sendValueWithFallbackWithdraw for safely sending ETH with fallback mechanisms"",
    ""_distributeFunds for handling payment distribution to various stakeholders""
  ],
  
  ""SpecialMechanisms"": [
    ""Auction Time Extension: If a bid is placed close to auction end time, the end time is extended to prevent sniping"",
    ""Escrow Management: NFTs are held in escrow during auctions with complex logic for transfers"",
    ""Account Migration: Admin can help migrate seller accounts with proper authorization"",
    ""Minimum Bid Increments: Subsequent bids must exceed previous bids by a minimum percentage"",
    ""Bidder Refunds: Previous bidders automatically get refunded when outbid"",
    ""ReentrancyGuard: Protects against reentrancy attacks in all external functions"",
    ""Fee Distribution: Automatically calculates and distributes fees to creators, sellers and platform""
  ],
  
  ""Questions"": [
    ""What is the exact implementation of the _distributeFunds function that handles fee distribution?"",
    ""How does the FETH token work in conjunction with ETH for bid payments?"",
    ""What are the specific implementations of the _getMinIncrement and _getNextAndIncrementAuctionId functions?"",
    ""What's the implementation of _afterAuctionStarted and what side effects does it have?"",
    ""How does the contract handle approvals for transferring NFTs to escrow?"",
    ""What happens if there are royalties configured on the NFT contract itself?"",
    ""How does the contract handle scenarios where the NFT is transferred outside of the marketplace while an auction is active?""
  ]
}","I've analyzed the provided input data containing multiple security issue reports for the NFTMarketReserveAuction smart contract. After combining similar issues, removing redundancies, and sorting by severity, here's the consolidated output:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in _finalizeReserveAuction"",
      ""Severity"": ""High"",
      ""Description"": ""The _finalizeReserveAuction function deletes auction data before handling fund distribution. While the function itself is marked with nonReentrant, the order of operations (state changes before external calls) creates a potential reentrancy risk. External calls during fund distribution could enable reentrancy attacks if receiving contracts contain malicious code."",
      ""Impact"": ""If an attacker can reenter during fund distribution, they could potentially exploit state inconsistencies since auction data is already deleted, leading to double payments or other unexpected behavior."",
      ""Location"": ""_finalizeReserveAuction function""
    },
    {
      ""Issue"": ""Reentrancy risk in placeBidOf function"",
      ""Severity"": ""High"",
      ""Description"": ""The placeBidOf function contains potential reentrancy vectors when sending ETH to previous bidders and when interacting with the FETH contract. While ReentrancyGuard is used, the pattern of state changes before external calls could still be vulnerable if receiving contracts are malicious."",
      ""Impact"": ""A malicious bidder could potentially exploit callbacks when their bid is refunded, manipulating auction state or stealing funds through transaction sequencing."",
      ""Location"": ""placeBidOf function, particularly where _sendValueWithFallbackWithdraw is called""
    },
    {
      ""Issue"": ""Centralized admin controls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract includes admin functions that allow privileged users to cancel auctions (adminCancelReserveAuction) and migrate accounts (adminAccountMigration). This creates significant centralization risks where admins have unilateral control over the marketplace operations."",
      ""Impact"": ""Foundation admins could potentially interfere with legitimate auctions or forcibly move accounts, undermining trust in the platform's decentralization. If admin accounts are compromised, an attacker could manipulate auction outcomes."",
      ""Location"": ""adminCancelReserveAuction and adminAccountMigration functions""
    },
    {
      ""Issue"": ""Front-running vulnerability in bidding mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The bidding mechanism is susceptible to front-running attacks. Attackers can observe pending bid transactions in the mempool and submit their own with slightly higher amounts and gas prices to ensure their transactions are processed first."",
      ""Impact"": ""Legitimate bidders might consistently lose auctions to front-runners who can see their intended bid amounts, reducing platform usability and fairness, and potentially manipulating market prices."",
      ""Location"": ""placeBidOf function""
    },
    {
      ""Issue"": ""Auction extension mechanism vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The auction extension mechanism extends auctions by a fixed duration when bids are placed near the end. This can be manipulated by bidders to extend auctions through coordinated bidding."",
      ""Impact"": ""Auctions could be artificially extended, delaying finalization and potentially manipulating market dynamics or causing user frustration."",
      ""Location"": ""placeBidOf function auction extension logic""
    },
    {
      ""Issue"": ""Unchecked external calls in ETH transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses _sendValueWithFallbackWithdraw to transfer ETH to users, but there's limited visibility into how failed transfers are handled. While there appears to be a fallback mechanism, it's unclear if it's robust enough to handle all edge cases."",
      ""Impact"": ""If the transfer or withdrawal mechanism fails, users could potentially lose funds or they might be locked in the contract, requiring manual intervention."",
      ""Location"": ""placeBidOf function and _finalizeReserveAuction function when using _sendValueWithFallbackWithdraw""
    },
    {
      ""Issue"": ""Potential DOS in adminAccountMigration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The adminAccountMigration function processes arrays of auction IDs without any upper limit. If a large array is provided, this could exceed block gas limits and cause the transaction to fail, creating a potential denial of service."",
      ""Impact"": ""Could prevent legitimate account migrations if too many auctions need to be migrated at once, creating operational difficulties."",
      ""Location"": ""adminAccountMigration function""
    },
    {
      ""Issue"": ""Lack of zero address validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't consistently validate against zero addresses, particularly when dealing with seller, bidder, and NFT contract addresses. This creates risks where transfers could be made to address(0)."",
      ""Impact"": ""Tokens or ETH could be permanently lost if accidentally transferred to address(0), especially in edge cases or during migrations."",
      ""Location"": ""createReserveAuction, placeBidOf functions, and account migration code""
    },
    {
      ""Issue"": ""Incomplete validation of auction parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract has incomplete validation for auction parameters. While reservePrice is checked to be non-zero, other validations may be missing, such as checking if an auction exists before operations or validating upper bounds on prices."",
      ""Impact"": ""Could lead to unexpected behavior, stuck auctions with unrealistically high reserve prices, or operations on non-existent auctions."",
      ""Location"": ""createReserveAuction, updateReserveAuction, and _finalizeReserveAuction functions""
    },
    {
      ""Issue"": ""Account migration with signature verification risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract allows for account migration through signatures. Without seeing the full implementation of signature verification, there are concerns about potential flaws like replay protection or improper validation."",
      ""Impact"": ""If there's a vulnerability in the signature verification process, attackers could potentially migrate accounts without proper authorization."",
      ""Location"": ""adminAccountMigration function and AccountMigrationLibrary usage""
    },
    {
      ""Issue"": ""NFT transfer failure handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't have robust error handling for NFT transfers in _transferFromEscrow and _transferToEscrow. If an NFT transfer fails (e.g., due to a blacklist), the auction state could be inconsistent."",
      ""Impact"": ""Failed transfers could leave the contract in an inconsistent state where an NFT is still in escrow but the auction is invalidated, or vice versa."",
      ""Location"": ""_transferFromEscrow and _transferToEscrow functions""
    },
    {
      ""Issue"": ""Complex escrow management"",
      ""Severity"": ""Low"",
      ""Description"": ""The NFT escrow management is complex with multiple override functions (_transferFromEscrow, _transferFromEscrowIfAvailable, _transferToEscrow) that handle different auction states. This complexity increases the risk of edge case bugs."",
      ""Impact"": ""Potential for NFTs to be stuck in escrow or transferred incorrectly in edge cases due to the complexity of the escrow management logic."",
      ""Location"": ""_transferFromEscrow, _transferFromEscrowIfAvailable, and _transferToEscrow functions""
    },
    {
      ""Issue"": ""Timestamp dependence"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies heavily on block.timestamp for auction timing, which can be slightly manipulated by miners (by several seconds). This could affect auction end times in edge cases or the auction extension mechanism."",
      ""Impact"": ""Miners could potentially extend or slightly manipulate auction timing to their advantage, especially in high-value auctions where small timing advantages matter."",
      ""Location"": ""placeBidOf function and auction duration logic""
    },
    {
      ""Issue"": ""Fixed gas limits for ETH transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a fixed gas limit (SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT) when transferring ETH, which could be problematic if gas costs change significantly in Ethereum or if receiving contracts have complex logic."",
      ""Impact"": ""In the event of significant network changes to gas costs or if bidders use contracts with gas-heavy receive functions, transfers might fail, potentially locking funds."",
      ""Location"": ""_sendValueWithFallbackWithdraw calls in placeBidOf and adminCancelReserveAuction""
    },
    {
      ""Issue"": ""Lack of slippage protection"",
      ""Severity"": ""Low"",
      ""Description"": ""When bidding, users cannot specify a maximum bid amount, which means they may end up bidding more than necessary to outbid the previous bidder."",
      ""Impact"": ""Users may overpay significantly for auctions if they're not careful with bid amounts, especially in fast-moving auction situations."",
      ""Location"": ""placeBidOf function""
    },
    {
      ""Issue"": ""Insufficient event emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""Some state-changing operations don't emit appropriate events. Events like ReserveAuctionInvalidated don't include comprehensive information about why the auction was invalidated."",
      ""Impact"": ""Reduced transparency and difficulty in debugging auction issues or tracking contract activity through event logs, making off-chain monitoring more challenging."",
      ""Location"": ""Various functions throughout the contract, including _transferFromEscrow""
    },
    {
      ""Issue"": ""Gap variables usage pattern"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses __gap variables for upgradeability, with one gap array named '__gap_was_config' which suggests it was previously used. If not properly maintained across upgrades, this could lead to storage collisions."",
      ""Impact"": ""Could lead to upgrade errors or data corruption if developers misunderstand the purpose of storage slots during contract upgrades."",
      ""Location"": ""uint256[5] private __gap_was_config; and uint256[1000] private __gap;""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 17
}",369.6847150325775,84323.0,32.0,"### **[H-01] NFT owner can create multiple auctions**

**Report Description**:
The `createReserveAuction()` function in `NFTMarketReserveAuction.sol` allows an NFT owner to create multiple auctions for the same NFT. This occurs because `_transferToEscrow` does not revert if there is an existing auction. As a result, the NFT owner can create multiple auctions, and bidders may unknowingly bid on the wrong auction, leading to permanently locked funds. This vulnerability can be exploited by an attacker to create confusion and potentially lock funds of bidders.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of multiple auctions being created for the same NFT. The issue is specific to the `createReserveAuction()` function and the lack of validation in `_transferToEscrow`, which is not covered in the response list. This is a critical oversight as it directly impacts the integrity of the auction mechanism.

---

### **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

**Report Description**:
The `adminAccountMigration()` function in `NFTMarketReserveAuction.sol` updates the seller's address for auctions but fails to update the `buyPrice.seller` in `NFTMarketBuyPrice.sol`. This inconsistency creates a deadlock situation where the new address cannot cancel the auction or withdraw the NFT without the compromised account first canceling the buy price. This issue can only be resolved by migrating the account back to the compromised address and then canceling the buy price before migrating again.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `adminAccountMigration()` failing to update `buyPrice.seller`. This is a significant oversight as it creates a deadlock situation that can only be resolved through manual intervention, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] NFT owner can create multiple auctions**
- **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

---

### **Conclusion**
The response list does not adequately address the issues reported in the `issue` list. Both **[H-01]** and **[M-04]** are critical vulnerabilities that are entirely missed in the response list. This indicates a significant gap in the coverage of the response list, particularly in addressing issues related to auction creation and account migration. The response list focuses on other vulnerabilities like reentrancy and centralized admin controls but fails to address these specific issues, which are equally important for the security and functionality of the smart contract.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
NFTMarketCreators.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363,268,"[H-02] Creators can steal sale revenue from owners' sales

Submitted by IllIllI
NFTMarketCreators.sol#L158-L160 NFTMarketCreators.sol#L196-L198 NFTMarketCreators.sol#L97-L99
According to the README.md:
All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.
Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.
  [M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array

Submitted by leastwood
NFTMarketCreators.sol#L49-L251
The _getCreatorPaymentInfo() function is utilised by _distributeFunds() whenever an NFT sale is made. The function uses try and catch statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a try statement, the revert is actually not handled and it will not fall through to the empty catch statement.

[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns

Submitted by WatchPug
Based on our research, getRoyalties() is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.
However, in the current implementation, it always assumes that getRoyalties() return in terms of BPS.
NFTMarketCreators.sol#L85-L112
NFTMarketFees.sol#L86-L90
if (creatorShares[i] > BASIS_POINTS) {
    // If the numbers are >100% we ignore the fee recipients and pay just the first instead
    maxCreatorIndex = 0;
    break;
}

As a result, if a particular implementation is returning get Royalties() with higher precision (say 1e6 for 100% instead of 1e4/BPS), the distribution of royalties can be distorted.
",3,,"pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();


abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable 
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  
  
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    

    
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch 
      {
        
      }
    }

    
    
    
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          

          
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch 
            {
              
            }
          }

          
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch 
            {
              
            }
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch 
          {
            
          }
        }
      } catch 
      {
        
      }
    }

    
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          
          recipients = new address payable[](1);
          recipients[0] = _creator;
          
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch 
    {
      
    }

    
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch 
    {
      
    }

    
  }

  
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  
  uint256[500] private __gap;
}",1579,1,2,"Based on the detailed analysis of the NFTMarketCreators contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify the effectiveness of the ReentrancyGuardUpgradeable implementation"",
        ""Analyze try/catch blocks for potential information leakage or unexpected behavior"",
        ""Check for potential integer overflow/underflow risks in basis points calculations"",
        ""Examine the security of multiple external contract calls in _getCreatorPaymentInfo method""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate ERC165 interface checking mechanism for robustness"",
        ""Review the multiple interface detection and fallback logic for potential edge cases"",
        ""Assess the gas limit (READ_ONLY_GAS_LIMIT) for sufficiency across different contract implementations"",
        ""Verify the safety of dynamic contract address resolution via royaltyRegistry""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Confirm full compatibility with EIP-2981 Royalty Standard"",
        ""Verify support for multiple royalty interfaces (IRoyaltyInfo, IGetRoyalties, IGetFees)"",
        ""Check the contract's handling of different royalty implementation patterns"",
        ""Validate the logic for determining creator/seller relationship""
      ]
    },
    {
      ""Area"": ""Contract Design"",
      ""Tasks"": [
        ""Analyze the purpose and potential risks of the extensive __gap storage variable"",
        ""Review why the contract is abstract and its intended usage"",
        ""Examine the constructor's interface validation mechanism"",
        ""Investigate the rationale behind the specific order of royalty lookup mechanisms""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test scenarios with contracts that partially implement royalty interfaces"",
        ""Verify behavior when no royalty recipients are found"",
        ""Check handling of zero-address scenarios in recipients"",
        ""Test with tokens that have multiple royalty recipients"",
        ""Validate error propagation and silent failure mechanisms""
      ]
    },
    {
      ""Area"": ""Performance and Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas consumption of multiple external calls in _getCreatorPaymentInfo"",
        ""Review the efficiency of unchecked loops and interface checks"",
        ""Assess the performance impact of multiple fallback mechanisms"",
        ""Evaluate the gas cost of different royalty retrieval paths""
      ]
    },
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify the scope and limitations of the royaltyRegistry initialization"",
        ""Check fallback mechanisms for determining token creator/owner"",
        ""Assess potential risks in owner-based royalty fallback"",
        ""Validate the contract's approach to creator identification""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list is structured to comprehensively cover the contract's complex royalty resolution mechanism.
2. Tasks are designed to probe both obvious and subtle potential vulnerabilities.
3. The approach considers multiple dimensions: security, performance, compliance, and design integrity.
4. Special attention is given to the contract's unique approach of supporting multiple royalty standards.

Recommended Next Steps:
- Conduct thorough testing for each task in the list
- Use both static analysis tools and manual review
- Create comprehensive test cases covering various NFT contract scenarios
- Consider formal verification for critical paths in the code

The task list provides a structured approach to auditing this sophisticated NFT royalty handling contract, ensuring a methodical and thorough review.","After carefully analyzing the provided smart contract, here's my detailed audit:

{
  ""ReviewingTheCode"": ""This code defines an abstract contract called 'NFTMarketCreators' that handles various methods of retrieving creator and royalty information for NFTs. It tries multiple standard interfaces to find royalty recipients and their payment splits, with fallbacks for different standards and implementations."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketCreators"",
    ""Purpose"": ""To retrieve and process creator royalty payment information for NFT sales across different royalty standards and implementations"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"",
        ""ReentrancyGuardUpgradeable""
      ],
      ""Imports"": [
        ""ERC165Checker"",
        ""ReentrancyGuardUpgradeable"",
        ""Constants"",
        ""IGetFees"",
        ""IGetRoyalties"",
        ""IOwnable"",
        ""IRoyaltyInfo"",
        ""ITokenCreator"",
        ""IRoyaltyRegistry""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""royaltyRegistry"",
        ""Type"": ""IRoyaltyRegistry"",
        ""Purpose"": ""Immutable reference to the royalty registry contract for royalty lookups""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[500]"",
        ""Purpose"": ""Storage gap for upgradeable contract pattern to prevent storage collisions""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Initializes the contract with a royalty registry address, verifying it supports the required interface"",
        ""Parameters"": [""_royaltyRegistry: address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getCreatorPaymentInfo"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core function that tries multiple methods to retrieve royalty information for an NFT"",
        ""Parameters"": [
          ""nftContract: address"",
          ""tokenId: uint256"",
          ""seller: address""
        ],
        ""Returns"": [
          ""recipients: address payable[]"",
          ""splitPerRecipientInBasisPoints: uint256[]"",
          ""isCreator: bool""
        ]
      },
      {
        ""Name"": ""getRoyaltyRegistry"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the royalty registry contract"",
        ""Parameters"": [],
        ""Returns"": [""registry: address""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRoyaltyRegistry - Used to look up registry-overridden royalty information"",
    ""IRoyaltyInfo - EIP-2981 standard royalty interface"",
    ""IGetRoyalties - Alternative royalty interface"",
    ""IGetFees - Rarible royalty interface with separate calls for recipients and basis points"",
    ""ITokenCreator - Used to find the original creator of a token"",
    ""IOwnable - Fallback to use contract owner as recipient if no other method works"",
    ""ERC165Checker - Used to check if contracts support specific interfaces""
  ],
  ""SpecialMechanisms"": [
    ""Interface detection using ERC165"",
    ""Multiple fallback mechanisms for royalty detection"",
    ""Low-level try/catch pattern for resilient external calls"",
    ""Gas-limited external calls (READ_ONLY_GAS_LIMIT) to prevent DOS attacks"",
    ""Upgradeable contract pattern with storage gap"",
    ""Empty catch blocks to handle failed external calls gracefully""
  ],
  ""Questions"": [
    ""What defines the BASIS_POINTS constant from the Constants contract?"",
    ""Is there a reason splitPerRecipientInBasisPoints is sometimes not initialized when recipients are set?"",
    ""What's the rationale behind the specific order of royalty lookup mechanisms?"",
    ""Are there situations where a missing splitPerRecipientInBasisPoints array could cause issues elsewhere?"",
    ""Why does the contract determine isCreator status but doesn't use this flag internally?"",
    ""The gas limit (READ_ONLY_GAS_LIMIT) for external calls - is it sufficient for all potential implementations?"",
    ""Why is the contract abstract rather than a regular contract?""
  ]
}

The NFTMarketCreators contract is a sophisticated implementation that accommodates multiple royalty standards in the NFT ecosystem. Its primary strength is its flexible approach to discovering royalty recipients through various interfaces (EIP-2981, Manifold's registry, Rarible's approach, etc.).

The code employs defensive programming techniques such as try/catch blocks, gas limits on external calls, and null checks on addresses to ensure robustness when interacting with external contracts that might behave unexpectedly.

One notable aspect is how it prioritizes different royalty standards, trying them in sequence until finding valid information. The contract also checks if the seller is a royalty recipient, which suggests this information is used to potentially modify how funds are distributed during a sale.","I've analyzed the input data containing multiple sets of issues found in the `NFTMarketCreators` contract. After reviewing and consolidating similar issues, here's my final report:

{
  ""Findings"": [
    {
      ""Issue"": ""Incomplete Implementation of splitPerRecipientInBasisPoints"",
      ""Severity"": ""High"",
      ""Description"": ""In multiple cases, the function sets up recipients but never initializes or populates the corresponding splitPerRecipientInBasisPoints array. This occurs notably when retrieving royalty info using IRoyaltyInfo and when using ITokenCreator or IOwnable as fallbacks. This array remains uninitialized but is returned and likely used for payment calculations downstream."",
      ""Impact"": ""This could lead to serious payment calculation errors, potentially sending incorrect amounts to royalty recipients, causing transactions to revert due to array access out of bounds, or resulting in undefined behavior when processing payments."",
      ""Location"": ""_getCreatorPaymentInfo function, specifically in the IRoyaltyInfo.royaltyInfo handling section and in the ITokenCreator and IOwnable fallback sections""
    },
    {
      ""Issue"": ""Missing Validation for Royalty Percentages"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate that the sum of royalty percentages returned by various interfaces doesn't exceed 100% (10000 basis points). Without proper validation of royalty basis points, malicious contracts could return extremely high royalty percentages."",
      ""Impact"": ""NFT contracts could specify excessive royalties that consume all or most of the sale proceeds, potentially making transactions unprofitable for sellers or the marketplace, or causing transactions to fail if total exceeds 100%."",
      ""Location"": ""Throughout the _getCreatorPaymentInfo function where royalty basis points are retrieved""
    },
    {
      ""Issue"": ""Unlimited Gas Consumption in Multiple External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract uses READ_ONLY_GAS_LIMIT for each external call, the function _getCreatorPaymentInfo makes multiple external calls to various contract interfaces, which could collectively consume excessive gas. If this gas limit is too restrictive, it could prevent legitimate but complex royalty calculation logic from executing properly."",
      ""Impact"": ""The function could potentially hit block gas limits in complex scenarios with multiple fallback systems in place, causing transactions to fail unpredictably. Some NFT contracts with valid but gas-intensive royalty calculation logic might not work correctly with this marketplace, leading to creators not receiving their royalties."",
      ""Location"": ""_getCreatorPaymentInfo function, multiple external calls throughout the entire function using the gas: READ_ONLY_GAS_LIMIT parameter""
    },
    {
      ""Issue"": ""Insufficient Return Value Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes multiple external calls to various royalty interfaces but doesn't always properly validate the returned data. For example, in the IRoyaltyInfo call, it checks if the receiver is not zero but doesn't validate the royalty amount. Similarly, when getting royalties, it checks if _recipients.length > 0 but doesn't validate the actual contents beyond checking for address(0)."",
      ""Impact"": ""This could lead to incorrect royalty payments if contracts return malformed data but with valid array lengths. Malicious contracts could return manipulated royalty data that might lead to incorrect payments, potentially draining funds from the marketplace."",
      ""Location"": ""_getCreatorPaymentInfo function, particularly in the sections handling IRoyaltyInfo, IGetRoyalties, and IGetFees interfaces""
    },
    {
      ""Issue"": ""Potential Denial of Service in Royalty Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't validate the maximum length of royalty recipient arrays returned from external calls. If a malicious NFT contract implements the royalty interfaces but returns extremely large arrays of recipients, it could cause excessive gas consumption when processing royalties."",
      ""Impact"": ""Transactions involving such NFTs could consistently fail due to out-of-gas errors, effectively preventing their sale in the marketplace. This creates a potential denial of service for marketplace transactions involving malicious NFT contracts."",
      ""Location"": ""_getCreatorPaymentInfo function, particularly in loops processing recipient arrays returned from external calls""
    },
    {
      ""Issue"": ""Immutable State Variables in Upgradeable Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses an immutable state variable (royaltyRegistry) while inheriting from ReentrancyGuardUpgradeable, which suggests this is meant to be an upgradeable contract. Immutable variables are not compatible with the proxy upgrade pattern as they are set in the constructor and baked into the contract bytecode."",
      ""Impact"": ""This could break the upgradeability of the contract, as the immutable variable cannot be changed in upgraded implementations, potentially leading to centralization risks if the registry has issues or is deprecated."",
      ""Location"": ""Declaration of `IRoyaltyRegistry private immutable royaltyRegistry;` and constructor""
    },
    {
      ""Issue"": ""Missing Initialization Check"",
      ""Severity"": ""Medium"",
      ""Description"": ""As a contract that inherits from ReentrancyGuardUpgradeable, the NFTMarketCreators should ensure proper initialization, but there's no clear initialize function visible in the snippet that calls __ReentrancyGuard_init()."",
      ""Impact"": ""Potential for the reentrancy protection to be ineffective if the contract is not properly initialized."",
      ""Location"": ""Missing initialization in contract setup""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection in Key Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the contract inherits from ReentrancyGuardUpgradeable, the _getCreatorPaymentInfo function itself is not marked with nonReentrant modifier. Since it makes multiple external calls, it could be vulnerable to reentrancy attacks if those external contracts are malicious."",
      ""Impact"": ""Although _getCreatorPaymentInfo is a view function, any non-view functions that call it without reentrancy protection could be vulnerable if they rely on its return values for financial calculations."",
      ""Location"": ""_getCreatorPaymentInfo function""
    },
    {
      ""Issue"": ""Function can exceed stack depth limits"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _getCreatorPaymentInfo function is very complex with many local variables and nested function calls. This could potentially hit the EVM stack depth limits (16) in certain execution paths."",
      ""Impact"": ""Potential for 'stack too deep' compiler errors or unexpected behavior in complex scenarios."",
      ""Location"": ""_getCreatorPaymentInfo() function as a whole""
    },
    {
      ""Issue"": ""Nested Try-Catch with Empty Catch Blocks"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses multiple try-catch blocks with empty catch blocks. While the function is meant to gracefully handle failures when checking different royalty interfaces, this approach obscures errors and may hide important failure information. No logging or tracking of which methods failed makes debugging difficult."",
      ""Impact"": ""Debugging issues becomes more difficult, and silent failures could lead to unexpected behavior where royalty information is not properly retrieved but no error is reported. Operational issues might be harder to diagnose, and silent failures could mask problems with the royalty retrieval process."",
      ""Location"": ""Throughout the _getCreatorPaymentInfo function, all catch blocks are empty""
    },
    {
      ""Issue"": ""Redundant Code Duplication"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract duplicates code for checking IRoyaltyInfo and IGetRoyalties interfaces after obtaining an override contract from the royalty registry. This duplication increases the contract size and complexity."",
      ""Impact"": ""Increased deployment costs, reduced readability, and higher risk of inconsistencies if one section is updated but not the other."",
      ""Location"": ""_getCreatorPaymentInfo function, in the royalty registry override section""
    },
    {
      ""Issue"": ""Missing Event Logging for Important State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't emit events when important information is retrieved or when fallbacks are used, making it difficult to track which royalty mechanism was ultimately used for a transaction."",
      ""Impact"": ""Limited transparency and auditability of royalty payments, making it harder to debug issues or verify correct royalty distributions."",
      ""Location"": ""Throughout the _getCreatorPaymentInfo function""
    },
    {
      ""Issue"": ""Insufficient Separation of Concerns"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract handles too many different royalty standards in a single complex function, making it difficult to maintain and test thoroughly."",
      ""Impact"": ""Higher likelihood of bugs, difficult maintenance, and challenges in testing all possible scenarios and edge cases."",
      ""Location"": ""_getCreatorPaymentInfo function as a whole""
    },
    {
      ""Issue"": ""Inconsistent use of unchecked blocks"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses unchecked blocks for some loops but not others when the operations are similar. This inconsistency suggests a lack of systematic approach to gas optimization and overflow protection."",
      ""Impact"": ""Potential gas inefficiency and inconsistent overflow protection."",
      ""Location"": ""Some for loops use unchecked while others don't throughout the _getCreatorPaymentInfo function""
    },
    {
      ""Issue"": ""Large __gap Reserved Space"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract reserves a very large gap (500 slots) for future storage variables. While this helps with upgradeability, it's much larger than typically needed and consumes unnecessary contract storage."",
      ""Impact"": ""Increased contract deployment costs due to excessive storage reservation."",
      ""Location"": ""uint256[500] private __gap; at the end of the contract""
    }
  ],
  ""IssueNumber"": 47,
  ""OutputList"": 15
}",358.1058728694916,51688.0,32.0,"### **Summary of Matches and Gaps**

---

#### **[H-02] Creators can steal sale revenue from owners' sales**

**Report Description**:  
The issue highlights that creators can manipulate royalty information using the Royalty Registry just before a sale is completed. This allows them to change the royalty recipient, potentially redirecting funds intended for the owner. The vulnerability arises because the contract does not enforce immutability of royalty information once a sale is initiated, leading to potential revenue theft.

**Match in Response List**:  
No direct match found. The response list does not address the specific scenario where creators can modify royalty information during a sale.

**Validation**:  
**Incorrect**. The response list does not cover the issue of creators manipulating royalty information during a sale. This is a critical oversight, as it directly impacts the fairness and security of revenue distribution.

---

#### **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**

**Report Description**:  
The `_getCreatorPaymentInfo()` function uses `try` and `catch` statements to handle external calls, but it does not properly handle reverts within the `try` block. If an external call reverts, the function does not fall through to the `catch` block, potentially leaving NFTs locked in the contract. This issue arises due to the unbounded nature of the `_recipients` array and the lack of robust error handling.

**Match in Response List**:  
Partially matches with the issue titled **""Nested Try-Catch with Empty Catch Blocks""**.

**Validation**:  
**Partially Correct**. The response identifies the use of empty `catch` blocks, which is related to the issue. However, it does not specifically address the failure to handle reverts within the `try` block or the unbounded `_recipients` array, which are critical aspects of the vulnerability.

---

#### **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Report Description**:  
The issue arises because the contract assumes that `getRoyalties()` returns values in terms of basis points (BPS). If an NFT contract returns values with higher precision (e.g., 1e6 instead of 1e4), the royalty distribution can be distorted. This can lead to unfair payments to recipients, as the contract does not validate or normalize the precision of the returned values.

**Match in Response List**:  
Partially matches with the issue titled **""Missing Validation for Royalty Percentages""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of validation for royalty percentages, which is related to the issue. However, it does not specifically address the problem of non-standard precision in `getRoyalties()` returns, which is the core of the vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**  
- **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Missed Issues from Issue Report**:  
- **[H-02] Creators can steal sale revenue from owners' sales**

---

### **Conclusion**  
The response list partially addresses some of the issues but misses critical vulnerabilities, particularly the manipulation of royalty information during a sale. Additionally, the responses lack specificity in addressing the core problems, such as the unbounded `_recipients` array and non-standard precision in `getRoyalties()` returns. These gaps highlight the need for more comprehensive and detailed analysis in the response list.","```
None.
```",0.0
NFTMarketOffer.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149,404,"[H-03] An offer made after auction end can be stolen by an auction winner

Submitted by hyh, also found by leastwood, shenwilly, and WatchPug
An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as _transferFromEscrow being called by _acceptOffer will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.
This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.

[M-13] Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it

function makeOffer() 
If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via makeOffer, acceptOffer combination.
I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.
This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of setBuyPrice or createReserveAuction, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();

error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);

error NFTMarketOffer_Offer_Expired(uint256 expiry);

error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);

error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();


abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  
  struct Offer {
    
    
    uint32 expiration;
    
    uint96 amount;
    

    
    
    address buyer;
  }

  
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        
      }
    }
  }

  
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      

      
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      

      if (amount < _getMinIncrement(offer.amount)) {
        
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      
      
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    
    offer.buyer = msg.sender;
    
    offer.expiration = uint32(expiration);
    
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    
    delete nftContractToIdToOffer[nftContract][tokenId];
    
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) 
    {
      
    } catch {
      
      
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      
      _invalidateOffer(nftContract, tokenId);
    }
    
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      
      delete nftContractToIdToOffer[nftContract][tokenId];
      
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    
    return 1;
  }

  
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      
      return (address(0), 0, 0);
    }

    
    return (offer.buyer, offer.expiration, offer.amount);
  }

  
  uint256[1000] private __gap;
}",1815,1,1,"Based on the comprehensive initial analysis, here's a refined audit task list for the NFTMarketOffer contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in all external and public functions, especially in acceptOffer and makeOffer"",
        ""Check for potential integer overflow/underflow risks in amount calculations (despite using ^0.8.0)"",
        ""Analyze the unchecked block in adminCancelOffers for potential integer manipulation"",
        ""Validate the NFT transfer mechanism, including the try-catch fallback in _acceptOffer"",
        ""Review all external contract calls for potential injection or manipulation vectors""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Validate the onlyFoundationAdmin modifier implementation in adminCancelOffers"",
        ""Verify the scope and limitations of administrative cancellation powers"",
        ""Check that only authorized parties can perform critical contract actions"",
        ""Ensure proper access control in inherited contracts""
      ]
    },
    {
      ""Area"": ""Fund Management"",
      ""Tasks"": [
        ""Audit the FETH contract interaction mechanisms (marketLockupFor, marketUnlockFor, etc.)"",
        ""Verify fund distribution logic in _distributeFunds"",
        ""Check minimum offer amount calculations and increment logic"",
        ""Validate that locked funds are properly managed across different scenarios"",
        ""Ensure no funds can be permanently locked or lost""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review interactions with IERC721 contract during token transfers"",
        ""Validate error handling in NFT transfer attempts"",
        ""Check the robustness of cross-contract method calls"",
        ""Verify Oracle or external data source interactions (if applicable)""
      ]
    },
    {
      ""Area"": ""Offer Lifecycle Management"",
      ""Tasks"": [
        ""Analyze offer expiration and invalidation mechanisms"",
        ""Verify offer cancellation and modification processes"",
        ""Check auction and offer interaction logic"",
        ""Validate offer acceptance conditions and restrictions""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Review storage usage and optimize storage operations"",
        ""Analyze loop implementations for potential gas inefficiencies"",
        ""Check the use of unchecked blocks for potential gas savings"",
        ""Verify the efficiency of mapping and array operations""
      ]
    },
    {
      ""Area"": ""Upgradability and Extensibility"",
      ""Tasks"": [
        ""Verify the implementation of the storage gap mechanism"",
        ""Check compatibility with future contract upgrades"",
        ""Validate the initialization process for upgradeable contracts"",
        ""Ensure no storage layout conflicts in inherited contracts""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Review all custom error implementations for comprehensive coverage"",
        ""Test boundary conditions in offer amount and expiration"",
        ""Validate handling of zero-value or expired offers"",
        ""Check error scenarios in complex method interactions""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list is comprehensive, covering critical smart contract audit areas.
2. Tasks are specific and actionable, providing clear guidance for the audit process.
3. The breakdown considers both technical implementation and potential attack vectors.
4. Each area addresses specific risks identified in the initial contract analysis.

Recommended Next Steps:
- Systematically work through each task area
- Document findings and potential improvements
- Provide specific code-level recommendations
- Prepare a detailed audit report with severity ratings

This task list provides a structured approach to thoroughly examining the NFTMarketOffer contract, ensuring a comprehensive security and functionality review.","After carefully analyzing the provided smart contract code, here's my audit review:

{
  ""ReviewingTheCode"": ""The code represents an NFT marketplace offer system that allows users to make offers on NFTs, accept offers, and provides administrative controls. It manages the offer lifecycle including creation, acceptance, and cancellation with proper fund management through a FETH (likely Foundation ETH wrapper) contract."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketOffer"",
    ""Purpose"": ""Manages the offer functionality within an NFT marketplace, allowing users to make offers on NFTs, token owners to accept offers, and includes administrative capabilities to cancel offers when needed."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""FoundationTreasuryNode"", 
        ""NFTMarketCore"", 
        ""ReentrancyGuardUpgradeable"", 
        ""NFTMarketFees""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketFees.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""nftContractToIdToOffer"",
        ""Type"": ""mapping(address => mapping(uint256 => Offer))"",
        ""Purpose"": ""Stores all active offers indexed by NFT contract address and token ID""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""acceptOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows NFT owner to accept an existing offer"",
        ""Parameters"": [""nftContract"", ""tokenId"", ""offerFrom"", ""minAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminCancelOffers"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admins to cancel offers with a reason"",
        ""Parameters"": [""nftContracts[]"", ""tokenIds[]"", ""reason""],
        ""Returns"": []
      },
      {
        ""Name"": ""makeOffer"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to make an offer on an NFT"",
        ""Parameters"": [""nftContract"", ""tokenId"", ""amount""],
        ""Returns"": [""expiration""]
      },
      {
        ""Name"": ""_acceptOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for accepting an offer, distributing funds and transferring the NFT"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_afterAuctionStarted"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook that invalidates offers when an auction starts"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrow"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides parent functionality to invalidate offers when transferring from escrow"",
        ""Parameters"": [""nftContract"", ""tokenId"", ""buyer"", ""seller""],
        ""Returns"": []
      },
      {
        ""Name"": ""_autoAcceptOffer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks and accepts valid offers automatically"",
        ""Parameters"": [""nftContract"", ""tokenId"", ""minAmount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_cancelBuyersOffer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Allows buyer to cancel their own offer"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_invalidateOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Invalidates an offer, releasing locked funds"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinOfferAmount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the minimum required amount for a new offer"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": [""minimum""]
      },
      {
        ""Name"": ""getOffer"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns details about the current offer for an NFT"",
        ""Parameters"": [""nftContract"", ""tokenId""],
        ""Returns"": [""buyer"", ""expiration"", ""amount""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""FETH contract via 'feth' reference for locking, unlocking, withdrawing, and changing locked funds"",
    ""IERC721 NFT contracts for transferring tokens"",
    ""Parent contracts for enforcing access control through onlyFoundationAdmin modifier"",
    ""Parent NFTMarketCore for auction-related functionality"",
    ""NFTMarketFees for distributing funds between parties""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern with storage gap for future extensions"",
    ""ReentrancyGuard to prevent reentrant attacks on key functions"",
    ""Escrow mechanism for NFT transfers with fallback handling"",
    ""ETH wrapper system (FETH) for locking funds during the offer period"",
    ""Expiration-based validity mechanism for offers"",
    ""Minimum offer increment mechanism to prevent spam offers""
  ],
  ""Questions"": [
    ""What is the implementation of the FETH contract that manages locked funds?"",
    ""What is the specific implementation of _getMinIncrement() and how is the minimum increment calculated?"",
    ""How does _autoAcceptBuyPrice() function work in the makeOffer function?"",
    ""What is the complete implementation of _isInActiveAuction() to understand how auction conflicts are detected?"",
    ""How does _distributeFunds() split the payments between platform, creator, and seller?"",
    ""Is there adequate validation in adminCancelOffers to ensure array lengths match?"",
    ""What protection mechanisms exist for handling large arrays in the adminCancelOffers function?""
  ]
}

This contract is part of a broader NFT marketplace system, specifically handling the offer mechanism. It allows users to make offers on NFTs, with funds being locked through a separate FETH contract. NFT owners can accept offers, and there are mechanisms to handle offer invalidation when competing mechanisms like auctions are activated. The contract implements reentrancy protection and follows the upgradeable contract pattern with appropriate storage gap.","I've analyzed the input data and consolidated similar issues. Here's the organized output:

{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in _acceptOffer Function"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract inherits from ReentrancyGuardUpgradeable and the acceptOffer function uses nonReentrant modifier, the internal _acceptOffer function does not. The contract performs external calls to NFT contracts after state changes, creating a potential reentrancy vector if _acceptOffer is called from an unprotected function or if a malicious NFT contract has exploitable code in its transferFrom function."",
      ""Impact"": ""An attacker could potentially reenter the contract during token transfer, manipulate transaction flow, and exploit the contract state, leading to theft of funds, double-spending attacks, or other unexpected behaviors."",
      ""Location"": ""_acceptOffer function""
    },
    {
      ""Issue"": ""Missing NFT Ownership Validation"",
      ""Severity"": ""High"",
      ""Description"": ""The acceptOffer function attempts a direct transferFrom call without first verifying that the caller is the actual owner of the NFT. While there is a fallback to _transferFromEscrow, proper validation should occur first to ensure the caller has authorization to accept offers for the specified NFT."",
      ""Impact"": ""Potential failed transactions or unauthorized attempts to accept offers for NFTs not owned by the caller, which could lead to security vulnerabilities if the fallback mechanisms fail."",
      ""Location"": ""_acceptOffer function""
    },
    {
      ""Issue"": ""Missing Re-entrancy Protection in makeOffer Function"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract inherits from ReentrancyGuardUpgradeable, the makeOffer function doesn't use the nonReentrant modifier. This could potentially allow a malicious contract to re-enter the function during external calls to _autoAcceptBuyPrice or feth.marketLockupFor."",
      ""Impact"": ""A reentrancy attack could allow an attacker to manipulate the state of the contract, potentially making multiple offers with the same funds or causing other unexpected behaviors."",
      ""Location"": ""makeOffer function""
    },
    {
      ""Issue"": ""Integer Overflow/Truncation Risk"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses uint96 for offer amounts and uint32 for expiration timestamps without proper validation. When casting from uint256 to these smaller types, values exceeding their maximum limits would be silently truncated. While Solidity 0.8.0+ has built-in overflow checks, explicit type casting could bypass these protections."",
      ""Impact"": ""Large offer amounts could be incorrectly stored, potentially allowing users to make offers at incorrect prices. Timestamps after February 2106 would overflow, causing offers to expire prematurely or remain unexpectedly valid."",
      ""Location"": ""Offer struct definition, makeOffer function where offer.expiration and offer.amount are assigned""
    },
    {
      ""Issue"": ""Unchecked Return Values in External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes several external calls without validating return values, particularly in _acceptOffer where calls to IERC721.transferFrom are handled in try/catch but other calls like feth.marketWithdrawLocked and _distributeFunds don't check return values. This issue also affects calls to the FETH contract."",
      ""Impact"": ""If these external calls fail silently, the function might continue execution with an incorrect state, potentially leading to locked funds, inconsistent contract state, or situations where payment was processed but the NFT wasn't transferred."",
      ""Location"": ""_acceptOffer function, particularly the try/catch block, and other functions calling FETH methods""
    },
    {
      ""Issue"": ""Missing Array Length Validation in adminCancelOffers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The adminCancelOffers function accepts two arrays (nftContracts and tokenIds) but doesn't verify that they have the same length before iterating through them. Additionally, there's no check for array size, which could lead to out-of-gas errors if the arrays are too large."",
      ""Impact"": ""If the arrays have different lengths, the function might attempt to access out-of-bounds array elements, resulting in transaction reversion, incorrect cancellation of offers, or out-of-gas errors for large input arrays."",
      ""Location"": ""adminCancelOffers function, particularly the unchecked loop""
    },
    {
      ""Issue"": ""Centralization Risk in Admin Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The adminCancelOffers function allows foundation admins to cancel any offers with only a reason string required. This introduces centralization risk where admins have significant control over the marketplace."",
      ""Impact"": ""Foundation admins could potentially manipulate the market by canceling legitimate offers, affecting user trust and market efficiency."",
      ""Location"": ""adminCancelOffers function""
    },
    {
      ""Issue"": ""Race Condition in makeOffer with _autoAcceptBuyPrice"",
      ""Severity"": ""Medium"",
      ""Description"": ""The makeOffer function first tries to auto-accept a buy price before creating an offer. This creates a potential race condition where market conditions might change between checking the buy price and making the offer."",
      ""Impact"": ""A user might create an offer when they intended to accept a buy price, or vice versa, potentially leading to financial loss or unexpected outcomes."",
      ""Location"": ""makeOffer function""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions like makeOffer don't fully validate inputs. The contract doesn't check if the NFT contract is a valid ERC721 contract, doesn't validate that nftContract addresses are non-zero, and doesn't verify that offer amounts are greater than zero."",
      ""Impact"": ""Interactions with non-compliant contracts could lead to unexpected behavior, locked funds, or potential spam with zero-value offers."",
      ""Location"": ""makeOffer, acceptOffer, and adminCancelOffers functions""
    },
    {
      ""Issue"": ""Potential Front-Running in Offer Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""Offers can be front-run by other users or manipulated by miners, as transaction ordering can affect who successfully places an offer or accepts an offer first."",
      ""Impact"": ""Users might experience their transactions being front-run, resulting in failed transactions or less favorable terms."",
      ""Location"": ""makeOffer and acceptOffer functions""
    },
    {
      ""Issue"": ""Missing Access Control in _invalidateOffer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _invalidateOffer function is private but lacks proper access controls when called from public functions. It is called from various functions that may not all have appropriate access controls."",
      ""Impact"": ""Unauthorized invalidation of offers could lead to users' offers being canceled without proper cause."",
      ""Location"": ""_invalidateOffer and calling functions""
    },
    {
      ""Issue"": ""Reliance on External FETH Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract heavily relies on an external FETH contract for token locking/unlocking logic. If there are issues with the FETH contract, it would impact this contract's functionality."",
      ""Impact"": ""Vulnerabilities or bugs in the FETH contract could cascade to affect this contract's security and functionality."",
      ""Location"": ""makeOffer, _acceptOffer, _invalidateOffer functions""
    },
    {
      ""Issue"": ""Timestamp Manipulation Risk"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses block.timestamp for offer expiration checks. Miners can manipulate block.timestamp slightly (usually by a few seconds), which could potentially be exploited in time-sensitive operations like offer expiration."",
      ""Impact"": ""An attacker could potentially manipulate the timing of transaction inclusion to affect offer validity in edge cases, or offers might be accepted or invalidated slightly earlier or later than intended."",
      ""Location"": ""acceptOffer(), makeOffer(), and _invalidateOffer() functions""
    },
    {
      ""Issue"": ""Lack of Offer Cancellation Function for Buyers"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract has functionality to invalidate offers, there's no direct function for buyers to cancel their offers unless they're also participating in other market actions that trigger _cancelBuyersOffer."",
      ""Impact"": ""Reduced flexibility for offer makers who may need to cancel offers manually."",
      ""Location"": ""Contract level design issue""
    },
    {
      ""Issue"": ""Missing Zero Address Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""When accepting an offer, there is no validation to ensure the offerFrom parameter is not the zero address, which could lead to unexpected behavior if called incorrectly."",
      ""Impact"": ""Potential system confusion or invalid state if incorrectly called with zero address parameters, or potential loss of funds if users interact with invalid zero-address contracts."",
      ""Location"": ""acceptOffer function and other functions handling address parameters""
    },
    {
      ""Issue"": ""Silent Failure in _acceptOffer's try/catch Block"",
      ""Severity"": ""Low"",
      ""Description"": ""When the IERC721 transferFrom call fails in _acceptOffer, the contract silently catches the error and attempts _transferFromEscrow without logging the original error, making debugging difficult."",
      ""Impact"": ""Reduced transparency in error handling, potentially difficult debugging of failed transfers, and issues with token transfers might go unnoticed."",
      ""Location"": ""_acceptOffer function's try/catch block""
    },
    {
      ""Issue"": ""Insufficient Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""When makeOffer auto-accepts a buy price via _autoAcceptBuyPrice or when a higher offer replaces an existing one, the contract doesn't emit events for the cancellation of previous offers or other related activities, making it harder to track offer history through event logs."",
      ""Impact"": ""Reduced transparency and potential difficulties in tracking offer activity through event logs, complicating dispute resolution or market analysis."",
      ""Location"": ""makeOffer function, specifically the _autoAcceptBuyPrice branch""
    },
    {
      ""Issue"": ""Unnecessary Gas Usage"",
      ""Severity"": ""Low"",
      ""Description"": ""The _invalidateOffer function reads the offer from storage twice - once to check expiration and again to store it in memory before deleting, which is inefficient gas usage. Additionally, adminCancelOffers processes arrays regardless of whether offers are expired."",
      ""Impact"": ""Higher than necessary gas costs when invalidating offers or processing admin operations, potential for transaction failures if gas limit is exceeded with large arrays."",
      ""Location"": ""_invalidateOffer and adminCancelOffers functions""
    },
    {
      ""Issue"": ""Large Gap Size in Contract Storage"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract reserves 1000 storage slots with '__gap', which is unusually large and could waste storage space in the blockchain."",
      ""Impact"": ""Excessive storage reservation increases deployment and upgrade costs while providing no functional benefit beyond what a smaller gap would offer."",
      ""Location"": ""uint256[1000] private __gap; at the end of the contract""
    }
  ],
  ""IssueNumber"": 63,
  ""OutputList"": 19
}",363.880576133728,57519.0,32.0,"### **[H-03] An offer made after auction end can be stolen by an auction winner**

**Report Description**:
An offer made for an NFT after the auction has ended, but before the winner has received the NFT, can be stolen by the auction winner. The `_transferFromEscrow` function, called by `_acceptOffer`, transfers the NFT to the winner, finalizing the auction. However, no transfer occurs to the user who made the offer. This allows the auction winner to obtain both the NFT and the offer amount after fees at no additional cost, at the expense of the user who made the offer.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves a race condition where the auction winner can exploit the timing of offer acceptance and NFT transfer. None of the responses in the `response_list` cover this scenario, which is a significant oversight given the potential financial impact.

---

### **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

**Report Description**:
If an NFT is in escrow without an active `buyPrice` or auction, it can be stolen by any actor using the `makeOffer` and `acceptOffer` functions. This occurs because the NFT is only guarded by `buyPrice` and `auction` structures. If neither is initialized (e.g., if the NFT is mistakenly sent to the contract), a malicious user can track the `FNDNFTMarket` contract and steal the NFT for free. The severity is medium because normal usage implies that one of these structures is initialized, leaving only mistakenly sent assets exposed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The vulnerability arises from the lack of protection for NFTs in escrow when no `buyPrice` or `auction` is active. This is a critical oversight, as it allows for the theft of NFTs under specific conditions. The `response_list` fails to identify this risk, which is a significant gap in coverage.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] An offer made after auction end can be stolen by an auction winner**
- **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

---

### **Analysis of Gaps**:
The `response_list` fails to address two critical issues from the `issue` report:
1. **[H-03]**: The race condition where an auction winner can steal an offer made after the auction ends is a high-severity issue with significant financial implications. The `response_list` does not cover this scenario, which is a major oversight.
2. **[M-13]**: The vulnerability allowing the theft of escrowed NFTs when no `buyPrice` or `auction` is active is a medium-severity issue. The `response_list` does not identify this risk, leaving a gap in the security analysis.

Both issues involve specific timing and state conditions that are not addressed in the `response_list`. This highlights the need for a more comprehensive review of the contract's logic and potential edge cases.","```
None.
```",0.0
NFTMarketPrivateSale.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896,205,"[M-01] EIP-712 signatures can be re-used in private sales

Function `buyFromPrivateSaleFor`
NFTMarketPrivateSale.sol#L123-L174
Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call #buyFromPrivateSaleFor providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.
The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.
  [M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT

Submitted by leastwood
NFTMarketPrivateSale.sol#L143-L150
The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.
  [M-12] Private sale spoofing
 function buyFromPrivateSaleFor()
NFTMarketPrivateSale.sol#L156
Similar to spoofing in finance, users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.
No funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature. It's also frustrating for the users if they try to accept the private sale but their transaction fails.

",3,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();


abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  
  
  
  bytes32 private immutable DOMAIN_SEPARATOR;

  
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  
  
  string private constant NAME = ""FNDNFTMarket"";

  
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      
      

      
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    
    
    address payable seller = payable(nftContract.ownerOf(tokenId));

    
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    
    nftContract.transferFrom(seller, msg.sender, tokenId);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  
  uint256[1000] private __gap;
}",888,0,3,"Based on the detailed analysis of the NFTMarketPrivateSale contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Signature Verification Security"",
      ""Tasks"": [
        ""Verify the correctness of the EIP-712 domain separator generation"",
        ""Audit the signature verification process in buyFromPrivateSaleFor function"",
        ""Check for potential signature replay attacks"",
        ""Validate the cryptographic signature verification using ecrecover()""
      ]
    },
    {
      ""Area"": ""Payment and Fund Distribution"",
      ""Tasks"": [
        ""Analyze the hybrid payment mechanism involving msg.value and feth contract"",
        ""Review the fund distribution logic in _distributeFunds method"",
        ""Verify handling of excess/insufficient payment amounts"",
        ""Check for potential arithmetic vulnerabilities in fee calculations""
      ]
    },
    {
      ""Area"": ""Time-based Constraints"",
      ""Tasks"": [
        ""Investigate the discrepancy between 24-hour and 48-hour deadline restrictions"",
        ""Verify deadline validation logic against potential timestamp manipulation"",
        ""Assess the impact of block.timestamp in signature validation""
      ]
    },
    {
      ""Area"": ""NFT Transfer Security"",
      ""Tasks"": [
        ""Verify the NFT transfer mechanism for potential reentrancy"",
        ""Check error handling for failed NFT transfers"",
        ""Ensure proper ownership verification before transfer""
      ]
    },
    {
      ""Area"": ""Contract Upgradeability and Storage"",
      ""Tasks"": [
        ""Validate the storage gap mechanism (__gap array)"",
        ""Review the implications of the immutable DOMAIN_SEPARATOR"",
        ""Check for potential storage collision risks""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Verify the market proxy address validation in the constructor"",
        ""Audit the interaction with the feth contract"",
        ""Review the NFTMarketFees contract's _distributeFunds implementation""
      ]
    },
    {
      ""Area"": ""Error Handling and Reverts"",
      ""Tasks"": [
        ""Review all custom error definitions for comprehensive coverage"",
        ""Verify the conditions triggering each custom error"",
        ""Ensure informative and precise error messaging""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Analyze the use of unchecked block in payment calculations"",
        ""Review the efficiency of signature verification process"",
        ""Identify potential gas optimization opportunities""
      ]
    },
    {
      ""Area"": ""Access Control and Permissions"",
      ""Tasks"": [
        ""Verify the nonReentrant modifier implementation"",
        ""Check for any potential unauthorized access points"",
        ""Review the scope of external and public functions""
      ]
    },
    {
      ""Area"": ""Cryptographic Considerations"",
      ""Tasks"": [
        ""Validate the cryptographic domain separation"",
        ""Review the constant BUY_FROM_PRIVATE_SALE_TYPEHASH"",
        ""Assess the security of the signature generation process""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers critical security, functional, and optimization aspects of the contract.
2. Each area is broken down into specific, actionable tasks that target potential vulnerabilities.
3. The tasks address both on-chain and cryptographic security considerations.
4. The approach considers the contract's unique implementation of private NFT sales.

Prioritization Approach:
- High-priority areas include Signature Verification Security and Payment/Fund Distribution
- Cryptographic and Access Control tasks are crucial for preventing potential exploits
- External Interactions and Error Handling are critical for overall contract reliability

The task list provides a structured approach to thoroughly audit the NFTMarketPrivateSale contract, ensuring comprehensive security and functionality assessment.","After reviewing the provided smart contract code, here's my detailed analysis:

{
  ""ReviewingTheCode"": ""This code represents a smart contract for handling private sales of NFTs. It includes functionality for validating signatures, ensuring proper payment, and distributing funds appropriately between different parties upon a successful sale. The contract implements EIP-712 for typed data signing and verification."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketPrivateSale"",
    ""Purpose"": ""Facilitates private sales of NFTs with signature-based verification and secure fund distribution"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""NFTMarketFees""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""./NFTMarketFees.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32 private"",
        ""Purpose"": ""Storage slot placeholder for a previous implementation variable""
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32 private immutable"",
        ""Purpose"": ""Domain separator for EIP-712 signature verification""
      },
      {
        ""Name"": ""BUY_FROM_PRIVATE_SALE_TYPEHASH"",
        ""Type"": ""bytes32 private constant"",
        ""Purpose"": ""Type hash for the private sale transaction, used in EIP-712 signatures""
      },
      {
        ""Name"": ""NAME"",
        ""Type"": ""string private constant"",
        ""Purpose"": ""Name of the contract for EIP-712 domain""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000] private"",
        ""Purpose"": ""Storage gap for future upgrades to prevent storage collision""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract and sets up the domain separator for signature verification"",
        ""Parameters"": [""address marketProxyAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSale"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Wrapper function to buy an NFT from a private sale using msg.value"",
        ""Parameters"": [""IERC721 nftContract"", ""uint256 tokenId"", ""uint256 deadline"", ""uint8 v"", ""bytes32 r"", ""bytes32 s""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSaleFor"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Executes the purchase of an NFT from a private sale with signature verification"",
        ""Parameters"": [""IERC721 nftContract"", ""uint256 tokenId"", ""uint256 amount"", ""uint256 deadline"", ""uint8 v"", ""bytes32 r"", ""bytes32 s""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IERC721 for NFT ownership verification and transfers"",
    ""NFTMarketFees for distributing funds via _distributeFunds function"",
    ""feth contract for handling withdrawals from user balances"",
    ""ecrecover for cryptographic signature verification""
  ],
  
  ""SpecialMechanisms"": [
    ""EIP-712 implementation for typed data hashing and signature verification"",
    ""Reentrancy protection with nonReentrant modifier (inherited from NFTMarketFees)"",
    ""Contract upgradeability pattern with storage gaps"",
    ""Hybrid payment mechanism that can use both direct ETH and escrowed funds from feth contract""
  ],
  
  ""Questions"": [
    ""What is the implementation of the _distributeFunds function in the NFTMarketFees contract?"",
    ""What is the feth contract, and how is it initialized in the contract?"",
    ""There seems to be a conflict in the deadline restrictions: the error message indicates 24Hrs max but the code checks for 2 days (48 hours). Which is correct?"",
    ""How is the nonReentrant modifier implemented in the inherited contract?"",
    ""What happens if the NFT transfer fails in the buyFromPrivateSaleFor function?"",
    ""Is there any mechanism to cancel a private sale once a signature has been created?"",
    ""Could the deadline be manipulated by miners to affect transaction validity?""
  ]
}

Based on my audit, this contract implements a secure method for private NFT sales using EIP-712 signatures. The seller signs an order off-chain, and a buyer can execute the purchase on-chain by providing the signature along with payment. The contract verifies the signature, transfers the NFT, and distributes the funds among the marketplace, creator, and seller.

The implementation includes proper checks for deadlines, signature validity, and payment amounts. It also uses reentrancy protection for the critical function. However, some aspects of the code depend on external contracts (NFTMarketFees and feth) which are not fully visible in this snippet, making it difficult to assess their security implications.","I'll analyze the issues from all the sources, combine similar ones, and provide a consolidated list ordered by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Signature Replay Attack Vulnerability"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract doesn't implement nonces or unique identifiers for signature verification. Once a seller signs a private sale offer, that signature can be reused multiple times if the NFT returns to the same owner within the signature's validity period."",
      ""Impact"": ""Attackers could replay signatures to force sales at outdated terms when the original seller reacquires the same NFT, potentially leading to financial losses for sellers who may have intended to sell at a different price point after reacquiring the NFT."",
      ""Location"": ""buyFromPrivateSaleFor function, signature verification logic""
    },
    {
      ""Issue"": ""Unsafe Transfer Ordering"",
      ""Severity"": ""High"",
      ""Description"": ""The contract transfers the NFT to the buyer before ensuring the payment is successfully distributed to all parties. This violates the Checks-Effects-Interactions pattern and creates a potential attack vector."",
      ""Impact"": ""If the ETH distribution fails after the NFT has been transferred, the buyer could receive the NFT without the seller receiving full payment, leading to financial loss for the seller."",
      ""Location"": ""buyFromPrivateSaleFor function (order of operations)""
    },
    {
      ""Issue"": ""Signature Replay Attacks Across Deployments"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses a hardcoded version string ('1') in the DOMAIN_SEPARATOR. If the contract logic changes in future versions but maintains the same version string, signatures could potentially be replayed across different versions of the contract. Additionally, there's an inconsistency where the DOMAIN_SEPARATOR uses marketProxyAddress but verification happens in the current contract."",
      ""Impact"": ""Signatures intended for one version of the contract might be valid on future versions or different deployments, potentially leading to unauthorized sales if contract behavior changes."",
      ""Location"": ""Constructor function, where DOMAIN_SEPARATOR is defined with hardcoded version '1'""
    },
    {
      ""Issue"": ""Unchecked ERC721 Approval Before Transfer"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not verify if it has approval to transfer the NFT from the seller before attempting the transfer. While the seller's signature indicates intent to sell, without proper approval to the marketplace contract, the transaction will fail."",
      ""Impact"": ""Failed transactions leading to gas wastage for users. In certain ERC721 implementations, this could also potentially lead to unexpected behavior if the transferFrom has side effects even when failing."",
      ""Location"": ""buyFromPrivateSaleFor function, NFT transfer operation""
    },
    {
      ""Issue"": ""Missing Seller Verification in Signature Logic"",
      ""Severity"": ""High"",
      ""Description"": ""The signature verification only validates that the signer is the current NFT owner, but doesn't include the seller address in the signed message. This assumes the current owner is the authorized seller, but doesn't verify that the seller was the one who signed the message when the signature was created."",
      ""Impact"": ""If an NFT changes hands after a signature is created, the signature remains valid and could be used to force a sale from the new owner who never agreed to sell."",
      ""Location"": ""buyFromPrivateSaleFor function, signature verification section""
    },
    {
      ""Issue"": ""Deadline Validation Inconsistency"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract claims to limit private sales to 24 hours maximum (as indicated in the error message), but the actual code checks against 2 days (48 hours). This creates a discrepancy between the documented behavior and actual implementation."",
      ""Impact"": ""Users may be misled about how long private sale offers remain valid. This inconsistency could lead to confusion and unexpected behavior where private sales remain valid for twice as long as the error message and comments suggest."",
      ""Location"": ""buyFromPrivateSaleFor function, condition: 'deadline > block.timestamp + 2 days' with error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max()""
    },
    {
      ""Issue"": ""Incomplete Signature Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses ecrecover directly for signature verification without the additional safety checks that would be provided by OpenZeppelin's ECDSA library. The contract also does not validate that the 'v' parameter in ecrecover is either 27 or 28 (the only valid values)."",
      ""Impact"": ""The implementation is vulnerable to signature malleability attacks where an attacker could forge a different but valid signature, potentially leading to unauthorized sale authorizations."",
      ""Location"": ""buyFromPrivateSaleFor function, where ecrecover is called""
    },
    {
      ""Issue"": ""No Cancellation Mechanism for Private Sales"",
      ""Severity"": ""Medium"",
      ""Description"": ""Once a seller signs a private sale offer, there appears to be no way to cancel it before the deadline expires. The seller must wait for the deadline to pass if they change their mind about the sale."",
      ""Impact"": ""If market conditions change rapidly or a seller discovers information that would cause them to want to cancel a sale, they have no recourse until the deadline expires, which could lead to forced sales at unfavorable terms."",
      ""Location"": ""Throughout the contract - absence of cancellation functionality""
    },
    {
      ""Issue"": ""Lack of Minimum Deadline Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract checks that the deadline cannot be more than 2 days in the future, but there's no minimum time validation. This means a seller could create a very short-lived private sale that expires almost immediately."",
      ""Impact"": ""Sellers could create sales with extremely short deadlines, leading to buyers attempting to purchase NFTs in sales that expire mid-transaction, causing their transactions to revert after spending gas."",
      ""Location"": ""buyFromPrivateSaleFor function - lines that check deadline validity""
    },
    {
      ""Issue"": ""FETH Integration Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract interacts with an external FETH contract (feth.marketWithdrawFrom) but there's no validation that this contract is correctly set or functioning before attempting withdrawals. If the FETH contract is misconfigured, this could cause transactions to fail or funds to be lost."",
      ""Impact"": ""If the FETH contract reference is incorrect or the contract malfunctions, users might be unable to complete purchases or could potentially lose funds during the withdrawal process. Furthermore, if a user has insufficient FETH balance, the transaction will revert in the FETH contract rather than providing a clear error message."",
      ""Location"": ""buyFromPrivateSaleFor function, feth.marketWithdrawFrom call""
    },
    {
      ""Issue"": ""Immutable DOMAIN_SEPARATOR Limitations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The DOMAIN_SEPARATOR is set as immutable during construction, which is generally secure but could cause problems if the contract needs to be upgraded or if the chain undergoes a fork that changes the chainId. The contract would not be able to update the DOMAIN_SEPARATOR."",
      ""Impact"": ""In case of a chain fork or chain ID change, the contract would be unable to process any private sales as all signatures would fail verification, requiring a complete redeployment."",
      ""Location"": ""Constructor function, DOMAIN_SEPARATOR initialization""
    },
    {
      ""Issue"": ""Lack of Explicit Fee Upper Bounds"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calls _distributeFunds to handle fee distribution but doesn't appear to have explicit upper bounds on fee percentages in this contract. Without seeing the implementation of _distributeFunds, this could potentially allow for excessive fees being taken from sales."",
      ""Impact"": ""If the fee calculation logic in the parent contract has vulnerabilities or can be manipulated by administrators, sellers might receive significantly less than expected from their sales."",
      ""Location"": ""_distributeFunds call in buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Deadline Validation Edge Case"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract checks if the deadline is strictly less than the current timestamp to determine if a sale has expired. This means a transaction with a deadline exactly equal to the current block's timestamp would be accepted."",
      ""Impact"": ""Transactions might be processed at the exact second they expire, potentially leading to disagreements about whether a transaction should have been processed or not."",
      ""Location"": ""buyFromPrivateSaleFor function, condition: 'deadline < block.timestamp'""
    },
    {
      ""Issue"": ""Use of Assembly for ChainId Retrieval"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses inline assembly to retrieve the chain ID. While this is a common pattern, it introduces complexity and potential for errors in code maintenance. Modern Solidity versions support 'block.chainid' natively."",
      ""Impact"": ""The use of assembly increases code complexity and could potentially lead to issues if the EVM implementation changes in future Ethereum upgrades."",
      ""Location"": ""Constructor function, assembly block retrieving chainid""
    },
    {
      ""Issue"": ""Missing Zero-Address Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't validate that the NFT contract address is not the zero address. While this would likely fail elsewhere in the execution, explicit validation would improve security."",
      ""Impact"": ""Potential issues with contract execution when interacting with invalid addresses, leading to failed transactions and wasted gas."",
      ""Location"": ""buyFromPrivateSale and buyFromPrivateSaleFor functions""
    },
    {
      ""Issue"": ""Missing Token Existence Check"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not explicitly verify that the tokenId exists before attempting the transfer, relying solely on the NFT contract's transfer behavior."",
      ""Impact"": ""If the token doesn't exist, the error handling might be non-intuitive, as the error would come from the NFT contract rather than this contract."",
      ""Location"": ""buyFromPrivateSaleFor function, NFT transfer logic""
    },
    {
      ""Issue"": ""Missing Event for Failed Transactions"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract only emits an event for successful transactions (PrivateSaleFinalized), but there are no events for failed attempts or rejections. This makes it difficult to monitor off-chain for issues or track why certain transactions failed."",
      ""Impact"": ""Reduced transparency and more difficult debugging for failed transactions, complicating user experience and system monitoring."",
      ""Location"": ""buyFromPrivateSaleFor function (event emission section)""
    }
  ],
  ""IssueNumber"": 51,
  ""OutputList"": 17
}",356.60195684432983,44862.0,32.0,"### **[M-01] EIP-712 signatures can be re-used in private sales**

**Report Description**:  
The `buyFromPrivateSaleFor` function in `NFTMarketPrivateSale.sol` allows buyers to purchase NFTs using EIP-712 signatures provided by sellers. However, the function does not check if the signature has been used before. This allows EIP-712 signatures to be re-used within a small time frame if the original seller regains ownership of the NFT, potentially leading to unauthorized or unintended sales.

**Match in Response List**:  
Matches with the issue titled **""Signature Replay Attack Vulnerability""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of signature replay attacks, where EIP-712 signatures can be reused if the NFT returns to the original owner. The description and impact align with the issue report, highlighting the risk of financial losses for sellers due to outdated terms being enforced. This response fully addresses the vulnerability described in the issue.

---

### **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Report Description**:  
The `buyFromPrivateSaleFor` function attempts to withdraw the required ETH from the buyer's unlocked balance if insufficient ETH is provided. However, if the buyer has an open offer on the same NFT, the funds remain locked until the offer expires. This prevents the buyer from using these funds for the private sale, causing the transaction to fail.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of locked funds due to open offers is not covered in any of the responses, leaving this vulnerability unaddressed.

---

### **[M-12] Private sale spoofing**

**Report Description**:  
Users can create private sales with correct signatures but then frontrun the buy transaction by transferring the NFT to a different wallet they control. While no funds are lost due to the atomic nature of the NFT <> FETH exchange, this can be problematic for third-party off-chain markets built on this feature. It also frustrates users whose transactions fail when attempting to accept the private sale.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of private sale spoofing or frontrunning. This vulnerability, which could lead to user frustration and misuse of the signature feature, is not covered in the responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] EIP-712 signatures can be re-used in private sales**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**
- **[M-12] Private sale spoofing**

---

### **Conclusion**

The response list effectively addresses the issue of signature replay attacks ([M-01]) but fails to cover the vulnerabilities related to insufficient buyer balances due to open offers ([M-06]) and private sale spoofing ([M-12]). These gaps indicate a need for additional responses to ensure comprehensive coverage of the reported issues.","```
1. Signature Replay Attack Vulnerability
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Signature Replay Attack Vulnerability"".
   - In the ranked list of predictions, this issue appears at **rank 1**.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - \( AP = 1.0 \).

**Output**:
```
1.0
```"
SendValueWithFallbackWithdraw.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802,94,"[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals

Function `withdrawFor()`
The `NFTMarketFees` contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.
",1,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();


abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  
  mapping(address => uint256) private pendingWithdrawals;

  
  event WithdrawPending(address indexed user, uint256 amount);
  
  event Withdrawal(address indexed user, uint256 amount);

  
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    
    
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      
      
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  
  uint256[499] private __gap;
}",353,0,1,"Based on the comprehensive initial analysis, I'll create a targeted task list for auditing the `SendValueWithFallbackWithdraw` contract:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection by thoroughly testing the nonReentrant modifier's implementation"",
        ""Analyze the unchecked block in _sendValueWithFallbackWithdraw for potential integer overflow risks"",
        ""Validate that low-level .call() method in _sendValueWithFallbackWithdraw cannot be exploited"",
        ""Confirm that pendingWithdrawals mapping cannot be manipulated to drain contract funds""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review AddressUpgradeable.sendValue() implementation for potential security weaknesses"",
        ""Test edge cases of gas limit parameter in _sendValueWithFallbackWithdraw"",
        ""Verify that failed transfers are correctly handled and logged"",
        ""Ensure no unexpected behavior when transferring to contracts with complex fallback mechanisms""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Confirm that withdrawFor() can only be called by intended parties"",
        ""Verify that getPendingWithdrawal() doesn't expose sensitive information"",
        ""Check for potential unauthorized withdrawal mechanisms""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the efficiency of unchecked block in pending withdrawal calculation"",
        ""Review the storage gap implementation for upgradeable contract"",
        ""Assess gas consumption of withdraw and withdrawFor functions"",
        ""Evaluate the impact of using view functions and internal methods""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Verify custom error SendValueWithFallbackWithdraw_No_Funds_Available is correctly implemented"",
        ""Test error scenarios with zero balance withdrawals"",
        ""Ensure meaningful event emissions for withdrawal attempts"",
        ""Check that failed transfers are properly tracked and can be retried""
      ]
    },
    {
      ""Area"": ""Upgrade Compatibility"",
      ""Tasks"": [
        ""Validate the __gap storage variable for future contract upgrades"",
        ""Confirm OpenZeppelin upgradeable contract patterns are correctly followed"",
        ""Test potential migration scenarios for the contract""
      ]
    },
    {
      ""Area"": ""Performance and Limits"",
      ""Tasks"": [
        ""Determine if there should be a maximum withdrawal limit"",
        ""Assess the potential accumulation of pending withdrawals"",
        ""Verify the contract can handle multiple simultaneous withdrawal attempts"",
        ""Check for potential denial of service through repeated failed transfers""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list directly addresses the questions and potential concerns raised in the initial analysis.
2. Tasks are grouped by audit areas to provide systematic coverage.
3. Each task is specific, actionable, and tied to potential vulnerabilities or improvement areas.
4. The approach balances security, gas efficiency, and contract upgradeability.

Recommended Next Steps:
- Use this task list as a comprehensive guide for detailed smart contract audit
- Implement thorough testing for each identified task
- Consider engaging multiple auditors to cross-validate findings
- Prepare detailed documentation of audit process and results

The task list provides a structured approach to auditing the `SendValueWithFallbackWithdraw` contract, ensuring a comprehensive review of its security, functionality, and potential improvement areas.","After reviewing the provided smart contract, here is my audit in JSON format:

{
  ""ReviewingTheCode"": ""The code implements a secure value transfer mechanism with a fallback withdrawal pattern. It handles cases where direct transfers fail by storing the value in a pending withdrawals mapping that users can claim later."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SendValueWithFallbackWithdraw"",
    ""Purpose"": ""Provides a secure way to send Ether to users with a fallback withdrawal mechanism that allows recipients to manually withdraw funds if automatic transfer fails"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuardUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""pendingWithdrawals"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks pending withdrawals for each user address when automatic transfers fail""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[499]"",
        ""Purpose"": ""Storage gap for upgradeable contracts to reserve storage slots for future versions""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their pending funds"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows withdrawal of pending funds for a specified user"",
        ""Parameters"": [""address payable user""],
        ""Returns"": []
      },
      {
        ""Name"": ""_sendValueWithFallbackWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Attempts to send Ether to a user with a gas limit; if the transfer fails, adds the amount to their pending withdrawals"",
        ""Parameters"": [""address payable user"", ""uint256 amount"", ""uint256 gasLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""getPendingWithdrawal"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the pending withdrawal amount for a specified user"",
        ""Parameters"": [""address user""],
        ""Returns"": [""uint256 balance""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Uses AddressUpgradeable.sendValue() for secure Ether transfers"",
    ""Makes low-level .call{value, gas}() to user addresses with configurable gas limits""
  ],
  ""SpecialMechanisms"": [
    ""Implements the 'Pull over Push' payment pattern for improved security"",
    ""Uses ReentrancyGuard to prevent reentrancy attacks during withdrawals"",
    ""Uses OpenZeppelin's upgradeable pattern with storage gaps"",
    ""Unchecked addition for pending withdrawals to save gas (overflow is unlikely in practical use)""
  ],
  ""Questions"": [
    ""Is there a maximum withdrawal limit that should be implemented?"",
    ""Should there be an emergency withdrawal function for the contract owner?"",
    ""Is the gas limit parameter in _sendValueWithFallbackWithdraw validated elsewhere to prevent excessively high values?"",
    ""Should there be a way to track or limit the total amount of pending withdrawals?"",
    ""Does the contract handle potential overflow when adding to pendingWithdrawals, especially since it's in an unchecked block?""
  ]
}

This contract follows the ""Pull over Push"" pattern, which is a recommended approach for handling Ether transfers in Ethereum. By attempting to send Ether directly but providing a fallback withdrawal mechanism, it balances efficiency with security. The use of OpenZeppelin's ReentrancyGuard and Address utilities shows good security practices.","I've analyzed the provided smart contract vulnerability findings and consolidated them according to the requirements. Here's my consolidated report:

{
  ""Findings"": [
    {
      ""Issue"": ""Integer Overflow in pendingWithdrawals Update"",
      ""Severity"": ""High"",
      ""Description"": ""The _sendValueWithFallbackWithdraw function uses an unchecked block for adding to pendingWithdrawals[user], which bypasses Solidity 0.8.0+'s automatic overflow checks. While this is likely done for gas optimization, it creates a vulnerability where if pendingWithdrawals[user] + amount exceeds the maximum value of uint256, it will wrap around to a smaller value."",
      ""Impact"": ""Users could lose funds if their pending withdrawals overflow, as the recorded amount would be less than what they're owed. In extreme cases, a user's pending withdrawal balance could reset to a lower value, resulting in loss of funds they were entitled to withdraw."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw, unchecked block for pendingWithdrawals[user] += amount""
    },
    {
      ""Issue"": ""Insufficient Contract Balance Check"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not verify if it has sufficient balance before attempting to send funds in _sendValueWithFallbackWithdraw. If the contract has insufficient balance, the transfer will fail, but this could lead to inconsistent behavior if some transfers succeed and others fail due to depleted balance."",
      ""Impact"": ""Potential for certain users to not receive funds if the contract balance is depleted during a batch of transfers, leading to inequality and trust issues."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw""
    },
    {
      ""Issue"": ""Missing Initialization for Upgradeable Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from ReentrancyGuardUpgradeable but doesn't include an initializer function to properly set up the inherited upgradeable contract. Upgradeable contracts require explicit initialization, and failing to call the parent initializer can lead to security issues."",
      ""Impact"": ""The reentrancy guard may not be properly initialized, potentially rendering its protections ineffective."",
      ""Location"": ""Contract level - missing initializer function""
    },
    {
      ""Issue"": ""Arbitrary Gas Limit Parameter"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _sendValueWithFallbackWithdraw function accepts a gasLimit parameter that is directly used when making the external call without validation. If this parameter is set too low, transfers might consistently fail, forcing users to always use the withdraw pattern instead of receiving direct transfers. If set too high, it could expose the contract to DoS attacks."",
      ""Impact"": ""Poor user experience and potential denial of service if the gas limit is set inappropriately. It could also lead to unexpected behavior if the gasLimit is manipulated by inherited contracts or cause transactions to fail if gas limits exceed block gas limits."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw, parameter gasLimit""
    },
    {
      ""Issue"": ""Potential for Silent Failures in Value Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses a low-level .call{value} method to transfer ETH and only checks if the call was successful, not whether the receiving contract accepted the transfer. Some contracts might execute successfully but still reject ETH transfers through their fallback logic without triggering the failure path."",
      ""Impact"": ""In rare cases, funds might appear to have been sent successfully but were actually rejected by the recipient's fallback function in a way that doesn't revert the transaction. This could lead to accounting discrepancies."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw, line with user.call{ value: amount, gas: gasLimit }(\""\"")""
    },
    {
      ""Issue"": ""No Mechanism to Handle Permanently Failed Withdrawals"",
      ""Severity"": ""Medium"",
      ""Description"": ""If a user's address consistently fails to receive Ether (e.g., it's a contract without a payable fallback or receive function), there's no mechanism for the contract owner or administrators to resolve the situation. The funds will remain locked in the contract indefinitely."",
      ""Impact"": ""Potential permanent lockup of funds in the contract, reducing available liquidity and potentially affecting the platform's financial operations."",
      ""Location"": ""General contract design, particularly the withdrawal flow""
    },
    {
      ""Issue"": ""Lack of Address Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not validate that the user address is not the zero address before attempting to send funds or record pending withdrawals. While OpenZeppelin's sendValue function does include this check, the _sendValueWithFallbackWithdraw function doesn't verify the address when using .call or when adding to pendingWithdrawals."",
      ""Impact"": ""Funds could be sent to the zero address and become irretrievable if the contract's internal logic mistakenly passes the zero address as a parameter."",
      ""Location"": ""Functions withdrawFor and _sendValueWithFallbackWithdraw""
    },
    {
      ""Issue"": ""Lack of Access Control for withdrawFor"",
      ""Severity"": ""Low"",
      ""Description"": ""The withdrawFor function is public and allows anyone to trigger a withdrawal on behalf of any user without any access control or authorization checks. While this doesn't directly lead to theft since funds are sent to the original user, it may have unexpected consequences in certain scenarios."",
      ""Impact"": ""Malicious actors could force users to receive funds at inopportune times, which might have tax implications or cause other unintended consequences."",
      ""Location"": ""Function withdrawFor""
    },
    {
      ""Issue"": ""Missing Reentrancy Protection for _sendValueWithFallbackWithdraw"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract inherits ReentrancyGuardUpgradeable and uses nonReentrant for withdrawFor, the internal _sendValueWithFallbackWithdraw function doesn't have reentrancy protection. It makes an external call which could potentially be exploited depending on how inheriting contracts use this function."",
      ""Impact"": ""If inheriting contracts don't implement proper safeguards, this could potentially lead to reentrancy vulnerabilities."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw, external call section""
    },
    {
      ""Issue"": ""No Events for Successful Direct Transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract emits events for pending withdrawals and successful withdrawals initiated via the withdraw function, it doesn't emit events for successful direct transfers in _sendValueWithFallbackWithdraw. This creates inconsistent event logging."",
      ""Impact"": ""Reduced transparency and difficulty in tracking successful transfers through event logs, complicating off-chain tracking systems and making it harder to audit the contract's payment activities."",
      ""Location"": ""Function _sendValueWithFallbackWithdraw, successful transfer case""
    },
    {
      ""Issue"": ""No Timestamp or Identifier for Pending Withdrawals"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't store any information about when the pending withdrawal was created or what it was for. This lack of contextual data could make it difficult for users or administrators to reconcile payments or debug issues."",
      ""Impact"": ""Reduced traceability and potential difficulties in customer support scenarios or during audits of payment flows."",
      ""Location"": ""General contract design, specifically the pendingWithdrawals mapping""
    },
    {
      ""Issue"": ""Large __gap Array Size"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses a very large __gap array (499 slots) which is intended for upgradeable contracts to reserve storage slots. While this is generally a good practice for upgradeable contracts, 499 slots might be excessive for most use cases."",
      ""Impact"": ""Higher deployment costs and potentially higher operational gas costs depending on implementation details of inheriting contracts."",
      ""Location"": ""End of contract, uint256[499] private __gap declaration""
    }
  ],
  ""IssueNumber"": 52,
  ""OutputList"": 12
}",302.246218919754,31998.0,32.0,"### **[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

**Report Description**:
The `withdrawFor()` function in the `NFTMarketFees` and `NFTMarketReserveAuction` contracts uses the `_sendValueWithFallbackWithdraw` function to send ether to various recipients (e.g., FoundationTreasury, CreatorRecipients, Seller, Bidder). If the receiver fails to receive ether due to reasons such as exceeding the gas limit or the receiver contract being unable to accept ether, the ether is recorded in the `pendingWithdrawals` variable. However, there is no mechanism to handle cases where withdrawals from `pendingWithdrawals` fail permanently, potentially leading to locked funds.

**Match in Response List**:
Matches with the issue titled **""No Mechanism to Handle Permanently Failed Withdrawals""**.

**Validation**:
**Correct**. The response accurately identifies the issue of permanently failed withdrawals, where funds could remain locked in the contract indefinitely if a user's address consistently fails to receive ether. This aligns with the reported issue, which highlights the lack of a mechanism to resolve such situations. The response correctly describes the impact and risk, making it a valid match.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

--- 

### **Additional Notes**:
The response list comprehensively covers the issue reported in `issue`. The match is accurate, and the response provides a detailed explanation of the vulnerability, its impact, and the associated risks. No gaps or missed issues were identified in this comparison.","```
1. No Mechanism to Handle Permanently Failed Withdrawals
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""No Mechanism to Handle Permanently Failed Withdrawals"".
   - This issue appears at rank 6 in the ranked list of predictions.

2. **Calculate the precision at rank 6 (\( P@6 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 6, there is 1 true positive.
   - \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.1667 \).

**Output**:
```
0.1667
```"
FETH.sol,"/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670,779,"[M-03] Approve race condition in FETH

Submitted by 0x1f8b
FETH.sol#L212
Front running attack in `approve()` function.
Proof of Concept

The contract of the FETH does not have any protection against the well-known “Multiple Withdrawal Attack” attack on the Approve/TransferFrom methods of the ERC20 standard.
Although this attack poses a limited risk in specific situations, it is worth mentioning to consider it for possible future operations.
There are solutions to mitigate this front running such as, to first reduce the spender's allowance to 0 and set the desired value afterwards; another solution could the one that Open Zeppelin offers, where the non-standard decreaseAllowance and increaseAllowance functions have been added to mitigate the well-known issues involving setting allowances.
  [M-09] Missing receiver validation in withdrawFrom

Submitted by cmichel
FETH.sol#L433
The FETH.withdrawFrom function does not validate its to parameter. Funds can be lost if to is the zero address.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();

error FETH_Insufficient_Allowance(uint256 amount);

error FETH_Insufficient_Available_Funds(uint256 amount);

error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();


contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  
  struct AccountInfo {
    
    uint96 freedBalance;
    
    uint32 lockupStartIndex;
    
    LockedBalance.Lockups lockups;
    
    mapping(address => uint256) allowance;
  }

  
  mapping(address => AccountInfo) private accountToInfo;

  
  
  uint256 private immutable lockupDuration;
  
  uint256 private immutable lockupInterval;

  
  address payable private immutable foundationMarket;

  
  
  uint8 public constant decimals = 18;
  
  string public constant name = ""Foundation Wrapped Ether"";
  
  string public constant symbol = ""FETH"";

  
  
  event Approval(address indexed from, address indexed spender, uint256 amount);
  
  event Transfer(address indexed from, address indexed to, uint256 amount);

  
  
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  
  receive() external payable {
    depositFor(msg.sender);
  }

  
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  
  function deposit() external payable {
    depositFor(msg.sender);
  }

  
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      
      if (escrow.expiration == 0) {
        break;
      }

      
      unchecked {
        
        ++escrowIndex;
      }

      
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  
  
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    
    unchecked {
      
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    
    
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      
      revert FETH_Too_Much_ETH_Provided();
    }

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  
  
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      
      while (true) {
        
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    
    uint256 lockedCount;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          
          ++lockedCount;
        }
      }
    }

    
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    
    uint256 i;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function totalSupply() external view returns (uint256 supply) {
    
    return address(this).balance;
  }
}",3357,0,2,"Based on the comprehensive analysis of the FETH smart contract, here's a detailed audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Thoroughly analyze the onlyFoundationMarket modifier for potential bypassing mechanisms"",
        ""Verify reentrancy protection in ETH transfer functions (sendValue calls)"",
        ""Validate unchecked arithmetic operations for potential integer overflow/underflow risks"",
        ""Review error handling and revert conditions for comprehensive edge case coverage"",
        ""Examine potential attack vectors in _freeFromEscrow and _marketLockupFor functions""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify the foundationMarket's privileged access is absolutely necessary"",
        ""Audit the scope and limitations of market-only functions"",
        ""Ensure no critical functions can be called outside intended market context"",
        ""Check for potential centralization risks with single market contract""
      ]
    },
    {
      ""Area"": ""Token Mechanics"",
      ""Tasks"": [
        ""Validate ERC20-like functionality compliance"",
        ""Review lockup mechanism for potential time-based manipulation"",
        ""Analyze the lockupDuration and lockupInterval calculation logic"",
        ""Verify total supply calculation matches expected behavior"",
        ""Check balance tracking across free and locked balances""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the efficiency of lockupStartIndex caching mechanism"",
        ""Review unchecked arithmetic for potential gas savings"",
        ""Evaluate the gas complexity of _freeFromEscrow function"",
        ""Check memory management in view functions like getLockups""
      ]
    },
    {
      ""Area"": ""Transfer and Allowance Mechanisms"",
      ""Tasks"": [
        ""Verify allowance deduction logic in _deductAllowanceFrom"",
        ""Check transfer restrictions (zero address, contract address)"",
        ""Validate balance deduction in _deductBalanceFrom"",
        ""Review edge cases in transferFrom and withdraw functions""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify contract address validation for foundationMarket"",
        ""Check ETH transfer safety using AddressUpgradeable library"",
        ""Analyze dependency on external LockedBalance library"",
        ""Review potential external call vulnerabilities""
      ]
    },
    {
      ""Area"": ""Lockup and Escrow System"",
      ""Tasks"": [
        ""Thoroughly test lockup creation and expiration mechanisms"",
        ""Verify time-based lockup interval calculations"",
        ""Check handling of multiple concurrent lockups"",
        ""Validate market lockup and unlock functions"",
        ""Examine expiration and balance release logic""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Review comprehensiveness of custom error messages"",
        ""Verify error conditions cover all potential edge cases"",
        ""Check error handling in critical functions like marketLockupFor"",
        ""Ensure appropriate reverts prevent unexpected contract states""
      ]
    }
  ]
}

Key Observations and Rationale:
1. The task list covers comprehensive security, functional, and optimization aspects.
2. Each area focuses on specific potential vulnerabilities or improvement opportunities.
3. Tasks are designed to be actionable and directly addressable during the audit.
4. The breakdown allows for systematic and thorough contract examination.

Recommended Next Steps:
- Conduct a detailed review following these task categories
- Use automated and manual testing approaches
- Perform scenario-based testing for each identified task
- Document findings, potential improvements, and recommendations

The task list provides a structured approach to auditing the FETH contract, ensuring a comprehensive examination of its security, functionality, and efficiency.","After reviewing the FETH smart contract, here is my audit:

{
  ""ReviewingTheCode"": ""The code implements a Foundation Wrapped Ether (FETH) token contract that extends ETH functionality with locking mechanisms. It allows users to deposit ETH in exchange for FETH tokens and provides a specialized escrow system where balances can be locked for specific durations. The contract appears designed for an NFT marketplace ecosystem, with special privileges given to the Foundation Market contract."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FETH"",
    ""Purpose"": ""A wrapped ETH implementation with specialized locking/escrow capabilities to support Foundation's NFT marketplace operations"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/math/Math.sol"",
        ""./libraries/LockedBalance.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""accountToInfo"",
        ""Type"": ""mapping(address => AccountInfo)"",
        ""Purpose"": ""Stores user balances, lockups, and allowances""
      },
      {
        ""Name"": ""lockupDuration"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""Determines how long funds are locked for""
      },
      {
        ""Name"": ""lockupInterval"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""Fraction of the lockup duration (lockupDuration/24) used for calculating expiration""
      },
      {
        ""Name"": ""foundationMarket"",
        ""Type"": ""address payable immutable"",
        ""Purpose"": ""Address of the Foundation marketplace contract with special privileges""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""uint8 constant"",
        ""Purpose"": ""Token decimals (18)""
      },
      {
        ""Name"": ""name"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Token name ('Foundation Wrapped Ether')""
      },
      {
        ""Name"": ""symbol"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Token symbol ('FETH')""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyFoundationMarket"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts functions to be called only by the Foundation market contract""
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with Foundation market address and lockup duration"",
        ""Parameters"": [""address payable _foundationMarket"", ""uint256 _lockupDuration""],
        ""Returns"": []
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Accepts ETH and deposits it for the sender"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""external"",
        ""Purpose"": ""ERC20-compatible approve function to authorize spending"",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits ETH for the sender"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""depositFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits ETH for a specified account"",
        ""Parameters"": [""address account""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketChangeLockup"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the market to unlock funds from one account and lock them for another in one operation"",
        ""Parameters"": [""address unlockFrom"", ""uint256 unlockExpiration"", ""uint256 unlockAmount"", ""address lockupFor"", ""uint256 lockupAmount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketLockupFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the market to lock funds for an account"",
        ""Parameters"": [""address account"", ""uint256 amount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketUnlockFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the market to unlock funds for an account"",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the market to withdraw freed funds from an account"",
        ""Parameters"": [""address from"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawLocked"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the market to withdraw locked funds from an account"",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""ERC20-compatible transfer function"",
        ""Parameters"": [""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""ERC20-compatible transferFrom function"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""withdrawAvailableBalance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw all their available (unlocked) ETH"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws funds from one account to a specified address"",
        ""Parameters"": [""address from"", ""address payable to"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""allowance"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""ERC20-compatible allowance function"",
        ""Parameters"": [""address account"", ""address operator""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns available balance (including matured lockups)"",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256 balance""]
      },
      {
        ""Name"": ""getFoundationMarket"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the Foundation market address"",
        ""Parameters"": [],
        ""Returns"": [""address market""]
      },
      {
        ""Name"": ""getLockups"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns all active lockups for an account"",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256[] memory expiries"", ""uint256[] memory amounts""]
      },
      {
        ""Name"": ""totalBalanceOf"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns total balance including locked funds"",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256 balance""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""ERC20-compatible totalSupply function (returns contract ETH balance)"",
        ""Parameters"": [],
        ""Returns"": [""uint256 supply""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""The contract uses AddressUpgradeable library for safe ETH transfers through sendValue"",
    ""The contract uses LockedBalance library for managing the locking mechanism"",
    ""The contract interacts with the Foundation Market contract through onlyFoundationMarket modifier"",
    ""The Math library is used for ceiling division in calculating expiration timestamps""
  ],
  
  ""SpecialMechanisms"": [
    ""Time-based escrow/locking system with automatic expiration and release of funds"",
    ""Partial ERC20 compliance with appropriate transfer, approve, and allowance mechanisms"",
    ""Specialized privilege system for the Foundation Market contract to manage escrows"",
    ""Caching mechanism for escrow management through lockupStartIndex to optimize gas usage"",
    ""Lockup expiration calculation that aligns expiration dates to specific time intervals""
  ],
  
  ""Questions"": [
    ""What is the purpose of the LockedBalance library and how does it store/manage lockups?"",
    ""What happens when a user tries to transfer more tokens than their freed balance but less than their total balance?"",
    ""Is there a mechanism to upgrade this contract, given the usage of OpenZeppelin upgradeable libraries?"",
    ""How are gas costs optimized in the _freeFromEscrow function when dealing with many expired lockups?"",
    ""How is the contract protected against reentrancy attacks during ETH transfers?"",
    ""What are the specific use cases for the marketChangeLockup function in the Foundation marketplace?""
  ]
}","I've analyzed the security findings for the FETH contract. After reviewing all the entries, I've consolidated similar issues while preserving the key information about each vulnerability.

{
  ""Findings"": [
    {
      ""Issue"": ""Unsafe uint96 casting for ETH amounts"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses uint96 for the freedBalance, but casts ETH values from uint256 to uint96 without checking if they exceed the maximum value of uint96. This is done in multiple places including depositFor() and when moving funds between locked and free balances. Large deposits or transfers could result in balance truncation."",
      ""Impact"": ""If a deposit or transfer amount exceeds the maximum value of uint96 (2^96 - 1), silent truncation would occur, leading to loss of funds for users."",
      ""Location"": ""Function depositFor() around line 120, _marketUnlockFor function, and any other place where uint256 values are cast to uint96""
    },
    {
      ""Issue"": ""Reentrancy Risk in External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes external calls using sendValue() after changing state in functions like withdrawAvailableBalance() and withdrawFrom(). While these functions generally follow the checks-effects-interactions pattern, there's no explicit reentrancy guard. Since sendValue is essentially a low-level call, recipients could potentially execute reentrant attacks."",
      ""Impact"": ""If there are vulnerabilities or if future modifications don't maintain the correct pattern, this could introduce reentrancy vulnerabilities that could lead to theft of funds."",
      ""Location"": ""Functions withdrawAvailableBalance(), withdrawFrom(), marketWithdrawFrom(), and marketWithdrawLocked()""
    },
    {
      ""Issue"": ""Market can potentially withdraw user funds repeatedly"",
      ""Severity"": ""High"",
      ""Description"": ""The marketWithdrawFrom and marketWithdrawLocked functions allow the Foundation Market contract to withdraw user funds. There's no mechanism preventing multiple withdrawals of the same funds if implementation errors exist in the Market contract."",
      ""Impact"": ""Users' funds could be over-withdrawn if the Market contract doesn't properly track withdrawals."",
      ""Location"": ""Functions marketWithdrawFrom and marketWithdrawLocked""
    },
    {
      ""Issue"": ""No Allowance Frontrunning Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The approve function directly sets the allowance rather than using the safer increaseAllowance/decreaseAllowance pattern, making it vulnerable to allowance frontrunning attacks."",
      ""Impact"": ""An attacker could observe a transaction that changes an allowance and frontrun it to spend the previous allowance before it's updated."",
      ""Location"": ""Function: approve()""
    },
    {
      ""Issue"": ""Potential Integer Overflow in lockup expiration calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _marketLockupFor function, the expiration calculation (expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval) uses unchecked math. While there's a check against type(uint32).max later, an intermediate overflow could still occur since block.timestamp is a uint256 value."",
      ""Impact"": ""If an overflow occurs during the calculation, it could lead to incorrect expiration dates for locked funds, potentially allowing premature access to funds that should be locked or causing funds to be locked for incorrect periods."",
      ""Location"": ""Function _marketLockupFor(), around line 280-300""
    },
    {
      ""Issue"": ""Potential DoS in Lockups Processing"",
      ""Severity"": ""Medium"",
      ""Description"": ""The _freeFromEscrow function iterates through all expired lockups, and the getLockups function iterates through all lockups. Similarly, balanceOf() and totalBalanceOf() also iterate through lockups. There's no limit to how many lockups a user can accumulate, which could lead to gas limits being exceeded if a user has too many lockups."",
      ""Impact"": ""An account with many lockups could become unusable as operations would exceed block gas limits, effectively freezing their funds."",
      ""Location"": ""Function _freeFromEscrow() around line 210-245, getLockups() around line 400-440, balanceOf(), and totalBalanceOf()""
    },
    {
      ""Issue"": ""Centralized Control by Foundation Market"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several critical functions are restricted to the Foundation Market address, creating a centralization risk. The foundationMarket address has significant privileges via the onlyFoundationMarket modifier, including the ability to lock, unlock, and withdraw funds. This creates a central point of failure."",
      ""Impact"": ""If the Foundation Market contract is compromised, an attacker could drain all locked funds or manipulate lockups to their advantage."",
      ""Location"": ""Functions with onlyFoundationMarket modifier""
    },
    {
      ""Issue"": ""Potential Locked ETH with No Access"",
      ""Severity"": ""Medium"",
      ""Description"": ""If a user has locked ETH and the foundationMarket contract is compromised or loses functionality (self-destructed, etc.), there is no emergency withdrawal mechanism to allow users to recover their locked funds. All locked funds rely entirely on the foundationMarket address for operations that can unlock them."",
      ""Impact"": ""Users could permanently lose access to their locked ETH if the foundationMarket contract becomes inoperable."",
      ""Location"": ""marketUnlockFor and other market-only functions""
    },
    {
      ""Issue"": ""Missing Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor validates that _foundationMarket is a contract and that _lockupDuration is non-zero and divisible by 24, but doesn't impose an upper limit. Extremely large lockup durations could effectively lock user funds permanently. Additionally, there's insufficient validation of the foundationMarket address beyond checking it's a contract."",
      ""Impact"": ""If the contract is deployed with an extremely high lockupDuration value, users could have their funds locked for an impractically long time without recourse. If an incorrect contract address is provided, the FETH contract could interact with an incompatible contract."",
      ""Location"": ""Constructor, around line 76-101""
    },
    {
      ""Issue"": ""Missing Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks slippage protection for operations that may be time-sensitive, particularly in market operations where tokens are locked and unlocked. When funds are locked up, the expiration is calculated based on the current block timestamp with no mechanism for users to specify a maximum acceptable expiration time."",
      ""Impact"": ""Users might have their funds locked for longer than anticipated if their transaction is delayed in the mempool. During high network congestion, users could experience unexpected token valuation changes."",
      ""Location"": ""_marketLockupFor function calculation of expiration time""
    },
    {
      ""Issue"": ""Implicit Assumption of ETH Transfer Success"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses the sendValue function for ETH transfers but doesn't handle potential failures in a robust way. While OpenZeppelin's sendValue does include revert conditions, the contract doesn't implement any specific fallback mechanisms for failed transfers."",
      ""Impact"": ""If a transfer fails due to recipient contract issues, it could lead to locked funds or unexpected state in the contract."",
      ""Location"": ""Functions marketWithdrawFrom(), marketWithdrawLocked(), withdrawAvailableBalance(), and withdrawFrom()""
    },
    {
      ""Issue"": ""No upper limit validation on lockupDuration"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor checks that lockupDuration is non-zero and divisible by 24, but doesn't impose an upper limit. Extremely large lockup durations could effectively lock user funds permanently."",
      ""Impact"": ""If the contract is deployed with an extremely high lockupDuration value, users could have their funds locked for an impractically long time without recourse."",
      ""Location"": ""Constructor, around line 76-85""
    },
    {
      ""Issue"": ""Precision Loss in Lockup Interval Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract sets lockupInterval = lockupDuration / 24, which could result in precision loss if lockupDuration is not perfectly divisible by 24. While there is a check that lockupInterval * 24 == lockupDuration, it's worth noting that certain calculations involving these values could be affected. The expiration calculation in _marketLockupFor() uses ceilDiv which rounds up division results."",
      ""Impact"": ""Potential minor discrepancies in lockup timing calculations, though the contract does validate that no loss occurs in the constructor. Users might experience slightly longer lockup periods than anticipated."",
      ""Location"": ""Constructor, around line 80 and _marketLockupFor() function""
    },
    {
      ""Issue"": ""Missing events for important state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some state-changing operations don't emit events, making it difficult to track contract activity off-chain. In the _freeFromEscrow function, when releasing expired locked balances, there are no events emitted. Similarly, when allowances are used in transferFrom or withdrawFrom, no specific events are emitted for the consumption of allowances."",
      ""Impact"": ""Reduced transparency and tracking capabilities for users and monitoring systems. More difficult accounting for allowance usage, which could impact user experiences with tools that rely on events."",
      ""Location"": ""_freeFromEscrow function, transferFrom() and withdrawFrom() where allowances are deducted""
    },
    {
      ""Issue"": ""Lack of Address Validation in Transfer Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract prevents transfers to address(0) and address(this), it doesn't validate if the recipient is a contract that can handle ETH or check if the spender address is the zero address. This could lead to tokens being sent to contracts without proper handling mechanisms."",
      ""Impact"": ""Users might inadvertently transfer tokens to contracts that cannot use or return them, resulting in permanent loss of funds. Users might accidentally approve the zero address, which would have no practical use."",
      ""Location"": ""transferFrom() function and approve() function""
    },
    {
      ""Issue"": ""No ETH Refund Mechanism"",
      ""Severity"": ""Low"",
      ""Description"": ""If excess ETH is sent during certain operations, the contract reverts (e.g., in _marketLockupFor). A more user-friendly approach would be to return excess funds to the sender."",
      ""Impact"": ""User transactions may fail completely instead of being partially processed with refunds, creating a poor user experience and potentially causing confusion."",
      ""Location"": ""_marketLockupFor() function when handling msg.value""
    },
    {
      ""Issue"": ""No way to cancel or update existing lockups"",
      ""Severity"": ""Low"",
      ""Description"": ""Once funds are locked, users have no direct way to cancel or modify their lockups - they must wait for expiration or rely on the Foundation Market to unlock them."",
      ""Impact"": ""Limited user control over their locked funds."",
      ""Location"": ""Lockup management functions""
    },
    {
      ""Issue"": ""No mechanism to recover incorrectly sent ETH"",
      ""Severity"": ""Low"",
      ""Description"": ""If ETH is sent to the contract through a method other than the dedicated deposit functions (although this should be caught by the receive function), there's no mechanism to recover those funds."",
      ""Impact"": ""Potential for permanently locked funds in edge cases."",
      ""Location"": ""Throughout the contract""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 18
}",394.1445748806,79713.0,33.0,"### **Comparison and Evaluation**

---

#### **[M-03] Approve race condition in FETH**

**Report Description**:  
The `approve()` function in `FETH.sol` is vulnerable to a front-running attack, commonly known as the ""Multiple Withdrawal Attack"" in ERC20 standards. This occurs when an attacker observes a transaction that changes an allowance and frontruns it to spend the previous allowance before it is updated. The report suggests mitigating this by either reducing the spender's allowance to 0 before setting the desired value or using OpenZeppelin's `increaseAllowance` and `decreaseAllowance` functions.

**Match in Response List**:  
Matches with the issue titled **""No Allowance Frontrunning Protection""**.

**Validation**:  
**Correct**. The response accurately identifies the vulnerability in the `approve()` function and explains the risk of frontrunning attacks. It also suggests using the safer `increaseAllowance` and `decreaseAllowance` pattern, which aligns with the mitigation strategies mentioned in the issue report. This response fully covers the security concern and its impact.

---

#### **[M-09] Missing receiver validation in withdrawFrom**

**Report Description**:  
The `withdrawFrom` function in `FETH.sol` does not validate the `to` parameter, which could result in funds being lost if `to` is the zero address. This oversight could lead to permanent loss of user funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing receiver validation in the `withdrawFrom` function. This is a critical oversight, as failing to validate the `to` parameter could result in funds being sent to the zero address, leading to permanent loss. The response list should have included this issue to ensure comprehensive coverage of vulnerabilities.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-03] Approve race condition in FETH**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-09] Missing receiver validation in withdrawFrom**

---

### **Conclusion**

The response list effectively addresses the **approve race condition** issue but fails to cover the **missing receiver validation** in the `withdrawFrom` function. This gap indicates a need for more thorough analysis to ensure all potential vulnerabilities are identified and mitigated. Future reviews should prioritize validating all input parameters, especially those that could lead to irreversible loss of funds.","```
1. No Allowance Frontrunning Protection
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""No Allowance Frontrunning Protection"".
   - From the ranked list of predictions, this issue appears at rank 4.

2. **Calculate the precision at rank 4 (\( P@4 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 4, there is 1 true positive.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
NFTMarketFees.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867,219,"[M-08] Primary seller can avoid paying the primary fee

Submitted by pedroais, also found by leastwood and WatchPug
A primary seller can circumvent the 15% fee and pay 5% as a secondary seller.
Context

The Foundation protocol charges a 15% fee if the sale is a primary sale and 5% if it's a secondary sale. https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L40
There are 2 conditions that must be met for a sale to be considered primary:
The seller is one of the creators in the NFT metadata.
It's the first time this NFT is sold on the foundation protocol.
https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L188
  [M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low

Submitted by cmichel
NFTMarketFees.sol#L78
The creator payouts are capped at MAX_ROYALTY_RECIPIENTS_INDEX. It's currently set to 4 and only 5 creators are paid out. Other creators are ignored.

",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  
  uint256[3] private __gap_was_fees;

  
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; 
  
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; 
  
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; 

  
  
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        
        uint256 totalShares;
        unchecked {
          
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              
              maxCreatorIndex = 0;
              break;
            }
            
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        
        creatorRev = price - foundationFee;
      } else {
        
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  
  uint256[1000] private __gap;
}",1195,0,2,"Based on the detailed analysis of the NFTMarketFees contract, here's a comprehensive audit task list:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify reentrancy protection in _distributeFunds method, especially during multiple value transfers"",
        ""Audit the unchecked block in fee distribution for potential integer overflow risks"",
        ""Validate the fallback withdrawal mechanism in _sendValueWithFallbackWithdraw for potential attack vectors"",
        ""Review the gas limit constants (SEND_VALUE_GAS_LIMIT_*) for potential out-of-gas scenarios""
      ]
    },
    {
      ""Area"": ""Fee Distribution Logic"",
      ""Tasks"": [
        ""Verify mathematical accuracy of fee calculations across primary and secondary sales"",
        ""Validate the complex creator royalty distribution logic with multiple recipients"",
        ""Check total fee percentage calculations to ensure they always sum to 100%"",
        ""Examine the MAX_ROYALTY_RECIPIENTS_INDEX handling for potential edge cases""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the _getCreatorPaymentInfo external call for potential manipulation"",
        ""Verify the integrity of getFoundationTreasury method"",
        ""Check the _getSellerFor method for potential spoofing or unauthorized access"",
        ""Validate input validation for external function parameters""
      ]
    },
    {
      ""Area"": ""Upgradability Concerns"",
      ""Tasks"": [
        ""Review storage gap mechanisms for potential storage collision risks"",
        ""Verify the Initializable pattern implementation"",
        ""Check the completeness of storage gaps for future contract upgrades"",
        ""Validate that critical state variables are not vulnerable during upgrades""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review inheritance chain for potential unauthorized access points"",
        ""Verify the access controls in fee distribution methods"",
        ""Check the visibility and access modifiers of critical methods"",
        ""Validate the treasury node access mechanism""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the efficiency of multiple creator fee distribution loops"",
        ""Review unchecked blocks for potential gas savings"",
        ""Examine the use of memory vs storage in complex calculations"",
        ""Verify the gas limit constants for optimal performance""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Test handling of zero-value sales"",
        ""Verify behavior with extremely large or small price inputs"",
        ""Check handling of NFTs with no creator royalties"",
        ""Validate first sale tracking mechanism for different NFT contracts""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify compliance with ERC-721 standard interaction"",
        ""Check adherence to NFT marketplace fee distribution best practices"",
        ""Validate creator royalty distribution mechanisms"",
        ""Review potential cross-contract interactions""
      ]
    }
  ]
}

Key Audit Focus Areas:
1. The complex fee distribution logic is the primary area of concern
2. Multiple external interactions require thorough validation
3. Upgradability mechanism needs careful scrutiny
4. Potential security vulnerabilities in value transfer methods

Recommendations for Auditors:
- Use comprehensive test cases covering multiple scenarios
- Employ static analysis tools
- Conduct manual code review focusing on mathematical accuracy
- Simulate various sale scenarios with different NFT configurations
- Pay special attention to unchecked blocks and external calls

This task list provides a structured approach to auditing the NFTMarketFees contract, addressing potential risks and ensuring robust implementation.","After reviewing the provided smart contract code, here's my analysis:

{
  ""ReviewingTheCode"": ""The provided code is an abstract contract called NFTMarketFees that manages fee distribution for an NFT marketplace. It handles the calculation and distribution of fees between the platform (Foundation), creators (royalties), and sellers for NFT sales."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketFees"",
    ""Purpose"": ""Manages the fee distribution logic for an NFT marketplace, including platform fees, creator royalties, and seller revenues"",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"", 
        ""Initializable"", 
        ""FoundationTreasuryNode"", 
        ""NFTMarketCore"", 
        ""NFTMarketCreators"", 
        ""SendValueWithFallbackWithdraw""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol"",
        ""./Constants.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketCreators.sol"",
        ""./SendValueWithFallbackWithdraw.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_fees"",
        ""Type"": ""uint256[3]"",
        ""Purpose"": ""Storage gap for upgradeable contracts (previously used for fees)""
      },
      {
        ""Name"": ""_nftContractToTokenIdToFirstSaleCompleted"",
        ""Type"": ""mapping(address => mapping(uint256 => bool))"",
        ""Purpose"": ""Tracks whether a token has completed its first sale""
      },
      {
        ""Name"": ""CREATOR_ROYALTY_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the 10% royalty rate for creators on secondary sales (1000 basis points)""
      },
      {
        ""Name"": ""PRIMARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the 15% platform fee for primary sales (1500 basis points)""
      },
      {
        ""Name"": ""SECONDARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the 5% platform fee for secondary sales (500 basis points)""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Storage gap for upgradeable contracts to reserve storage slots for future versions""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""_distributeFunds"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and distributes the proceeds from an NFT sale between platform, creators, and seller"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address payable seller"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""uint256 creatorFee"", ""uint256 ownerRev""]
      },
      {
        ""Name"": ""getFeesAndRecipients"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Public function to get fee information without executing a transaction"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""uint256 creatorRev"", ""address payable[] creatorRecipients"", ""uint256[] creatorShares"", ""uint256 ownerRev"", ""address payable owner""]
      },
      {
        ""Name"": ""_getFees"",
        ""Visibility"": ""private view"",
        ""Purpose"": ""Calculates the fee breakdown for a sale based on whether it's a primary or secondary sale"",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address payable seller"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""address payable[] creatorRecipients"", ""uint256[] creatorShares"", ""uint256 creatorRev"", ""address payable ownerRevTo"", ""uint256 ownerRev""]
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""Calls to _sendValueWithFallbackWithdraw to send ETH to recipients"",
    ""Calls to getFoundationTreasury to get the treasury address"",
    ""Calls to _getSellerFor to determine the seller for a given NFT"",
    ""Calls to _getCreatorPaymentInfo to get creator royalty information""
  ],
  
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern with storage gaps and Initializable import"",
    ""Split fee distribution system with different rates for primary vs secondary sales"",
    ""Multiple creator royalty distribution system that handles proportional sharing"",
    ""Fallback withdrawal mechanism for failed ETH transfers""
  ],
  
  ""Questions"": [
    ""What is the implementation of the SendValueWithFallbackWithdraw contract that handles ETH transfers?"",
    ""How are the creator payment details determined in the _getCreatorPaymentInfo function?"",
    ""What is the MAX_ROYALTY_RECIPIENTS_INDEX constant value that limits the number of creators?"",
    ""How does the contract determine if a seller is the original creator in _getCreatorPaymentInfo?"",
    ""Is there a way to update the fee structures if needed, or are they permanently fixed as constants?"",
    ""What is the mechanism to prevent creators from setting shares that exceed BASIS_POINTS?""
  ]
}

The contract implements a sophisticated fee distribution system for an NFT marketplace. Key observations:

1. It's an upgradeable contract using OpenZeppelin's upgradeable pattern with storage gaps.

2. It handles two types of sales with different fee structures:
   - Primary sales (first sale by creator): 15% platform fee, rest to creator
   - Secondary sales: 5% platform fee, 10% creator royalty, 85% to seller

3. It supports multiple creators for a single NFT with proportional distribution based on shares.

4. There are safety checks to ensure shares don't exceed the basis points limit and to handle edge cases.

5. The contract uses a fallback withdrawal pattern to handle failed ETH transfers safely.","I've analyzed the provided issue findings from the NFTMarketFees.sol smart contract. I'll now provide a consolidated list of the issues, merging similar ones and organizing them by severity.

{
  ""Findings"": [
    {
      ""Issue"": ""Potential reentrancy vulnerability in fee distribution"",
      ""Severity"": ""High"",
      ""Description"": ""The _distributeFunds function makes multiple external calls when sending ETH to various recipients using _sendValueWithFallbackWithdraw. Without proper reentrancy guards, this could be vulnerable to reentrancy attacks, especially since it updates state after these calls by marking first sales as completed."",
      ""Impact"": ""A malicious recipient contract could reenter the marketplace during payment and manipulate the market state, potentially exploit the distribution logic, or cause double payments leading to fund theft."",
      ""Location"": ""Function _distributeFunds, particularly in the ETH transfer calls and subsequent state update marking first sales as completed""
    },
    {
      ""Issue"": ""First sale tracking manipulation"",
      ""Severity"": ""High"",
      ""Description"": ""The _nftContractToTokenIdToFirstSaleCompleted mapping is only updated after all transfers. If a transaction reverts after setting this value but before completing, or if an attacker can cause a sale to execute but fail (e.g., through a reentrant call), they might be able to manipulate this tracking."",
      ""Impact"": ""Could lead to incorrect fee calculations where primary sale fees (15%) might be applied instead of secondary sale fees (5%) or vice versa, leading to financial losses for either the platform or the seller."",
      ""Location"": ""End of _distributeFunds function where _nftContractToTokenIdToFirstSaleCompleted is set""
    },
    {
      ""Issue"": ""Insufficient validation of creator shares"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract checks if individual creator shares exceed BASIS_POINTS (10000), but doesn't validate that the sum of all shares equals BASIS_POINTS. This could lead to unexpected royalty distributions if the total shares are significantly different from the expected value."",
      ""Impact"": ""Incorrect distribution of royalties among multiple creators, potentially causing some creators to receive more than their fair share while others receive less. If total shares are much less than BASIS_POINTS, creators would receive proportionally correct distribution but of a smaller total amount than intended."",
      ""Location"": ""Function _distributeFunds, in the validation logic for creatorShares""
    },
    {
      ""Issue"": ""Potential integer overflow in creator shares calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the _distributeFunds function, when calculating the total shares for multiple creator recipients, there's a risk of integer overflow as the code uses unchecked for gas optimization. If many creators with large share values are specified, this could potentially overflow."",
      ""Impact"": ""Could lead to incorrect fee distribution if shares are maliciously crafted to cause overflow, potentially resulting in creators receiving incorrect payment amounts."",
      ""Location"": ""Function _distributeFunds, in the unchecked block calculating totalShares""
    },
    {
      ""Issue"": ""Precision loss and rounding errors in fee distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""When calculating individual creator shares using '(creatorFee * creatorShares[i]) / totalShares', there can be precision loss due to integer division. The contract attempts to handle this by giving the remaining balance to the first creator, but this approach may not be intuitive or fair, leading to rounding errors."",
      ""Impact"": ""Minor discrepancies in payment distribution among multiple creators, especially with unusual share ratios or small payment amounts. The first creator might receive slightly more or less than their proportional share."",
      ""Location"": ""Function _distributeFunds, in the loop distributing payments to multiple creators""
    },
    {
      ""Issue"": ""Gas limit constraints for transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses fixed gas limits (SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT and SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS) for ETH transfers. If recipients are contracts with complex fallback functions, these limits might be insufficient, causing transfers to fail."",
      ""Impact"": ""Failed transfers could lead to funds being temporarily stuck in the contract or requiring manual withdrawal, affecting the user experience and potentially the market's operation."",
      ""Location"": ""All _sendValueWithFallbackWithdraw calls in the _distributeFunds function""
    },
    {
      ""Issue"": ""No validation for zero addresses in recipient lists"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not check if any of the creator recipients are zero addresses before attempting to send payments. While the _sendValueWithFallbackWithdraw function might handle this, it's better to validate earlier."",
      ""Impact"": ""Funds could be sent to a zero address and become permanently lost, or the transaction could revert causing the entire distribution to fail."",
      ""Location"": ""Function _distributeFunds, when processing creator recipients""
    },
    {
      ""Issue"": ""Potential for gas griefing with many creators"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract allows multiple creator recipients (up to MAX_ROYALTY_RECIPIENTS_INDEX), but each transfer consumes gas. A malicious actor could set up many creators to make transactions prohibitively expensive."",
      ""Impact"": ""Extremely high gas costs for sales, potentially making some NFT sales economically unviable or causing transactions to fail due to out-of-gas errors if there are many creator recipients."",
      ""Location"": ""Creator payment distribution loop in _distributeFunds function""
    },
    {
      ""Issue"": ""Unchecked array access"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract accesses creatorRecipients and creatorShares arrays without verifying that both arrays have matching lengths. If _getCreatorPaymentInfo returns arrays of different lengths, this could cause an out-of-bounds access or revert."",
      ""Impact"": ""Potential out-of-bounds access, revert on transaction, or in worst case, incorrect fund distribution."",
      ""Location"": ""Function _distributeFunds, in the loop that processes creator shares""
    },
    {
      ""Issue"": ""Front-running vulnerability in fee distribution"",
      ""Severity"": ""Low"",
      ""Description"": ""The fee distribution mechanism depends on whether a token has had its first sale completed. This state could potentially be manipulated through front-running attacks to affect the fee percentages applied."",
      ""Impact"": ""An attacker could potentially manipulate the system to pay lower foundation fees or incorrect creator royalties by changing the sale order of NFTs."",
      ""Location"": ""Function _getFees and the _nftContractToTokenIdToFirstSaleCompleted mapping usage""
    },
    {
      ""Issue"": ""Centralized fee structure"",
      ""Severity"": ""Low"",
      ""Description"": ""The fee percentages (CREATOR_ROYALTY_BASIS_POINTS, PRIMARY_FOUNDATION_FEE_BASIS_POINTS, SECONDARY_FOUNDATION_FEE_BASIS_POINTS) are hardcoded as constants rather than configurable parameters. This means they cannot be changed without upgrading the contract."",
      ""Impact"": ""The contract operators cannot adjust fees in response to market conditions or community feedback without a full contract upgrade, creating a centralization risk and lack of flexibility."",
      ""Location"": ""Constant fee definitions at the beginning of the contract""
    },
    {
      ""Issue"": ""Missing event emissions for significant state changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't emit events when significant state changes occur, such as marking a first sale as completed (_nftContractToTokenIdToFirstSaleCompleted). This reduces transparency and makes it harder to track the contract's state off-chain."",
      ""Impact"": ""Reduced visibility into contract state changes and difficulty in tracking first sale status off-chain, making it difficult to audit fee distributions or troubleshoot issues."",
      ""Location"": ""_distributeFunds function (line 102)""
    },
    {
      ""Issue"": ""No mechanism to update creator royalty information"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract doesn't appear to have a mechanism for updating creator information or royalty splits after initial setup. This creates inflexibility for creators who may need to change their payment details."",
      ""Impact"": ""Creator payment information becomes immutable, which could cause issues if a creator changes their preferred wallet or if there are changes to the creator team."",
      ""Location"": ""Entire contract, absence of update functions for creator payment info""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 13
}",341.5377869606018,48190.0,32.0,"### **[M-08] Primary seller can avoid paying the primary fee**

**Report Description**:
The Foundation protocol charges a 15% fee for primary sales and a 5% fee for secondary sales. A primary seller can circumvent the 15% fee and pay only 5% by manipulating the conditions that determine whether a sale is primary. Specifically, a sale is considered primary if:
1. The seller is one of the creators in the NFT metadata.
2. It is the first time the NFT is sold on the Foundation protocol.

A primary seller could potentially manipulate these conditions to avoid paying the higher fee, leading to a loss of revenue for the protocol.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of a primary seller circumventing the primary fee. While some responses discuss fee distribution and state manipulation (e.g., ""First sale tracking manipulation""), none directly address the vulnerability where a primary seller can avoid paying the 15% fee. This issue is missed entirely in the response list.

---

### **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Report Description**:
The `MAX_ROYALTY_RECIPIENTS_INDEX` is set to 4, which means only 5 creators can be paid out. Any additional creators beyond this limit are ignored. This could lead to unfair royalty distributions, as some creators may not receive their rightful share of the royalties.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `MAX_ROYALTY_RECIPIENTS_INDEX` being set too low. While some responses discuss issues related to creator shares and royalty distributions (e.g., ""Insufficient validation of creator shares"" and ""Potential for gas griefing with many creators""), none specifically address the limitation imposed by `MAX_ROYALTY_RECIPIENTS_INDEX`. This issue is missed entirely in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-08] Primary seller can avoid paying the primary fee**
- **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

---

### **Conclusion**
The response list fails to address the two specific issues from the issue report. While the response list covers a wide range of vulnerabilities and risks related to fee distribution, reentrancy, and state manipulation, it does not include any mention of the primary fee circumvention issue or the limitation imposed by `MAX_ROYALTY_RECIPIENTS_INDEX`. These gaps indicate that the response list is incomplete and does not fully cover the vulnerabilities identified in the issue report.","```
None.
```",0.0
