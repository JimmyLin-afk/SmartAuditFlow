nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTPairWithOracle.sol,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8413,754,"[H-01] Avoidance of Liquidation Via Malicious Oracle
Issue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.
Consequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed
  [H-02] The return value success of the get function of the INFTOracle interface is not checked “(, uint256 rate) = loanParams.oracle.get(address(this), tokenId);”
The get function of the INFTOracle interface returns two values, but the success value is not checked when used in the NFTPairWithOracle contract. When success is false, NFTOracle may return stale data.
  [H-03] Critical Oracle Manipulation Risk by Lender
The intended use of the Oracle is to protect the lender from a drop in the borrower's collateral value. If the collateral value goes up significantly and higher than borrowed amount + interest, the lender should not be able to seize the collateral at the expense of the borrower. However, in the NFTPairWithOracle contract, the lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly. This is a critical risk because borrowers asset could be lost to malicious lenders.
  [H-04] Lender is able to seize the collateral by changing the loan parameters The `updateLoanParams()` allows the lender to modify the parameters of an active loan in favor of the borrower. But, by setting the ltvBPS value to 0 they are able to seize the collateral.   [H-05] Mistake while checking LTV to lender accepted LTV
It comments in the `_lend()` function that lender accepted conditions must be at least as good as the borrower is asking for. The line which checks the accepted LTV (lender's LTV) against borrower asking LTV is: `params.ltvBPS >= accepted.ltvBPS`, This means lender should be offering a lower LTV, which must be the opposite way around. I think this may have the potential to strand the lender, if he enters a lower LTV. For example borrower asking LTV is 86%. However, lender enters his accepted LTV as 80%. lend() will execute with 86% LTV and punish the lender, whereas it should revert and acknowledge the lender that his bid is not good enough.
  [M-01] Reentrancy at _requestLoan allows requesting a loan without supplying collateral
The function `_requestLoan` makes an external call to the collateral contract before updating the NFTPair contract state.
",6,,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; 
    uint64 duration; 
    uint16 annualInterestBPS; 
    uint16 ltvBPS; 
    INFTOracle oracle; 
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}




contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    
    address public feeTo;

    
    
    IERC721 public collateral;
    IERC20 public asset;

    
    

    
    uint256 public feesEarnedShare;

    
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    
    mapping(address => uint256) public nonces;

    
    
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            
            
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        
        
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    
    
    
    
    
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    
    
    
    
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                
                
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        
        
        
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        
        
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); 
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    
    
    
    
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    
    

    
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    

    
    
    
    
    
    
    
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    
    
    
    
    
    
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); 
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        
        
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    
    uint8 internal constant ACTION_CALL = 30;

    
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); 
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    
    
    
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    
    
    
    
    
    
    
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    
    
    
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",4953,5,1,"Based on the code analysis, here's a comprehensive audit task list targeting key areas of concern:

{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Conduct thorough reentrancy analysis for all external calls, especially in lend(), repay(), and removeCollateral() functions"",
        ""Verify implementation of checks-effects-interactions pattern"",
        ""Analyze potential integer overflow/underflow risks in mathematical operations"",
        ""Review signature replay protection mechanisms in requestAndBorrow() and takeCollateralAndLend()"",
        ""Validate nonce management in signature verification to prevent duplicate signatures""
      ]
    },
    {
      ""Area"": ""Oracle Integration & Valuation"",
      ""Tasks"": [
        ""Investigate oracle price feed manipulation vulnerabilities"",
        ""Verify oracle price validation logic in loan parameters"",
        ""Assess oracle failure modes and potential economic attacks"",
        ""Analyze how price fluctuations impact loan liquidation mechanisms"",
        ""Review INFTOracle interface implementation and potential exploit vectors""
      ]
    },
    {
      ""Area"": ""Complex Interest Calculation"",
      ""Tasks"": [
        ""Mathematically verify the compound interest calculation algorithm"",
        ""Perform numerical stability testing across different principal and time ranges"",
        ""Check for potential precision loss in interest calculations"",
        ""Validate Taylor series approximation for compound interest"",
        ""Test edge cases in calculateInterest() function""
      ]
    },
    {
      ""Area"": ""Access Control & Permissions"",
      ""Tasks"": [
        ""Review ownership transfer and management in BoringOwnable"",
        ""Verify access control in critical functions like updateLoanParams()"",
        ""Analyze potential privilege escalation risks"",
        ""Check setFeeTo() function for potential centralization risks"",
        ""Validate signature-based authorization mechanisms""
      ]
    },
    {
      ""Area"": ""Token and Collateral Management"",
      ""Tasks"": [
        ""Verify ERC721 and ERC20 token interaction safety"",
        ""Analyze collateral removal and loan foreclosure logic"",
        ""Check for potential front-running in loan request and lending processes"",
        ""Review 'skim' mechanism security implications"",
        ""Validate asset transfer and BentoBox integration safety""
      ]
    },
    {
      ""Area"": ""Economic Attack Vectors"",
      ""Tasks"": [
        ""Identify potential flash loan attack surfaces"",
        ""Analyze loan parameter manipulation risks"",
        ""Review fee calculation and distribution mechanisms"",
        ""Check for potential economic incentive misalignments"",
        ""Validate loan-to-value (LTV) ratio enforcement""
      ]
    },
    {
      ""Area"": ""Batch Execution & Complex Interactions"",
      ""Tasks"": [
        ""Thoroughly test the 'cook()' multi-action execution function"",
        ""Verify security of dynamically executed actions"",
        ""Check for potential reentrancy in batch operations"",
        ""Analyze gas consumption and potential DoS vectors"",
        ""Review action type validation and execution safety""
      ]
    },
    {
      ""Area"": ""Signature and Permissionless Operations"",
      ""Tasks"": [
        ""Validate EIP-712 signature implementation"",
        ""Review signature verification logic in requestAndBorrow()"",
        ""Check nonce management and replay protection"",
        ""Analyze potential signature forgery risks"",
        ""Verify deadline and signature expiration mechanisms""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Verify ERC-721 and ERC-20 standard compliance"",
        ""Check BentoBox integration adherence to expected behaviors"",
        ""Review domain separator and signature domain implementation"",
        ""Validate interface compatibility with external contracts""
      ]
    }
  ]
}

Key Observations:
- The task list covers comprehensive security, economic, and operational aspects
- Tasks are specific, actionable, and directly address potential vulnerabilities
- Prioritizes complex areas like oracle integration, interest calculations, and signature mechanisms
- Provides a structured approach to auditing the NFT lending protocol

Recommendations for Audit Execution:
1. Use formal verification tools for mathematical calculations
2. Conduct extensive scenario-based testing
3. Perform manual code review alongside automated tools
4. Consider economic simulations to test edge cases
5. Engage domain experts for oracle and financial instrument analysis

Would you like me to elaborate on any specific area or provide more detailed analysis of potential risks?","I've performed a comprehensive review of the provided smart contract code. Here's my analysis structured in the requested JSON format:

{
  ""ReviewingTheCode"": ""The code represents an NFT-backed lending protocol implemented as a smart contract. It allows borrowers to use their NFTs as collateral to obtain loans in ERC20 tokens, with lenders providing the funds. The contract implements a system of loan requests, lending, repayments, and collateral management with parameters like valuation, duration, interest rates, and loan-to-value ratios."",
  
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTPairWithOracle"",
    ""Purpose"": ""Facilitates NFT-collateralized lending by matching borrowers and lenders, managing NFT collateral, handling loan terms, and processing repayments with interest calculation"",
    
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""BoringOwnable"", ""Domain"", ""IMasterContract""],
      ""Imports"": [
        ""BoringMath"", 
        ""BoringOwnable"", 
        ""Domain"", 
        ""IMasterContract"", 
        ""BoringRebase"", 
        ""BoringERC20"", 
        ""IBentoBoxV1"", 
        ""IERC721"", 
        ""INFTOracle""
      ]
    },
    
    ""StateVariables"": [
      {
        ""Name"": ""bentoBox"",
        ""Type"": ""IBentoBoxV1"",
        ""Purpose"": ""Reference to the BentoBox contract that handles token storage""
      },
      {
        ""Name"": ""masterContract"",
        ""Type"": ""NFTPairWithOracle"",
        ""Purpose"": ""Reference to the master implementation contract for clones""
      },
      {
        ""Name"": ""feeTo"",
        ""Type"": ""address"",
        ""Purpose"": ""Address that receives protocol fees""
      },
      {
        ""Name"": ""collateral"",
        ""Type"": ""IERC721"",
        ""Purpose"": ""The NFT contract used as collateral""
      },
      {
        ""Name"": ""asset"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The ERC20 token used for lending""
      },
      {
        ""Name"": ""feesEarnedShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated protocol fees that haven't been withdrawn""
      },
      {
        ""Name"": ""tokenLoanParams"",
        ""Type"": ""mapping(uint256 => TokenLoanParams)"",
        ""Purpose"": ""Stores loan parameters for each NFT token ID""
      },
      {
        ""Name"": ""tokenLoan"",
        ""Type"": ""mapping(uint256 => TokenLoan)"",
        ""Purpose"": ""Stores active loan information for each NFT token ID""
      },
      {
        ""Name"": ""nonces"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks nonces for EIP-712 signatures per user""
      }
    ],
    
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with BentoBox reference"",
        ""Parameters"": [""IBentoBoxV1 bentoBox_""],
        ""Returns"": []
      },
      {
        ""Name"": ""init"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes a clone instance with NFT and asset token addresses"",
        ""Parameters"": [""bytes calldata data""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateLoanParams"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates loan parameters for a specific NFT"",
        ""Parameters"": [""uint256 tokenId"", ""TokenLoanParams memory params""],
        ""Returns"": []
      },
      {
        ""Name"": ""requestLoan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits NFT and requests a loan with specified parameters"",
        ""Parameters"": [""uint256 tokenId"", ""TokenLoanParams memory params"", ""address to"", ""bool skim""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows borrower to withdraw collateral before loan is granted or allows foreclosure"",
        ""Parameters"": [""uint256 tokenId"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a lender to fund a loan request"",
        ""Parameters"": [""uint256 tokenId"", ""TokenLoanParams memory accepted"", ""bool skim""],
        ""Returns"": []
      },
      {
        ""Name"": ""calculateInterest"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates compound interest for a loan"",
        ""Parameters"": [""uint256 principal"", ""uint64 t"", ""uint16 aprBPS""],
        ""Returns"": [""uint256 interest""]
      },
      {
        ""Name"": ""repay"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Repays a loan with interest and returns the collateral"",
        ""Parameters"": [""uint256 tokenId"", ""bool skim""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""cook"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Batch execution function to perform multiple operations in one transaction"",
        ""Parameters"": [""uint8[] calldata actions"", ""uint256[] calldata values"", ""bytes[] calldata datas""],
        ""Returns"": [""uint256 value1"", ""uint256 value2""]
      },
      {
        ""Name"": ""requestAndBorrow"",
        ""Visibility"": ""public"",
        ""Purpose"": ""One-step function to request a loan and get funding using a lender's signature"",
        ""Parameters"": [""uint256 tokenId"", ""address lender"", ""address recipient"", ""TokenLoanParams memory params"", ""bool skimCollateral"", ""bool anyTokenId"", ""SignatureParams memory signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""takeCollateralAndLend"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a lender to take a borrower's NFT and provide a loan using the borrower's signature"",
        ""Parameters"": [""uint256 tokenId"", ""address borrower"", ""TokenLoanParams memory params"", ""bool skimFunds"", ""SignatureParams memory signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Withdraws accumulated fees to the feeTo address"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setFeeTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the address that receives protocol fees"",
        ""Parameters"": [""address newFeeTo""],
        ""Returns"": []
      }
    ]
  },
  
  ""ExternalInteractions"": [
    ""IBentoBoxV1 - used for token storage and transfers"",
    ""IERC721 - NFT contract for collateral"",
    ""IERC20 - Asset token for loans"",
    ""INFTOracle - External price oracle to verify NFT valuations"",
    ""ILendingClub - Interface for lender approval""
  ],
  
  ""SpecialMechanisms"": [
    ""EIP-712 signature verification for permissionless loan operations"",
    ""Compound interest calculation with Taylor series approximation"",
    ""Fee system with protocol fees on interest and open fees"",
    ""BentoBox integration for efficient token transfers and storage"",
    ""Batch execution pattern through the 'cook' function"",
    ""Token valuations backed by optional oracle price feeds"",
    ""Clone factory pattern through MasterContract implementation""
  ],
  
  ""Questions"": [
    ""Is there a mechanism to handle loans after they expire other than removeCollateral?"",
    ""The compound interest calculation seems complex - has it been thoroughly tested for numerical stability?"",
    ""Is there a maximum loan-to-value (LTV) limit to prevent risky lending?"",
    ""How does the oracle implementation work for determining if an NFT is sufficiently valuable?"",
    ""What happens if an NFT's price drops dramatically while it's being used as collateral?"",
    ""The protocol allows changing loan parameters after a loan is outstanding - could this create edge cases in interest calculations?"",
    ""The contract uses skim patterns in various functions - what is the security implication of allowing this?"",
    ""There appears to be no timelock or delay mechanism for setFeeTo - could this be a concern?""
  ]
}

Beyond the JSON structure, I've identified several potential security considerations:

1. The contract has a sophisticated compound interest calculation which could potentially be vulnerable to precision issues or manipulation if not properly implemented and tested.

2. The contract relies heavily on external oracles for NFT valuations, which could be a point of failure if the oracle is compromised or manipulated.

3. The use of signatures for permissionless operations creates complexity that requires careful implementation to avoid replay attacks and signature manipulations.

4. The removeCollateral function has complex conditions involving the oracle valuation that might lead to edge cases where NFTs can be withdrawn improperly.

5. The contract allows ""skim"" operations in multiple functions which could potentially be abused if not properly secured.

6. The lack of clear liquidation mechanics might lead to undercollateralized loans if NFT prices fall significantly.

This is a sophisticated lending protocol with multiple moving parts that would benefit from additional security review, particularly around the oracle integration and interest calculations.","I've analyzed the provided input data containing multiple issue reports for the NFTPairWithOracle contract. After combining similar issues and organizing them by severity, here's the consolidated security assessment:

{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in removeCollateral"",
      ""Severity"": ""Critical"",
      ""Description"": ""The removeCollateral() function violates the Checks-Effects-Interactions pattern by performing external calls (transferFrom) after modifying state (delete tokenLoan[tokenId]). This creates a potential reentrancy vector, as the external call could allow an attacker to re-enter the contract before the state change is completed."",
      ""Impact"": ""An attacker could potentially re-enter the contract through the NFT's onERC721Received callback and exploit the state before it's fully updated, possibly extracting collateral multiple times or manipulating other contract state."",
      ""Location"": ""removeCollateral() function where it deletes the tokenLoan before transferring the NFT""
    },
    {
      ""Issue"": ""Oracle Manipulation Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The contract allows borrowers to specify arbitrary oracle contracts via the TokenLoanParams struct. While there is a check that verifies the oracle price during lending, there's no validation of the oracle contract itself or its interface compliance. Any contract implementing the INFTOracle interface could be used, regardless of its reliability or trustworthiness."",
      ""Impact"": ""Malicious actors could provide fake oracles that return manipulated prices, potentially enabling excessive borrowing against undervalued NFTs, leading to protocol insolvency and significant financial losses for lenders who would receive undervalued collateral."",
      ""Location"": ""TokenLoanParams struct, requestLoan(), _lend() function at the oracle verification logic""
    },
    {
      ""Issue"": ""Signature Replay Attack Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""While the contract uses nonces for signatures, it has a vulnerability in the requestAndBorrow() function with anyTokenId flag. When set to true (tokenId = 0), a signature can be reused across different NFTs as the signature doesn't include the specific tokenId. Additionally, signatures could be reused across different chains or contract instances as the signature validation doesn't include chain ID or contract address in all cases."",
      ""Impact"": ""An attacker could reuse a lender's signature intended for one NFT on multiple different NFTs, potentially causing unintended capital deployment or loans on undesired NFTs. Signatures could also potentially be replayed across different deployments or chains."",
      ""Location"": ""requestAndBorrow() and takeCollateralAndLend() functions, especially the LEND_SIGNATURE_HASH validation when anyTokenId is true""
    },
    {
      ""Issue"": ""Integer Overflow in Interest Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""The calculateInterest function has potential integer overflow issues in its compound interest calculation. While there is a revert if interest >= 2^128, there are potential intermediate overflow issues during calculation, especially with the term_k and denom_k variables which could exceed uint256 limits with extreme inputs before this check is reached."",
      ""Impact"": ""Potential integer overflows could result in incorrect interest calculations or transaction failures for large loans or long time periods, causing financial losses to either borrowers or lenders."",
      ""Location"": ""calculateInterest() function""
    },
    {
      ""Issue"": ""Improper Validation in removeCollateral When Loan is Outstanding"",
      ""Severity"": ""High"",
      ""Description"": ""In the removeCollateral() function, there's logic to check if an NFT's value has decreased using the oracle, but the implementation allows a lender to take the NFT if the value decreased below the loan amount. There's also a logical flaw in the comparison that could allow premature liquidation."",
      ""Impact"": ""A lender could take full ownership of an NFT worth significantly more than the outstanding loan amount if the NFT's value drops slightly below the loan amount, effectively stealing the excess value from the borrower. This creates a liquidation mechanism without proper safeguards or partial repayment options."",
      ""Location"": ""removeCollateral() function conditional block for LOAN_OUTSTANDING status""
    },
    {
      ""Issue"": ""Unsafe External Calls in cook() Function"",
      ""Severity"": ""High"",
      ""Description"": ""The cook() function allows arbitrary calls to external contracts through the ACTION_CALL action. While there are checks preventing calls to bentoBox, collateral, and this contract, it still allows potentially dangerous calls to other contracts. The _call function makes arbitrary external calls to addresses provided in the input data with only basic restrictions."",
      ""Impact"": ""Malicious or vulnerable external contracts called through cook() could gain control over the contract's execution context, potentially accessing or modifying its state in unexpected ways. Users could unknowingly approve transactions that execute harmful external calls, potentially leading to loss of funds."",
      ""Location"": ""_call() function within cook() execution flow""
    },
    {
      ""Issue"": ""Compound Interest Calculation Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The calculateInterest function implements compound interest using a Taylor series approximation with a fixed number of terms (COMPOUND_INTEREST_TERMS = 6). This may not accurately calculate interest for all possible parameter inputs, especially for high interest rates or long durations. The function also performs multiple division operations which can lead to precision loss, especially for small values."",
      ""Impact"": ""Incorrect interest calculations may lead to borrowers paying too much or too little interest, potentially causing financial losses to either borrowers or lenders. Under extreme conditions, this could also lead to transaction failures due to excessive gas consumption."",
      ""Location"": ""calculateInterest() function""
    },
    {
      ""Issue"": ""Lack of Slippage Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks slippage protection in several areas: 1) In lend() function, prices are retrieved from the oracle at transaction execution time without any slippage protection, 2) When converting between token amounts and shares using bentoBox.toShare, there's no slippage protection, and 3) In lending operations, there's vulnerability to front-running attacks."",
      ""Impact"": ""Users might receive less value than anticipated, especially in volatile market conditions. A lender might provide a loan based on a stale or manipulated price that no longer reflects the actual value of the NFT, potentially resulting in an undercollateralized position."",
      ""Location"": ""lend() function, various functions using bentoBox.toShare and bentoBox.transfer, lending operations""
    },
    {
      ""Issue"": ""Centralization Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several centralization risks exist: 1) The contract inherits from BoringOwnable which gives significant control to the owner, including the ability to change the feeTo address, 2) The contract allows borrowers to use a LendingClub contract instead of a signature without validating its logic, and 3) Heavy reliance on potentially centralized oracles without fallback mechanisms."",
      ""Impact"": ""A compromised owner could redirect fees to a malicious address. Users may trust a LendingClub that makes poor lending decisions, or attackers could create malicious LendingClub implementations. System failure in case of oracle outage or manipulation could lead to incorrect loan valuations."",
      ""Location"": ""setFeeTo() function, requestAndBorrow function where ILendingClub is used, oracle dependencies""
    },
    {
      ""Issue"": ""Unchecked Return Values from External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions in the contract that interact with external contracts (like ERC20 and ERC721) don't check the return values from those calls. This is particularly concerning for older tokens that may return false instead of reverting on failure. The contract assumes ERC20 and ERC721 transfers always succeed."",
      ""Impact"": ""Failed transfers might not be detected, leading to inconsistent state and potentially lost funds or collateral. This could lead to accounting errors, where the contract thinks a token transfer succeeded when it actually failed."",
      ""Location"": ""Multiple functions including requestLoan(), removeCollateral(), repay(), and places where collateral.transferFrom() is called""
    },
    {
      ""Issue"": ""Missing Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks comprehensive validation for various inputs: 1) Several functions accept TokenLoanParams without validating all fields, 2) No validation for loan parameters such as duration, interest rates, or LTV ratios being within reasonable bounds, 3) Missing zero-address checks in initialization and parameter setting, and 4) No proper validation that oracles return reasonable prices."",
      ""Impact"": ""Users might accidentally or intentionally set extreme loan parameters that could lead to excessive interest accumulation or other unexpected behaviors. Could lead to loans with unreasonable terms that may cause issues during repayment or liquidation."",
      ""Location"": ""requestLoan(), updateLoanParams(), lend() functions, and other places accepting TokenLoanParams""
    },
    {
      ""Issue"": ""Front-running Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The nonce is only incremented after signature validation in requestAndBorrow and takeCollateralAndLend. This creates a race condition where multiple transactions using the same signature could be submitted simultaneously. Transactions like requestAndBorrow can be front-run by observers who see the pending transaction."",
      ""Impact"": ""An attacker observing pending transactions could front-run users' transactions, potentially causing their legitimate transactions to fail due to a now-invalid nonce. Potential transaction failure or unexpected behavior for users as lending conditions could change between transaction submission and execution."",
      ""Location"": ""requestAndBorrow() and takeCollateralAndLend() functions""
    },
    {
      ""Issue"": ""Missing Deadline Checks in Signature-based Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""While requestAndBorrow() and takeCollateralAndLend() check if the current block timestamp is less than or equal to the deadline, there's no minimum value enforced for the deadline, which could lead to signature replay if a very far future deadline is set. Front-running protection should be consistently applied to all signature-based operations."",
      ""Impact"": ""Signatures with far-future deadlines could remain valid for years, creating a long-term security risk if private keys are compromised. Transactions could potentially be front-run or replayed if not properly protected with expiration mechanisms."",
      ""Location"": ""requestAndBorrow() and takeCollateralAndLend() functions""
    },
    {
      ""Issue"": ""Price Validation Only at Lending Time"",
      ""Severity"": ""Medium"",
      ""Description"": ""NFT prices are only checked at the time of lending but not during the lifetime of the loan. If NFT values drop significantly after the loan is issued, the contract doesn't have a proper liquidation mechanism to protect the lender."",
      ""Impact"": ""In volatile NFT markets, a significant value decrease could leave lenders with bad debt, as borrowers would have incentive to default rather than repay if the NFT value drops below the loan amount."",
      ""Location"": ""_lend function where oracle.get() is used""
    },
    {
      ""Issue"": ""Unsafe Type Casting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses unsafe type casting in multiple locations, particularly when converting uint256 to smaller types like uint128 or uint64. This can lead to silent overflow if the original value exceeds the maximum value of the target type."",
      ""Impact"": ""Potential loss of value precision or unexpected behavior if values exceed type limits, particularly for high value NFTs or calculations involving large numbers."",
      ""Location"": ""calculateInterest() function with .to128() casting, loan.startTime = uint64(block.timestamp) in _lend()""
    },
    {
      ""Issue"": ""Timing Attack in Loan Repayment"",
      ""Severity"": ""Medium"",
      ""Description"": ""The repay function requires the loan to NOT be expired to allow repayment, which means borrowers can't repay after expiration. This could cause issues if there's high network congestion close to expiration time. The contract relies on block.timestamp for determining loan durations and interest calculations."",
      ""Impact"": ""Borrowers might lose their collateral if they can't submit a repay transaction before expiration due to network conditions. Miners could slightly manipulate timestamps to affect interest calculations or loan durations, potentially benefiting either borrowers or lenders in edge cases."",
      ""Location"": ""repay() function condition checking loan expiration, functions using block.timestamp""
    },
    {
      ""Issue"": ""Lack of Events for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical state changes don't emit events, such as when fees are earned during lend() operations or when a loan expires. This makes it difficult to track the full state history off-chain."",
      ""Impact"": ""Reduced transparency and ability to monitor protocol activity, complicating auditing and making it harder to detect suspicious activities."",
      ""Location"": ""Throughout the contract, especially in lend() and repay() functions""
    },
    {
      ""Issue"": ""No Comprehensive Rate Limiting"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks rate limiting on key operations, which could make it vulnerable to denial-of-service attacks or market manipulation if a large number of loans are created or modified quickly."",
      ""Impact"": ""Could lead to network congestion or economic attacks through rapid manipulation of lending terms."",
      ""Location"": ""Contract-wide concern""
    },
    {
      ""Issue"": ""Insufficient Fee Parameter Bounds Checking"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses hardcoded fee constants (PROTOCOL_FEE_BPS, OPEN_FEE_BPS) without any upper bounds validation. While these are constants and cannot be changed after deployment, they should be validated to ensure they don't exceed reasonable limits."",
      ""Impact"": ""If deployed with excessive fee parameters, the contract could charge unreasonable fees to users, affecting the economic viability of the protocol."",
      ""Location"": ""Contract constants PROTOCOL_FEE_BPS, OPEN_FEE_BPS""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 19
}",505.53132605552673,105883.0,33.0,"### **Summary of Matches and Gaps**

---

#### **[H-01] Avoidance of Liquidation Via Malicious Oracle**

**Report Description**:  
Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle. A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. The lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed.

**Match in Response List**:  
Matches with the issue titled **""Oracle Manipulation Vulnerability""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with arbitrary oracles and the lack of validation. It correctly explains the risks associated with malicious oracles, which aligns with the issue's description of avoiding liquidation.

---

#### **[H-02] The return value `success` of the get function of the INFTOracle interface is not checked**

**Report Description**:  
The `get` function of the INFTOracle interface returns two values, but the `success` value is not checked when used in the NFTPairWithOracle contract. When `success` is false, NFTOracle may return stale data.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of unchecked return values from the INFTOracle interface, which could lead to stale or incorrect data being used in the contract.

---

#### **[H-03] Critical Oracle Manipulation Risk by Lender**

**Report Description**:  
The lender could change the Oracle once a loan is outstanding, allowing them to seize the collateral at the expense of the borrower if the actual value of the collateral has increased significantly. This is a critical risk because the borrower's asset could be lost to malicious lenders.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the specific risk of lenders changing the Oracle after a loan is active, which could lead to unfair seizure of collateral.

---

#### **[H-04] Lender is able to seize the collateral by changing the loan parameters**

**Report Description**:  
The `updateLoanParams()` function allows the lender to modify the parameters of an active loan. By setting the `ltvBPS` value to `0`, they are able to seize the collateral.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of lenders modifying loan parameters to seize collateral, which is a significant risk to borrowers.

---

#### **[H-05] Mistake while checking LTV to lender accepted LTV**

**Report Description**:  
The `_lend()` function checks the lender's accepted LTV against the borrower's asking LTV with the condition `params.ltvBPS >= accepted.ltvBPS`. This means the lender should be offering a lower LTV, but the condition is reversed, potentially punishing the lender.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of incorrect LTV checks, which could lead to unfair lending conditions.

---

#### **[M-01] Reentrancy at _requestLoan allows requesting a loan without supplying collateral**

**Report Description**:  
The function `_requestLoan` makes an external call to the collateral contract before updating the NFTPair contract state, creating a reentrancy vulnerability.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in removeCollateral""**.

**Validation**:  
**Partially Correct**. The response identifies a reentrancy vulnerability but focuses on the `removeCollateral` function rather than `_requestLoan`. While the issue is similar, the specific function and context are not fully addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Avoidance of Liquidation Via Malicious Oracle**

**Partially Correct Matches**:

- **[M-01] Reentrancy at _requestLoan allows requesting a loan without supplying collateral**

**Missed Issues from Issue Report**:

- **[H-02] The return value `success` of the get function of the INFTOracle interface is not checked**
- **[H-03] Critical Oracle Manipulation Risk by Lender**
- **[H-04] Lender is able to seize the collateral by changing the loan parameters**
- **[H-05] Mistake while checking LTV to lender accepted LTV**

---

The response list covers some critical issues but misses several high-severity vulnerabilities, particularly those related to oracle manipulation, unchecked return values, and incorrect LTV checks. These gaps highlight the need for a more comprehensive review of the contract's security mechanisms.","```
1. Oracle Manipulation Vulnerability
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Oracle Manipulation Vulnerability"".
   - In the ranked list of predictions, ""Oracle Manipulation Vulnerability"" appears at rank 2.

2. **Calculate the precision at that rank**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by 2.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - Therefore, \( AP = 0.5 \).

**Output**:
```
0.5
```"
