nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LiquidityPool.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025,434,"[H-01] Can deposit native token for free and steal funds

Submitted by cmichel, also found by CertoraInc
LiquidityPool.sol#L151
The depositErc20 function allows setting tokenAddress = NATIVE and does not throw an error. No matter the amount chosen, the SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount); call will not revert because it performs a low-level call to NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, which is an EOA, and the low-level calls to EOAs always succeed. Because the safe* version is used, the EOA not returning any data does not revert either.
This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same Deposit event as a real depositNative call and the attacker receives the native funds on the other chain.
  [H-03] Wrong formula when add fee incentivePool can lead to loss of funds.

Submitted by minhquanym, also found by cmichel, hickuphh3, and WatchPug
LiquidityPool.sol#L319-L322
The `getAmountToTransfer` function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.
  [M-08] Incentive Pool can be drained without rebalancing the pool

Submitted by kyliek, also found by Ruhum and WatchPug
LiquidityPool.sol#L149-L173 LiquidityPool.sol#L263-L277
`depositErc20()` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.
  [M-18] Possible frontrun on `deposits` on LiquidityPool

Submitted by Cantor_Dust, also found by WatchPug
Rewards are given to a user for depositing either ERC20 tokens or their native token into the LiquidityPool. This reward is used to incentivize users to deposit funds into the liquidity pool when the pool is not in an equilibrium state.
For regular users, this liquidity pool state fluctuates based on the frequency and amount of deposits made to the liquidity pool. If a malicious user can control the state of the liquidity pool before a victim deposits tokens into the liquidity pool, they can gain double rewards.
To gain these double rewards, a malicious user can watch the mempool for transactions that will receive a reward when the deposit occurs. When a malicious user sees that victim deposit, the malicious user can attach a higher fee to their transaction and initiate a deposit. This will allow the malicious user's transaction to front-run before the victim's transaction.
",4,,"pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; 

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; 
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; 

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3573,2,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions that interact with external contracts, especially in `depositErc20`, `sendFundsToUser`, and `transfer`."",
        ""Verify that all arithmetic operations are protected against overflow/underflow using Solidity 0.8.0's built-in checks."",
        ""Ensure that external calls (e.g., `SafeERC20Upgradeable.safeTransferFrom`) are properly handled and do not introduce vulnerabilities."",
        ""Review the `processedHash` mapping to ensure it effectively prevents replay attacks by checking if a transaction hash has already been processed.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards in handling token transfers and approvals."",
        ""Ensure that the `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions correctly implement EIP-2612 permit functionality.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the `getRewardAmount` function to ensure it correctly calculates rewards based on liquidity and does not introduce unexpected behavior."",
        ""Review the `getTransferFee` function to verify that it accurately calculates fees based on liquidity and does not lead to incorrect fee distributions."",
        ""Check the `getAmountToTransfer` function to ensure it correctly deducts fees and gas costs from the transfer amount.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that all interactions with external contracts (e.g., `executorManager`, `tokenManager`, `liquidityProviders`) are properly validated and do not introduce vulnerabilities."",
        ""Ensure that the contract handles failures in external calls gracefully, especially in functions like `sendFundsToUser` and `transfer`.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only authorized executors can call `sendFundsToUser`, `withdrawErc20GasFee`, and `withdrawNativeGasFee` using the `onlyExecutor` modifier."",
        ""Ensure that only the owner can call critical functions like `setTrustedForwarder`, `setLiquidityProviders`, and `setExecutorManager`."",
        ""Check that the `onlyLiquidityProviders` modifier is correctly applied to the `transfer` function.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, especially in functions like `getAmountToTransfer` and `getTransferFee`."",
        ""Review the use of storage variables (e.g., `processedHash`, `gasFeeAccumulatedByToken`) to minimize gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the `liquidityProviders` contract correctly manages liquidity and does not introduce risks like impermanent loss."",
        ""Verify that the `incentivePool` is properly funded and managed to prevent exploitation.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Review the contract for vulnerabilities to flash loan attacks, especially in functions that calculate rewards or fees based on liquidity.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""If the contract relies on external price feeds or oracles, ensure that they are tamper-proof and provide accurate data.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""If the contract includes governance mechanisms, ensure they are secure and not susceptible to manipulation.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Verify that the `incentivePool` is correctly managed and that rewards are distributed fairly and securely.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Ensure that the contract's tokenomics do not introduce inflationary risks or other unintended consequences.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities, especially in functions that handle deposits and transfers.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not allow unauthorized withdrawal of funds or other malicious exits.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""If the contract interacts with other chains, ensure that cross-chain operations are secure and do not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the `Pausable` mechanism is correctly implemented and can be used to halt the contract in case of emergencies.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named 'LiquidityPool' that facilitates the management of liquidity across different chains. It integrates with external contracts for executor management, token management, and liquidity providers. The contract supports ERC20 token deposits, native token deposits, and fund transfers, while handling fees, gas costs, and incentives."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityPool"",
    ""Purpose"": ""To manage liquidity across chains, handle deposits, transfers, and fees for ERC20 and native tokens, and interact with external contracts for executor and token management."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuardUpgradeable"", ""Pausable"", ""OwnableUpgradeable"", ""ERC2771ContextUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/IExecutorManager.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""../interfaces/IERC20Permit.sol"",
        ""./interfaces/ITokenManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address"",
        ""Purpose"": ""Constant representing the native token address.""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant used for fee calculations.""
      },
      {
        ""Name"": ""baseGas"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Base gas cost for transactions.""
      },
      {
        ""Name"": ""executorManager"",
        ""Type"": ""IExecutorManager"",
        ""Purpose"": ""Contract managing executors.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Contract managing supported tokens.""
      },
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Contract managing liquidity providers.""
      },
      {
        ""Name"": ""processedHash"",
        ""Type"": ""mapping(bytes32 => bool)"",
        ""Purpose"": ""Tracks processed transaction hashes.""
      },
      {
        ""Name"": ""gasFeeAccumulatedByToken"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Accumulated gas fees by token.""
      },
      {
        ""Name"": ""gasFeeAccumulated"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Accumulated gas fees by token and executor.""
      },
      {
        ""Name"": ""incentivePool"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Pool of incentives for liquidity providers.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with executor manager, pauser, trusted forwarder, token manager, and liquidity providers."",
        ""Parameters"": [""address _executorManagerAddress"", ""address _pauser"", ""address _trustedForwarder"", ""address _tokenManager"", ""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTrustedForwarder"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the trusted forwarder address."",
        ""Parameters"": [""address trustedForwarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the liquidity providers address."",
        ""Parameters"": [""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBaseGas"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the base gas cost."",
        ""Parameters"": [""uint128 gas""],
        ""Returns"": []
      },
      {
        ""Name"": ""getExecutorManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the executor manager address."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""setExecutorManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the executor manager address."",
        ""Parameters"": [""address _executorManagerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""getCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the current liquidity for a token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256 currentLiquidity""]
      },
      {
        ""Name"": ""depositErc20"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits ERC20 tokens into the liquidity pool."",
        ""Parameters"": [""uint256 toChainId"", ""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""getRewardAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the reward amount for a deposit."",
        ""Parameters"": [""uint256 amount"", ""address tokenAddress""],
        ""Returns"": [""uint256 rewardAmount""]
      },
      {
        ""Name"": ""permitAndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Permits and deposits ERC20 tokens."",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""permitEIP2612AndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Permits and deposits ERC20 tokens using EIP2612."",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositNative"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits native tokens into the liquidity pool."",
        ""Parameters"": [""address receiver"", ""uint256 toChainId"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendFundsToUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends funds to a user."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash"", ""uint256 tokenGasPrice"", ""uint256 fromChainId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountToTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the amount to transfer after fees."",
        ""Parameters"": [""uint256 initialGas"", ""address tokenAddress"", ""uint256 amount"", ""uint256 tokenGasPrice""],
        ""Returns"": [""uint256 amountToTransfer""]
      },
      {
        ""Name"": ""getTransferFee"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the transfer fee."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": [""uint256 fee""]
      },
      {
        ""Name"": ""checkHashStatus"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a transaction hash has been processed."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash""],
        ""Returns"": [""bytes32 hashSendTransaction"", ""bool status""]
      },
      {
        ""Name"": ""withdrawErc20GasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws accumulated ERC20 gas fees."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawNativeGasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws accumulated native gas fees."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers tokens to a receiver."",
        ""Parameters"": [""address _tokenAddress"", ""address receiver"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the message sender."",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the message data."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Receives native tokens."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IExecutorManager"",
    ""ITokenManager"",
    ""ILiquidityProviders"",
    ""IERC20Permit"",
    ""IERC20Upgradeable""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuardUpgradeable for preventing reentrancy attacks."",
    ""Pausable for pausing the contract in case of emergencies."",
    ""OwnableUpgradeable for ownership management."",
    ""ERC2771ContextUpgradeable for meta-transactions."",
    ""SafeERC20Upgradeable for safe ERC20 transfers.""
  ],
  ""Questions"": [
    ""How is the 'incentivePool' funded and managed?"",
    ""What is the purpose of the 'BASE_DIVISOR' constant in fee calculations?"",
    ""How are the gas fees calculated and distributed?"",
    ""What is the role of the 'processedHash' mapping and how is it used to prevent replay attacks?"",
    ""How does the 'getTransferFee' function determine the fee based on liquidity?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `sendFundsToUser`"",
      ""Severity"": ""High"",
      ""Description"": ""The `sendFundsToUser` function transfers funds to a user before updating the state, making it vulnerable to reentrancy attacks if the `receiver` is a malicious contract. Although the function uses the `nonReentrant` modifier, the state update occurs after the transfer, which could still be exploited."",
      ""Impact"": ""An attacker could drain funds from the contract by recursively calling `sendFundsToUser` before the state is updated."",
      ""Location"": ""`sendFundsToUser` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `getAmountToTransfer` and `getRewardAmount`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getAmountToTransfer` and `getRewardAmount` functions perform arithmetic operations without checking for potential integer overflow. This could lead to incorrect calculations, especially with large values."",
      ""Impact"": ""Incorrect calculations could result in incorrect fund transfers, reward distributions, or loss of funds."",
      ""Location"": ""`getAmountToTransfer` and `getRewardAmount` functions""
    },
    {
      ""Issue"": ""Unchecked Return Value for Low-Level Call in `withdrawNativeGasFee`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawNativeGasFee` function does not check the return value of the low-level call to transfer native tokens. If the transfer fails, the function will not revert, leading to potential loss of funds."",
      ""Impact"": ""Funds could be lost if the transfer fails, and the executor would not receive the gas fee."",
      ""Location"": ""`withdrawNativeGasFee` function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `permitAndDepositErc20` and `permitEIP2612AndDepositErc20`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions do not validate the `permitOptions` parameters, such as `nonce`, `expiry`, and `allowed`. This could lead to the acceptance of invalid or expired permits."",
      ""Impact"": ""Invalid or expired permits could be accepted, potentially allowing unauthorized deposits."",
      ""Location"": ""`permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions""
    },
    {
      ""Issue"": ""Potential Front-Running in `depositErc20`, `depositNative`, `permitAndDepositErc20`, and `permitEIP2612AndDepositErc20`"",
      ""Severity"": ""Medium"",
      ""Description"": ""These functions are susceptible to front-running attacks, where an attacker could intercept the transaction and manipulate the state before the original transaction is processed."",
      ""Impact"": ""Front-running could lead to inconsistent state, unfair advantages for attackers, or loss of funds."",
      ""Location"": ""`depositErc20`, `depositNative`, `permitAndDepositErc20`, and `permitEIP2612AndDepositErc20` functions""
    },
    {
      ""Issue"": ""Unrestricted Access to `setBaseGas`, `withdrawErc20GasFee`, and `withdrawNativeGasFee`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setBaseGas` function allows the owner to set the base gas value without validation, while `withdrawErc20GasFee` and `withdrawNativeGasFee` are restricted to the executor but lack mechanisms to prevent misuse. This could lead to incorrect gas fee calculations or unfair fee distributions."",
      ""Impact"": ""Incorrect gas fee calculations or unfair distribution of fees."",
      ""Location"": ""`setBaseGas`, `withdrawErc20GasFee`, and `withdrawNativeGasFee` functions""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several critical functions, such as `setExecutorManager`, `setLiquidityProviders`, and `transfer`, do not emit events when important state changes occur. This reduces transparency and auditability."",
      ""Impact"": ""Lack of event emission makes it difficult to track changes and audit the contract's behavior."",
      ""Location"": ""`setExecutorManager`, `setLiquidityProviders`, and `transfer` functions""
    },
    {
      ""Issue"": ""Potential Division by Zero in `getTransferFee`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTransferFee` function performs a division operation without checking if the denominator is zero, which could lead to a division by zero error."",
      ""Impact"": ""A division by zero error could cause the function to revert, disrupting the contract's functionality."",
      ""Location"": ""`getTransferFee` function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 8
}",445.1176283359528,98043.0,24.0,"### **Summary of Matches and Gaps**

---

#### **[H-01] Can deposit native token for free and steal funds**

**Report Description**:  
The `depositErc20` function in `LiquidityPool.sol` allows setting `tokenAddress = NATIVE` without throwing an error. The `SafeERC20Upgradeable.safeTransferFrom` call does not revert when `tokenAddress` is set to `NATIVE` (an EOA), as low-level calls to EOAs always succeed. This allows an attacker to deposit infinite native tokens without paying anything, leading to fund theft.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific vulnerability. The issue involves a critical flaw in the `depositErc20` function, which is not covered in the response list.

---

#### **[H-03] Wrong formula when add fee in `incentivePool` can lead to loss of funds**

**Report Description**:  
The `getAmountToTransfer` function in `LiquidityPool.sol` incorrectly updates `incentivePool[tokenAddress]` by dividing the value by `BASE_DIVISOR` (10000000000) each time. This causes `incentivePool[tokenAddress]` to quickly become zero, locking the tokens in the contract.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow in `getAmountToTransfer` and `getRewardAmount`""**.

**Validation**:  
**Partially Correct**. The response identifies potential arithmetic issues in `getAmountToTransfer` but focuses on integer overflow rather than the incorrect division logic described in the issue. The core problem of the formula error is not addressed.

---

#### **[M-08] Incentive Pool can be drained without rebalancing the pool**

**Report Description**:  
The `depositErc20` function allows an attacker to specify the destination chain and receiver account as the same as the source chain and caller account. This enables draining the incentive pool without rebalancing the pool to its equilibrium state.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves a logical flaw in the `depositErc20` function, which is not covered in the response list.

---

#### **[M-18] Possible frontrun on `deposits` on `LiquidityPool`**

**Report Description**:  
Rewards for depositing tokens into the `LiquidityPool` can be exploited through front-running. A malicious user can watch the mempool for victim deposits, attach a higher fee, and front-run the victim's transaction to gain double rewards.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running in `depositErc20`, `depositNative`, `permitAndDepositErc20`, and `permitEIP2612AndDepositErc20`""**.

**Validation**:  
**Correct**. The response accurately identifies the front-running vulnerability in deposit functions, which aligns with the issue description. The impact and risk are similarly identified.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-18] Possible frontrun on `deposits` on `LiquidityPool`**

**Partially Correct Matches**:

- **[H-03] Wrong formula when add fee in `incentivePool` can lead to loss of funds**

**Missed Issues from Issue Report**:

- **[H-01] Can deposit native token for free and steal funds**
- **[M-08] Incentive Pool can be drained without rebalancing the pool**

---

The response list covers some issues but misses critical vulnerabilities like **[H-01]** and **[M-08]**. Additionally, the response for **[H-03]** partially addresses the issue but does not fully capture the incorrect formula logic. Improvements are needed to ensure comprehensive coverage of all reported vulnerabilities.","```
1. Potential Front-Running in `depositErc20`, `depositNative`, `permitAndDepositErc20`, and `permitEIP2612AndDepositErc20`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is: ""Potential Front-Running in `depositErc20`, `depositNative`, `permitAndDepositErc20`, and `permitEIP2612AndDepositErc20`"".
   - This issue appears at rank **5** in the ranked list of predictions.

2. **Calculate the precision at rank 5 (\( P@5 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 5, \( P@5 = \frac{1}{5} = 0.2 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.2 \).

**Output**:
```
0.2
```"
LiquidityProviders.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555,475,"[H-02] LiquidityProviders.sol The share price of the LP can be manipulated and making future liquidityProviders unable to removeLiquidity()

Submitted by WatchPug
LiquidityProviders.sol#L345-L362
function removeLiquidity(uint256 _nftId, uint256 _amount)
    external
    nonReentrant
    onlyValidLpToken(_nftId, _msgSender())
    whenNotPaused
{
    (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
    require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

    require(_amount != 0, ""ERR__INVALID_AMOUNT"");
    require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
    whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
    // Claculate how much shares represent input amount
    uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

    // Calculate rewards accumulated
    uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
  [M-01] Unsupported tokens cannot be withdrawn

Submitted by cmichel, also found by kyliek, pedroais, and PPrieditis
LiquidityProviders.sol#L273
Supported tokens can be turned off again by calling TokenManager.removeSupportedToken. Users won't be able to withdraw their liquidity anymore because of this check in removeLiquidity.
  [M-11] LiquidityProviders: Setting new liquidity pool will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L171
Owners can change the liquidityPool variable any time with the setLiquidityPool function. If a liquidity pool was already set and users added liquidity with addTokenLiquidity, the tokens are directly transferred to the liquidity pool and not kept in the LiquidityProviders contract. Changing the liquidityPool to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity because the tokens are still in the old liquidityPool and cannot be retrieved.
  [M-12] LiquidityProviders: Setting new LP token will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L116
Owners can change the lpToken variable at any time with the setLpToken function. If an LP token was already set and users added liquidity with addTokenLiquidity and were minted a lpToken NFT, changing the lpToken to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity.
All users will lose their funds.

[M-17] wrong condition checking in price calculation

Submitted by CertoraInc
LiquidityProviders.sol#L180-L186
The getTokenPriceInLPShares function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return BASE_DIVISOR if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.
Proof of Concept
  [M-19] sharesToTokenAmount: Division by zero

Submitted by cmichel, also found by cccz and CertoraInc
LiquidityProviders.sol#L192
The public sharesToTokenAmount function does not check if the denominator totalSharesMinted[_tokenAddress] is zero. Neither do the callers of this function. The function will revert. Calling functions like getFeeAccumulatedOnNft and sharesToTokenAmount from another contract should never revert.
 [M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state

Submitted by kyliek
LiquidityProviders.sol#L388 LiquidityProviders.sol#L392
LP token holders can not redeem their tokens when the pool is in the deficit state, i.e. currentLiquidity << providedLiquidity. This is due to that LP shares are computed based on providedLiquidity and the actual available pool balance is based on currentLiquidity.
",7,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    
    mapping(address => uint256) public totalReserve; 
    mapping(address => uint256) public totalLiquidity; 
    mapping(address => uint256) public currentLiquidity; 
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3709,1,6,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions handling external calls, especially in `addNativeLiquidity`, `addTokenLiquidity`, and `removeLiquidity`."",
        ""Verify that all arithmetic operations are protected against overflow/underflow using SafeMath or Solidity 0.8.0's built-in checks."",
        ""Ensure that all external calls (e.g., `call`, `transferFrom`) are checked for success to prevent silent failures."",
        ""Audit the `_transferFromLiquidityPool` function to ensure it safely handles token transfers and does not expose the contract to potential attacks.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 and ERC-721 standards where applicable, especially in interactions with LP tokens and ERC20 tokens."",
        ""Ensure that the contract follows best practices for upgradeable contracts as per OpenZeppelin's upgradeable contracts framework.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the fee calculation logic in `getFeeAccumulatedOnNft` and `claimFee` to ensure accuracy and prevent potential manipulation."",
        ""Audit the liquidity share calculation in `sharesToTokenAmount` and `getTokenPriceInLPShares` to ensure correct and fair distribution of shares."",
        ""Verify the logic in `_increaseLiquidity` and `_decreaseLiquidity` to ensure proper handling of liquidity adjustments and state updates.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all interactions with external contracts (e.g., `lpToken`, `liquidityPool`, `tokenManager`) to ensure they are secure and properly handled."",
        ""Verify that the contract correctly handles native ETH transfers and does not leave the contract vulnerable to attacks like reentrancy or front-running.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that all `onlyOwner` and `onlyLiquidityPool` modifiers are correctly applied to restrict access to sensitive functions."",
        ""Verify that the `tokenChecks` modifier is consistently used to validate token addresses and prevent unauthorized token interactions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in functions like `removeLiquidity` and `claimFee` which involve multiple state updates and external calls."",
        ""Review the use of mappings and state variables to ensure efficient storage and retrieval, minimizing gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Audit the liquidity pool interactions to ensure they are secure and not susceptible to manipulation or impermanent loss."",
        ""Verify that the contract correctly handles edge cases, such as when the total reserve or liquidity for a token becomes zero.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Ensure that the contract is protected against flash loan attacks, particularly in functions that calculate fees or adjust liquidity.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""If the contract relies on external price feeds or oracles, verify that they are secure and tamper-proof.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review any governance or voting mechanisms to ensure they are secure and not susceptible to manipulation.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Audit the fee distribution mechanism to ensure it is fair and secure, preventing potential exploits in reward distribution.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Verify that the tokenomics of the LP tokens and fee distribution are sustainable and not prone to inflationary or deflationary issues.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Implement or verify the presence of mechanisms to prevent front-running, especially in liquidity addition and removal functions.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms in place to prevent fund drainage or malicious exits, such as proper access controls and emergency stops.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the contract has a robust emergency stop mechanism (e.g., `Pausable`) to halt operations in case of a security breach or other critical issues.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity smart contract is a liquidity management system that allows users to add, remove, and manage liquidity in a decentralized manner. It integrates with various external contracts for token management, liquidity pool operations, and whitelist period management. The contract is upgradeable, uses OpenZeppelin libraries for security and access control, and includes mechanisms to handle both native (ETH) and ERC20 token liquidity."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityProviders"",
    ""Purpose"": ""To manage liquidity provisioning, including adding, removing, and claiming fees for liquidity providers (LPs) in a decentralized liquidity pool."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""ReentrancyGuardUpgradeable"", ""ERC2771ContextUpgradeable"", ""OwnableUpgradeable"", ""Pausable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/ILPToken.sol"",
        ""./interfaces/ITokenManager.sol"",
        ""./interfaces/IWhiteListPeriodManager.sol"",
        ""./interfaces/ILiquidityPool.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address"",
        ""Purpose"": ""Constant address representing native ETH.""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant used for scaling and precision in calculations.""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface for interacting with the LP token contract.""
      },
      {
        ""Name"": ""liquidityPool"",
        ""Type"": ""ILiquidityPool"",
        ""Purpose"": ""Interface for interacting with the liquidity pool contract.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface for managing supported tokens.""
      },
      {
        ""Name"": ""whiteListPeriodManager"",
        ""Type"": ""IWhiteListPeriodManager"",
        ""Purpose"": ""Interface for managing whitelist periods for liquidity operations.""
      },
      {
        ""Name"": ""totalReserve"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total reserve of each token in the liquidity pool.""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total liquidity provided for each token.""
      },
      {
        ""Name"": ""currentLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the current liquidity available for each token.""
      },
      {
        ""Name"": ""totalLPFees"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total fees accumulated for each token.""
      },
      {
        ""Name"": ""totalSharesMinted"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total shares minted for each token.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyValidLpToken"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the LP token exists and the transactor owns it."",
        ""Parameters"": [""uint256 _tokenId"", ""address _transactor""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLiquidityPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to the liquidity pool contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the token address is valid and supported."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with necessary addresses and settings."",
        ""Parameters"": [""address _trustedForwarder"", ""address _lpToken"", ""address _tokenManager"", ""address _pauser""],
        ""Returns"": []
      },
      {
        ""Name"": ""_isSupportedToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a token is supported by the token manager."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getTotalReserveByToken"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total reserve of a specific token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getSuppliedLiquidityByToken"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total liquidity supplied for a specific token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getTotalLPFeeByToken"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total LP fees accumulated for a specific token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the current liquidity available for a specific token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""setLpToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the LP token contract address."",
        ""Parameters"": [""address _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setLPToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to set the LP token contract address."",
        ""Parameters"": [""address _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increases the current liquidity for a specific token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Decreases the current liquidity for a specific token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_increaseCurrentLiquidity"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to increase the current liquidity for a specific token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_decreaseCurrentLiquidity"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to decrease the current liquidity for a specific token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the token manager contract address."",
        ""Parameters"": [""address _tokenManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setTokenManager"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to set the token manager contract address."",
        ""Parameters"": [""address _tokenManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setWhiteListPeriodManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the whitelist period manager contract address."",
        ""Parameters"": [""address _whiteListPeriodManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the liquidity pool contract address."",
        ""Parameters"": [""address _liquidityPool""],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokenPriceInLPShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the price of a token in LP shares."",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""sharesToTokenAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts LP shares to the corresponding token amount."",
        ""Parameters"": [""uint256 _shares"", ""address _tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getFeeAccumulatedOnNft"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the accumulated fee on a specific NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""addLPFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds LP fees to the total reserve and LP fees."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addLiquidity"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to add liquidity for a specific token."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addNativeLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds native ETH liquidity to the pool."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""addTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds ERC20 token liquidity to the pool."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_increaseLiquidity"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to increase liquidity for a specific NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases ERC20 token liquidity for a specific NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseNativeLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases native ETH liquidity for a specific NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes liquidity from a specific NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims accumulated fees for a specific NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burnSharesFromNft"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to burn shares from a specific NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _shares"", ""uint256 _tokenAmount"", ""address _tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromLiquidityPool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to transfer tokens from the liquidity pool."",
        ""Parameters"": [""address _tokenAddress"", ""address _receiver"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""getSuppliedLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total liquidity supplied for a specific NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides the _msgSender function to support meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides the _msgData function to support meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Handles incoming ETH payments."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ILPToken"",
    ""ILiquidityPool"",
    ""ITokenManager"",
    ""IWhiteListPeriodManager"",
    ""IERC20Upgradeable"",
    ""SafeERC20Upgradeable""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using Initializable."",
    ""Reentrancy protection using ReentrancyGuardUpgradeable."",
    ""Ownership management using OwnableUpgradeable."",
    ""Pausable functionality for emergency stops."",
    ""Meta-transaction support using ERC2771ContextUpgradeable."",
    ""LP token minting and metadata management."",
    ""Liquidity pool interactions for adding, removing, and transferring liquidity."",
    ""Whitelist period management for liquidity operations.""
  ],
  ""Questions"": [
    ""How is the whitelist period managed, and what are the specific rules for adding and removing liquidity during these periods?"",
    ""What is the exact mechanism for calculating LP fees, and how are they distributed among LPs?"",
    ""Are there any specific security considerations or potential vulnerabilities in the way the contract handles native ETH transfers?"",
    ""How does the contract handle edge cases, such as when the total reserve or liquidity for a token becomes zero?"",
    ""What are the gas implications of the various functions, especially those involving multiple external calls and state updates?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `removeLiquidity` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `removeLiquidity` function transfers tokens to the user before updating the internal state, making it vulnerable to reentrancy attacks. This could allow an attacker to recursively call the function and drain the contract's funds. Multiple reports highlight this issue with slight variations in description, but the core vulnerability remains the same."",
      ""Impact"": ""An attacker could exploit this vulnerability to drain the contract's liquidity, leading to significant financial loss."",
      ""Location"": ""Function `removeLiquidity` (Lines: 292, ~400, or general function reference)""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability in `claimFee` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimFee` function is also vulnerable to reentrancy attacks, similar to `removeLiquidity`. It transfers tokens to the user before updating the state, which could be exploited by an attacker to claim fees multiple times."",
      ""Impact"": ""An attacker could exploit this vulnerability to claim fees multiple times, leading to loss of funds."",
      ""Location"": ""Function `claimFee` (Lines: 333 or general function reference)""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Arithmetic Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (`_increaseLiquidity`, `_increaseCurrentLiquidity`, `_decreaseCurrentLiquidity`, `getFeeAccumulatedOnNft`) perform arithmetic operations without explicit checks for overflow/underflow. While Solidity 0.8.0 has built-in checks, explicit handling is recommended for critical financial operations."",
      ""Impact"": ""Incorrect calculations could lead to incorrect state updates, financial discrepancies, or potential loss of funds."",
      ""Location"": ""Functions: `_increaseLiquidity`, `_increaseCurrentLiquidity`, `_decreaseCurrentLiquidity`, `getFeeAccumulatedOnNft` (Lines: ~200, ~300, or general function references)""
    },
    {
      ""Issue"": ""Lack of Input Validation in Key Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions (`_addLiquidity`, `_increaseLiquidity`, `addTokenLiquidity`, `increaseTokenLiquidity`, `increaseNativeLiquidity`) lack proper input validation for parameters like `_amount`, `_nftId`, or `_token`. This could lead to unexpected behavior or vulnerabilities if invalid or malicious input is provided."",
      ""Impact"": ""Invalid input could lead to incorrect state updates, potential vulnerabilities, or unexpected behavior."",
      ""Location"": ""Functions: `_addLiquidity`, `_increaseLiquidity`, `addTokenLiquidity`, `increaseTokenLiquidity`, `increaseNativeLiquidity` (Lines: 178, ~250, ~350, or general function references)""
    },
    {
      ""Issue"": ""Incorrect Token Price Calculation in `getTokenPriceInLPShares`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTokenPriceInLPShares` function calculates token price by dividing `totalSharesMinted` by `totalReserve`, which may yield incorrect results if `totalReserve` is zero or the division results in a value less than `BASE_DIVISOR`. This could affect liquidity management and pricing."",
      ""Impact"": ""Incorrect token pricing could lead to unfair liquidity provisioning or withdrawal, or potential exploitation."",
      ""Location"": ""Function `getTokenPriceInLPShares` (Line: 150 or general function reference)""
    },
    {
      ""Issue"": ""Unrestricted Access to Critical Configuration Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `setLpToken`, `setTokenManager`, `setWhiteListPeriodManager`, and `setLiquidityPool` are only restricted to the owner but lack safeguards (e.g., timelock, multi-signature). If the owner is compromised, these could be set to malicious addresses, disrupting contract functionality."",
      ""Impact"": ""Potential unauthorized changes to critical contract parameters, leading to unexpected behavior or exploitation."",
      ""Location"": ""Functions: `setLpToken`, `setTokenManager`, `setWhiteListPeriodManager`, `setLiquidityPool` (Lines: 127, 135, 143, 147, ~150, or general function references)""
    },
    {
      ""Issue"": ""Lack of Event Emission in State-Changing Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several state-changing functions (`_setLPToken`, `_setTokenManager`, `_burnSharesFromNft`, `_increaseLiquidity`) do not emit events, reducing transparency and making it difficult to track or audit state changes."",
      ""Impact"": ""Reduced transparency and difficulty in auditing or monitoring contract state changes."",
      ""Location"": ""Functions: `_setLPToken`, `_setTokenManager`, `_burnSharesFromNft`, `_increaseLiquidity` (Lines: ~150, ~200, ~450, or general function references)""
    },
    {
      ""Issue"": ""Potential Front-Running in Liquidity Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `addTokenLiquidity` and `increaseTokenLiquidity` are susceptible to front-running attacks, as they lack mechanisms (e.g., commit-reveal schemes) to prevent manipulation of transaction order."",
      ""Impact"": ""Attackers could front-run transactions to manipulate token prices or liquidity metrics, leading to unfair advantages or loss of funds."",
      ""Location"": ""Functions: `addTokenLiquidity`, `increaseTokenLiquidity` (Lines: ~250, ~350, or general function references)""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 8
}",461.4707899093628,102422.0,24.0,"### **Comparison and Evaluation**

---

#### **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**

**Report Description**:  
The `removeLiquidity` function in `LiquidityProviders.sol` calculates the share price of the LP token based on the token price in LP shares. However, the share price can be manipulated, potentially preventing future liquidity providers from withdrawing their liquidity. This manipulation could occur due to incorrect calculations or external factors affecting the token price.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of LP share price manipulation or its impact on liquidity withdrawal. This is a critical vulnerability that is entirely missed in the response list.

---

#### **[M-01] Unsupported tokens cannot be withdrawn**

**Report Description**:  
If a supported token is removed via `TokenManager.removeSupportedToken`, users holding that token will be unable to withdraw their liquidity due to the `_isSupportedToken` check in the `removeLiquidity` function. This could lead to locked funds and user dissatisfaction.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unsupported tokens being locked in the contract. This is a significant oversight, as it directly impacts user funds and contract functionality.

---

#### **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**

**Report Description**:  
The `setLiquidityPool` function allows the owner to change the liquidity pool address. If users have already added liquidity to the old pool, changing the pool address will make it impossible for them to withdraw their funds, as the tokens remain in the old pool.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Access to Critical Configuration Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the unrestricted access to critical functions like `setLiquidityPool` but does not explicitly address the impact of changing the liquidity pool on user withdrawals. The core issue is partially covered but lacks critical details.

---

#### **[M-12] LiquidityProviders: Setting new LP token will break contract**

**Report Description**:  
The `setLpToken` function allows the owner to change the LP token contract. If users have already been minted LP tokens from the old contract, changing the LP token address will make it impossible for them to withdraw their liquidity, leading to a loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Access to Critical Configuration Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the unrestricted access to critical functions like `setLpToken` but does not explicitly address the impact of changing the LP token on user withdrawals. The core issue is partially covered but lacks critical details.

---

#### **[M-17] Wrong condition checking in price calculation**

**Report Description**:  
The `getTokenPriceInLPShares` function checks if `totalSharesMinted` is zero instead of `totalReserve`. This could lead to incorrect price calculations or division by zero errors, affecting liquidity management.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Token Price Calculation in `getTokenPriceInLPShares`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with incorrect token price calculations in `getTokenPriceInLPShares`. It correctly explains the risks associated with the wrong condition check, which aligns with the reported issue.

---

#### **[M-19] sharesToTokenAmount: Division by zero**

**Report Description**:  
The `sharesToTokenAmount` function does not check if `totalSharesMinted[_tokenAddress]` is zero, leading to potential division by zero errors. This could cause the function to revert, affecting other contract functionalities.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the division by zero issue in `sharesToTokenAmount`. This is a significant oversight, as it directly impacts contract functionality and user experience.

---

#### **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

**Report Description**:  
When the pool is in a deficit state (i.e., `currentLiquidity << providedLiquidity`), LP token holders cannot redeem their tokens. This is because LP shares are computed based on `providedLiquidity`, while the actual available balance is based on `currentLiquidity`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of liquidity providers being unable to withdraw funds when the pool is in a deficit state. This is a critical vulnerability that is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-17] Wrong condition checking in price calculation**

**Partially Correct Matches**:

- **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**
- **[M-12] LiquidityProviders: Setting new LP token will break contract**

**Missed Issues from Issue Report**:

- **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**
- **[M-01] Unsupported tokens cannot be withdrawn**
- **[M-19] sharesToTokenAmount: Division by zero**
- **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

---

### **Conclusion**

The response list partially addresses some issues but misses several critical vulnerabilities, particularly those related to LP share price manipulation, unsupported tokens, division by zero, and liquidity withdrawal in deficit states. These gaps highlight the need for a more comprehensive review of the contract's security and functionality.","```
1. Incorrect Token Price Calculation in `getTokenPriceInLPShares`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Token Price Calculation in `getTokenPriceInLPShares`"".
   - This issue appears at rank **5** in the ranked list of predictions.

2. **Calculate the precision at rank 5**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 5, \( P@5 = \frac{1}{5} = 0.2 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.2 \).

**Output**:
```
0.2
```"
LiquidityFarming.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691,373,"[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased
 In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.
However, at L244, the whole nftInfo is being deleted, so that nft.unpaidRewards will also get erased.
There is no way for the user to get back this unpaidRewards anymore
  [H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss

Submitted by WatchPug, also found by hyh
LiquidityFarming.sol#L265-L291
function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) 
  [M-04] Owners have absolute control over protocol

Submitted by throttle, also found by cccz, cmichel, danb, defsec, hickuphh3, IllIllI, pedroais, and Ruhum
LiquidityFarming.sol#L174-L192
Owners have full control over the protocol.

[M-06] DoS by gas limit

Submitted by danb, also found by benk10 and pedroais
LiquidityFarming.sol#L220 LiquidityFarming.sol#L233
In `deposit` function it is possible to push to nftIdsStaked of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.
 [M-10] Call to non-existing contracts returns success

Submitted by CertoraInc, also found by kenta and wuwe1
LiquidityFarming.sol#L140 LiquidityFarming.sol#L145 LiquidityFarming.sol#L187
Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed).
This makes a user be able to send his funds to non-existing addresses.
 [M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases

Submitted by WatchPug
In the current implementation of withdraw(), it calls _sendRewardsForNft() at L243 which calls updatePool() at L129 which calls getUpdatedAccTokenPerShare() at L319.
getUpdatedAccTokenPerShare() will loop over rewardRateLog to calculate an up to date value of accTokenPerShare.
LiquidityFarming.sol#L270-L285
",6,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    
    mapping(address => PoolInfo) public poolInfo;

    
    mapping(uint256 => NFTInfo) public nftInfo;

    
    

    
    mapping(address => address) public rewardTokens;

    
    mapping(address => uint256[]) public nftIdsStaked;

    
    mapping(address => uint256) public totalSharesStaked;

    
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    
    
    
    
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    
    
    
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    
    
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    
    
    
    
    
    
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    
    
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    
    
    
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    
    
    
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    
    
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        
        
        
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    
    
    
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    
    
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    
    
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3032,2,4,,,,941.4144568443298,217058.0,62.0,"### **Output**

---

**[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased**

**Report Description**:  
In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` is recorded, allowing the user to retrieve it later. However, at L244, the entire `nftInfo` is deleted, erasing `nft.unpaidRewards` permanently. This leaves users unable to recover their unpaid rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, leaving a critical vulnerability unacknowledged. The permanent loss of user funds due to improper deletion of data is a significant oversight.

---

**[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Report Description**:  
In `getUpdatedAccTokenPerShare()`, precision loss occurs when the total shares are too large, leading to users losing a significant portion or all of their rewards. This is due to insufficient handling of arithmetic operations in Solidity.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list fails to address this issue, leaving users vulnerable to losing rewards due to precision loss. This is a critical mathematical vulnerability that should be mitigated.

---

**[M-04] Owners have absolute control over protocol**

**Report Description**:  
Owners have full control over the protocol, as evidenced by functions in `LiquidityFarming.sol` (L174-L192). This centralization poses a risk of misuse or abuse of power, potentially compromising the protocol's integrity.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of excessive owner control, leaving the protocol vulnerable to centralization risks. This is a significant governance concern.

---

**[M-06] DoS by gas limit**

**Report Description**:  
In the `deposit` function, an attacker can deposit too many NFTs to another user's `nftIdsStaked`. When the user attempts to withdraw an NFT at the end of the list, the iteration over the list may exceed the gas limit, causing a denial of service (DoS).

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, leaving the protocol vulnerable to DoS attacks. This is a critical gas-related vulnerability.

---

**[M-10] Call to non-existing contracts returns success**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, `staticcall`) return success even if the called contract does not exist (e.g., not deployed or destructed). This allows users to send funds to non-existing addresses, leading to permanent loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, leaving the protocol vulnerable to fund loss due to improper handling of low-level calls. This is a significant security oversight.

---

**[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**

**Report Description**:  
In `withdraw()`, the function calls `_sendRewardsForNft()`, which calls `updatePool()`, which in turn calls `getUpdatedAccTokenPerShare()`. The latter loops over `rewardRateLog` to calculate an updated value of `accTokenPerShare`. Unbounded loops can lead to gas exhaustion, potentially freezing users' funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, leaving the protocol vulnerable to gas exhaustion and fund freezing. This is a critical gas-related vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased**  
- **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**  
- **[M-04] Owners have absolute control over protocol**  
- **[M-06] DoS by gas limit**  
- **[M-10] Call to non-existing contracts returns success**  
- **[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**  

---

**Conclusion**:  
The `response_list` does not address any of the issues in the `issue` report, leaving all vulnerabilities unacknowledged and unmitigated. This represents a significant gap in coverage, accuracy, and sufficiency of the responses. Immediate attention is required to address these critical security concerns.","```
None.
```",0.0
WhitelistPeriodManager.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}

",2422,291,"[M-05] Frontrunning of setPerTokenWalletCap edge case

The `setPerTokenWalletCap()` function in WhitelistPeriodManager.sol contains a comment stating:
Special care must be taken when calling this function
There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it should be >= max lp provided by an lp.
Checking this on chain will probably require implementing a bbst, which needs more bandwidth
Call the view function getMaxCommunityLpPositon() separately before changing this value

Even if the manual step of calling the getMaxCommunityLpPositon() function is properly performed, it is possible for a user to add liquidity to increase the maxLp value in between when the getMaxCommunityLpPositon() function is called and when the setPerTokenWalletCap() function is called. Because this process is manual, this doesn't need to be bot frontrunning in the same block as when the setPerTokenWalletCap() function is called, but can be cause by poor timing of an innocent unknowing user adding liquidity to the protocol. If this condition occurs, the liquidity provider will have provided more liquidity than the perTokenWalletCap limit, breaking the assumptions for this variable and leading to some denial of service conditions.
  [M-15] WhitelistPeriodManager: Improper state handling of exclusion removals

Submitted by hickuphh3, also found by throttle
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L115-L125
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is removed from the isExcludedAddress mapping. While this affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.
In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.
  [M-16] WhitelistPeriodManager: Improper state handling of exclusion additions

Submitted by hickuphh3
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L83-L99
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is added to the isExcludedAddress mapping. This affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, which implicitly assumes that whitelisted addresses will have 0 liquidity, for addresses with non-zero liquidity at the time of addition to the whitelist.
",3,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    
    
    mapping(address => bool) public isExcludedAddress;
    
    mapping(address => uint256) private totalLiquidity;
    
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    
    
    mapping(address => uint256) public perTokenTotalCap;
    
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        
        _beforeLiquidityRemoval(_from, _token, _amount);

        
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",1958,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks, especially in functions interacting with external contracts."",
        ""Verify that all arithmetic operations are safe from overflows and underflows, leveraging Solidity 0.8.0's built-in checks."",
        ""Ensure that external contract calls are properly handled and validated to prevent malicious interactions."",
        ""Review the use of `_msgSender()` and `_msgData()` to ensure they are correctly overriding and handling meta-transactions securely.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to relevant ERC standards, particularly for interactions with LP tokens and liquidity providers."",
        ""Ensure that the contract's upgradeable nature complies with best practices for upgradeable contracts.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the `_beforeLiquidityAddition` and `_beforeLiquidityRemoval` functions for logical errors, especially in handling excluded addresses and caps."",
        ""Review the `getMaxCommunityLpPositon` function for potential inefficiencies or errors in iterating through LP tokens."",
        ""Verify the correctness of the `ifEnabled` function and its usage in enforcing whitelist restrictions.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Validate the integrity and security of interactions with `ILiquidityProviders`, `ITokenManager`, and `ILPToken` contracts."",
        ""Ensure that the contract correctly handles dependencies on external contracts, especially in the `initialize` function.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only authorized entities (e.g., owner, liquidity pool, LP NFT) can call restricted functions."",
        ""Check that the `onlyOwner` modifier is consistently and correctly applied to functions that require administrative privileges."",
        ""Ensure that the `onlyLiquidityPool` and `onlyLpNft` modifiers are correctly implemented and enforced.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize any gas-intensive operations, particularly in loops and mappings."",
        ""Review the use of storage variables and consider optimizations to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract's mechanisms for managing liquidity caps and whitelist restrictions are robust and cannot be exploited."",
        ""Verify that the contract correctly handles liquidity transfers and prevents manipulation.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Assess whether the contract is vulnerable to flash loan attacks, particularly in functions that modify liquidity or caps.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that any dependencies on external price feeds or oracles are secure and tamper-proof.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the contract's governance mechanisms, particularly the role of the owner in setting caps and whitelist restrictions.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the contract's mechanisms for managing liquidity do not inadvertently create vulnerabilities in staking or reward distribution.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Verify that the contract's tokenomics, particularly around liquidity caps and whitelist restrictions, do not create inflationary risks.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Assess whether the contract is vulnerable to front-running, particularly in functions that modify liquidity or caps.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract's mechanisms for managing liquidity and caps cannot be exploited for malicious exits or fund drainage.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security (if applicable)"",
      ""Tasks"": [
        ""Verify that the contract's mechanisms for managing liquidity and caps are secure in a cross-chain context, if applicable.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract's pausable functionality is correctly implemented and can be used to halt operations in case of an emergency.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract is a WhitelistPeriodManager that manages liquidity restrictions, caps, and whitelist statuses for tokens and liquidity providers. It integrates with external contracts for liquidity management, token management, and LP tokens. The contract is upgradeable and uses OpenZeppelin's Initializable, OwnableUpgradeable, Pausable, and ERC2771ContextUpgradeable contracts."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""WhitelistPeriodManager"",
    ""Purpose"": ""Manages whitelist restrictions, liquidity caps, and exclusions for tokens and liquidity providers."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable"", ""Pausable"", ""ERC2771ContextUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""./interfaces/ITokenManager.sol"",
        ""./interfaces/ILPToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface for interacting with the liquidity providers contract.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface for interacting with the token manager contract.""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface for interacting with the LP token contract.""
      },
      {
        ""Name"": ""areWhiteListRestrictionsEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable or disable whitelist restrictions.""
      },
      {
        ""Name"": ""isExcludedAddress"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to track addresses excluded from restrictions.""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Mapping to track total liquidity per token.""
      },
      {
        ""Name"": ""totalLiquidityByLp"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Mapping to track liquidity per token by LP.""
      },
      {
        ""Name"": ""perTokenTotalCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Mapping to track total liquidity cap per token.""
      },
      {
        ""Name"": ""perTokenWalletCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Mapping to track liquidity cap per token per wallet.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with necessary addresses and settings."",
        ""Parameters"": [""address _trustedForwarder"", ""address _liquidityProviders"", ""address _tokenManager"", ""address _lpToken"", ""address _pauser""],
        ""Returns"": []
      },
      {
        ""Name"": ""_isSupportedToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a token is supported by the token manager."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_beforeLiquidityAddition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Validates and updates liquidity before adding it."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityAddition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""External function to validate and update liquidity before adding it."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeLiquidityRemoval"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates liquidity before removing it."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityRemoval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""External function to update liquidity before removing it."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityTransfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Handles liquidity transfer between LPs."",
        ""Parameters"": [""address _from"", ""address _to"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the token manager address."",
        ""Parameters"": [""address _tokenManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the liquidity providers address."",
        ""Parameters"": [""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLpToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the LP token address."",
        ""Parameters"": [""address _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""setIsExcludedAddressStatus"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the exclusion status for multiple addresses."",
        ""Parameters"": [""address[] memory _addresses"", ""bool[] memory _status""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTotalCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the total liquidity cap for a token."",
        ""Parameters"": [""address _token"", ""uint256 _totalCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPerTokenWalletCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the per wallet liquidity cap for a token."",
        ""Parameters"": [""address _token"", ""uint256 _perTokenWalletCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets both total and per wallet liquidity caps for a token."",
        ""Parameters"": [""address _token"", ""uint256 _totalCap"", ""uint256 _perTokenWalletCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCaps"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets caps for multiple tokens."",
        ""Parameters"": [""address[] memory _tokens"", ""uint256[] memory _totalCaps"", ""uint256[] memory _perTokenWalletCaps""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAreWhiteListRestrictionsEnabled"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables or disables whitelist restrictions."",
        ""Parameters"": [""bool _status""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMaxCommunityLpPositon"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the maximum liquidity position for a token."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""ifEnabled"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Checks if a condition is enabled based on whitelist restrictions."",
        ""Parameters"": [""bool _cond""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides _msgSender to support ERC2771 context."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides _msgData to support ERC2771 context."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ILiquidityProviders"",
    ""ITokenManager"",
    ""ILPToken""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using Initializable and OwnableUpgradeable."",
    ""ERC2771ContextUpgradeable for meta-transactions."",
    ""Pausable functionality for emergency stops.""
  ],
  ""Questions"": [
    ""What is the purpose of the ifEnabled function and how is it used?"",
    ""How does the contract handle the initialization of state variables?"",
    ""Are there any potential risks with the external contract dependencies?"",
    ""How is the contract protected from reentrancy attacks?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (`beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`, `_beforeLiquidityRemoval`) do not apply the `nonReentrant` modifier despite inheriting from `ReentrancyGuardUpgradeable`. This could allow reentrancy attacks, especially where external calls or state changes are involved."",
      ""Impact"": ""An attacker could exploit this to re-enter the contract, manipulate state variables, or drain funds."",
      ""Location"": ""Functions `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`, `_beforeLiquidityRemoval`""
    },
    {
      ""Issue"": ""Uninitialized State Variables"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical state variables (`totalLiquidity`, `totalLiquidityByLp`, `perTokenTotalCap`, `perTokenWalletCap`) are not initialized in the `initialize` function, leading to undefined behavior if accessed before being set."",
      ""Impact"": ""Undefined behavior or incorrect state management could occur, potentially causing vulnerabilities or unexpected contract behavior."",
      ""Location"": ""State variables `totalLiquidity`, `totalLiquidityByLp`, `perTokenTotalCap`, `perTokenWalletCap`; Function `initialize`""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `initialize`, `setIsExcludedAddressStatus`, and `setCaps` do not validate input addresses or array lengths, potentially leading to invalid or malicious inputs being processed."",
      ""Impact"": ""Invalid inputs could render the contract unusable, corrupt state, or bypass intended restrictions."",
      ""Location"": ""Functions `initialize`, `setIsExcludedAddressStatus`, `setCaps`""
    },
    {
      ""Issue"": ""Unrestricted Access to Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Owner-only functions (`setTokenManager`, `setLiquidityProviders`, `setLpToken`, `setTotalCap`, `setPerTokenWalletCap`) lack additional safeguards (e.g., timelocks or multi-sig), creating a single point of failure if the owner is compromised."",
      ""Impact"": ""An attacker could take control of critical contract functions, manipulate caps, or disrupt liquidity management."",
      ""Location"": ""Functions `setTokenManager`, `setLiquidityProviders`, `setLpToken`, `setTotalCap`, `setPerTokenWalletCap`""
    },
    {
      ""Issue"": ""Inconsistent Use of Pausable"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from both `Pausable` and `PausableUpgradeable`, but the `whenNotPaused` modifier is inconsistently applied, potentially allowing functions to execute while paused."",
      ""Impact"": ""Critical functions might remain operational during pauses, leading to security risks or unexpected behavior."",
      ""Location"": ""Functions `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Low"",
      ""Description"": ""Arithmetic operations in `_beforeLiquidityAddition` and `_beforeLiquidityRemoval` lack explicit overflow/underflow checks, though Solidity 0.8.0 provides built-in protection."",
      ""Impact"": ""Unexpected reverts or incorrect calculations could occur, affecting user experience."",
      ""Location"": ""Functions `_beforeLiquidityAddition`, `_beforeLiquidityRemoval`""
    },
    {
      ""Issue"": ""Inconsistent Modifier Usage"",
      ""Severity"": ""Low"",
      ""Description"": ""The `tokenChecks` modifier is missing in functions like `beforeLiquidityAddition` and `beforeLiquidityRemoval`, while being used in others (`setTotalCap`, `setPerTokenWalletCap`), creating inconsistency in token validation."",
      ""Impact"": ""Unsupported tokens might bypass checks, leading to errors or vulnerabilities."",
      ""Location"": ""Functions `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `setTotalCap`, `setPerTokenWalletCap`""
    },
    {
      ""Issue"": ""Missing Event Emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state-changing functions (`_setTokenManager`, `_setLiquidityProviders`, `_setLpToken`, `setAreWhiteListRestrictionsEnabled`) do not emit events, reducing transparency."",
      ""Impact"": ""Off-chain tracking of state changes becomes difficult, hindering auditing and monitoring."",
      ""Location"": ""Functions `_setTokenManager`, `_setLiquidityProviders`, `_setLpToken`, `setAreWhiteListRestrictionsEnabled`""
    },
    {
      ""Issue"": ""Unbounded Loops"",
      ""Severity"": ""Medium"",
      ""Description"": ""`getMaxCommunityLpPositon` iterates over all LP tokens, which could exceed gas limits for large supplies."",
      ""Impact"": ""Functionality may become unusable or expensive due to gas exhaustion."",
      ""Location"": ""Function `getMaxCommunityLpPositon`""
    },
    {
      ""Issue"": ""Incorrect Cap Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""`setTotalCap` does not ensure the new cap exceeds current liquidity, potentially locking funds or breaking logic."",
      ""Impact"": ""Invalid cap settings could disrupt liquidity management or cause denial of service."",
      ""Location"": ""Function `setTotalCap`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 10
}",427.0546939373016,63337.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Report Description**:  
The `setPerTokenWalletCap()` function in `WhitelistPeriodManager.sol` lacks on-chain validation for the `_perTokenWalletCap` value, which should be greater than or equal to the maximum liquidity provided by any liquidity provider (LP). Although the manual step of calling `getMaxCommunityLpPositon()` is recommended, a user could add liquidity between the time this function is called and when `setPerTokenWalletCap()` is executed. This could lead to a situation where the `perTokenWalletCap` limit is exceeded, causing denial of service conditions and breaking the assumptions for this variable.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of frontrunning or the edge case related to `setPerTokenWalletCap`. The issue involves a timing vulnerability and improper validation of `_perTokenWalletCap`, which is not covered in the response list.

---

#### **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**

**Report Description**:  
When an address is removed from the `isExcludedAddress` mapping, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function. The worst impact is that users may be unable to withdraw their staked LP tokens from the liquidity farming contract due to subtraction overflow, especially if the address becomes non-excluded.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improper state handling when removing addresses from the `isExcludedAddress` mapping. The issue involves incorrect updates to `totalLiquidity` and `totalLiquidityByLp`, which is not covered in the response list.

---

#### **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

**Report Description**:  
When an address is added to the `isExcludedAddress` mapping, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function, which assumes that whitelisted addresses will have zero liquidity. If an address has non-zero liquidity at the time of addition, this assumption is violated, leading to incorrect state management.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improper state handling when adding addresses to the `isExcludedAddress` mapping. The issue involves incorrect updates to `totalLiquidity` and `totalLiquidityByLp`, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-05] Frontrunning of setPerTokenWalletCap edge case**  
- **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**  
- **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

---

### **Conclusion**  
The response list does not adequately address the issues reported in the `issue` list. Specifically, the issues related to frontrunning, improper state handling of exclusion additions and removals, and the edge case in `setPerTokenWalletCap` are entirely missed. The response list focuses on other vulnerabilities (e.g., reentrancy, uninitialized state variables, and input validation) but fails to cover the critical issues identified in the `issue` report. This indicates a significant gap in the coverage and accuracy of the responses.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is calculated as 0."
TokenManager.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169,146,"[M-09] Improper Upper Bound Definition on the Fee
 function changeFee()
Submitted by defsec, also found by catchup, danb, Dravee, gzeon, hickuphh3, hubble, peritoflores, Ruhum, and throttle
The equilibriumFee and maxFee does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.
Proof of Concept

Navigate to the following contract.
TokenManager.sol#L52
Owner can identify fee amount. That directly affect to LP management. LiquidityPool.sol#L352
Here you can see there is no upper bound has been defined.
",1,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1066,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions that modify state variables."",
        ""Verify that all arithmetic operations are protected against overflows and underflows."",
        ""Ensure that external calls (if any) are properly checked and handled to prevent unexpected behavior."",
        ""Review the use of `require` statements to ensure proper validation of inputs and state conditions.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Ensure that the contract adheres to the ERC-20/721 standards if it interacts with such tokens."",
        ""Verify that the contract complies with any other relevant standards or protocols.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `setDepositConfig` to ensure that array lengths are correctly validated and processed."",
        ""Verify the logic in `addSupportedToken` and `updateTokenCap` to ensure that token configurations are correctly set and updated.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Check the integration with ERC2771Context to ensure that meta-transactions are correctly handled."",
        ""Verify that interactions with external contracts (if any) are secure and properly validated.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that all functions with `onlyOwner` modifier are correctly restricted to the contract owner."",
        ""Verify that the `tokenChecks` modifier is correctly applied to functions that require token validation.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize any functions that may have high gas costs, especially those involving loops or complex mappings."",
        ""Consider using more efficient data structures or algorithms where possible to reduce gas consumption.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Review the contract for potential front-running vulnerabilities, especially in functions that modify state variables."",
        ""Consider implementing commit-reveal schemes or other mechanisms to mitigate front-running risks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the `Pausable` functionality is correctly implemented and can be used to pause critical functions in case of an emergency."",
        ""Verify that the contract has a clear and effective emergency stop mechanism.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Review the `setDepositConfig` function to ensure that cross-chain configurations are securely managed."",
        ""Verify that the contract handles cross-chain interactions (if any) securely and correctly.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that any external data sources (if used) are securely integrated and tamper-proof."",
        ""Verify that the contract does not rely on potentially manipulable external data.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided smart contract is a TokenManager that manages token configurations, fees, and supported tokens. It inherits from multiple contracts and interfaces to provide functionalities like ownership, pausing, and meta-transactions. The contract allows the owner to add, remove, and update token configurations, set fees, and manage deposit and transfer configurations."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""TokenManager"",
    ""Purpose"": ""To manage token configurations, fees, and supported tokens, allowing the owner to control various aspects of token management."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ITokenManager"", ""ERC2771Context"", ""Ownable"", ""Pausable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/security/Pausable.sol"",
        ""../metatx/ERC2771Context.sol"",
        ""../interfaces/ITokenManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""tokensInfo"",
        ""Type"": ""mapping(address => TokenInfo)"",
        ""Purpose"": ""Stores information about supported tokens, including fees and transfer overhead.""
      },
      {
        ""Name"": ""depositConfig"",
        ""Type"": ""mapping(uint256 => mapping(address => TokenConfig))"",
        ""Purpose"": ""Stores configuration for deposits, including minimum and maximum limits.""
      },
      {
        ""Name"": ""transferConfig"",
        ""Type"": ""mapping(address => TokenConfig)"",
        ""Purpose"": ""Stores configuration for token transfers, including minimum and maximum limits.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the token address is valid and the token is supported."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""getEquilibriumFee"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the equilibrium fee for a given token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getMaxFee"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the maximum fee for a given token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""changeFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to change the equilibrium and maximum fees for a token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 _equilibriumFee"", ""uint256 _maxFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenTransferOverhead"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the gas overhead for a token transfer."",
        ""Parameters"": [""address tokenAddress"", ""uint256 gasOverhead""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDepositConfig"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set deposit configurations for multiple tokens and chain IDs."",
        ""Parameters"": [""uint256[] memory toChainId"", ""address[] memory tokenAddresses"", ""TokenConfig[] memory tokenConfig""],
        ""Returns"": []
      },
      {
        ""Name"": ""addSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to add a new supported token with specified configurations."",
        ""Parameters"": [""address tokenAddress"", ""uint256 minCapLimit"", ""uint256 maxCapLimit"", ""uint256 equilibriumFee"", ""uint256 maxFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to remove a supported token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTokenCap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the minimum and maximum cap limits for a token."",
        ""Parameters"": [""address tokenAddress"", ""uint256 minCapLimit"", ""uint256 maxCapLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokensInfo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the information for a given token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""TokenInfo memory""]
      },
      {
        ""Name"": ""getDepositConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the deposit configuration for a given token and chain ID."",
        ""Parameters"": [""uint256 toChainId"", ""address tokenAddress""],
        ""Returns"": [""TokenConfig memory""]
      },
      {
        ""Name"": ""getTransferConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the transfer configuration for a given token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""TokenConfig memory""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides the _msgSender function to support meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Overrides the _msgData function to support meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The contract interacts with the ERC2771Context for meta-transactions and relies on OpenZeppelin's Ownable and Pausable contracts for ownership and pausing functionalities.""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses meta-transactions via ERC2771Context, allowing transactions to be relayed by a third party. It also implements the Pausable pattern to allow the owner to pause certain functionalities.""
  ],
  ""Questions"": [
    ""What is the exact structure of the TokenInfo and TokenConfig types?"",
    ""How are the min and max cap limits used in the context of token transfers and deposits?"",
    ""Are there any specific security considerations for the meta-transaction implementation?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Uninitialized Storage Variables"",
      ""Severity"": ""Medium"",
      ""Description"": ""The mappings `tokensInfo`, `depositConfig`, and `transferConfig` are not properly initialized, leading to potential undefined behavior when accessing uninitialized entries. This affects functions like `addSupportedToken`, `getEquilibriumFee`, and `getMaxFee`."",
      ""Impact"": ""Incorrect token configurations or fee calculations, potentially leading to financial losses or operational issues."",
      ""Location"": ""Throughout the contract, especially in functions like `addSupportedToken`, `getEquilibriumFee`, `getMaxFee`, and `getTokensInfo`.""
    },
    {
      ""Issue"": ""Lack of Input Validation in `setDepositConfig`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setDepositConfig` function does not validate input arrays (`toChainId`, `tokenAddresses`, `tokenConfig`) beyond length checks, potentially allowing invalid or malicious configurations."",
      ""Impact"": ""Incorrect deposit configurations, leading to failed transactions or financial losses."",
      ""Location"": ""Function `setDepositConfig`.""
    },
    {
      ""Issue"": ""Potential Reentrancy in `changeFee`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `changeFee` function updates state variables and emits events without reentrancy guards. While no direct external calls exist, future modifications could introduce vulnerabilities."",
      ""Impact"": ""Potential reentrancy attacks if combined with other vulnerable functions."",
      ""Location"": ""Function `changeFee`.""
    },
    {
      ""Issue"": ""Inconsistent State Update in `addSupportedToken`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addSupportedToken` function updates both `transferConfig` and `tokensInfo` mappings but does not ensure consistency between them, potentially leading to discrepancies."",
      ""Impact"": ""Inconsistent token configurations, affecting fee calculations and token management."",
      ""Location"": ""Function `addSupportedToken`.""
    },
    {
      ""Issue"": ""Missing Event Emission in `removeSupportedToken`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `removeSupportedToken` function does not emit events when tokens are removed, reducing transparency and auditability."",
      ""Impact"": ""Difficulty in tracking token support changes off-chain."",
      ""Location"": ""Function `removeSupportedToken`.""
    },
    {
      ""Issue"": ""Incorrect Modifier Usage in `removeSupportedToken`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `removeSupportedToken` function uses the `tokenChecks` modifier redundantly, as it is meant to remove tokens, not check their support status."",
      ""Impact"": ""Unnecessary gas consumption and potential confusion in code logic."",
      ""Location"": ""Function `removeSupportedToken`.""
    },
    {
      ""Issue"": ""Missing Zero Address Check in `updateTokenCap`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateTokenCap` function does not validate if `tokenAddress` is a zero address, which could lead to unintended updates."",
      ""Impact"": ""Potential for accidental updates to a zero address, leading to undefined behavior."",
      ""Location"": ""Function `updateTokenCap`.""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Low"",
      ""Description"": ""Arithmetic operations in functions like `updateTokenCap` lack explicit overflow/underflow checks, though Solidity 0.8.0 mitigates this."",
      ""Impact"": ""Compiler will revert, but explicit handling would improve robustness."",
      ""Location"": ""Multiple functions involving arithmetic operations.""
    },
    {
      ""Issue"": ""Inheritance Conflict in `_msgSender` and `_msgData`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `_msgSender` and `_msgData` override both `Context` and `ERC2771Context`, potentially causing confusion if inheritance changes."",
      ""Impact"": ""Potential errors in function resolution if inheritance hierarchy is modified."",
      ""Location"": ""Functions `_msgSender` and `_msgData`.""
    },
    {
      ""Issue"": ""Unused `Pausable` Functionality"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract inherits from `Pausable` but does not utilize its functions, indicating incomplete implementation or oversight."",
      ""Impact"": ""Missed opportunities to enhance security via pausing mechanisms."",
      ""Location"": ""Contract inheritance and unused `Pausable` functions.""
    }
  ],
  ""IssueNumber"": 54,
  ""OutputList"": 10
}",418.3107998371124,48487.0,28.0,"---

**[M-09] Improper Upper Bound Definition on the Fee**

**Report Description**:
The `changeFee()` function in the contract does not define any upper or lower bounds for the `equilibriumFee` and `maxFee` variables. This lack of bounds can lead to reversions in critical functions or result in liquidity providers (LPs) losing all their funds when paying the fee. The issue is particularly critical because the owner can set the fee amount, directly affecting LP management. The absence of an upper bound is highlighted in `TokenManager.sol#L52` and `LiquidityPool.sol#L352`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper upper bound definition on the fee. While there are responses related to input validation and state updates, none of them specifically mention the lack of bounds on fee variables or the associated risks of reversions or fund loss. This is a significant oversight, as the issue directly impacts the financial security of LPs and the contract's functionality.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-09] Improper Upper Bound Definition on the Fee**

---","```
None.
```",0.0
