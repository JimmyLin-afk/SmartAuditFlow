nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Lock.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}

",1088,145,"[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
There are two functions that allow to lock some amount of assets. The first function is Lock.lock which creates a new bond. The second function is the function `extendLock`. This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.
The issue is that the `extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `release` is called.
Therefore only the amount of assets deposited via `lock` can be released again. The amount of assets deposited using `extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.
  [M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract
When calling the function `claimGovFees()`, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in the function `bondNFT.distribute`.
  [M-02] Must approve 0 first
Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved in function `claimGovFees()`.  Recommend: Add an approve(0) before approving  ",3,,"pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",790,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions that interact with external contracts, such as 'claim', 'claimDebt', 'lock', 'extendLock', and 'release'."",
        ""Verify that all external calls (e.g., IERC20.transfer, IERC20.transferFrom, bondNFT.claim, govNFT.claim) are handled safely and do not introduce vulnerabilities."",
        ""Ensure that the contract is protected against integer overflows and underflows, especially in calculations involving 'totalLocked' and 'bondNFT' interactions."",
        ""Review the 'sendNFTs' function for potential risks associated with transferring multiple NFTs, ensuring that it does not allow unauthorized transfers.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to the ERC-20 standard in all interactions with ERC-20 tokens."",
        ""Ensure that the contract complies with the ERC-721 standard in interactions with the BondNFT and GovNFT contracts.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in the 'claimGovFees' function to ensure that fee calculation and distribution are accurate and secure."",
        ""Examine the 'extendLock' function to verify that it correctly handles the extension of the lock period and updates the state appropriately.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze all interactions with external contracts (BondNFT, GovNFT, IERC20) to ensure they are secure and do not introduce risks."",
        ""Verify that the contract handles errors from external calls gracefully and does not leave the contract in an inconsistent state.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only the owner can call the 'editAsset' and 'sendNFTs' functions, as they modify critical state variables."",
        ""Verify that the 'claimGovFees' function can be called by anyone but does not introduce any security risks.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify any gas inefficiencies in the contract, particularly in loops (e.g., in 'claimGovFees') and optimize where possible."",
        ""Review the use of mappings and state variables to ensure they are used efficiently to minimize gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract does not interact with liquidity pools or AMMs in a way that could be exploited for manipulation or impermanent loss.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Verify that the contract is protected against flash loan attacks, especially in functions that involve asset transfers or state changes.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the governance mechanisms in the contract, particularly the 'claimGovFees' function, to ensure they are secure and not susceptible to manipulation.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the locking and releasing mechanisms in the contract are secure and do not allow for unauthorized access or manipulation of rewards.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the tokenomics of the contract to ensure that there are no inflationary risks or other token-related vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Ensure that the contract is protected against front-running attacks, particularly in functions that involve asset transfers or state changes.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Verify that the contract does not have any mechanisms that could be used to drain funds or perform a malicious exit.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms in place to handle emergencies, such as pausing or stopping critical functions if necessary.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity smart contract is named 'Lock' and is designed to manage the locking and releasing of assets, as well as claiming fees. It interacts with two external NFT contracts (BondNFT and GovNFT) and uses ERC20 tokens for asset management. The contract includes functionalities for locking assets, extending locks, releasing locks, and claiming fees. It also allows the owner to manage allowed assets and transfer NFTs."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Lock"",
    ""Purpose"": ""To manage the locking and releasing of assets, claim fees, and interact with BondNFT and GovNFT contracts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""hardhat/console.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/IBondNFT.sol"",
        ""./interfaces/IGovNFT.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""minPeriod"",
        ""Type"": ""uint"",
        ""Purpose"": ""Minimum lock period in days.""
      },
      {
        ""Name"": ""maxPeriod"",
        ""Type"": ""uint"",
        ""Purpose"": ""Maximum lock period in days.""
      },
      {
        ""Name"": ""bondNFT"",
        ""Type"": ""IBondNFT"",
        ""Purpose"": ""Interface for the BondNFT contract.""
      },
      {
        ""Name"": ""govNFT"",
        ""Type"": ""IGovNFT"",
        ""Purpose"": ""Interface for the GovNFT contract.""
      },
      {
        ""Name"": ""allowedAssets"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to track allowed assets for locking.""
      },
      {
        ""Name"": ""totalLocked"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Mapping to track total locked amount per asset.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims the locked asset and transfers it to the caller."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims debt for a specific asset and transfers it to the caller."",
        ""Parameters"": [""address _tigAsset""],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Locks a specified amount of an asset for a specified period."",
        ""Parameters"": [""address _asset"", ""uint _amount"", ""uint _period""],
        ""Returns"": []
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Extends the lock period for a specified lock ID."",
        ""Parameters"": [""uint _id"", ""uint _amount"", ""uint _period""],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Releases the locked asset and transfers it to the owner."",
        ""Parameters"": [""uint _id""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimGovFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims governance fees for all assets and distributes them."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""editAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to edit the list of allowed assets."",
        ""Parameters"": [""address _tigAsset"", ""bool _isAllowed""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendNFTs"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to transfer multiple NFTs to a specified address."",
        ""Parameters"": [""uint[] memory _ids""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IBondNFT (BondNFT contract)"",
    ""IGovNFT (GovNFT contract)"",
    ""IERC20 (ERC20 token standard)""
  ],
  ""SpecialMechanisms"": [
    ""Ownable pattern for access control."",
    ""Interaction with external NFT contracts for locking and claiming mechanisms."",
    ""Mapping to track allowed assets and total locked amounts.""
  ],
  ""Questions"": [
    ""What is the purpose of the 'claimGovFees' function and how are the fees calculated?"",
    ""How does the 'extendLock' function handle the extension of the lock period?"",
    ""Are there any potential security risks with the 'sendNFTs' function transferring multiple NFTs?"",
    ""How is the 'totalLocked' mapping updated and what is its significance in the contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `claim`, `claimDebt`, and `release` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `claim`, `claimDebt`, and `release` functions transfer tokens to the user before updating the state. This can lead to reentrancy attacks where an attacker recursively calls these functions before the state is updated, potentially draining the contract's funds."",
      ""Impact"": ""An attacker could exploit this vulnerability to drain funds from the contract."",
      ""Location"": ""Functions: `claim`, `claimDebt`, `release`""
    },
    {
      ""Issue"": ""Unrestricted Approval in `claimGovFees` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimGovFees` function grants unlimited approval to the `bondNFT` contract for all assets. This could allow the `bondNFT` contract to transfer any amount of tokens from the `Lock` contract if compromised."",
      ""Impact"": ""If the `bondNFT` contract is malicious or compromised, it could drain all tokens from the `Lock` contract."",
      ""Location"": ""Function: `claimGovFees`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `lock` and `extendLock` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `lock` and `extendLock` functions do not validate the `_amount` parameter, which could lead to issues such as locking zero tokens or more tokens than the user has."",
      ""Impact"": ""Potential loss of funds or unexpected behavior due to invalid inputs."",
      ""Location"": ""Functions: `lock`, `extendLock`""
    },
    {
      ""Issue"": ""Potential Front-Running in `extendLock` and `editAsset` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `extendLock` function calls the `claim` function before extending the lock, and the `editAsset` function allows the owner to modify the list of allowed assets. Both could be front-run by an attacker to manipulate the state before the intended action is completed."",
      ""Impact"": ""Potential loss of funds or manipulation of allowed assets."",
      ""Location"": ""Functions: `extendLock`, `editAsset`""
    },
    {
      ""Issue"": ""Unrestricted Access to `sendNFTs` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `sendNFTs` function allows the owner to transfer multiple NFTs to any address without restrictions, which could lead to unintended transfers or loss of NFTs if the owner's account is compromised."",
      ""Impact"": ""Potential loss of NFTs due to unintended transfers."",
      ""Location"": ""Function: `sendNFTs`""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not emit events for critical state changes such as locking, releasing, or extending locks, reducing transparency and auditability."",
      ""Impact"": ""Reduced transparency and difficulty in tracking state changes off-chain."",
      ""Location"": ""Multiple functions (e.g., `lock`, `release`, `extendLock`)""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses arithmetic operations without explicit checks for overflow or underflow, which could lead to incorrect calculations or unexpected behavior."",
      ""Impact"": ""Incorrect accounting or potential financial loss due to arithmetic errors."",
      ""Location"": ""Functions: `lock`, `release`""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 7
}",371.4481389522553,35092.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Report Description**:  
The `extendLock` function in `Lock.sol` allows users to extend the lock period or increase the locked amount. However, it fails to update the `totalLocked[_asset]` state variable. This omission means that assets deposited via `extendLock` cannot be released later, as `totalLocked[_asset]` will underflow when `release` is called. This results in permanent loss of funds for users who deposit assets via `extendLock`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. While it mentions a lack of input validation in `lock` and `extendLock` functions, it does not identify the critical failure to update `totalLocked[_asset]`, which is the core vulnerability here.

---

#### **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Report Description**:  
The `claimGovFees` function silently fails when assets are not allowed or have no shares in the `BondNFT` contract. This can cause assets to be stuck in the `Lock` contract, as the `bondNFT.distribute` function does not handle these cases properly.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Approval in `claimGovFees` Function""**.

**Validation**:  
**Partially Correct**. The response identifies a related issue in the `claimGovFees` function but focuses on unrestricted approval rather than the silent failure and asset-sticking problem described in the issue report. The core issue of assets being stuck is not addressed.

---

#### **[M-02] Must approve 0 first**

**Report Description**:  
Some tokens (e.g., USDT) require setting the allowance to zero before approving a new value. The `claimGovFees` function does not implement this, which could cause the function to fail for certain tokens.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. While it mentions unrestricted approval in `claimGovFees`, it does not identify the need to approve zero first for certain tokens, which is a specific and critical vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Missed Issues from Issue Report**:  
- **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**  
- **[M-02] Must approve 0 first**

---

### **Conclusion**  
The response list partially addresses one issue ([M-01]) but misses or misidentifies the other two issues ([H-01] and [M-02]). The lack of coverage for critical vulnerabilities like the failure to update `totalLocked[_asset]` and the need to approve zero first for certain tokens highlights significant gaps in the response list. Improvements are needed to ensure comprehensive coverage of all identified issues.","```
None.
```",0.0
BondNFT.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}
",3270,384,"[H-05] Malicious user can steal all assets in BondNFT
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
When calling `claim()` for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.
  [M-06] BondNFTs can revert when transferred
In the function `_transfer`, `BondNFTs` should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against.
  [M-14] BondNFT.sol#claim() needs to correct all the missing epochs
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.
 
[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch
Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function Lock.lock() first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.
  [M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT
After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.   [M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called
Calling the following `Trading._handleOpenFees` function does not approve the GovNFT contract for spending any of the Trading contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. ",6,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; 
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; 

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             
                address(0),     
                _asset,         
                _amount,        
                epoch[_asset],  
                block.timestamp,
                expireEpoch,    
                0,              
                shares,         
                _period,        
                false           
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",2608,1,5,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy risks in functions that interact with external contracts (e.g., `claim`, `release`, `distribute`)."",
        ""Verify that all arithmetic operations are protected against overflow/underflow using SafeMath or Solidity 0.8.x built-in checks."",
        ""Ensure that external calls (e.g., `IERC20.transfer`, `IERC20.transferFrom`) are handled securely and do not expose the contract to reentrancy attacks."",
        ""Review the `onlyManager` modifier to ensure it is not bypassable and that the manager role is securely managed.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract fully complies with the ERC721 standard, including all required functions and events."",
        ""Ensure that the contract correctly implements the ERC721Enumerable extension for tracking token ownership."",
        ""Check that the contract adheres to the OpenZeppelin Ownable pattern for ownership management.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the reward distribution mechanism, particularly the `accRewardsPerShare` and `bondPaid` mappings, to ensure they correctly calculate and distribute rewards."",
        ""Review the bond creation, extension, and release logic to ensure it correctly updates state variables and handles edge cases."",
        ""Verify that the `idToBond` function correctly retrieves and updates bond information, including the `pending` rewards calculation.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Ensure that all external calls to ERC20 tokens (e.g., `IERC20.transfer`, `IERC20.transferFrom`) are properly validated and handle potential failures gracefully."",
        ""Verify that the contract does not rely on untrusted external data or contracts that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review the `onlyManager` modifier to ensure it is correctly applied and that only the manager can execute sensitive functions."",
        ""Verify that the `setManager` function is only callable by the owner and that the manager role cannot be maliciously transferred."",
        ""Ensure that the `addAsset` and `setAllowedAsset` functions are only callable by the owner and that they correctly update the allowed assets list.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize any gas-intensive operations, particularly in loops or complex calculations (e.g., `distribute`, `claim`, `release`)."",
        ""Review the use of mappings and state variables to ensure they are efficiently accessed and updated.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the bond creation and release logic does not expose the contract to liquidity pool manipulation or impermanent loss risks."",
        ""Verify that the reward distribution mechanism is not susceptible to manipulation by malicious actors.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Ensure that the contract is not vulnerable to flash loan attacks, particularly in functions that calculate or distribute rewards (e.g., `claim`, `distribute`).""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Verify that the contract does not rely on external oracles for critical data, and if it does, ensure that the oracles are secure and tamper-proof.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Ensure that the contract does not implement governance or voting mechanisms that could be exploited by malicious actors.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Audit the reward distribution logic to ensure it correctly calculates and distributes rewards based on bond shares and epochs."",
        ""Verify that the `claim` function correctly transfers rewards to the bond owner and updates the `bondPaid` mapping.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Ensure that the bond creation and reward distribution logic does not introduce inflationary token models or other tokenomics risks.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Ensure that the contract does not have vulnerabilities to front-running attacks, particularly in functions that create or release bonds (e.g., `createLock`, `release`).""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Verify that the contract does not have mechanisms that allow the owner or manager to drain funds or maliciously exit the system.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security (if applicable)"",
      ""Tasks"": [
        ""Ensure that the contract does not interact with cross-chain protocols in a way that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the contract has mechanisms in place to halt operations in case of an emergency, such as a pause function or similar.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract is an ERC721 token implementation with additional functionality for managing bonds. It allows users to create, extend, and release bonds, and includes mechanisms for distributing rewards and managing debts. The contract inherits from ERC721Enumerable and Ownable, and uses OpenZeppelin libraries for standard token and ownership functionality."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BondNFT"",
    ""Purpose"": ""To manage and track bonds represented as ERC721 tokens, allowing for creation, extension, and release of bonds, as well as distribution of rewards and management of debts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ERC721Enumerable"", ""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DAY"",
        ""Type"": ""uint"",
        ""Purpose"": ""Constant representing the number of seconds in a day.""
      },
      {
        ""Name"": ""Bond"",
        ""Type"": ""struct"",
        ""Purpose"": ""Structure to store bond details including ID, owner, asset, amount, mint and expiry details, and shares.""
      },
      {
        ""Name"": ""epoch"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the current epoch for each asset.""
      },
      {
        ""Name"": ""totalBonds"",
        ""Type"": ""uint"",
        ""Purpose"": ""Total number of bonds created.""
      },
      {
        ""Name"": ""baseURI"",
        ""Type"": ""string"",
        ""Purpose"": ""Base URI for token metadata.""
      },
      {
        ""Name"": ""manager"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the manager who can execute certain functions.""
      },
      {
        ""Name"": ""assets"",
        ""Type"": ""address[]"",
        ""Purpose"": ""List of allowed assets.""
      },
      {
        ""Name"": ""allowedAsset"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps assets to their allowed status.""
      },
      {
        ""Name"": ""assetsIndex"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Maps assets to their index in the assets array.""
      },
      {
        ""Name"": ""bondPaid"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the amount paid for each bond and asset.""
      },
      {
        ""Name"": ""accRewardsPerShare"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Accumulated rewards per share for each asset and epoch.""
      },
      {
        ""Name"": ""_idToBond"",
        ""Type"": ""mapping(uint => Bond)"",
        ""Purpose"": ""Maps bond IDs to their Bond struct.""
      },
      {
        ""Name"": ""totalShares"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Total shares for each asset.""
      },
      {
        ""Name"": ""userDebt"",
        ""Type"": ""mapping(address => mapping(address => uint))"",
        ""Purpose"": ""Tracks user debts for each asset.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""createLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new bond."",
        ""Parameters"": [""address _asset"", ""uint _amount"", ""uint _period"", ""address _owner""],
        ""Returns"": [""uint id""]
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Extends the lock period of an existing bond."",
        ""Parameters"": [""uint _id"", ""address _asset"", ""uint _amount"", ""uint _period"", ""address _sender""],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Releases a bond and transfers the locked amount to the owner."",
        ""Parameters"": [""uint _id"", ""address _releaser""],
        ""Returns"": [""uint amount"", ""uint lockAmount"", ""address asset"", ""address _owner""]
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims pending rewards for a bond."",
        ""Parameters"": [""uint _id"", ""address _claimer""],
        ""Returns"": [""uint amount"", ""address tigAsset""]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims user debt for a specific asset."",
        ""Parameters"": [""address _user"", ""address _tigAsset""],
        ""Returns"": [""uint amount""]
      },
      {
        ""Name"": ""distribute"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes rewards for a specific asset."",
        ""Parameters"": [""address _tigAsset"", ""uint _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""idToBond"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the Bond struct for a given bond ID."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""Bond memory bond""]
      },
      {
        ""Name"": ""isExpired"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a bond is expired."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""pending"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the pending rewards for a bond."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""totalAssets"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total number of allowed assets."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getAssets"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the list of allowed assets."",
        ""Parameters"": [],
        ""Returns"": [""address[] memory""]
      },
      {
        ""Name"": ""_baseURI"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the base URI for token metadata."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""safeTransferMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers multiple tokens to a specified address."",
        ""Parameters"": [""address _to"", ""uint[] calldata _ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""safeTransferFromMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers multiple tokens from one address to another."",
        ""Parameters"": [""address _from"", ""address _to"", ""uint[] calldata _ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveMany"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves multiple tokens for transfer."",
        ""Parameters"": [""address _to"", ""uint[] calldata _ids""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints a new bond token."",
        ""Parameters"": [""address to"", ""Bond memory bond""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burn"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Burns a bond token."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers a bond token from one address to another."",
        ""Parameters"": [""address from"", ""address to"", ""uint256 _id""],
        ""Returns"": []
      },
      {
        ""Name"": ""balanceIds"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the list of bond IDs owned by a user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint[] memory""]
      },
      {
        ""Name"": ""addAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new asset to the allowed assets list."",
        ""Parameters"": [""address _asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the allowed status of an asset."",
        ""Parameters"": [""address _asset"", ""bool _bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBaseURI"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the base URI for token metadata."",
        ""Parameters"": [""string calldata _newBaseURI""],
        ""Returns"": []
      },
      {
        ""Name"": ""setManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the manager address."",
        ""Parameters"": [""address _manager""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyManager"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the manager."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20.transfer"",
    ""IERC20.transferFrom""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses a reward distribution mechanism based on shares and epochs."",
    ""It implements a debt tracking system for users."",
    ""The contract uses a manager role to restrict access to certain functions.""
  ],
  ""Questions"": [
    ""How is the epoch calculated and managed for each asset?"",
    ""What is the purpose of the `bondPaid` mapping and how is it updated?"",
    ""How are rewards distributed and how is the `accRewardsPerShare` mapping used?"",
    ""What is the significance of the `userDebt` mapping and how is it managed?"",
    ""Are there any potential security risks with the `onlyManager` modifier and external interactions?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unrestricted Manager Privileges"",
      ""Severity"": ""High"",
      ""Description"": ""The `onlyManager` modifier allows the manager to execute critical functions without additional checks. This could lead to abuse if the manager account is compromised or acts maliciously. Functions include creating, extending, or releasing bonds, and claiming debts."",
      ""Impact"": ""Potential for unauthorized actions such as creating, extending, or releasing bonds, which could lead to financial loss or manipulation of the contract state."",
      ""Location"": ""Functions with `onlyManager` modifier: `createLock`, `extendLock`, `release`, `claim`, `claimDebt`, `setManager`.""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `claim`, `claimDebt`, and `release` transfer tokens before updating the state, making them vulnerable to reentrancy attacks if the manager is a malicious contract."",
      ""Impact"": ""Potential for reentrancy attacks leading to repeated token transfers or manipulation of the contract state."",
      ""Location"": ""Functions: `claim`, `claimDebt`, `release`.""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses `unchecked` blocks extensively, which can lead to integer overflow or underflow if not handled properly, particularly in functions like `createLock` and `extendLock`."",
      ""Impact"": ""Incorrect calculations could lead to improper distribution of rewards or locking of assets, potentially causing financial losses."",
      ""Location"": ""Functions: `createLock`, `extendLock`, `release`, `claim`, `distribute`, `_mint`, `_transfer`.""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `createLock`, `extendLock`, and `distribute` do not validate input parameters adequately, such as `_amount`, `_period`, or `_tigAsset`, leading to potential vulnerabilities."",
      ""Impact"": ""Invalid inputs could cause the contract to behave unexpectedly, potentially leading to loss of funds or other issues."",
      ""Location"": ""Functions: `createLock`, `extendLock`, `distribute`.""
    },
    {
      ""Issue"": ""Incorrect Epoch Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calculates epochs based on `block.timestamp / DAY`, which can lead to incorrect epoch calculations if the timestamp is manipulated or not aligned with the expected day boundary."",
      ""Impact"": ""Potential for incorrect bond transfers or state updates."",
      ""Location"": ""Functions: `createLock`, `extendLock`, `release`, `distribute`, `_transfer`.""
    },
    {
      ""Issue"": ""Unrestricted Asset Addition"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addAsset` function allows the owner to add assets without proper validation, which could lead to the addition of malicious or incompatible assets."",
      ""Impact"": ""Potential for adding malicious assets, leading to vulnerabilities or financial loss."",
      ""Location"": ""Function: `addAsset`.""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions such as `_mint`, `_burn`, and `addAsset` do not emit events, reducing transparency and auditability of the contract."",
      ""Impact"": ""Reduced transparency and auditability of the contract."",
      ""Location"": ""Functions: `_mint`, `_burn`, `addAsset`, `setBaseURI`.""
    },
    {
      ""Issue"": ""Potential Denial of Service"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `safeTransferMany` and `safeTransferFromMany` iterate over arrays, which could run out of gas if the arrays are too large, leading to denial of service."",
      ""Impact"": ""A large array of token IDs could cause the transaction to run out of gas, leading to a denial of service for legitimate users."",
      ""Location"": ""Functions: `safeTransferMany`, `safeTransferFromMany`.""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 8
}",460.77625703811646,78027.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-05] Malicious user can steal all assets in BondNFT**

**Report Description**:  
A malicious user can drain all assets in `BondNFT`, causing other users to lose their rewards. When calling `claim()` for an expired bond, `accRewardsPerShare` is recalculated. However, rewards after the `expireEpoch` do not belong to the expired bond and should be redistributed to all other bonds. This vulnerability allows a malicious user to exploit the redistribution logic and steal assets.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves improper reward redistribution logic, which is not covered in the response list.

---

#### **[M-06] BondNFTs can revert when transferred**

**Report Description**:  
The `_transfer` function in `BondNFTs` should allow transfers, as per the proposal and sponsor's intent. However, the function may revert, preventing bonds from being sold or borrowed against.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves transfer functionality reverting, which is not mentioned in the response list.

---

#### **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Report Description**:  
In `claim()`, `accRewardsPerShare[][]` is updated to reflect expired shares, but only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed, leading to incorrect reward calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves missing epoch updates in reward calculations, which is not covered in the response list.

---

#### **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**

**Report Description**:  
When `totalShares[tigAsset] == 0`, `distribute()` does not update `epoch[asset]`. This can cause later created bonds for this `tigAsset` to have an incorrect mint epoch, leading to improper bond creation and reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves incorrect epoch updates in `distribute()`, which is not covered in the response list.

---

#### **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**

**Report Description**:  
After a lock expires, it no longer receives rewards. However, unreleased locks cause `totalShares` to remain unchanged, leading to incorrect reward distribution. Bond owners receive fewer rewards than they should.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves flawed reward distribution due to unreleased locks, which is not covered in the response list.

---

#### **[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees is called, can lose deserved rewards**

**Report Description**:  
The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance, unlike `Trading._handleCloseFees`. This can cause governance NFT holders to lose deserved rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves missing approvals in `Trading._handleOpenFees`, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-05] Malicious user can steal all assets in BondNFT**  
- **[M-06] BondNFTs can revert when transferred**  
- **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**  
- **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0**  
- **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**  
- **[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees is called, can lose deserved rewards**

---

### **Conclusion**  
The response list does not adequately address the issues in the issue report. Most of the vulnerabilities, risks, and impacts described in the issue report are either partially covered or entirely missed. The response list focuses on general issues like reentrancy, integer overflow, and input validation but fails to address the specific vulnerabilities related to reward distribution, epoch calculations, and transfer functionality in `BondNFT`.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is calculated as 0."
Trading.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}

",9443,1055,"[H-02] Riskless trades due to delay check
`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
  [H-06] Incorrect calculation of new price while adding position
The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.
  [H-09] Users can bypass the `maxWinPercent` limit using a partially closing
Users can bypass the `maxWinPercent` limit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.
  [H-11] Not enough margin pulled or burned from user when adding to a position
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.
  [M-04] Approved operators of Position token can't call Trading.initiateCloseOrder
Approved operators of owner of Position token can't call several function in Trading.
Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function.
  [M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations
Formula for `fee paid` in the `_handleOpenFees`  is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.   [M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds
The function `initiateCloseOrder()`   [M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()
The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.
  [M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18
In Trading.sol a deposit or withdrawal of tokens with decimals higher than 18 will always revert.
  [M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred
When `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`.
",10,,"pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); 
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; 
    uint private constant liqPercent = 9e9; 

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; 

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; 
        bool actionType; 
    }
    mapping(uint => Delay) public blockDelayPassed; 
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; 

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    

    
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); 
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, 
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); 
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); 
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); 
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); 

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    

    
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); 
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) 
                / DIVISION_CONSTANT 
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); 
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); 
        }
    }

    
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); 
    }

    
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); 
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    

    
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",7509,4,6,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions handling deposits and withdrawals."",
        ""Verify that all external calls (e.g., to `tradingExtension`, `pairsContract`, `position`) are safe and handle potential failures."",
        ""Ensure that all arithmetic operations are protected against overflow and underflow."",
        ""Review the `_handleDeposit` and `_handleWithdraw` functions for potential vulnerabilities in token transfers and approvals."",
        ""Check the `_closePosition` function for proper handling of payouts and fee distributions to prevent fund drainage.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards in token interactions."",
        ""Ensure that the contract follows best practices for ERC-20 permit functionality.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the `_updateFunding` function to ensure correct calculation and updating of funding rates."",
        ""Examine the `_handleOpenFees` and `_handleCloseFees` functions for accurate fee distribution and calculations."",
        ""Verify the logic in `initiateMarketOrder` and `initiateLimitOrder` for correct order execution and validation."",
        ""Check the `_checkSl` function for proper stop-loss validation.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review all interactions with external contracts (`ITradingExtension`, `IPairsContract`, `IPosition`, `IGovNFT`, `IStableVault`) for potential risks."",
        ""Ensure that the `tradingExtension` contract is trusted and its functions are correctly implemented."",
        ""Verify that the `pairsContract` provides accurate and tamper-proof data for trading pairs.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only the owner can set critical parameters like `blockDelay`, `allowedVault`, `maxWinPercent`, and `limitOrderPriceRange`."",
        ""Verify that the `_validateProxy` function correctly validates proxy approvals."",
        ""Check that the `onlyOwner` modifier is correctly applied to all relevant functions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, especially in functions like `initiateMarketOrder`, `initiateCloseOrder`, and `_handleOpenFees`."",
        ""Review the use of `unchecked` blocks to ensure they are safe and do not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract handles liquidity pool interactions safely, especially in `_handleDeposit` and `_handleWithdraw`."",
        ""Verify that the contract is protected against impermanent loss and other AMM-related risks.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to flash loan attacks, especially in functions that calculate payouts and fees."",
        ""Implement safeguards to prevent flash loan-based manipulation.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that price data from `tradingExtension.getVerifiedPrice` is tamper-proof and reliable."",
        ""Verify that the contract handles oracle failures gracefully and does not rely on a single point of failure.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the role of the `gov` contract in fee distribution and ensure it is secure."",
        ""Verify that governance functions are protected against manipulation and abuse.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the fee distribution mechanism in `_handleOpenFees` and `_handleCloseFees` is secure and fair."",
        ""Verify that the contract handles staking and rewards safely, especially in interactions with the `gov` contract.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the tokenomics of the contract to ensure it does not have an inflationary token model."",
        ""Verify that the contract handles token burns and mints safely.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to front-running, especially in order execution and fee distribution."",
        ""Implement commit-reveal schemes or other mechanisms to prevent front-running.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not have any hidden mechanisms that could allow fund drainage."",
        ""Verify that all critical functions are transparent and do not allow malicious exits.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms to halt trading in case of emergencies."",
        ""Verify that the `paused` function in `tradingExtension` is correctly implemented and used.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity code snippet is a comprehensive trading contract that handles various trading operations such as market orders, limit orders, position management, and fee distribution. The contract interacts with multiple external contracts and interfaces to manage trading pairs, positions, and fees. It also includes mechanisms for handling deposits, withdrawals, and fee calculations."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Trading"",
    ""Purpose"": ""To facilitate trading operations including market orders, limit orders, position management, and fee distribution."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""MetaContext"", ""ITrading""],
      ""Imports"": [
        ""./utils/MetaContext.sol"",
        ""./interfaces/ITrading.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/IPairsContract.sol"",
        ""./interfaces/IReferrals.sol"",
        ""./interfaces/IPosition.sol"",
        ""./interfaces/IGovNFT.sol"",
        ""./interfaces/IStableVault.sol"",
        ""./utils/TradingLibrary.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DIVISION_CONSTANT"",
        ""Type"": ""uint"",
        ""Purpose"": ""Constant used for division calculations to avoid floating-point arithmetic.""
      },
      {
        ""Name"": ""liqPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Percentage threshold for liquidation.""
      },
      {
        ""Name"": ""openFees"",
        ""Type"": ""Fees"",
        ""Purpose"": ""Structure to store fees for opening positions.""
      },
      {
        ""Name"": ""closeFees"",
        ""Type"": ""Fees"",
        ""Purpose"": ""Structure to store fees for closing positions.""
      },
      {
        ""Name"": ""limitOrderPriceRange"",
        ""Type"": ""uint"",
        ""Purpose"": ""Price range for limit orders.""
      },
      {
        ""Name"": ""maxWinPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Maximum win percentage for payouts.""
      },
      {
        ""Name"": ""vaultFundingPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Percentage of funding allocated to the vault.""
      },
      {
        ""Name"": ""pairsContract"",
        ""Type"": ""IPairsContract"",
        ""Purpose"": ""Interface for interacting with the pairs contract.""
      },
      {
        ""Name"": ""position"",
        ""Type"": ""IPosition"",
        ""Purpose"": ""Interface for interacting with the position contract.""
      },
      {
        ""Name"": ""gov"",
        ""Type"": ""IGovNFT"",
        ""Purpose"": ""Interface for interacting with the governance NFT contract.""
      },
      {
        ""Name"": ""tradingExtension"",
        ""Type"": ""ITradingExtension"",
        ""Purpose"": ""Interface for interacting with the trading extension contract.""
      },
      {
        ""Name"": ""blockDelayPassed"",
        ""Type"": ""mapping(uint => Delay)"",
        ""Purpose"": ""Mapping to track block delays for actions.""
      },
      {
        ""Name"": ""blockDelay"",
        ""Type"": ""uint"",
        ""Purpose"": ""Block delay for actions.""
      },
      {
        ""Name"": ""limitDelay"",
        ""Type"": ""mapping(uint => uint)"",
        ""Purpose"": ""Mapping to track limit order delays.""
      },
      {
        ""Name"": ""allowedVault"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to track allowed vaults.""
      },
      {
        ""Name"": ""proxyApprovals"",
        ""Type"": ""mapping(address => Proxy)"",
        ""Purpose"": ""Mapping to track proxy approvals.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initiateMarketOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates a market order."",
        ""Parameters"": [""TradeInfo"", ""PriceData"", ""bytes"", ""ERC20PermitData"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateCloseOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates a close order."",
        ""Parameters"": [""uint"", ""uint"", ""PriceData"", ""bytes"", ""address"", ""address"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""addToPosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds margin to an existing position."",
        ""Parameters"": [""uint"", ""uint"", ""PriceData"", ""bytes"", ""address"", ""address"", ""ERC20PermitData"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates a limit order."",
        ""Parameters"": [""TradeInfo"", ""uint"", ""uint"", ""ERC20PermitData"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancels a limit order."",
        ""Parameters"": [""uint"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""addMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds margin to a position."",
        ""Parameters"": [""uint"", ""address"", ""address"", ""uint"", ""ERC20PermitData"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes margin from a position."",
        ""Parameters"": [""uint"", ""address"", ""address"", ""uint"", ""PriceData"", ""bytes"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTpSl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the take profit or stop loss of a position."",
        ""Parameters"": [""bool"", ""uint"", ""uint"", ""PriceData"", ""bytes"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Executes a limit order."",
        ""Parameters"": [""uint"", ""PriceData"", ""bytes""],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidatePosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates a position."",
        ""Parameters"": [""uint"", ""PriceData"", ""bytes""],
        ""Returns"": []
      },
      {
        ""Name"": ""limitClose"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes a limit order."",
        ""Parameters"": [""uint"", ""bool"", ""PriceData"", ""bytes""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveProxy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves a proxy for trading."",
        ""Parameters"": [""address"", ""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""_closePosition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to close a position."",
        ""Parameters"": [""uint"", ""uint"", ""uint"", ""address"", ""address"", ""bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle deposits."",
        ""Parameters"": [""address"", ""address"", ""uint"", ""address"", ""ERC20PermitData"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle withdrawals."",
        ""Parameters"": [""IPosition.Trade"", ""address"", ""address"", ""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleOpenFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle open fees."",
        ""Parameters"": [""uint"", ""uint"", ""address"", ""address"", ""bool""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_handleCloseFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle close fees."",
        ""Parameters"": [""uint"", ""uint"", ""address"", ""uint"", ""address"", ""bool""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_updateFunding"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to update funding."",
        ""Parameters"": [""uint"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkSl"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to check stop loss."",
        ""Parameters"": [""uint"", ""bool"", ""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkOwner"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to check ownership."",
        ""Parameters"": [""uint"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkDelay"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to check delay."",
        ""Parameters"": [""uint"", ""bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkVault"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to check vault."",
        ""Parameters"": [""address"", ""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""_validateProxy"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to validate proxy."",
        ""Parameters"": [""address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBlockDelay"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the block delay."",
        ""Parameters"": [""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets allowed vaults."",
        ""Parameters"": [""address"", ""bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxWinPercent"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the maximum win percentage."",
        ""Parameters"": [""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLimitOrderPriceRange"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the limit order price range."",
        ""Parameters"": [""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFees"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the fees for opening or closing positions."",
        ""Parameters"": [""bool"", ""uint"", ""uint"", ""uint"", ""uint"", ""uint""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTradingExtension"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the trading extension contract."",
        ""Parameters"": [""address""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ITradingExtension"",
    ""IPairsContract"",
    ""IPosition"",
    ""IGovNFT"",
    ""IStableVault"",
    ""IERC20"",
    ""ERC20Permit""
  ],
  ""SpecialMechanisms"": [
    ""Proxy pattern for approving trading proxies."",
    ""Fee distribution mechanism for DAO, burn, referral, and bot fees."",
    ""Block delay mechanism to prevent rapid actions."",
    ""Limit order execution with price range checks.""
  ],
  ""Questions"": [
    ""How is the `_checkGas` function in `ITradingExtension` implemented and what is its purpose?"",
    ""What is the exact role of the `gov` contract in fee distribution?"",
    ""How are the `openFees` and `closeFees` structures initialized and managed?"",
    ""What is the purpose of the `_updateFunding` function and how does it interact with the `pairsContract`?"",
    ""Are there any security considerations for the `_handleDeposit` and `_handleWithdraw` functions?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions interact with external contracts (e.g., `IStableVault`, `IStable`) before updating the state, making them vulnerable to reentrancy attacks. This includes functions like `_handleDeposit`, `_handleWithdraw`, and `_closePosition`."",
      ""Impact"": ""An attacker could re-enter the contract and manipulate its state, potentially leading to loss of funds."",
      ""Location"": ""Functions: `_handleDeposit`, `_handleWithdraw`, `_closePosition`""
    },
    {
      ""Issue"": ""Unchecked External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes external calls to other contracts (e.g., `IStableVault`, `IStable`, `ERC20Permit`) without checking return values or handling failures. This can lead to unexpected behavior if the external call fails or the called contract is malicious."",
      ""Impact"": ""Potential loss of funds or contract state corruption if the external call fails or behaves unexpectedly."",
      ""Location"": ""Functions: `_handleDeposit`, `_handleWithdraw`, `_handleOpenFees`, `_handleCloseFees`""
    },
    {
      ""Issue"": ""Unrestricted Proxy Approval"",
      ""Severity"": ""High"",
      ""Description"": ""The `approveProxy` function allows any address to be set as a proxy without validation or restrictions. This could lead to unauthorized access or manipulation of user funds."",
      ""Impact"": ""An attacker could set themselves as a proxy and perform unauthorized actions on behalf of the user."",
      ""Location"": ""Function: `approveProxy`""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (e.g., `initiateMarketOrder`, `initiateCloseOrder`, `addToPosition`) do not validate input parameters thoroughly, such as checking for zero addresses or ensuring values are within acceptable bounds."",
      ""Impact"": ""Potential exploitation or unexpected behavior due to invalid or malicious inputs."",
      ""Location"": ""Functions: `initiateMarketOrder`, `initiateCloseOrder`, `addToPosition`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations in functions like `_handleOpenFees`, `_handleCloseFees`, and `_closePosition` are performed without checks for overflow/underflow, despite Solidity 0.8.x's built-in checks."",
      ""Impact"": ""Incorrect calculations could lead to financial losses or incorrect state updates."",
      ""Location"": ""Functions: `_handleOpenFees`, `_handleCloseFees`, `_closePosition`""
    },
    {
      ""Issue"": ""Front-Running Risk"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `initiateMarketOrder`, `initiateCloseOrder`, and `executeLimitOrder` do not implement mechanisms to prevent front-running, such as commit-reveal schemes or gas price auctions."",
      ""Impact"": ""Potential loss of funds or unfair advantage to attackers who can front-run transactions."",
      ""Location"": ""Functions: `initiateMarketOrder`, `initiateCloseOrder`, `executeLimitOrder`""
    },
    {
      ""Issue"": ""Unrestricted Access to Critical Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical functions like `setBlockDelay`, `setAllowedVault`, and `setFees` are only protected by the `onlyOwner` modifier, making them vulnerable if the owner's private key is compromised."",
      ""Impact"": ""Potential loss of funds or contract state corruption if the owner's account is compromised."",
      ""Location"": ""Functions: `setBlockDelay`, `setAllowedVault`, `setFees`""
    },
    {
      ""Issue"": ""Insufficient Gas Limit Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `_handleOpenFees` and `_handleCloseFees` involve loops or complex computations without proper gas limit handling, risking out-of-gas errors."",
      ""Impact"": ""Potential transaction failures or unexpected behavior due to out-of-gas errors."",
      ""Location"": ""Functions: `_handleOpenFees`, `_handleCloseFees`""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state-changing functions (e.g., `setBlockDelay`, `setAllowedVault`, `_updateFunding`) do not emit events, reducing transparency and auditability."",
      ""Impact"": ""Reduced ability to track changes and monitor contract activity."",
      ""Location"": ""Functions: `setBlockDelay`, `setAllowedVault`, `_updateFunding`""
    },
    {
      ""Issue"": ""Hardcoded Constants"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses hardcoded constants (e.g., `DIVISION_CONSTANT`, `liqPercent`), reducing flexibility and requiring redeployment for updates."",
      ""Impact"": ""Reduced flexibility and potential need for contract redeployment."",
      ""Location"": ""Constants: `DIVISION_CONSTANT`, `liqPercent`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 10
}",459.6472351551056,183712.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] Riskless trades due to delay check**

**Report Description**:  
The `Trading.limitClose()` function uses `_checkDelay()`, which allows for riskless trades. Users can capture price rises by increasing the stop-loss while preventing underwater positions from being closed by continuously increasing the delay. This creates an unfair advantage and potential financial loss for the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of riskless trades due to delay checks. This is a critical oversight, as it directly impacts the fairness and security of the trading mechanism.

---

#### **[H-06] Incorrect calculation of new price while adding position**

**Report Description**:  
The formula used for calculating `_newPrice` in the `addToPosition()` function of `Trading.sol` is incorrect. This leads to users losing part of their funds or profits when using this function.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect price calculations in the `addToPosition()` function. This is a significant financial risk for users and the protocol.

---

#### **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**

**Report Description**:  
Users can bypass the `maxWinPercent` limit by partially closing positions. This allows users to receive more funds than their upper limit from the protocol, leading to potential financial losses for the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of bypassing the `maxWinPercent` limit through partial closing. This is a critical vulnerability that could lead to significant financial losses.

---

#### **[H-11] Not enough margin pulled or burned from user when adding to a position**

**Report Description**:  
When adding to a position, the amount of margin pulled from the user is insufficient. This leaks value from the protocol and lowers the collateralization ratio of `tigAsset`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient margin being pulled or burned when adding to a position. This is a significant financial risk for the protocol.

---

#### **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**

**Report Description**:  
Approved operators of the Position token cannot call several functions in `Trading`, including `initiateCloseOrder`. Functions that accept Position tokens in `Trading` check that the caller is the owner of the token using the `_checkOwner` function, which prevents approved operators from performing these actions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of approved operators being unable to call `initiateCloseOrder`. This is a functional limitation that could impact user experience and contract usability.

---

#### **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**

**Report Description**:  
The formula for `fee paid` in the `_handleOpenFees` function is incorrect, leading to incorrect margin calculations. This directly impacts trader margin and associated fee calculations, posing a high risk.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Potential Integer Overflow/Underflow""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for incorrect calculations due to arithmetic operations but does not specifically address the issue of incorrect fee calculations in `_handleOpenFees`. The core issue is partially covered but not fully resolved.

---

#### **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**

**Report Description**:  
The owner can freeze withdrawals and use a timelock to steal all funds, posing a significant centralization risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the centralization risks associated with the owner's ability to freeze withdrawals and potentially steal funds. This is a critical security concern.

---

#### **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

**Report Description**:  
The open price of a stop order might change during execution, but the function does not validate StopLoss/TakeProfit for the changed price, leading to potential financial losses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of validating StopLoss/TakeProfit for the new price in `executeLimitOrder()`. This is a significant oversight that could lead to financial losses.

---

#### **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Report Description**:  
The `_handleDeposit` and `_handleWithdraw` functions in `Trading.sol` do not account for tokens with decimals higher than 18, causing deposits or withdrawals of such tokens to always revert.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Reentrancy Vulnerability""**.

**Validation**:  
**Partially Correct**. The response identifies issues with `_handleDeposit` and `_handleWithdraw` but focuses on reentrancy rather than the handling of tokens with decimals higher than 18. The core issue is partially covered but not fully resolved.

---

#### **[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred**

**Report Description**:  
When `initiateMarketOrder` is called, `_marginAfterFees` is calculated incorrectly when a trade is referred, allowing users to open a position with more margin than expected.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Potential Integer Overflow/Underflow""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for incorrect calculations due to arithmetic operations but does not specifically address the issue of incorrect margin calculations in `initiateMarketOrder`. The core issue is partially covered but not fully resolved.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**  
- **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**  
- **[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred**

**Missed Issues from Issue Report**:  
- **[H-02] Riskless trades due to delay check**  
- **[H-06] Incorrect calculation of new price while adding position**  
- **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**  
- **[H-11] Not enough margin pulled or burned from user when adding to a position**  
- **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**  
- **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**  
- **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

--- 

The response list fails to address several critical issues from the issue report, particularly those related to financial risks, centralization, and functional limitations. While some issues are partially covered, the overall coverage is insufficient, leaving significant vulnerabilities unaddressed.","```
None.
```",0.0
