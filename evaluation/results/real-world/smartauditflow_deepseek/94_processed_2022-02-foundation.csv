nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTMarketReserveAuction.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797,677,"[H-01] NFT owner can create multiple auctions

  function `createReserveAuction()`
NFTMarketReserveAuction.sol#L325-L349 NFTMarketReserveAuction.sol#L596-L599
NFT owner can permanently lock funds of bidders.
Proof of Concept

Alice (the attacker) calls createReserveAuction, and creates one like normal. let this be auction id 1.
Alice calls createReserveAuction again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because _transferToEscrow doesn't revert if there's an existing auction. let this be Auction id 2.
Since nftContractToTokenIdToAuctionId[nftContract][tokenId] will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).
  [M-04] adminAccountMigration() Does Not Update buyPrice.seller

Submitted by leastwood, also found by cccz
NFTMarketReserveAuction.sol#L263-L292 NFTMarketBuyPrice.sol#L125-L141
The adminAccountMigration() function is called by the operator role to update all sellers' auctions. The auction.seller account is updated to the new address, however, the protocol fails to update buyPrice.seller. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then cancelBuyPrice() is called before migrating back.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();

error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);

error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();

error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);

error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();

error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);

error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();

error NFTMarketReserveAuction_Not_Matching_Seller(address seller);

error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();


abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  
  struct ReserveAuction {
    
    address nftContract;
    
    uint256 tokenId;
    
    address payable seller;
    
    uint256 duration;
    
    uint256 extensionDuration;
    
    
    uint256 endTime;
    
    
    address payable bidder;
    
    
    uint256 amount;
  }

  
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  
  
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  
  uint256[5] private __gap_was_config;

  
  uint256 private immutable DURATION;

  
  
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          

          if (auction.seller != originalAddress) {
            
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    
    _transferToEscrow(nftContract, tokenId);

    
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, 
      payable(0), 
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  
  
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;

        
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      

      if (auction.amount > amount) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      
      unchecked {
        
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        
        
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        

        if (auction.seller != seller) {
          
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        
        _finalizeReserveAuction(auctionId, false);

        
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      
      _finalizeReserveAuction(auctionId, true);
    }
  }

  
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  
  uint256[1000] private __gap;
}",3541,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions like `placeBidOf`, `adminCancelReserveAuction`, and `cancelReserveAuction`."",
        ""Verify that all external calls (e.g., `_sendValueWithFallbackWithdraw`) are safe and do not introduce vulnerabilities."",
        ""Ensure that all arithmetic operations are protected against overflow/underflow using `unchecked` blocks where appropriate."",
        ""Audit the `_transferFromEscrow` and `_transferToEscrow` functions to ensure they handle NFT transfers securely.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-721 standards for NFT transfers and ownership."",
        ""Ensure that the contract complies with OpenZeppelin's upgradeable contract standards.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `placeBidOf` to ensure it correctly handles bid amounts and extensions."",
        ""Audit the `_finalizeReserveAuction` function to ensure it correctly distributes funds and transfers NFTs."",
        ""Check the `adminAccountMigration` function for correct handling of seller migrations.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify the integration with the `feth` contract in the `placeBidOf` function."",
        ""Ensure that all external contract calls (e.g., `_sendValueWithFallbackWithdraw`) are safe and do not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the seller can cancel or update their own auctions."",
        ""Ensure that only authorized admins can perform admin-specific functions like `adminCancelReserveAuction` and `adminAccountMigration`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in functions like `placeBidOf` and `_finalizeReserveAuction`."",
        ""Review the use of mappings and storage variables to minimize gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract does not interact with liquidity pools or AMMs in a way that could be exploited.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Verify that the contract is not vulnerable to flash loan attacks, particularly in the `placeBidOf` function.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that the contract does not rely on external oracles for critical operations.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Verify that the contract does not implement governance or voting mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the contract does not implement staking or reward mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Verify that the contract does not implement tokenomics that could lead to inflationary risks.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in the `placeBidOf` function."",
        ""Consider implementing commit-reveal schemes if necessary.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not have mechanisms that could allow for fund drainage or malicious exits.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Verify that the contract does not implement cross-chain operations that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms to halt operations in case of emergencies.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code snippet is a Solidity smart contract named `NFTMarketReserveAuction`. It is designed to manage reserve auctions for NFTs, allowing users to create, bid on, and finalize auctions. The contract integrates with other components like `NFTMarketCore`, `NFTMarketFees`, and `ReentrancyGuardUpgradeable` to ensure secure and functional auction management."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketReserveAuction"",
    ""Purpose"": ""To manage reserve auctions for NFTs, enabling users to create auctions, place bids, and finalize auctions securely."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Constants"", ""FoundationTreasuryNode"", ""NFTMarketCore"", ""ReentrancyGuardUpgradeable"", ""SendValueWithFallbackWithdraw"", ""NFTMarketFees"", ""NFTMarketAuction""],
      ""Imports"": [""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"", ""../libraries/AccountMigrationLibrary.sol"", ""./Constants.sol"", ""./FoundationTreasuryNode.sol"", ""./NFTMarketAuction.sol"", ""./NFTMarketCore.sol"", ""./NFTMarketFees.sol"", ""./SendValueWithFallbackWithdraw.sol"", ""@openzeppelin/contracts/token/ERC721/IERC721.sol""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""nftContractToTokenIdToAuctionId"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Maps NFT contracts and token IDs to their respective auction IDs.""
      },
      {
        ""Name"": ""auctionIdToAuction"",
        ""Type"": ""mapping(uint256 => ReserveAuction)"",
        ""Purpose"": ""Maps auction IDs to their respective auction details.""
      },
      {
        ""Name"": ""__gap_was_config"",
        ""Type"": ""uint256[5]"",
        ""Purpose"": ""Reserved storage for future upgrades.""
      },
      {
        ""Name"": ""DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Immutable duration of the auction.""
      },
      {
        ""Name"": ""EXTENSION_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant duration for auction extensions.""
      },
      {
        ""Name"": ""MAX_MAX_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum allowed duration for an auction.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Reserved storage for future upgrades.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""adminCancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an admin to cancel an auction with a specified reason."",
        ""Parameters"": [""uint256 auctionId"", ""string calldata reason""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminAccountMigration"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an admin to migrate seller accounts to a new address."",
        ""Parameters"": [""uint256[] calldata listedAuctionIds"", ""address originalAddress"", ""address payable newAddress"", ""bytes memory signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the seller to cancel an auction."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""createReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a seller to create a new reserve auction."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""finalizeReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Finalizes an auction, distributing funds and transferring the NFT."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBid"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to place a bid on an auction."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBidOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to place a bid with a specified amount."",
        ""Parameters"": [""uint256 auctionId"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the seller to update the reserve price of an auction."",
        ""Parameters"": [""uint256 auctionId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""_finalizeReserveAuction"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to finalize an auction."",
        ""Parameters"": [""uint256 auctionId"", ""bool keepInEscrow""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrow"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to transfer an NFT from escrow."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient"", ""address seller""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrowIfAvailable"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to transfer an NFT from escrow if available."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferToEscrow"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to transfer an NFT to escrow."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinBidAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the minimum bid amount for an auction."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""uint256 minimum""]
      },
      {
        ""Name"": ""getReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the details of a specific auction."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""ReserveAuction memory auction""]
      },
      {
        ""Name"": ""getReserveAuctionIdFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the auction ID for a specific NFT contract and token ID."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""uint256 auctionId""]
      },
      {
        ""Name"": ""_getSellerFor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to get the seller for a specific NFT."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""address payable seller""]
      },
      {
        ""Name"": ""_isInActiveAuction"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to check if an NFT is in an active auction."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [""ReentrancyGuardUpgradeable"", ""AccountMigrationLibrary"", ""Constants"", ""FoundationTreasuryNode"", ""NFTMarketAuction"", ""NFTMarketCore"", ""NFTMarketFees"", ""SendValueWithFallbackWithdraw"", ""IERC721""],
  ""SpecialMechanisms"": [""ReentrancyGuardUpgradeable is used to prevent reentrancy attacks."", ""The contract uses a mapping to track auctions and their details."", ""The contract supports account migration for sellers.""],
  ""Questions"": [""How is the `feth` contract integrated into the `placeBidOf` function?"", ""What is the purpose of the `__gap` and `__gap_was_config` variables?"", ""How does the `_distributeFunds` function work in detail?""]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Bid Placement"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (`placeBidOf`, `adminCancelReserveAuction`) are vulnerable to reentrancy attacks due to improper handling of external calls (`_sendValueWithFallbackWithdraw`, `feth.marketWithdrawFrom`) before state updates. This could allow attackers to re-enter the function and manipulate the auction state or drain funds."",
      ""Impact"": ""Potential loss of funds, manipulation of auction outcomes, or unauthorized transfers."",
      ""Location"": ""placeBidOf function, adminCancelReserveAuction function""
    },
    {
      ""Issue"": ""Unchecked External Call in `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function makes external calls without checking success, potentially leading to inconsistent state or lost funds if the call fails."",
      ""Impact"": ""Funds could be lost or contract state corrupted if external calls fail."",
      ""Location"": ""_sendValueWithFallbackWithdraw function""
    },
    {
      ""Issue"": ""Lack of Input Validation in Auction Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions (`createReserveAuction`, `updateReserveAuction`, `adminCancelReserveAuction`) lack proper validation for inputs like `nftContract`, `tokenId`, `reservePrice`, and `auctionId`, which could lead to invalid auctions or unexpected behavior."",
      ""Impact"": ""Creation of invalid auctions, potential exploitation, or disputes among users."",
      ""Location"": ""createReserveAuction function, updateReserveAuction function, adminCancelReserveAuction function""
    },
    {
      ""Issue"": ""Potential Front-Running in Auction Creation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `createReserveAuction` and `placeBidOf` are vulnerable to front-running, where attackers can monitor pending transactions and manipulate auction parameters or bids."",
      ""Impact"": ""Unfair auction outcomes, discouragement of legitimate users, and potential financial losses."",
      ""Location"": ""createReserveAuction function, placeBidOf function""
    },
    {
      ""Issue"": ""Unbounded Loops in `adminAccountMigration`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adminAccountMigration` function iterates over an unbounded array (`listedAuctionIds`), risking gas limit exhaustion and failed transactions."",
      ""Impact"": ""Denial of service, incomplete migrations, and operational disruptions."",
      ""Location"": ""adminAccountMigration function""
    },
    {
      ""Issue"": ""Insufficient Gas Limit Handling"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function uses a fixed gas limit (`SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`), which may fail for contracts with complex fallback functions."",
      ""Impact"": ""Failed transactions and stuck funds, requiring manual intervention."",
      ""Location"": ""_sendValueWithFallbackWithdraw function calls""
    },
    {
      ""Issue"": ""Inconsistent State Handling in Auction Finalization"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_finalizeReserveAuction` function deletes auction state before transferring funds, risking inconsistency if the transfer fails."",
      ""Impact"": ""Potential inconsistency in auction state or unresolved auctions."",
      ""Location"": ""_finalizeReserveAuction function""
    },
    {
      ""Issue"": ""Insufficient Event Logging"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_finalizeReserveAuction` function lacks detailed event logging, hindering auditability."",
      ""Impact"": ""Reduced visibility into auction finalization processes."",
      ""Location"": ""_finalizeReserveAuction function""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 8
}",363.3437149524689,96081.0,24.0,"### **[H-01] NFT owner can create multiple auctions**

**Report Description**:  
The `createReserveAuction()` function in `NFTMarketReserveAuction.sol` allows an NFT owner to create multiple auctions for the same NFT token. This occurs because `_transferToEscrow` does not revert if there is an existing auction. As a result, the NFT owner can create a second auction (Auction ID 2) before any user places a bid on the first auction (Auction ID 1). This leads to confusion for bidders, as they will only see Auction ID 2 as the active auction unless they manually inspect contract events or data. This vulnerability can permanently lock funds of bidders and disrupt the auction process.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of multiple auctions being created for the same NFT token. The closest match is the ""Lack of Input Validation in Auction Functions"" issue, which mentions `createReserveAuction` but focuses on input validation rather than the specific vulnerability of allowing multiple auctions for the same token. This issue is not covered in the response list.

---

### **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

**Report Description**:  
The `adminAccountMigration()` function, called by the operator role, updates the seller's address in auctions but fails to update the `buyPrice.seller` field. This inconsistency creates a deadlock where the new address cannot cancel the auction or withdraw the NFT without the compromised account first canceling the buy price. The only recovery path is to migrate the new account back to the compromised account, call `cancelBuyPrice()`, and then migrate back. This oversight can lead to operational disruptions and unresolved auctions.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loops in `adminAccountMigration`""**.

**Validation**:  
**Partially Correct**. The response identifies the `adminAccountMigration` function but focuses on the issue of unbounded loops, which risks gas limit exhaustion. While this is a valid concern, it does not address the core issue of the `buyPrice.seller` field not being updated, leading to a deadlock situation. The response misses the critical detail of the inconsistency between auction and buy price states.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

**Missed Issues from Issue Report**:  
- **[H-01] NFT owner can create multiple auctions**

---

### **Conclusion**  
The response list does not adequately address the issues raised in the issue report. While it identifies some related concerns, it misses the core vulnerabilities in both the `createReserveAuction` and `adminAccountMigration` functions. The response list should be expanded to include these specific issues to ensure comprehensive coverage of the security risks in the smart contract.","```
None.
```",0.0
NFTMarketCreators.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363,268,"[H-02] Creators can steal sale revenue from owners' sales

Submitted by IllIllI
NFTMarketCreators.sol#L158-L160 NFTMarketCreators.sol#L196-L198 NFTMarketCreators.sol#L97-L99
According to the README.md:
All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.
Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.
  [M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array

Submitted by leastwood
NFTMarketCreators.sol#L49-L251
The _getCreatorPaymentInfo() function is utilised by _distributeFunds() whenever an NFT sale is made. The function uses try and catch statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a try statement, the revert is actually not handled and it will not fall through to the empty catch statement.

[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns

Submitted by WatchPug
Based on our research, getRoyalties() is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.
However, in the current implementation, it always assumes that getRoyalties() return in terms of BPS.
NFTMarketCreators.sol#L85-L112
NFTMarketFees.sol#L86-L90
if (creatorShares[i] > BASIS_POINTS) {
    // If the numbers are >100% we ignore the fee recipients and pay just the first instead
    maxCreatorIndex = 0;
    break;
}

As a result, if a particular implementation is returning get Royalties() with higher precision (say 1e6 for 100% instead of 1e4/BPS), the distribution of royalties can be distorted.
",3,,"pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();


abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable 
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  
  
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    

    
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch 
      {
        
      }
    }

    
    
    
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          

          
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch 
            {
              
            }
          }

          
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch 
            {
              
            }
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch 
          {
            
          }
        }
      } catch 
      {
        
      }
    }

    
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          
          recipients = new address payable[](1);
          recipients[0] = _creator;
          
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch 
    {
      
    }

    
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch 
    {
      
    }

    
  }

  
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  
  uint256[500] private __gap;
}",1579,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that all external calls within `_getCreatorPaymentInfo` are properly handled with try-catch blocks to prevent reverts from affecting the contract's state."",
        ""Ensure that the `royaltyRegistry` address is validated in the constructor to support the `IRoyaltyRegistry` interface, preventing potential issues with incompatible contracts."",
        ""Check for potential reentrancy vulnerabilities in the `_getCreatorPaymentInfo` function, especially in the context of external calls to NFT contracts."",
        ""Review the use of `READ_ONLY_GAS_LIMIT` in external calls to ensure that gas limits are sufficient to prevent out-of-gas errors.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Ensure that the contract adheres to the ERC-721 standard for NFT interactions, particularly in the context of royalty and creator payment information."",
        ""Verify that the contract correctly implements the `ERC165Checker` to check for interface support, ensuring compliance with ERC-165.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic within `_getCreatorPaymentInfo` to ensure that it correctly handles all edge cases, such as when no recipients are found or when the seller is the creator."",
        ""Verify that the `splitPerRecipientInBasisPoints` array is correctly populated and matches the length of the `recipients` array in all scenarios.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interactions with the `royaltyRegistry` contract to ensure that the `getRoyaltyLookupAddress` function is used correctly and safely."",
        ""Review all external calls to NFT contracts (e.g., `IRoyaltyInfo`, `IGetRoyalties`, `IGetFees`, `ITokenCreator`, `IOwnable`) to ensure they are secure and handle potential failures gracefully.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the constructor is the only place where the `royaltyRegistry` address can be set, ensuring it cannot be modified after deployment."",
        ""Ensure that the `_getCreatorPaymentInfo` function is internal and cannot be called directly by external users, maintaining proper access control.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas usage of the `_getCreatorPaymentInfo` function, particularly in loops and external calls, to identify potential optimizations."",
        ""Consider reducing the size of the `__gap` array if possible, to optimize storage usage in upgradeable contracts.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Review the use of the `__gap` variable to ensure it is correctly used to reserve storage slots for future upgrades."",
        ""Verify that the contract is compatible with the OpenZeppelin upgradeable contracts pattern, particularly with `ReentrancyGuardUpgradeable`.""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Ensure that all potential errors in the `_getCreatorPaymentInfo` function are properly handled, either through try-catch blocks or explicit checks."",
        ""Verify that the custom error `NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry` is correctly used and provides meaningful information.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity code snippet defines an abstract contract named `NFTMarketCreators`. This contract is designed to handle royalty and creator payment information for NFTs by interacting with various interfaces and external contracts. It leverages the OpenZeppelin `ReentrancyGuardUpgradeable` for security against reentrancy attacks and uses the `ERC165Checker` library to verify interface support. The contract is part of a larger system that manages NFT marketplaces, focusing on royalty distribution and creator payments."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketCreators"",
    ""Purpose"": ""To manage and retrieve royalty and creator payment information for NFTs, ensuring proper distribution of funds and adherence to royalty standards."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Constants"", ""ReentrancyGuardUpgradeable""],
      ""Imports"": [
        ""./OZ/ERC165Checker.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""./Constants.sol"",
        ""../interfaces/IGetFees.sol"",
        ""../interfaces/IGetRoyalties.sol"",
        ""../interfaces/IOwnable.sol"",
        ""../interfaces/IRoyaltyInfo.sol"",
        ""../interfaces/ITokenCreator.sol"",
        ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""royaltyRegistry"",
        ""Type"": ""IRoyaltyRegistry"",
        ""Purpose"": ""Stores the address of the royalty registry contract, which is used to look up royalty information for NFTs.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by setting the royalty registry address and verifying that it supports the `IRoyaltyRegistry` interface."",
        ""Parameters"": [""address _royaltyRegistry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getCreatorPaymentInfo"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Retrieves the payment information for the creator of an NFT, including recipients, split percentages, and whether the seller is the creator."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address seller""],
        ""Returns"": [""address payable[] memory recipients"", ""uint256[] memory splitPerRecipientInBasisPoints"", ""bool isCreator""]
      },
      {
        ""Name"": ""getRoyaltyRegistry"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the address of the royalty registry contract."",
        ""Parameters"": [],
        ""Returns"": [""address registry""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRoyaltyRegistry: Used to look up royalty information for NFTs."",
    ""IRoyaltyInfo: Provides royalty information for a specific NFT."",
    ""IGetRoyalties: Retrieves royalty recipients and their basis points."",
    ""IGetFees: Retrieves fee recipients and their basis points."",
    ""ITokenCreator: Retrieves the creator of a specific token."",
    ""IOwnable: Retrieves the owner of a contract.""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuardUpgradeable: Protects against reentrancy attacks."",
    ""ERC165Checker: Verifies if a contract supports specific interfaces."",
    ""Immutable State Variable: `royaltyRegistry` is marked as immutable, ensuring it cannot be changed after deployment.""
  ],
  ""Questions"": [
    ""What is the purpose of the `__gap` variable, and how is it used in the context of upgradeable contracts?"",
    ""How are the `READ_ONLY_GAS_LIMIT` and `BASIS_POINTS` constants defined, and what values do they hold?"",
    ""Are there any specific security considerations or potential vulnerabilities in the external calls made within the `_getCreatorPaymentInfo` function?""
  ]
}","{
  ""Findings"": [],
  ""IssueNumber"": 0,
  ""OutputList"": 0
}",75.12848401069641,14127.0,8.0,"### **[H-02] Creators can steal sale revenue from owners' sales**

**Report Description**:  
The issue highlights a vulnerability in `NFTMarketCreators.sol` where creators can manipulate royalty information using the Royalty Registry just before a sale is completed. This allows them to redirect sale revenue unfairly, bypassing the intended 10% royalty distribution for secondary sales. The vulnerability arises because the royalty information can be updated dynamically, and the contract does not enforce immutability or validation of royalty data at the time of sale.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The vulnerability involves improper access control and dynamic manipulation of royalty data, which is a critical security concern. The lack of any response indicates a significant gap in addressing this risk.

---

### **[M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array**

**Report Description**:  
The `_getCreatorPaymentInfo()` function in `NFTMarketCreators.sol` uses `try` and `catch` statements to handle potential reverts from API endpoints. However, if a revert occurs within the iteration over an unbounded `_recipients` array, the function fails to handle it properly. This could lead to NFTs being locked in the contract, as the revert is not caught by the `catch` statement. The issue stems from improper error handling and the assumption that all reverts will be caught.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves improper error handling and the risk of NFTs being locked due to unhandled reverts. This is a significant oversight, as it directly impacts the functionality and security of the contract.

---

### **[M-15] Royalties can be distributed unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns**

**Report Description**:  
The issue arises because the `getRoyalties()` function is not standardized across NFT contracts, and the current implementation assumes that the returned values are in terms of Basis Points (BPS). If a contract returns values with higher precision (e.g., 1e6 for 100% instead of 1e4/BPS), the royalty distribution can be distorted. This leads to unfair distribution of royalties among `creatorRecipients`. The issue is due to a lack of validation and normalization of the returned values.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves incorrect assumptions about the format of `getRoyalties()` returns, leading to unfair royalty distribution. This is a critical issue that needs to be addressed to ensure fair and accurate royalty payments.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-02] Creators can steal sale revenue from owners' sales**  
- **[M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array**  
- **[M-15] Royalties can be distributed unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns**  

---

**Conclusion**:  
The `response_list` fails to address any of the issues reported in the `issue` list. This indicates a significant gap in the coverage, accuracy, and sufficiency of the responses. All three issues involve critical vulnerabilities that could lead to financial losses, unfair royalty distribution, or NFTs being locked in the contract. Immediate attention is required to address these gaps and ensure the security and functionality of the smart contracts.","```
None.
```",0.0
NFTMarketOffer.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149,404,"[H-03] An offer made after auction end can be stolen by an auction winner

Submitted by hyh, also found by leastwood, shenwilly, and WatchPug
An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as _transferFromEscrow being called by _acceptOffer will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.
This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.

[M-13] Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it

function makeOffer() 
If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via makeOffer, acceptOffer combination.
I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.
This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of setBuyPrice or createReserveAuction, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();

error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);

error NFTMarketOffer_Offer_Expired(uint256 expiry);

error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);

error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();


abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  
  struct Offer {
    
    
    uint32 expiration;
    
    uint96 amount;
    

    
    
    address buyer;
  }

  
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        
      }
    }
  }

  
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      

      
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      

      if (amount < _getMinIncrement(offer.amount)) {
        
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      
      
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    
    offer.buyer = msg.sender;
    
    offer.expiration = uint32(expiration);
    
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    
    delete nftContractToIdToOffer[nftContract][tokenId];
    
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) 
    {
      
    } catch {
      
      
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      
      _invalidateOffer(nftContract, tokenId);
    }
    
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      
      delete nftContractToIdToOffer[nftContract][tokenId];
      
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    
    return 1;
  }

  
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      
      return (address(0), 0, 0);
    }

    
    return (offer.buyer, offer.expiration, offer.amount);
  }

  
  uint256[1000] private __gap;
}",1815,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions handling external calls, especially in `acceptOffer` and `_acceptOffer`."",
        ""Verify that all arithmetic operations are protected against overflow/underflow, particularly in `makeOffer` and `_acceptOffer`."",
        ""Ensure that all external calls (e.g., `IERC721.transferFrom`) are handled safely with try-catch blocks to prevent reverts from disrupting contract logic."",
        ""Review the use of `nonReentrant` modifier to ensure it is applied correctly to all functions that could be vulnerable to reentrancy attacks.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-721 standards, especially in the `_acceptOffer` function where NFT transfers occur."",
        ""Verify that the contract follows OpenZeppelin's upgradeable contract patterns, given the use of `ReentrancyGuardUpgradeable` and the `__gap` storage.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Analyze the logic in `makeOffer` to ensure it correctly handles both new and updated offers, including the locking and unlocking of funds via the `feth` contract."",
        ""Review the `_autoAcceptOffer` and `_autoAcceptBuyPrice` functions (though not defined in the snippet) to ensure they correctly determine when an offer should be auto-accepted."",
        ""Examine the `_getMinIncrement` function (not defined in the snippet) to ensure it correctly calculates the minimum required increment for new offers.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Investigate the integration with the `feth` contract to ensure that funds are locked, unlocked, and withdrawn correctly and securely."",
        ""Verify that interactions with the `IERC721` interface are handled correctly, especially in cases where NFT transfers might fail."",
        ""Ensure that the `FoundationTreasuryNode`, `NFTMarketCore`, and `NFTMarketFees` contracts are integrated securely and that their functions are called correctly.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyFoundationAdmin` modifier is correctly implemented and that only authorized admins can call `adminCancelOffers`."",
        ""Ensure that the `msg.sender` is properly validated in functions like `acceptOffer` and `makeOffer` to prevent unauthorized access."",
        ""Check that the `_invalidateOffer` function can only be called under the correct conditions, especially when invalidating offers during NFT transfers.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs in loops, especially in `adminCancelOffers` where multiple offers are processed."",
        ""Optimize storage usage by reviewing the `Offer` struct and the `nftContractToIdToOffer` mapping to ensure efficient data storage and retrieval."",
        ""Consider using `unchecked` blocks where safe to reduce gas costs, especially in arithmetic operations where overflow/underflow is not possible.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Review the `makeOffer` function to ensure that it is not vulnerable to front-running, especially when updating existing offers."",
        ""Consider implementing a commit-reveal scheme for offer creation to prevent front-running attacks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the contract includes mechanisms to handle unexpected situations, such as failed NFT transfers or locked funds that cannot be withdrawn."",
        ""Ensure that the `adminCancelOffers` function can be used as an emergency stop to cancel offers in case of unexpected issues.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided smart contract is an abstract contract named `NFTMarketOffer` that facilitates the creation, acceptance, and cancellation of offers for NFTs. It integrates with other contracts for treasury management, market core functionalities, and fee distribution. The contract also includes mechanisms to handle offer expiration, minimum offer amounts, and reentrancy protection."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketOffer"",
    ""Purpose"": ""To manage offers for NFTs, including creation, acceptance, cancellation, and validation of offers, while ensuring security and proper fee distribution."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""FoundationTreasuryNode"", ""NFTMarketCore"", ""ReentrancyGuardUpgradeable"", ""NFTMarketFees""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketFees.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""nftContractToIdToOffer"",
        ""Type"": ""mapping(address => mapping(uint256 => Offer))"",
        ""Purpose"": ""Stores offers made for specific NFTs, indexed by NFT contract address and token ID.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Reserved storage space for future upgrades in the contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""acceptOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the seller to accept an offer for an NFT, provided the offer meets certain conditions."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address offerFrom"", ""uint256 minAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminCancelOffers"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an admin to cancel multiple offers, requiring a reason for cancellation."",
        ""Parameters"": [""address[] nftContracts"", ""uint256[] tokenIds"", ""string reason""],
        ""Returns"": []
      },
      {
        ""Name"": ""makeOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a buyer to make an offer for an NFT, handling the locking of funds and updating the offer details."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 amount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""_acceptOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to process the acceptance of an offer, including fund distribution and NFT transfer."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_invalidateOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal function to invalidate an offer, unlocking the funds and emitting an event."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinOfferAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the minimum amount required for a new offer on a specific NFT."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""uint256 minimum""]
      },
      {
        ""Name"": ""getOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Retrieves the details of an offer for a specific NFT."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""address buyer"", ""uint256 expiration"", ""uint256 amount""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The contract interacts with the `feth` contract for locking and unlocking funds."",
    ""It uses the `IERC721` interface for NFT transfers."",
    ""It relies on inherited contracts (`FoundationTreasuryNode`, `NFTMarketCore`, `NFTMarketFees`) for core functionalities and fee distribution.""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses `ReentrancyGuardUpgradeable` to prevent reentrancy attacks."",
    ""It implements a mechanism to handle offer expiration and minimum offer amounts."",
    ""The contract includes a gap storage (`__gap`) for future upgrades.""
  ],
  ""Questions"": [
    ""What is the exact role of the `feth` contract and how does it integrate with this contract?"",
    ""How is the `_getMinIncrement` function implemented, as it is referenced but not defined in the provided code?"",
    ""Are there any specific conditions or restrictions on who can call the `adminCancelOffers` function, aside from the `onlyFoundationAdmin` modifier?"",
    ""How does the `_autoAcceptBuyPrice` function work, as it is referenced in the `makeOffer` function but not defined in the provided code?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in `acceptOffer` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `acceptOffer` function and its internal `_acceptOffer` function perform external calls (e.g., `IERC721.transferFrom`, `marketWithdrawLocked`) after state changes, potentially allowing reentrancy attacks despite the `nonReentrant` modifier. Multiple reports highlight variations of this issue, including calls to external contracts that could be malicious or buggy."",
      ""Impact"": ""An attacker could re-enter the function before state updates, leading to loss of funds, unauthorized transfers, or double-spending."",
      ""Location"": ""`acceptOffer` function, `_acceptOffer` function""
    },
    {
      ""Issue"": ""Potential Front-Running in `makeOffer` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeOffer` function updates offer state after external calls (e.g., `feth.marketLockupFor`), making it susceptible to front-running. Attackers could monitor pending transactions and submit higher offers to outbid legitimate users."",
      ""Impact"": ""Legitimate users may lose offers unfairly, leading to poor user experience and potential financial loss."",
      ""Location"": ""`makeOffer` function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `makeOffer` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeOffer` function lacks validation for `nftContract` address, `tokenId`, and `msg.value` matching the `amount` parameter. Invalid or malicious inputs could cause unexpected behavior."",
      ""Impact"": ""Potential loss of funds, incorrect fund locking, or exploitation via malicious contract addresses."",
      ""Location"": ""`makeOffer` function""
    },
    {
      ""Issue"": ""Unbounded Loops in `adminCancelOffers` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adminCancelOffers` function iterates over arrays (`nftContracts`, `tokenIds`) without length checks or gas limits, risking out-of-gas errors or inconsistent state if arrays are large or unequal in length."",
      ""Impact"": ""Failed transactions or incomplete cancellations due to gas limits, potentially leaving offers in an inconsistent state."",
      ""Location"": ""`adminCancelOffers` function""
    },
    {
      ""Issue"": ""Insufficient Error Handling in `_acceptOffer` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_acceptOffer` function uses a `try-catch` for `IERC721.transferFrom` but lacks robust error handling. Silent failures could lead to inconsistent state or fallback to `_transferFromEscrow` without clear outcomes."",
      ""Impact"": ""NFTs may not transfer correctly while funds are disbursed, causing asset loss or state corruption."",
      ""Location"": ""`_acceptOffer` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `makeOffer` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""Arithmetic operations in `makeOffer` (e.g., `expiration` calculation) lack explicit overflow checks, though Solidity 0.8.x has built-in protections. Rare edge cases could still cause issues."",
      ""Impact"": ""Incorrect expiration times or unexpected behavior due to overflow."",
      ""Location"": ""`makeOffer` function""
    },
    {
      ""Issue"": ""Lack of Event Emission in `_invalidateOffer` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_invalidateOffer` function emits no event when offers expire naturally, reducing transparency and auditability of state changes."",
      ""Impact"": ""Difficulty tracking offer invalidations, hindering monitoring and debugging."",
      ""Location"": ""`_invalidateOffer` function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 7
}",376.0540499687195,58043.0,24.0,"### **[H-03] An offer made after auction end can be stolen by an auction winner**

**Report Description**:
An offer made for an NFT after the auction has ended, but before the winner has received the NFT, can be stolen by the auction winner. The `_transferFromEscrow` function, called by `_acceptOffer`, transfers the NFT to the winner, finalizing the auction. However, no transfer occurs to the user who made the offer. This allows the auction winner to obtain both the NFT and the offer amount after fees at no additional cost, at the expense of the user who made the offer.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves a logical flaw in the auction and offer handling mechanism, which is not covered by any of the findings in the response list. The response list focuses on reentrancy, front-running, input validation, and other issues but does not mention the scenario where an auction winner can exploit the offer system to steal both the NFT and the offer amount.

---

### **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

**Report Description**:
If an NFT is in escrow without an active `buyPrice` or auction, it can be stolen by any actor using the `makeOffer` and `acceptOffer` functions. A malicious user can monitor the `FNDNFTMarket` contract and obtain any NFT for which there are no `buyPrice` or auction structures initialized. For example, if an NFT is mistakenly sent to the contract, an attacker can immediately steal it. This occurs because the NFT is only guarded by `buyPrice` and `auction` structures. The severity is medium because normal usage implies that one of these structures is initialized, leaving only mistakenly sent assets exposed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves a security gap in the escrow mechanism, where NFTs without active `buyPrice` or auction structures can be stolen. The response list does not mention this scenario, focusing instead on reentrancy, front-running, input validation, and other issues. This represents a significant gap in the coverage of the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] An offer made after auction end can be stolen by an auction winner**
- **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

---

The response list fails to address the two critical issues described in the issue report. Both vulnerabilities involve logical flaws and security gaps in the auction and escrow mechanisms, which are not covered by the findings in the response list. This indicates a significant gap in the response list's coverage and accuracy regarding the specific vulnerabilities described in the issue report.","```
None.
```",0.0
NFTMarketPrivateSale.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896,205,"[M-01] EIP-712 signatures can be re-used in private sales

Function `buyFromPrivateSaleFor`
NFTMarketPrivateSale.sol#L123-L174
Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call #buyFromPrivateSaleFor providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.
The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.
  [M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT

Submitted by leastwood
NFTMarketPrivateSale.sol#L143-L150
The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.
  [M-12] Private sale spoofing
 function buyFromPrivateSaleFor()
NFTMarketPrivateSale.sol#L156
Similar to spoofing in finance, users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.
No funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature. It's also frustrating for the users if they try to accept the private sale but their transaction fails.

",3,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();


abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  
  
  
  bytes32 private immutable DOMAIN_SEPARATOR;

  
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  
  
  string private constant NAME = ""FNDNFTMarket"";

  
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      
      

      
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    
    
    address payable seller = payable(nftContract.ownerOf(tokenId));

    
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    
    nftContract.transferFrom(seller, msg.sender, tokenId);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  
  uint256[1000] private __gap;
}",888,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify the implementation of the `nonReentrant` modifier to ensure it effectively prevents reentrancy attacks."",
        ""Check for potential integer overflows/underflows, especially in the `buyFromPrivateSaleFor` function where arithmetic operations are performed."",
        ""Ensure that the `ecrecover` function is used securely to prevent signature malleability issues."",
        ""Review the handling of `msg.value` and `amount` to ensure no funds are lost or incorrectly transferred.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-721 standards, particularly in the `transferFrom` function."",
        ""Ensure that the EIP-712 implementation is correctly following the standard for typed structured data hashing and signing.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the `_distributeFunds` function to ensure fees are correctly calculated and distributed."",
        ""Review the logic for handling `deadline` to ensure it correctly enforces the 24-hour maximum duration for private sales.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify the behavior of `feth.marketWithdrawFrom` to ensure it correctly handles fund withdrawals."",
        ""Ensure that calls to external contracts (e.g., `nftContract.transferFrom`) are safe and handle potential failures gracefully.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Check if there are any missing access controls that could allow unauthorized users to execute critical functions."",
        ""Ensure that the `marketProxyAddress` is correctly validated as a contract in the constructor.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in the `buyFromPrivateSaleFor` function."",
        ""Review the use of storage variables to minimize gas costs, especially in the context of the `__gap` variable for upgradeability.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Assess the contract for potential front-running vulnerabilities, particularly in the `buyFromPrivateSaleFor` function."",
        ""Consider implementing a commit-reveal scheme to mitigate front-running risks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Check if there is a mechanism to pause or halt the contract in case of an emergency."",
        ""Ensure that any emergency stop mechanism does not leave the contract in an inconsistent state.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code snippet is a Solidity smart contract named `NFTMarketPrivateSale`. It is designed to facilitate private sales of NFTs, ensuring that transactions are secure, verifiable, and time-bound. The contract uses EIP-712 for signature verification and includes mechanisms for fee distribution and reentrancy protection."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketPrivateSale"",
    ""Purpose"": ""To enable private sales of NFTs with secure, verifiable, and time-bound transactions, including fee distribution and reentrancy protection."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""NFTMarketFees""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""./NFTMarketFees.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Previously used for domain separator, now a gap for upgradeability.""
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""EIP-712 domain separator for signature verification.""
      },
      {
        ""Name"": ""BUY_FROM_PRIVATE_SALE_TYPEHASH"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Type hash for the `BuyFromPrivateSale` struct used in EIP-712.""
      },
      {
        ""Name"": ""NAME"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the contract used in EIP-712 domain separator.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Storage gap for future upgrades.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the market proxy address and sets up the EIP-712 domain separator."",
        ""Parameters"": [""address marketProxyAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSale"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a buyer to purchase an NFT from a private sale using the provided value."",
        ""Parameters"": [""IERC721 nftContract"", ""uint256 tokenId"", ""uint256 deadline"", ""uint8 v"", ""bytes32 r"", ""bytes32 s""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSaleFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Facilitates the purchase of an NFT from a private sale, handling payment, signature verification, and fee distribution."",
        ""Parameters"": [""IERC721 nftContract"", ""uint256 tokenId"", ""uint256 amount"", ""uint256 deadline"", ""uint8 v"", ""bytes32 r"", ""bytes32 s""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""AddressUpgradeable.isContract()"",
    ""IERC721.ownerOf()"",
    ""IERC721.transferFrom()"",
    ""feth.marketWithdrawFrom()""
  ],
  ""SpecialMechanisms"": [
    ""EIP-712 for signature verification."",
    ""Reentrancy protection using `nonReentrant` modifier."",
    ""Fee distribution mechanism via `_distributeFunds` function.""
  ],
  ""Questions"": [
    ""What is the purpose of the `feth.marketWithdrawFrom` function, and where is it defined?"",
    ""How is the `_distributeFunds` function implemented, and what are the specific fee distribution rules?"",
    ""Is there a specific reason for the 24-hour maximum duration for private sales?"",
    ""How is the `nonReentrant` modifier implemented, and is it sufficient to prevent reentrancy attacks?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFromPrivateSaleFor` function uses the `nonReentrant` modifier but interacts with external contracts (e.g., `nftContract.transferFrom` and `feth.marketWithdrawFrom`) before updating state. This could allow reentrancy if the external contracts are malicious or compromised, despite the modifier."",
      ""Impact"": ""An attacker could re-enter the function to manipulate state or funds, leading to financial loss or unintended behavior."",
      ""Location"": ""Function `buyFromPrivateSaleFor`""
    },
    {
      ""Issue"": ""Signature Verification Bypass"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFromPrivateSaleFor` function uses `ecrecover` to verify the seller's signature, but lacks validation for the zero address (invalid signature) and may suffer from hash collisions due to `abi.encodePacked`. Malicious actors could forge signatures or exploit the `DOMAIN_SEPARATOR` if misconfigured."",
      ""Impact"": ""Unauthorized private sales could occur, leading to loss of NFTs or funds."",
      ""Location"": ""Function `buyFromPrivateSaleFor`""
    },
    {
      ""Issue"": ""Deadline Validation Inconsistency"",
      ""Severity"": ""Medium"",
      ""Description"": ""The deadline check in `buyFromPrivateSaleFor` allows up to 2 days but the error message suggests a 24-hour limit. This inconsistency could confuse users or enable unintended sale durations. Miners could also manipulate block timestamps."",
      ""Impact"": ""Misuse of private sales or disputes due to incorrect deadline expectations."",
      ""Location"": ""Function `buyFromPrivateSaleFor`""
    },
    {
      ""Issue"": ""Unchecked External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `buyFromPrivateSaleFor` does not verify return values of `feth.marketWithdrawFrom` or `nftContract.transferFrom`. Failed calls could leave the contract in an inconsistent state."",
      ""Impact"": ""Funds or NFTs may be lost if external calls fail silently."",
      ""Location"": ""Function `buyFromPrivateSaleFor`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations (e.g., `amount - msg.value`) lack explicit overflow/underflow checks. While Solidity 0.8.0 has built-in protection, edge cases could still arise."",
      ""Impact"": ""Incorrect calculations or unexpected behavior in fund distributions."",
      ""Location"": ""Function `buyFromPrivateSaleFor`""
    },
    {
      ""Issue"": ""Immutable DOMAIN_SEPARATOR"",
      ""Severity"": ""Low"",
      ""Description"": ""The `DOMAIN_SEPARATOR` is immutable, preventing updates if the contract address or chain ID changes. This could necessitate redeployment."",
      ""Impact"": ""Inflexibility in future upgrades or chain migrations."",
      ""Location"": ""Constructor and `DOMAIN_SEPARATOR` declaration""
    },
    {
      ""Issue"": ""Uninitialized Storage Gap"",
      ""Severity"": ""Low"",
      ""Description"": ""The `__gap` storage variable is reserved for upgrades but uninitialized, risking storage collisions if new variables are added in future versions."",
      ""Impact"": ""Potential data corruption during contract upgrades."",
      ""Location"": ""Variable `__gap`""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 7
}",346.57373785972595,37030.0,24.0,"### **[M-01] EIP-712 signatures can be re-used in private sales**

**Report Description**:
The `buyFromPrivateSaleFor` function in `NFTMarketPrivateSale.sol` allows buyers to purchase NFTs using EIP-712 signatures provided by sellers. However, the function does not check if the signature has been used before. This allows the same signature to be reused within a small time window if the seller regains ownership of the NFT. This could lead to unauthorized or unintended NFT transfers.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of EIP-712 signature reuse. The closest match is the ""Signature Verification Bypass"" issue, which discusses potential signature forgery but does not cover the reuse of valid signatures. This is a critical oversight as it directly impacts the security of private sales.

---

### **[M-06] `buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Report Description**:
The `buyFromPrivateSaleFor` function attempts to withdraw the required ETH from the buyer's unlocked balance if insufficient ETH is provided. However, if the buyer has an open offer on the same NFT, the funds are locked and cannot be used for the private sale. This could cause the transaction to fail, even if the buyer has sufficient funds in their unlocked balance.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of locked funds due to open offers. This is a significant gap as it affects the usability and reliability of the private sale mechanism.

---

### **[M-12] Private sale spoofing**

**Report Description**:
Users can create private sales with valid signatures and then frontrun the buy transaction by transferring the NFT to a different wallet they control. While no funds are lost due to the atomic nature of the NFT <> FETH exchange, this can be problematic for third-party off-chain markets that rely on the signature feature. It can also frustrate users if their transactions fail due to such spoofing.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of private sale spoofing. This is a critical oversight as it impacts the integrity of the private sale process and could lead to user dissatisfaction or exploitation by malicious actors.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-01] EIP-712 signatures can be re-used in private sales**
- **[M-06] `buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**
- **[M-12] Private sale spoofing**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. Key vulnerabilities related to EIP-712 signature reuse, insufficient balance handling due to open offers, and private sale spoofing are entirely missed. This indicates significant gaps in the coverage, accuracy, and sufficiency of the responses provided.","```
None.
```",0.0
SendValueWithFallbackWithdraw.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802,94,"[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals

Function `withdrawFor()`
The `NFTMarketFees` contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.
",1,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();


abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  
  mapping(address => uint256) private pendingWithdrawals;

  
  event WithdrawPending(address indexed user, uint256 amount);
  
  event Withdrawal(address indexed user, uint256 amount);

  
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    
    
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      
      
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  
  uint256[499] private __gap;
}",353,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the nonReentrant modifier is correctly applied to prevent reentrancy attacks in the withdrawFor function."",
        ""Check for potential overflow/underflow issues in the pendingWithdrawals mapping, especially in the _sendValueWithFallbackWithdraw function."",
        ""Ensure that the sendValue function from AddressUpgradeable is used safely to prevent reentrancy and other vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to relevant Ethereum standards, such as ERC-20 or ERC-721, if applicable."",
        ""Ensure that the contract follows best practices for upgradeable contracts as per OpenZeppelin's guidelines.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in the _sendValueWithFallbackWithdraw function to ensure it correctly handles failed Ether transfers and updates the pendingWithdrawals mapping."",
        ""Verify that the unchecked block in _sendValueWithFallbackWithdraw is used appropriately and does not introduce any risks.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Ensure that the contract interacts safely with external contracts and libraries, particularly OpenZeppelin's AddressUpgradeable and ReentrancyGuardUpgradeable."",
        ""Check that the gasLimit parameter in _sendValueWithFallbackWithdraw is determined safely and does not lead to excessive gas consumption or failed transactions.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that there are appropriate access controls in place for functions that modify state, such as withdraw and withdrawFor."",
        ""Ensure that the contract does not expose any sensitive functions or data to unauthorized users.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify any potential gas inefficiencies in the contract, particularly in the _sendValueWithFallbackWithdraw function."",
        ""Optimize the use of storage variables to reduce gas costs, such as minimizing writes to the pendingWithdrawals mapping.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has a mechanism to handle emergency stops or pauses, especially for critical functions like withdrawals."",
        ""Verify that the fallback mechanism in _sendValueWithFallbackWithdraw is robust and does not lead to fund loss or other issues.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Review the use of the __gap state variable to ensure it is correctly implemented for future upgrades."",
        ""Verify that the contract follows best practices for upgradeable contracts, including proper initialization and storage layout.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract is an abstract contract designed to handle withdrawals and fallback mechanisms for sending Ether. It uses OpenZeppelin's ReentrancyGuardUpgradeable to prevent reentrancy attacks and AddressUpgradeable for safe Ether transfers. The contract allows users to withdraw funds and handles failed transfers by storing them in a pending withdrawals mapping."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SendValueWithFallbackWithdraw"",
    ""Purpose"": ""To manage withdrawals and handle failed Ether transfers by storing pending withdrawals."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuardUpgradeable""],
      ""Imports"": [""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"", ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""pendingWithdrawals"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores the amount of Ether pending withdrawal for each user.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[499]"",
        ""Purpose"": ""Reserved storage space for future upgrades.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the caller to withdraw their pending Ether."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to withdraw their pending Ether. Uses nonReentrant modifier to prevent reentrancy attacks."",
        ""Parameters"": [""address payable user""],
        ""Returns"": []
      },
      {
        ""Name"": ""_sendValueWithFallbackWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sends Ether to a user and stores the amount in pending withdrawals if the transfer fails."",
        ""Parameters"": [""address payable user"", ""uint256 amount"", ""uint256 gasLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""getPendingWithdrawal"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the amount of Ether pending withdrawal for a user."",
        ""Parameters"": [""address user""],
        ""Returns"": [""uint256 balance""]
      }
    ]
  },
  ""ExternalInteractions"": [""OpenZeppelin's AddressUpgradeable and ReentrancyGuardUpgradeable libraries""],
  ""SpecialMechanisms"": [""Reentrancy protection using OpenZeppelin's ReentrancyGuardUpgradeable""],
  ""Questions"": [
    ""Why is the __gap state variable used and what is its significance?"",
    ""Is there a specific reason for using unchecked in the _sendValueWithFallbackWithdraw function?"",
    ""How is the gasLimit parameter determined in the _sendValueWithFallbackWithdraw function?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple instances of potential reentrancy vulnerabilities were identified, primarily in the `_sendValueWithFallbackWithdraw` and `withdrawFor` functions. These functions use low-level calls (`call` or `sendValue`) to transfer Ether without adequate reentrancy protection, potentially allowing malicious contracts to re-enter and manipulate the contract state before updates are completed."",
      ""Impact"": ""An attacker could exploit these vulnerabilities to drain funds from the contract or cause other unintended state changes."",
      ""Location"": ""Functions `_sendValueWithFallbackWithdraw` and `withdrawFor`""
    },
    {
      ""Issue"": ""Unchecked External Call"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function uses low-level calls (`call`) without properly checking the return value or handling failures robustly. This could lead to silent failures where Ether is not transferred but the function continues execution, potentially leaving the contract in an inconsistent state."",
      ""Impact"": ""Silent failures could result in incorrect accounting of funds or loss of Ether if the transfer fails but the state is not reverted."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Gas Limit Issues"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function allows the caller to specify a gas limit for the external call. If the gas limit is set too low, legitimate transactions may fail, leading to unnecessary fallbacks to the withdrawal mechanism. Conversely, setting it too high could result in excessive gas consumption."",
      ""Impact"": ""Improper gas limits could cause failed transactions, increased pending withdrawals, or unnecessary gas costs."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Unchecked Arithmetic"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function performs arithmetic operations inside an `unchecked` block. While this is generally safe due to Solidity's built-in overflow checks, it could theoretically lead to overflow if the `pendingWithdrawals` value is already very high."",
      ""Impact"": ""In extreme cases, overflow could result in incorrect accounting of pending withdrawals."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Lack of Event Emission on Successful Transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function emits an event only when the transfer fails, omitting event emission for successful transfers. This reduces transparency and makes it harder to track successful transactions."",
      ""Impact"": ""Lack of visibility into successful transfers complicates auditing and monitoring of contract activity."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Lack of Zero-Address Check"",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdrawFor` and `_sendValueWithFallbackWithdraw` functions do not validate whether the recipient address is the zero address, potentially leading to irreversible loss of funds if Ether is sent to the zero address."",
      ""Impact"": ""Funds could be permanently lost if accidentally or maliciously sent to the zero address."",
      ""Location"": ""Functions `withdrawFor` and `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Uninitialized Upgradeable Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from `ReentrancyGuardUpgradeable` but lacks an initializer function, which could lead to uninitialized state variables if the contract is upgraded without proper initialization."",
      ""Impact"": ""Uninitialized state variables could cause unexpected behavior or vulnerabilities in the contract."",
      ""Location"": ""Contract `SendValueWithFallbackWithdraw`""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 7
}",360.8681991100311,25265.0,25.0,"---

**[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

**Report Description**:
The `withdrawFor()` function in the `NFTMarketFees` and `NFTMarketReserveAuction` contracts uses the `_sendValueWithFallbackWithdraw` function to send ether to various recipients (e.g., FoundationTreasury, CreatorRecipients, Seller, Bidder). If the receiver fails to receive ether due to reasons such as exceeding the gas limit or the receiver contract being unable to accept ether, the ether is recorded in the `pendingWithdrawals` variable. However, there is no mechanism to ensure that the ether recorded in `pendingWithdrawals` is successfully withdrawn later, potentially leading to stranded funds.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of the `withdrawFor` function potentially failing to withdraw ether recorded in `pendingWithdrawals`. While the response list identifies related issues such as unchecked external calls, gas limit issues, and lack of zero-address checks, it does not cover the core problem of ensuring that ether recorded in `pendingWithdrawals` is successfully withdrawn. This is a critical oversight, as it directly impacts the contract's ability to manage funds securely.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

---","```
None.
```","Given that there are no true positives in the provided list, the **Average Precision (AP)** for the query is:

**0.0**"
FETH.sol,"/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670,779,"[M-03] Approve race condition in FETH

Submitted by 0x1f8b
FETH.sol#L212
Front running attack in `approve()` function.
Proof of Concept

The contract of the FETH does not have any protection against the well-known “Multiple Withdrawal Attack” attack on the Approve/TransferFrom methods of the ERC20 standard.
Although this attack poses a limited risk in specific situations, it is worth mentioning to consider it for possible future operations.
There are solutions to mitigate this front running such as, to first reduce the spender's allowance to 0 and set the desired value afterwards; another solution could the one that Open Zeppelin offers, where the non-standard decreaseAllowance and increaseAllowance functions have been added to mitigate the well-known issues involving setting allowances.
  [M-09] Missing receiver validation in withdrawFrom

Submitted by cmichel
FETH.sol#L433
The FETH.withdrawFrom function does not validate its to parameter. Funds can be lost if to is the zero address.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();

error FETH_Insufficient_Allowance(uint256 amount);

error FETH_Insufficient_Available_Funds(uint256 amount);

error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();


contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  
  struct AccountInfo {
    
    uint96 freedBalance;
    
    uint32 lockupStartIndex;
    
    LockedBalance.Lockups lockups;
    
    mapping(address => uint256) allowance;
  }

  
  mapping(address => AccountInfo) private accountToInfo;

  
  
  uint256 private immutable lockupDuration;
  
  uint256 private immutable lockupInterval;

  
  address payable private immutable foundationMarket;

  
  
  uint8 public constant decimals = 18;
  
  string public constant name = ""Foundation Wrapped Ether"";
  
  string public constant symbol = ""FETH"";

  
  
  event Approval(address indexed from, address indexed spender, uint256 amount);
  
  event Transfer(address indexed from, address indexed to, uint256 amount);

  
  
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  
  receive() external payable {
    depositFor(msg.sender);
  }

  
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  
  function deposit() external payable {
    depositFor(msg.sender);
  }

  
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      
      if (escrow.expiration == 0) {
        break;
      }

      
      unchecked {
        
        ++escrowIndex;
      }

      
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  
  
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    
    unchecked {
      
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    
    
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      
      revert FETH_Too_Much_ETH_Provided();
    }

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  
  
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      
      while (true) {
        
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    
    uint256 lockedCount;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          
          ++lockedCount;
        }
      }
    }

    
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    
    uint256 i;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function totalSupply() external view returns (uint256 supply) {
    
    return address(this).balance;
  }
}",3357,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions that transfer ETH (e.g., `withdrawAvailableBalance`, `withdrawFrom`, `marketWithdrawFrom`)."",
        ""Verify that all arithmetic operations are protected against overflow/underflow, especially in functions like `_deductBalanceFrom` and `_marketLockupFor`."",
        ""Ensure that external calls (e.g., `sendValue`) are safe and do not allow for unexpected behavior or gas exhaustion."",
        ""Review the custom error handling system to ensure it correctly reverts transactions and does not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract complies with ERC-20 standards, particularly in functions like `transfer`, `transferFrom`, and `approve`."",
        ""Ensure that the `decimals`, `name`, and `symbol` variables are correctly implemented and immutable as per ERC-20 requirements.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Analyze the lockup mechanism in `_marketLockupFor` and `_marketUnlockFor` to ensure it correctly handles expiration and locking/unlocking of funds."",
        ""Review the `_freeFromEscrow` function to ensure it correctly frees expired escrows and updates balances."",
        ""Examine the `_removeFromLockedBalance` function to ensure it correctly handles the removal of locked funds and updates the lockup start index.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the `foundationMarket` contract is correctly validated in the constructor and that it is used safely in functions like `marketChangeLockup` and `marketWithdrawFrom`."",
        ""Ensure that the contract does not rely on external contracts or oracles that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Check that the `onlyFoundationMarket` modifier is correctly applied to functions that should only be called by the designated market contract."",
        ""Verify that the `approve` and `transferFrom` functions correctly handle allowances and do not allow unauthorized transfers.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize any loops or operations that could lead to high gas costs, particularly in functions like `_freeFromEscrow` and `_marketLockupFor`."",
        ""Ensure that storage variables are used efficiently and that unnecessary reads/writes are minimized.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Review the contract to ensure it does not interact with liquidity pools or AMMs in a way that could lead to manipulation or impermanent loss.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Ensure that the contract does not have any functions that could be exploited via flash loans, particularly in functions that transfer or lock/unlock funds.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Verify that the contract does not rely on external oracles for critical operations, such as determining expiration times or balances.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Ensure that the contract does not include any governance or voting mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Verify that the contract does not include any staking or reward mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the tokenomics of the contract to ensure there are no inflationary or deflationary risks.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Ensure that the contract does not have any functions that are susceptible to front-running, particularly in functions that transfer or lock/unlock funds.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Verify that the contract does not have any mechanisms that could allow for fund drainage or malicious exits.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Ensure that the contract does not interact with other chains in a way that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the contract includes appropriate fallback functions and emergency stop mechanisms to halt operations if necessary.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named 'FETH' (Foundation Wrapped Ether). It appears to be a token contract that wraps Ether (ETH) and allows for locking and unlocking of funds, with specific permissions and restrictions. The contract uses OpenZeppelin libraries for safe math operations and address utilities, and it includes custom error handling for various scenarios."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FETH"",
    ""Purpose"": ""The contract is designed to wrap Ether (ETH) and provide functionalities for locking, unlocking, and transferring funds. It also includes mechanisms for managing allowances and escrow accounts, with specific permissions for a designated market contract."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/math/Math.sol"",
        ""./libraries/LockedBalance.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""accountToInfo"",
        ""Type"": ""mapping(address => AccountInfo)"",
        ""Purpose"": ""Stores account information including freed balance, lockup start index, and lockups.""
      },
      {
        ""Name"": ""lockupDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the lockup period.""
      },
      {
        ""Name"": ""lockupInterval"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Interval for lockup periods.""
      },
      {
        ""Name"": ""foundationMarket"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the designated market contract that has special permissions.""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""uint8"",
        ""Purpose"": ""Number of decimal places for the token.""
      },
      {
        ""Name"": ""name"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the token.""
      },
      {
        ""Name"": ""symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Symbol of the token.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""approve"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a spender to spend a certain amount of tokens on behalf of the caller."",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits ETH into the contract and assigns it to the caller's account."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""depositFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits ETH into the contract and assigns it to a specified account."",
        ""Parameters"": [""address account""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketChangeLockup"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Changes the lockup status of funds for a specified account."",
        ""Parameters"": [""address unlockFrom"", ""uint256 unlockExpiration"", ""uint256 unlockAmount"", ""address lockupFor"", ""uint256 lockupAmount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketLockupFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Locks up funds for a specified account."",
        ""Parameters"": [""address account"", ""uint256 amount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketUnlockFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlocks funds for a specified account."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws funds from a specified account."",
        ""Parameters"": [""address from"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawLocked"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws locked funds from a specified account."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers tokens from the caller's account to a specified recipient."",
        ""Parameters"": [""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers tokens from one account to another, with allowance checks."",
        ""Parameters"": [""address from"", ""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""withdrawAvailableBalance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws the available balance from the caller's account."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws funds from a specified account to a specified recipient."",
        ""Parameters"": [""address from"", ""address payable to"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyFoundationMarket"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions that can only be called by the designated market contract."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The contract interacts with the 'foundationMarket' address, which is a designated market contract with special permissions."",
    ""It uses OpenZeppelin libraries for safe math operations and address utilities.""
  ],
  ""SpecialMechanisms"": [
    ""The contract implements a lockup mechanism where funds can be locked for a specified duration and then unlocked after expiration."",
    ""It includes an allowance mechanism similar to ERC20 tokens, allowing accounts to permit others to spend tokens on their behalf."",
    ""The contract uses a custom error handling system to revert transactions with specific error messages for various scenarios.""
  ],
  ""Questions"": [
    ""What is the exact purpose of the 'lockupDuration' and 'lockupInterval'? How are they calculated and used in the contract?"",
    ""How does the 'LockedBalance.Lockups' library work, and what are its key functionalities?"",
    ""Are there any specific security considerations or potential vulnerabilities in the way the contract handles locked funds and allowances?"",
    ""What is the role of the 'foundationMarket' contract, and how does it interact with the FETH contract?"",
    ""How is the 'expiration' calculated in the '_marketLockupFor' function, and what ensures it is within acceptable bounds?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in ETH Withdrawal Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (`marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawAvailableBalance`, `withdrawFrom`) use `sendValue` to transfer ETH, which can potentially lead to reentrancy attacks if the recipient is a malicious contract. Although `sendValue` limits the gas forwarded, it does not entirely prevent reentrancy."",
      ""Impact"": ""An attacker could exploit this to re-enter the contract and manipulate its state, potentially draining funds or causing unexpected behavior."",
      ""Location"": ""Functions: `marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawAvailableBalance`, `withdrawFrom`""
    },
    {
      ""Issue"": ""Unchecked External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (`marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawAvailableBalance`, `withdrawFrom`, `marketChangeLockup`) perform external calls without checking return values or validating inputs, which could lead to silent failures or inconsistent state."",
      ""Impact"": ""Failed transfers or invalid inputs could result in loss of funds, incorrect accounting, or unauthorized access to locked funds."",
      ""Location"": ""Functions: `marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawAvailableBalance`, `withdrawFrom`, `marketChangeLockup`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations in functions like `_marketLockupFor`, `_deductBalanceFrom`, `_freeFromEscrow`, and others use `unchecked` blocks or lack explicit overflow checks, which could lead to incorrect calculations if not carefully managed."",
      ""Impact"": ""Integer overflow/underflow could result in incorrect balance deductions, lockup durations, or other state inconsistencies, potentially leading to loss of funds."",
      ""Location"": ""Functions: `_marketLockupFor`, `_deductBalanceFrom`, `_freeFromEscrow`, `_marketUnlockFor`, `_removeFromLockedBalance`""
    },
    {
      ""Issue"": ""Unbounded Loops in Escrow Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `_freeFromEscrow` and `_marketLockupFor` iterate over escrow entries, which could grow unbounded over time, leading to high gas consumption or denial of service."",
      ""Impact"": ""Users may be unable to interact with the contract if gas costs exceed block limits, potentially locking funds or causing transaction failures."",
      ""Location"": ""Functions: `_freeFromEscrow`, `_marketLockupFor`""
    },
    {
      ""Issue"": ""Insufficient Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `depositFor`, `marketChangeLockup`, and `_marketLockupFor` lack validation for critical inputs (e.g., zero addresses, expiration timestamps, or `msg.value`), which could lead to unintended behavior or loss of funds."",
      ""Impact"": ""Invalid inputs could result in incorrect lockup durations, loss of funds, or other state inconsistencies."",
      ""Location"": ""Functions: `depositFor`, `marketChangeLockup`, `_marketLockupFor`, `_removeFromLockedBalance`""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `_deductAllowanceFrom` and `withdrawAvailableBalance` modify state (e.g., allowances or balances) without emitting events, reducing transparency and auditability."",
      ""Impact"": ""Difficulty in tracking state changes off-chain, potentially leading to unnoticed issues or reduced accountability."",
      ""Location"": ""Functions: `_deductAllowanceFrom`, `withdrawAvailableBalance`""
    },
    {
      ""Issue"": ""Insufficient Gas Stipend for External Calls"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions using `sendValue` forward a fixed 2300 gas stipend, which might be insufficient for complex recipient contract logic, leading to failed transactions or stuck funds."",
      ""Impact"": ""Poor user experience or potential fund loss if recipient contracts require more gas than provided."",
      ""Location"": ""Functions: `marketWithdrawFrom`, `marketWithdrawLocked`, `withdrawAvailableBalance`, `withdrawFrom`""
    },
    {
      ""Issue"": ""Potential Front-Running in `approve` and `transferFrom`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `approve` and `transferFrom` functions lack protections against front-running, which could allow attackers to manipulate allowances or state changes."",
      ""Impact"": ""Unauthorized fund transfers or state manipulation if allowances are exploited."",
      ""Location"": ""Functions: `approve`, `transferFrom`""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 8
}",396.028516292572,91409.0,24.0,"### **[M-03] Approve race condition in FETH**

**Report Description**:
The `approve()` function in `FETH.sol` is vulnerable to a front-running attack, commonly known as the ""Multiple Withdrawal Attack."" This occurs when an attacker exploits the race condition between the approval and transfer of tokens. The contract lacks protections against this attack, such as reducing the spender's allowance to 0 before setting a new value or using OpenZeppelin's `decreaseAllowance` and `increaseAllowance` functions. Although the risk is limited in specific scenarios, it is worth addressing to prevent potential future exploits.

**Match in Response List**:
Matches with the issue titled **""Potential Front-Running in `approve` and `transferFrom`""**.

**Validation**:
**Correct**. The response accurately identifies the front-running vulnerability in the `approve` and `transferFrom` functions. It correctly explains the risks associated with manipulating allowances, which aligns with the issue described in the report. The response also implicitly acknowledges the need for mitigations, such as reducing allowances to 0 before setting a new value, which is consistent with Solidity best practices.

---

### **[M-09] Missing receiver validation in withdrawFrom**

**Report Description**:
The `withdrawFrom` function in `FETH.sol` does not validate the `to` parameter, which represents the recipient address. If `to` is the zero address, funds could be permanently lost. This oversight could lead to unintended loss of funds, especially if the function is called with invalid or malicious inputs.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing receiver validation in the `withdrawFrom` function. This is a critical oversight, as failing to validate the recipient address can result in irreversible loss of funds. The response list focuses on other issues, such as reentrancy and unchecked external calls, but does not cover this specific vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-03] Approve race condition in FETH**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-09] Missing receiver validation in withdrawFrom**

---

### **Conclusion**

The response list effectively addresses the front-running vulnerability in the `approve` function but fails to identify the critical issue of missing receiver validation in the `withdrawFrom` function. This gap highlights the need for a more comprehensive review of input validation mechanisms in the contract.","```
1. Potential Front-Running in `approve` and `transferFrom`
```",0.125
NFTMarketFees.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867,219,"[M-08] Primary seller can avoid paying the primary fee

Submitted by pedroais, also found by leastwood and WatchPug
A primary seller can circumvent the 15% fee and pay 5% as a secondary seller.
Context

The Foundation protocol charges a 15% fee if the sale is a primary sale and 5% if it's a secondary sale. https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L40
There are 2 conditions that must be met for a sale to be considered primary:
The seller is one of the creators in the NFT metadata.
It's the first time this NFT is sold on the foundation protocol.
https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L188
  [M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low

Submitted by cmichel
NFTMarketFees.sol#L78
The creator payouts are capped at MAX_ROYALTY_RECIPIENTS_INDEX. It's currently set to 4 and only 5 creators are paid out. Other creators are ignored.

",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  
  uint256[3] private __gap_was_fees;

  
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; 
  
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; 
  
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; 

  
  
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        
        uint256 totalShares;
        unchecked {
          
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              
              maxCreatorIndex = 0;
              break;
            }
            
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        
        creatorRev = price - foundationFee;
      } else {
        
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  
  uint256[1000] private __gap;
}",1195,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in the `_distributeFunds` function, especially around the `_sendValueWithFallbackWithdraw` calls."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, particularly in fee calculations."",
        ""Ensure that external calls to `_sendValueWithFallbackWithdraw` are checked for success and handle failures gracefully.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-721 standards, especially in interactions with the `IERC721` interface."",
        ""Verify that the fee distribution logic complies with any relevant legal or regulatory requirements.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `_distributeFunds` for handling multiple creator recipients, ensuring it correctly distributes shares and handles edge cases."",
        ""Audit the `_getFees` function to ensure it correctly calculates fees for both primary and secondary sales.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Inspect the `_sendValueWithFallbackWithdraw` function to ensure it safely interacts with external contracts and handles fallback mechanisms correctly."",
        ""Verify that the `FoundationTreasuryNode` contract is securely managed and that interactions with it are safe.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only authorized entities can call critical functions like `_distributeFunds` and `getFeesAndRecipients`."",
        ""Verify that the `Initializable` contract is correctly used to manage upgradeable state variables.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Optimize the loop in `_distributeFunds` that iterates over creator recipients to reduce gas costs."",
        ""Review the storage usage and identify opportunities to reduce gas consumption, especially in the `_nftContractToTokenIdToFirstSaleCompleted` mapping.""
      ]
    },
    {
      ""Area"": ""Edge Cases"",
      ""Tasks"": [
        ""Test the contract behavior when the creator fee exceeds the basis points or when there are no creator recipients."",
        ""Verify that the contract handles cases where the `creatorShares` array is empty or contains invalid values.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that there are mechanisms in place to halt fee distribution in case of an emergency or detected vulnerability."",
        ""Verify that the contract can safely recover from failed transactions or external call failures.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code snippet is an abstract Solidity contract named `NFTMarketFees`. It is part of a larger NFT marketplace system, handling the distribution of fees and royalties for NFT sales. The contract inherits from multiple other contracts and uses several imported libraries and interfaces. The primary function of this contract is to calculate and distribute fees to the foundation, creators, and sellers during NFT transactions."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketFees"",
    ""Purpose"": ""To manage the distribution of fees and royalties in an NFT marketplace, ensuring that the foundation, creators, and sellers receive their respective shares during NFT transactions."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Constants"", ""Initializable"", ""FoundationTreasuryNode"", ""NFTMarketCore"", ""NFTMarketCreators"", ""SendValueWithFallbackWithdraw""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""./Constants.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketCreators.sol"",
        ""./SendValueWithFallbackWithdraw.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_fees"",
        ""Type"": ""uint256[3]"",
        ""Purpose"": ""Reserved storage space for future upgrades, previously used for fees.""
      },
      {
        ""Name"": ""_nftContractToTokenIdToFirstSaleCompleted"",
        ""Type"": ""mapping(address => mapping(uint256 => bool))"",
        ""Purpose"": ""Tracks whether the first sale of an NFT has been completed.""
      },
      {
        ""Name"": ""CREATOR_ROYALTY_BASIS_POINTS"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Basis points for creator royalties, set to 1000 (10%).""
      },
      {
        ""Name"": ""PRIMARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Basis points for the foundation fee on the primary sale, set to 1500 (15%).""
      },
      {
        ""Name"": ""SECONDARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Basis points for the foundation fee on secondary sales, set to 500 (5%).""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Reserved storage space for future upgrades.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""_distributeFunds"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Distributes funds to the foundation, creators, and seller based on the NFT sale."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address payable seller"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""uint256 creatorFee"", ""uint256 ownerRev""]
      },
      {
        ""Name"": ""getFeesAndRecipients"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the calculated fees and recipients for a given NFT sale."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""uint256 creatorRev"", ""address payable[] memory creatorRecipients"", ""uint256[] memory creatorShares"", ""uint256 ownerRev"", ""address payable owner""]
      },
      {
        ""Name"": ""_getFees"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Calculates the fees and recipients for a given NFT sale."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address payable seller"", ""uint256 price""],
        ""Returns"": [""uint256 foundationFee"", ""address payable[] memory creatorRecipients"", ""uint256[] memory creatorShares"", ""uint256 creatorRev"", ""address payable ownerRevTo"", ""uint256 ownerRev""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The contract interacts with the OpenZeppelin `Initializable` contract for upgradeable contracts."",
    ""It uses the `IERC721` interface from OpenZeppelin for ERC721 token interactions."",
    ""The contract relies on the `FoundationTreasuryNode` for treasury management."",
    ""It uses `SendValueWithFallbackWithdraw` for handling value transfers with fallback mechanisms.""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses a reserved storage gap (`__gap`) for future upgrades, a common pattern in upgradeable contracts."",
    ""It employs a mapping to track whether the first sale of an NFT has been completed (`_nftContractToTokenIdToFirstSaleCompleted`)."",
    ""The contract calculates fees using basis points, a standard method for representing percentages in financial calculations.""
  ],
  ""Questions"": [
    ""What is the purpose of the `MAX_ROYALTY_RECIPIENTS_INDEX` constant, and how is it determined?"",
    ""How is the `_getCreatorPaymentInfo` function implemented, and what does it return?"",
    ""Are there any specific gas limits or considerations for the `_sendValueWithFallbackWithdraw` function?"",
    ""How does the contract handle edge cases, such as when the creator fee exceeds the basis points or when there are no creator recipients?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Risk"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function is used multiple times in the `_distributeFunds` function to send Ether to various recipients. If any of these recipients are malicious contracts, they could potentially re-enter the `_distributeFunds` function before it completes, leading to reentrancy attacks."",
      ""Impact"": ""Reentrancy attacks could allow an attacker to drain funds from the contract or manipulate the fee distribution logic."",
      ""Location"": ""_distributeFunds function, lines with `_sendValueWithFallbackWithdraw` calls""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""High"",
      ""Description"": ""The code performs arithmetic operations without explicit checks for overflow or underflow. Although Solidity 0.8.0 has built-in overflow checks, it's still a good practice to ensure that arithmetic operations are safe, especially when dealing with financial calculations."",
      ""Impact"": ""If an overflow or underflow occurs, it could lead to incorrect fee calculations, potentially causing financial losses or unexpected behavior in the contract."",
      ""Location"": ""_distributeFunds and _getFees functions""
    },
    {
      ""Issue"": ""Unbounded Loop in `_distributeFunds`"",
      ""Severity"": ""High"",
      ""Description"": ""The loop in the `_distributeFunds` function that iterates over `creatorRecipients` does not have a bound check for the array length. If the array length is unexpectedly large, it could lead to excessive gas consumption or even out-of-gas errors."",
      ""Impact"": ""Excessive gas consumption or transaction failures due to out-of-gas errors, which could disrupt the distribution of funds."",
      ""Location"": ""_distributeFunds function, loop over `creatorRecipients`""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_distributeFunds` and `_getFees` functions do not validate the input parameters such as `nftContract`, `tokenId`, `seller`, and `price`. This could lead to unexpected behavior if invalid or malicious inputs are provided."",
      ""Impact"": ""Invalid inputs could cause the contract to behave unexpectedly, potentially leading to financial losses or incorrect fee calculations."",
      ""Location"": ""_distributeFunds and _getFees functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Fee Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The fee calculations in the `_getFees` function involve arithmetic operations that could potentially lead to integer overflow if the `price` is very high. For example, `foundationFee = (price * fee) / BASIS_POINTS` could overflow if `price * fee` exceeds the maximum value of `uint256`."",
      ""Impact"": ""An integer overflow could result in incorrect fee calculations, leading to financial losses or incorrect distribution of funds."",
      ""Location"": ""_getFees function, line where `foundationFee = (price * fee) / BASIS_POINTS` is calculated""
    },
    {
      ""Issue"": ""Inconsistent Fee Calculation Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""The fee calculation logic in `_getFees` uses different basis points for primary and secondary sales (`PRIMARY_FOUNDATION_FEE_BASIS_POINTS` and `SECONDARY_FOUNDATION_FEE_BASIS_POINTS`). However, the logic for determining whether a sale is primary or secondary is based on the `_nftContractToTokenIdToFirstSaleCompleted` mapping, which could be manipulated."",
      ""Impact"": ""Inconsistent or incorrect fee calculations could lead to financial losses or disputes between parties involved in the transaction."",
      ""Location"": ""_getFees function""
    },
    {
      ""Issue"": ""Hardcoded Fee Values"",
      ""Severity"": ""Low"",
      ""Description"": ""The fee values `CREATOR_ROYALTY_BASIS_POINTS`, `PRIMARY_FOUNDATION_FEE_BASIS_POINTS`, and `SECONDARY_FOUNDATION_FEE_BASIS_POINTS` are hardcoded in the contract. This reduces flexibility and requires a contract upgrade to change these values."",
      ""Impact"": ""Inability to adjust fee rates without deploying a new contract could lead to suboptimal fee structures or missed opportunities for revenue optimization."",
      ""Location"": ""Constants declared at the top of the contract""
    },
    {
      ""Issue"": ""Storage Gap for Upgradeable Contracts"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract includes a storage gap (`__gap`) to reserve storage slots for future upgrades. However, the gap size of 1000 might be excessive or insufficient depending on future needs, and it does not provide clear guidance on how to manage storage layout during upgrades."",
      ""Impact"": ""Incorrect management of storage gaps could lead to storage collisions during contract upgrades, potentially causing data corruption or unexpected behavior."",
      ""Location"": ""`uint256[1000] private __gap;` at the end of the contract""
    },
    {
      ""Issue"": ""Lack of Event Logging"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not emit events for important actions such as fee distribution or first sale completion. Event logging is crucial for transparency and debugging purposes."",
      ""Impact"": ""Lack of event logging makes it difficult to track and audit contract actions, potentially leading to disputes or difficulties in debugging issues."",
      ""Location"": ""Entire contract""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 9
}",378.3739409446716,45285.0,24.0,"### **[M-08] Primary seller can avoid paying the primary fee**

**Report Description**:
The Foundation protocol charges a 15% fee for primary sales and a 5% fee for secondary sales. A primary seller can circumvent the 15% fee by manipulating the conditions that determine whether a sale is primary or secondary. Specifically, the seller can avoid being identified as a creator in the NFT metadata or ensure that the NFT is not marked as a first sale on the Foundation protocol. This allows the seller to pay the lower 5% fee instead of the intended 15% fee, leading to a loss of revenue for the protocol.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of primary sellers circumventing the 15% fee. None of the findings in the response list discuss the conditions for determining primary vs. secondary sales or the potential manipulation of these conditions. This issue is entirely missed in the response list.

---

### **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Report Description**:
The `MAX_ROYALTY_RECIPIENTS_INDEX` is set to 4, which means only 5 creators can be paid out. Any additional creators beyond this limit are ignored. This limitation could lead to unfair distribution of royalties, especially in cases where an NFT has more than 5 creators. The issue is located in the `NFTMarketFees.sol` contract.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of the `MAX_ROYALTY_RECIPIENTS_INDEX` being set too low. None of the findings in the response list discuss the limitation on the number of royalty recipients or the potential impact on creators. This issue is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-08] Primary seller can avoid paying the primary fee**
- **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

---

The response list fails to address the two issues from the issue report. Both issues involve significant vulnerabilities that could lead to financial losses or unfair practices, and they should be included in any comprehensive security review.","```
None.
```",0.0
