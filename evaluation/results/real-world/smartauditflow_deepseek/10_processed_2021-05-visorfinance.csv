nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}

",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using timeLockERC721() with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using timeUnlockERC721().  This is possible because transferERC721() does all the timelock checks on expires/block.timestamp and recipient/msg.sender as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()).  [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval.  [H-03] Approval for NFT transfers is not removed after transfer

Submitted by cmichel, also found by gpersoon, and pauliax
The Visor.transferERC721 does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
 [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack
The function _removeNft uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time.  [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2.  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).  [M-03] timelockERC721Keys could exceed the block size limit
On line 504 of Visor.sol, looping through the timelockERC721Keys could exceed the block size limit
Recommend transfer by index instead of token ID

",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";




contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    

    
    
    
    
    
    
    
    
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    

    
    
    
    
    
    
    
    
    
    
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

    
    
    
    
    
    
    
    
    
    
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }

    
    
    
    
    
    
    
    
    
    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    
    
    
    
    
    
    
    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    
    
    
    
    
    
    
    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    
    
    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }

    
    
    
    
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    
    
    
    
    
    
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    
    
    
    
    
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    
    
    
    
    
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    
    
    
    
    
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity smart contract named 'Visor' that serves as a universal vault for managing ERC20 and ERC721 tokens. It includes functionalities for locking, unlocking, and transferring tokens, as well as timelock mechanisms for both token types. The contract inherits from multiple interfaces and libraries to implement these features."", 'IdentifyingKeyComponents': {'ContractName': 'Visor', 'Purpose': 'The contract acts as a universal vault for managing ERC20 and ERC721 tokens, providing functionalities for locking, unlocking, transferring, and timelocking tokens. It also supports delegated transfers and rage quit mechanisms.', 'InheritanceAndImports': {'InheritsFrom': ['IUniversalVault', 'EIP712', 'ERC1271', 'OwnableERC721', 'Initializable', 'IERC721Receiver'], 'Imports': ['SafeMath', 'IERC20', 'IERC721', 'IERC721Receiver', 'Initializable', 'EnumerableSet', 'Address', 'TransferHelper', 'EIP712', 'ERC1271', 'OwnableERC721', 'IRageQuit', 'IUniversalVault', 'IVisorService']}, 'StateVariables': [{'Name': 'RAGEQUIT_GAS', 'Type': 'uint256', 'Purpose': 'Constant gas limit for rage quit function.'}, {'Name': 'LOCK_TYPEHASH', 'Type': 'bytes32', 'Purpose': 'EIP-712 type hash for lock operations.'}, {'Name': 'UNLOCK_TYPEHASH', 'Type': 'bytes32', 'Purpose': 'EIP-712 type hash for unlock operations.'}, {'Name': 'VERSION', 'Type': 'string', 'Purpose': 'Version identifier for the contract.'}, {'Name': '_nonce', 'Type': 'uint256', 'Purpose': 'Nonce for replay protection in signed messages.'}, {'Name': '_locks', 'Type': 'mapping(bytes32 => LockData)', 'Purpose': 'Mapping to store lock data by lock ID.'}, {'Name': '_lockSet', 'Type': 'EnumerableSet.Bytes32Set', 'Purpose': 'Set of active lock IDs.'}, {'Name': 'uri', 'Type': 'string', 'Purpose': 'URI for the contract metadata.'}, {'Name': 'nfts', 'Type': 'Nft[]', 'Purpose': 'Array to store NFT information.'}, {'Name': 'nftApprovals', 'Type': 'mapping(bytes32 => bool)', 'Purpose': 'Mapping to store NFT transfer approvals.'}, {'Name': 'erc20Approvals', 'Type': 'mapping(bytes32 => uint256)', 'Purpose': 'Mapping to store ERC20 transfer approvals.'}, {'Name': 'timelockERC20s', 'Type': 'mapping(bytes32 => TimelockERC20)', 'Purpose': 'Mapping to store timelocked ERC20 tokens.'}, {'Name': 'timelockERC20Keys', 'Type': 'mapping(address => bytes32[])', 'Purpose': 'Mapping to store keys for timelocked ERC20 tokens by token address.'}, {'Name': 'timelockERC20Balances', 'Type': 'mapping(address => uint256)', 'Purpose': 'Mapping to store balances of timelocked ERC20 tokens by token address.'}, {'Name': 'timelockERC721s', 'Type': 'mapping(bytes32 => TimelockERC721)', 'Purpose': 'Mapping to store timelocked ERC721 tokens.'}, {'Name': 'timelockERC721Keys', 'Type': 'mapping(address => bytes32[])', 'Purpose': 'Mapping to store keys for timelocked ERC721 tokens by NFT contract address.'}], 'FunctionsAndModifiers': [{'Name': 'initializeLock', 'Visibility': 'external', 'Purpose': 'Initializes the lock mechanism.', 'Parameters': [], 'Returns': []}, {'Name': 'initialize', 'Visibility': 'external', 'Purpose': 'Initializes the contract and sets the NFT owner.', 'Parameters': [], 'Returns': []}, {'Name': 'lock', 'Visibility': 'external', 'Purpose': 'Locks a specified amount of ERC20 tokens.', 'Parameters': ['address token', 'uint256 amount', 'bytes calldata permission'], 'Returns': []}, {'Name': 'unlock', 'Visibility': 'external', 'Purpose': 'Unlocks a specified amount of ERC20 tokens.', 'Parameters': ['address token', 'uint256 amount', 'bytes calldata permission'], 'Returns': []}, {'Name': 'rageQuit', 'Visibility': 'external', 'Purpose': 'Allows the owner to forcibly unlock tokens and notify the delegate.', 'Parameters': ['address delegate', 'address token'], 'Returns': ['bool notified', 'string memory error']}, {'Name': 'transferERC20', 'Visibility': 'external', 'Purpose': 'Transfers ERC20 tokens to a specified address.', 'Parameters': ['address token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'approveTransferERC20', 'Visibility': 'external', 'Purpose': 'Approves a delegate to transfer a specified amount of ERC20 tokens.', 'Parameters': ['address token', 'address delegate', 'uint256 amount'], 'Returns': []}, {'Name': 'delegatedTransferERC20', 'Visibility': 'external', 'Purpose': 'Allows a delegate to transfer approved ERC20 tokens.', 'Parameters': ['address token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'transferETH', 'Visibility': 'external', 'Purpose': 'Transfers ETH to a specified address.', 'Parameters': ['address to', 'uint256 amount'], 'Returns': []}, {'Name': 'approveTransferERC721', 'Visibility': 'external', 'Purpose': 'Approves a delegate to transfer a specified ERC721 token.', 'Parameters': ['address delegate', 'address nftContract', 'uint256 tokenId'], 'Returns': []}, {'Name': 'transferERC721', 'Visibility': 'external', 'Purpose': 'Transfers an ERC721 token to a specified address.', 'Parameters': ['address to', 'address nftContract', 'uint256 tokenId'], 'Returns': []}, {'Name': 'onERC721Received', 'Visibility': 'external', 'Purpose': 'Handles the receipt of an ERC721 token.', 'Parameters': ['address operator', 'address from', 'uint256 tokenId', 'bytes calldata'], 'Returns': ['bytes4']}, {'Name': 'timeLockERC721', 'Visibility': 'public', 'Purpose': 'Locks an ERC721 token for a specified recipient with an expiration time.', 'Parameters': ['address recipient', 'address nftContract', 'uint256 tokenId', 'uint256 expires'], 'Returns': []}, {'Name': 'timeUnlockERC721', 'Visibility': 'public', 'Purpose': 'Unlocks a timelocked ERC721 token if the expiration time has passed.', 'Parameters': ['address recipient', 'address nftContract', 'uint256 tokenId', 'uint256 expires'], 'Returns': []}, {'Name': 'timeLockERC20', 'Visibility': 'public', 'Purpose': 'Locks an ERC20 token for a specified recipient with an expiration time.', 'Parameters': ['address recipient', 'address token', 'uint256 amount', 'uint256 expires'], 'Returns': []}, {'Name': 'timeUnlockERC20', 'Visibility': 'public', 'Purpose': 'Unlocks a timelocked ERC20 token if the expiration time has passed.', 'Parameters': ['address recipient', 'address token', 'uint256 amount', 'uint256 expires'], 'Returns': []}]}, 'ExternalInteractions': ['IERC20', 'IERC721', 'IRageQuit', 'TransferHelper', 'EIP712', 'ERC1271', 'OwnableERC721', 'IUniversalVault', 'IVisorService'], 'SpecialMechanisms': ['EIP-712 typed data signing for secure permission handling.', 'Timelock mechanisms for ERC20 and ERC721 tokens.', 'Delegate approvals for token transfers.', 'Rage quit functionality for forced token unlocking.'], 'Questions': ['How is the `RAGEQUIT_GAS` value determined? Is it sufficient for all cases?', 'Are there any safeguards against reentrancy attacks in the `lock` and `unlock` functions?', 'How is the `uri` variable intended to be used?', 'Is there a mechanism to handle failed `rageQuit` notifications?', 'Are there any gas optimizations that could be applied to the `_removeNft` function?']}","{'Findings': [{'Issue': 'Reentrancy Risk in ERC20 Transfer Functions', 'Severity': 'High', 'Description': 'Multiple functions (`transferERC20`, `delegatedTransferERC20`, `timeUnlockERC20`, `timeUnlockERC721`) do not follow the checks-effects-interactions pattern, making them vulnerable to reentrancy attacks. External calls are made before updating the internal state, which could allow an attacker to recursively call these functions and drain funds.', 'Impact': 'An attacker could exploit this vulnerability to drain funds from the contract by recursively calling these functions before the state is updated.', 'Location': 'Functions: `transferERC20`, `delegatedTransferERC20`, `timeUnlockERC20`, `timeUnlockERC721`'}, {'Issue': 'Unrestricted Approval in ERC20 and ERC721 Functions', 'Severity': 'Medium', 'Description': 'The `approveTransferERC20` and `approveTransferERC721` functions allow the owner to set unlimited approvals for ERC20 and ERC721 tokens without any restrictions. This could lead to unintended transfers if the approved delegate is compromised.', 'Impact': ""If an approved delegate's account is compromised, an attacker could transfer all approved tokens or NFTs without further authorization."", 'Location': 'Functions: `approveTransferERC20`, `approveTransferERC721`'}, {'Issue': 'Lack of Input Validation in TimeLock Functions', 'Severity': 'Medium', 'Description': 'The `timeLockERC20` and `timeLockERC721` functions do not validate the `recipient` address or other input parameters. This could lead to tokens being locked to an invalid or unintended address, resulting in permanent loss of access.', 'Impact': 'Tokens or NFTs could be locked permanently if an invalid recipient address is provided.', 'Location': 'Functions: `timeLockERC20`, `timeLockERC721`'}, {'Issue': 'Potential Gas Limit Issues in `rageQuit` Function', 'Severity': 'Medium', 'Description': 'The `rageQuit` function uses a fixed gas limit for external calls, which could lead to out-of-gas errors if the external contract requires more gas than the provided limit. This could leave the contract in an inconsistent state.', 'Impact': 'The `rageQuit` function may fail to execute properly, potentially leaving the contract in an inconsistent state.', 'Location': 'Function: `rageQuit`'}, {'Issue': 'Unrestricted `setURI` Function', 'Severity': 'Low', 'Description': 'The `setURI` function allows the owner to change the URI without any restrictions or validation. This could be used to set malicious or misleading URIs.', 'Impact': ""The contract's URI could be set to a malicious or misleading value, affecting its usability or reputation."", 'Location': 'Function: `setURI`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': ""Several state-changing functions (e.g., `initialize`, `_removeNft`, `approveTransferERC20`, `approveTransferERC721`) do not emit events, making it difficult to track changes and audit the contract's behavior."", 'Impact': 'Reduced transparency and auditability of the contract.', 'Location': 'Functions: `initialize`, `_removeNft`, `approveTransferERC20`, `approveTransferERC721`'}, {'Issue': 'Potential Front-Running in TimeLock and Approval Functions', 'Severity': 'Low', 'Description': 'Functions like `timeLockERC20`, `timeLockERC721`, `approveTransferERC20`, and `approveTransferERC721` are susceptible to front-running attacks, where an attacker could manipulate the state before the original transaction is processed.', 'Impact': 'An attacker could manipulate the locking or approval of tokens or NFTs, leading to potential loss of funds or incorrect state updates.', 'Location': 'Functions: `timeLockERC20`, `timeLockERC721`, `approveTransferERC20`, `approveTransferERC721`'}, {'Issue': 'Potential Integer Overflow in `timeLockERC20` and `_removeNft`', 'Severity': 'Low', 'Description': 'The `timeLockERC20` function and `_removeNft` function may encounter integer overflow issues if not handled properly, especially since Solidity 0.7.6 does not include built-in overflow checks.', 'Impact': 'Integer overflow could result in incorrect token balances or other state inconsistencies.', 'Location': 'Functions: `timeLockERC20`, `_removeNft`'}], 'IssueNumber': 70, 'OutputList': 8}",584.7457799911499,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:  
If a timelocked NFT is transferred out of the vault using `transferERC721()` without explicitly unlocking it via `timeUnlockERC721()`, the `timelockERC721s[key]` entry for that NFT tokenID is not deleted. This omission can cause the NFT to become permanently stuck in the vault if it is moved back in, as the timelock entry remains active.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of missing deletion of `timelockERC721s[key]` in `transferERC721()` is not covered, leading to a potential permanent lock of NFTs.

---

#### **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**

**Report Description**:  
NFT transfer approvals set in `approveTransferERC721()` are never reset to `false`, and there is no mechanism to revoke such approvals. This oversight could lead to unauthorized transfers and loss of NFTs if the approved delegate is compromised.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Approval in ERC20 and ERC721 Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unrestricted approvals but focuses on the risk of compromised delegates rather than the inability to revoke approvals. The critical detail of missing revocation functionality is not addressed.

---

#### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:  
The `Visor.transferERC721` function does not reset the approval for the NFT after a transfer. This allows an approved delegate to move the NFT out of the contract multiple times, even if the NFT is re-deposited by a new owner.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Approval in ERC20 and ERC721 Functions""**.

**Validation**:  
**Partially Correct**. The response highlights the risk of unrestricted approvals but does not specifically address the failure to reset approvals after a transfer, which is the core issue here.

---

#### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:  
The `_removeNft` function uses an unbounded loop to iterate through the `nfts` array, which could consume excessive gas if the array is large. A malicious user could exploit this by repeatedly calling `onERC721Received` to grow the array, causing legitimate transactions to fail due to gas limits.

**Match in Response List**:  
Matches with the issue titled **""Potential Gas Limit Issues in `rageQuit` Function""**.

**Validation**:  
**Incorrect**. The response discusses gas limit issues in the `rageQuit` function but does not address the unbounded loop in `_removeNft` or the potential griefing attack.

---

#### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:  
The `timeLockERC20()` function does not handle the return value of `transferFrom`. Some ERC20 implementations return `false` on failure instead of reverting, which could lead to silent failures and fund loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The risk of unhandled return values in `transferFrom` is not covered.

---

#### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:  
The `transferERC721` function does not delete the `timelockERC721s[key]` entry for the transferred NFT, unlike `timeUnlockERC721`. This could lead to stale timelock entries and potential misuse of old keys.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The failure to clean `timelockERC721s` in `transferERC721` is not covered.

---

#### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:  
Looping through `timelockERC721Keys` in `Visor.sol` could exceed the block size limit, especially if the array grows too large. This could cause transactions to fail.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The potential block size limit problem with `timelockERC721Keys` is not covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**  
- **[H-03] Approval for NFT transfers is not removed after transfer**

**Missed Issues from Issue Report**:  
- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**  
- **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**  
- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**  
- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**  
- **[M-03] `timelockERC721Keys` could exceed the block size limit**

---

The response list fails to address several critical issues, particularly those related to timelock management, unbounded loops, and unhandled return values. While it partially covers some issues related to approvals, the coverage is incomplete and lacks depth.","```
None.
```",0.0
