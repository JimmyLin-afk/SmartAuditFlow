nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
NestedFactory.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";

/// @title Creates, updates and destroys NestedAssets.
/// @notice Responsible for the business logic of the protocol and interaction with operators
contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Supported operators by the factory contract
    bytes32[] private operators;

    /// @dev Current feeSplitter contract/address
    FeeSplitter public feeSplitter;

    /// @dev Current reserve contract/address
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    /// @dev Reverts the transaction if the caller is not the token owner
    /// @param _nftId The NFT Id
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    /// @dev Reverts the transaction if the nft is locked (hold by design).
    /// The block.timestamp must be greater than NFT record lock timestamp
    /// @param _nftId The NFT Id
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    /// @dev Receive function
    receive() external payable {}

    /// @notice Get the required operator addresses
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    /// @inheritdoc INestedFactory
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    /// @inheritdoc INestedFactory
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    /// @inheritdoc INestedFactory
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    /// @inheritdoc INestedFactory
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    /// @inheritdoc INestedFactory
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    /// @inheritdoc INestedFactory
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        // Amount calculation to send fees and tokens
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        // Burn NFT
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    /// @inheritdoc INestedFactory
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        // Use destroy instead if NFT has a single holding
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    /// @inheritdoc INestedFactory
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit buy orders (where the input is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _inputToken Token used to make the orders
    /// @param _inputTokenAmount Amount of input tokens to use
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent

        // If input is from the reserve, update the records
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit sell orders (where the output is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _outputToken Token received for every orders
    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return amountBought The total amount bought
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            // Submit order and update holding of spent token
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            // Under spent input amount send to fee splitter
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    /// @dev Call the operator to submit the order (commit/revert) and add the output
    /// assets to the reserve (if needed).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _nftId The nftId
    /// @param _order The order calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    /// @dev Call the operator to submit the order (commit/revert) but dont stop if
    /// the call to the operator fail. It will send the input token back to the msg.sender.
    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was
    ///        useless for the only use case (destroy).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _amountToSpend The input amount available (to spend)
    /// @param _nftId The nftId
    /// @param _order The order calldata
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    /// @dev Transfer tokens to the reserve, and compute the amount received to store
    /// in the records. We need to know the amount received in case of deflationary tokens.
    /// @param _token The token address
    /// @param _amount The amount to send to the reserve
    /// @param _nftId The Token ID to store the assets
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        // Send output to reserve
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve
    ///      or the user wallet, to the factory.
    /// @param _nftId The NFT id
    /// @param _inputToken The token to receive
    /// @param _inputTokenAmount Amount to transfer
    /// @param _fromReserve True to transfer from the reserve
    /// @return tokenUsed Token transfered (in case of ETH)
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            // Get input from reserve
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    /// @dev Send the under spent amount to the FeeSplitter without the royalties.
    ///      The ""under spent"" amount is the positive difference between the amount supposed
    ///      to be spent and the amount really spent.
    /// @param _amountToSpent The amount supposed to be spent
    /// @param _amountSpent The amount really spent
    /// @param _token The amount-related token
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset
    /// @param _amount Amount to send
    /// @param _token Token to send
    /// @param _nftId User portfolio ID used to find a potential royalties recipient
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    /// @dev Decrease the amount of a NFT holding
    /// @param _nftId The NFT id
    /// @param _inputToken The token holding
    /// @param _amount The amount to subtract from the actual holding amount
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    /// @dev Transfer a token amount from the factory to the recipient.
    ///      The token is unwrapped if WETH.
    /// @param _token The token to transfer
    /// @param _amount The amount to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        // if buy token is WETH, unwrap it instead of transferring it to the sender
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    /// @dev Transfer from factory and collect fees
    /// @param _token The token to transfer
    /// @param _amount The amount (with fees) to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    /// @dev Calculate the fees for a specific user and amount (1%)
    /// @param _user The user address
    /// @param _amount The amount
    /// @return The fees amount
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}

",5567,562,"[H-01] Copy your own portfolio to keep earning royalties

Submitted by jayjonah8
Impact

In NestedFactory.sol going through the create() function which leads to the sendFeesWithRoyalties() => addShares() function, Im not seeing any checks preventing someone from copying their own portfolio and receiving royalty shares for it and simply repeating the process over and over again.

[M-01] setReserve() can be front-run

Submitted by palina
Impact

The reserve address variable in NestedFactory.sol remains equal to 0 before the setReserve() function is called by an owner. This may lead to incorrect transfers of tokens or invalid comparison with e.g., the asset reserve (nestedRecords.getAssetReserve(_nftId) == address(reserve)), should they occur before the value for reserve was set. In addition, the immutabiliy of the reserve variable requires extra caution when setting the value.
Proof of Concept

setReserve(): NestedFactory.sol L89
 [M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged

Function `_submitInOrders`
When executing orders, the actual amountSpent + feesAmount can be lower than _inputTokenAmount, the unspent amount should be returned to the user.
However, in the current implementation, the unspent amount will be taken as part of the fee. NestedFactory.sol L285-L309
 [M-07] Ensure on-chain that cache is synced

Submitted by GreyArt, also found by WatchPug
Impact

Currently, many core operations (like `NestedFactory.create()`, `NestedFactory.swapTokenForTokens()`) are dependent on the assumption that the cache is synced before these functions are executed however this may not necessarily be the case.
 [M-08] Passing multiple ETH deposits in orders array will use the same msg.value many times

malicious user `msg.value` function `_transferInputTokens`

Contract holdings can be emptied as malicious user will do deposit/withdraw to extract value. This is possible because after transferInputTokens system uses contract balance for user's operations, assuming that equivalent value was transferred.
",5,,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";



contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    bytes32[] private operators;

    
    FeeSplitter public feeSplitter;

    
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    
    
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    
    
    
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    
    receive() external payable {}

    
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    
    
    
    
    
    
    
    
    
    
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); 

        
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    
    
    
    
    
    
    
    
    
    
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    
    
    
    
    
    
    
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    
    
    
    
    
    
    
    
    
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    
    
    
    
    
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    
    
    
    
    
    
    
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    
    
    
    
    
    
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    
    
    
    
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    
    
    
    
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    
    
    
    
    
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    
    
    
    
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    
    
    
    
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",4148,1,4,,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'NestedFactory' that inherits from multiple OpenZeppelin contracts and interfaces. It appears to manage the creation, modification, and destruction of NFTs (Non-Fungible Tokens) associated with a reserve system. The contract allows users to create NFTs, add tokens to them, swap tokens, sell tokens, and destroy NFTs. It also handles fees and royalties through a 'FeeSplitter' contract."", 'IdentifyingKeyComponents': {'ContractName': 'NestedFactory', 'Purpose': 'To manage the lifecycle of NFTs associated with a reserve system, including creation, modification, and destruction, while handling fees and royalties.', 'InheritanceAndImports': {'InheritsFrom': ['ReentrancyGuard', 'Ownable', 'MixinOperatorResolver', 'Multicall'], 'Imports': ['@openzeppelin/contracts/security/ReentrancyGuard.sol', '@openzeppelin/contracts/access/Ownable.sol', '@openzeppelin/contracts/utils/Multicall.sol', '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol', './libraries/ExchangeHelpers.sol', './libraries/OperatorHelpers.sol', './interfaces/external/IWETH.sol', './interfaces/INestedFactory.sol', './FeeSplitter.sol', './MixinOperatorResolver.sol', './NestedReserve.sol', './NestedAsset.sol', './NestedRecords.sol']}, 'StateVariables': [{'Name': 'ETH', 'Type': 'address', 'Purpose': 'Constant representing the Ethereum address.'}, {'Name': 'operators', 'Type': 'bytes32[]', 'Purpose': 'List of operator addresses.'}, {'Name': 'feeSplitter', 'Type': 'FeeSplitter', 'Purpose': 'Contract to handle fee distribution.'}, {'Name': 'reserve', 'Type': 'NestedReserve', 'Purpose': 'Contract to manage the reserve of assets.'}, {'Name': 'nestedAsset', 'Type': 'NestedAsset', 'Purpose': 'Contract to manage NFTs.'}, {'Name': 'weth', 'Type': 'IWETH', 'Purpose': 'Wrapped Ether contract.'}, {'Name': 'nestedRecords', 'Type': 'NestedRecords', 'Purpose': 'Contract to manage records of NFT holdings.'}], 'FunctionsAndModifiers': [{'Name': 'onlyTokenOwner', 'Visibility': 'modifier', 'Purpose': 'Ensures the caller is the owner of the specified NFT.', 'Parameters': ['uint256 _nftId'], 'Returns': []}, {'Name': 'isUnlocked', 'Visibility': 'modifier', 'Purpose': 'Ensures the specified NFT is not locked.', 'Parameters': ['uint256 _nftId'], 'Returns': []}, {'Name': 'create', 'Visibility': 'external', 'Purpose': 'Creates a new NFT with specified orders.', 'Parameters': ['uint256 _originalTokenId', 'IERC20 _sellToken', 'uint256 _sellTokenAmount', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'addTokens', 'Visibility': 'external', 'Purpose': 'Adds tokens to an existing NFT.', 'Parameters': ['uint256 _nftId', 'IERC20 _sellToken', 'uint256 _sellTokenAmount', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'swapTokenForTokens', 'Visibility': 'external', 'Purpose': 'Swaps tokens within an NFT.', 'Parameters': ['uint256 _nftId', 'IERC20 _sellToken', 'uint256 _sellTokenAmount', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'sellTokensToNft', 'Visibility': 'external', 'Purpose': 'Sells tokens from an NFT to another NFT.', 'Parameters': ['uint256 _nftId', 'IERC20 _buyToken', 'uint256[] memory _sellTokensAmount', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'sellTokensToWallet', 'Visibility': 'external', 'Purpose': 'Sells tokens from an NFT to a wallet.', 'Parameters': ['uint256 _nftId', 'IERC20 _buyToken', 'uint256[] memory _sellTokensAmount', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'destroy', 'Visibility': 'external', 'Purpose': 'Destroys an NFT and transfers remaining tokens to the owner.', 'Parameters': ['uint256 _nftId', 'IERC20 _buyToken', 'Order[] calldata _orders'], 'Returns': []}, {'Name': 'withdraw', 'Visibility': 'external', 'Purpose': 'Withdraws a token from an NFT.', 'Parameters': ['uint256 _nftId', 'uint256 _tokenIndex'], 'Returns': []}, {'Name': 'increaseLockTimestamp', 'Visibility': 'external', 'Purpose': 'Increases the lock timestamp of an NFT.', 'Parameters': ['uint256 _nftId', 'uint256 _timestamp'], 'Returns': []}, {'Name': 'unlockTokens', 'Visibility': 'external', 'Purpose': 'Unlocks tokens held by the contract.', 'Parameters': ['IERC20 _token'], 'Returns': []}]}, 'ExternalInteractions': [""OpenZeppelin's ReentrancyGuard, Ownable, Multicall, and SafeERC20 contracts."", 'FeeSplitter contract for handling fees.', 'NestedReserve contract for managing asset reserves.', 'NestedAsset contract for managing NFTs.', 'IWETH contract for handling Wrapped Ether.', 'NestedRecords contract for managing NFT records.'], 'SpecialMechanisms': ['Factory pattern for creating and managing NFTs.', ""Fee and royalty distribution through the 'FeeSplitter' contract."", ""Reentrancy protection using OpenZeppelin's ReentrancyGuard."", 'Multicall functionality for batch operations.'], 'Questions': [""What is the purpose of the 'operators' array and how is it used in the contract?"", ""How are fees calculated and distributed in the 'FeeSplitter' contract?"", ""What is the role of the 'MixinOperatorResolver' and how does it interact with the 'operators' array?"", ""How does the 'NestedRecords' contract manage the records of NFT holdings?"", ""Are there any potential security risks associated with the 'destroy' function or other functions that handle token transfers?""]}","{'Findings': [{'Issue': 'Reentrancy Risk in `_submitOrder`, `_safeSubmitOrder`, and `_safeTransferAndUnwrap`', 'Severity': 'High', 'Description': 'Multiple functions (`_submitOrder`, `_safeSubmitOrder`, `_safeTransferAndUnwrap`) make external calls without adequate reentrancy protection. Although the contract uses `nonReentrant` modifiers in some functions, these internal or unprotected functions could allow attackers to re-enter and manipulate the contract state or drain funds.', 'Impact': 'Potential loss of funds or manipulation of contract state through reentrancy attacks.', 'Location': '`_submitOrder`, `_safeSubmitOrder`, and `_safeTransferAndUnwrap` functions'}, {'Issue': 'Incorrect Handling of ETH and Token Transfers', 'Severity': 'High', 'Description': 'Functions like `_safeTransferAndUnwrap` and `_transferInputTokens` handle ETH and ERC20 token transfers but lack proper validation or success checks. For ETH transfers, low-level calls are used without checking success, and for ERC20 tokens, assumptions about compliance or balance are not verified.', 'Impact': 'Potential loss of funds due to failed transfers or incorrect state updates.', 'Location': '`_safeTransferAndUnwrap` and `_transferInputTokens` functions'}, {'Issue': 'Lack of Validation in Critical Functions', 'Severity': 'High', 'Description': 'Functions such as `_transferInputTokens`, `_submitInOrders`, and `_decreaseHoldingAmount` lack input validation for parameters like `_inputTokenAmount`, `_orders` array length, or token addresses. This could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Incorrect token transfers, logical errors, or potential exploits due to unvalidated inputs.', 'Location': '`_transferInputTokens`, `_submitInOrders`, and `_decreaseHoldingAmount` functions'}, {'Issue': 'Inconsistent or Incorrect Fee Calculations', 'Severity': 'Medium', 'Description': 'The `_calculateFees` function calculates fees as a fixed 1% of the input amount but does not handle edge cases (e.g., small amounts rounding to zero) or validate inputs. This could lead to incorrect fee distributions or financial discrepancies.', 'Impact': 'Incorrect fee calculations could result in revenue loss or disputes.', 'Location': '`_calculateFees` function'}, {'Issue': 'Potential ERC-721 and ERC-20 Compliance Issues', 'Severity': 'Medium', 'Description': 'Interactions with `NestedAsset` (ERC-721) and `feeSplitter` (ERC-20) assume compliance with standards but lack explicit validation. Non-compliant implementations could lead to ownership tracking errors or failed transfers.', 'Impact': 'Unexpected behavior, unauthorized transfers, or loss of funds due to non-compliance.', 'Location': 'Functions interacting with `NestedAsset` and `feeSplitter`'}, {'Issue': 'Inefficient Looping and State Updates', 'Severity': 'Medium', 'Description': 'Functions like `_submitInOrders` and `_submitOutOrders` use gas-intensive loops for order processing, and `_submitOrder` performs redundant state updates. This increases transaction costs.', 'Impact': 'High gas consumption and increased costs for users.', 'Location': '`_submitInOrders`, `_submitOutOrders`, and `_submitOrder` functions'}, {'Issue': 'Missing Event Emissions for Critical State Changes', 'Severity': 'Low', 'Description': 'Functions like `setReserve` and `setFeeSplitter` update critical state variables but do not emit events, reducing transparency and auditability.', 'Impact': 'Difficulty in tracking state changes and reduced contract transparency.', 'Location': '`setReserve` and `setFeeSplitter` functions'}, {'Issue': 'Precision Loss in Fee and Under-Spent Handling', 'Severity': 'Low', 'Description': 'Functions like `_handleUnderSpending` and `_calculateFees` may suffer from precision loss for small amounts, leading to residual funds or incorrect calculations.', 'Impact': 'Minor financial discrepancies or residual amounts left in the contract.', 'Location': '`_handleUnderSpending` and `_calculateFees` functions'}], 'IssueNumber': 30, 'OutputList': 8}",310.9492952823639,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Copy your own portfolio to keep earning royalties**

**Report Description**:  
In `NestedFactory.sol`, the `create()` function leads to `sendFeesWithRoyalties()` and `addShares()`. There are no checks preventing users from copying their own portfolio and receiving royalty shares repeatedly, which could lead to abuse and unfair earnings.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of users copying their own portfolios to earn royalties repeatedly. This is a critical oversight in the contract's logic, and the response list fails to identify or mitigate this risk.

---

#### **[M-01] `setReserve()` can be front-run**

**Report Description**:  
The `reserve` address variable in `NestedFactory.sol` remains `0` until `setReserve()` is called by an owner. This could lead to incorrect token transfers or invalid comparisons (e.g., `nestedRecords.getAssetReserve(_nftId) == address(reserve)`) before the `reserve` is set. The immutability of `reserve` requires careful handling.

**Match in Response List**:  
Matches with the issue titled **""Missing Event Emissions for Critical State Changes""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of event emissions for critical state changes, which is related to the `setReserve()` function. However, it does not address the front-running risk or the immutability concerns highlighted in the issue report. The response partially covers the issue but misses critical details.

---

#### **[M-06] `NestedFactory.sol#_submitInOrders()` Wrong implementation cause users to be overcharged**

**Report Description**:  
When executing orders, the actual `amountSpent + feesAmount` can be lower than `_inputTokenAmount`. The unspent amount should be returned to the user, but the current implementation takes it as part of the fee, leading to users being overcharged.

**Match in Response List**:  
Matches with the issue titled **""Precision Loss in Fee and Under-Spent Handling""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of precision loss and under-spent handling in fee calculations. It correctly explains the risk of users being overcharged due to incorrect handling of unspent amounts, aligning with the issue report.

---

#### **[M-07] Ensure on-chain that cache is synced**

**Report Description**:  
Core operations like `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()` assume the cache is synced before execution. However, this assumption may not hold, leading to potential vulnerabilities or incorrect behavior.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of ensuring the cache is synced before executing critical operations. This is a significant oversight, as it could lead to vulnerabilities or incorrect contract behavior.

---

#### **[M-08] Passing multiple ETH deposits in orders array will use the same `msg.value` many times**

**Report Description**:  
A malicious user can exploit the `_transferInputTokens` function by passing multiple ETH deposits in the orders array, reusing the same `msg.value` multiple times. This could allow the user to drain the contract's holdings by repeatedly depositing and withdrawing value.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Handling of ETH and Token Transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of incorrect handling of ETH and token transfers, including the risk of reusing `msg.value` multiple times. It correctly explains the potential for contract funds to be drained, aligning with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-06] `NestedFactory.sol#_submitInOrders()` Wrong implementation cause users to be overcharged**
- **[M-08] Passing multiple ETH deposits in orders array will use the same `msg.value` many times**

**Partially Correct Matches**:

- **[M-01] `setReserve()` can be front-run**

**Missed Issues from Issue Report**:

- **[H-01] Copy your own portfolio to keep earning royalties**
- **[M-07] Ensure on-chain that cache is synced**

--- 

The response list covers some issues accurately but misses critical vulnerabilities like portfolio copying and cache synchronization. Additionally, the front-running issue is only partially addressed. Improvements are needed to ensure comprehensive coverage of all identified risks.","```
1. Precision Loss in Fee and Under-Spent Handling
2. Incorrect Handling of ETH and Token Transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Precision Loss in Fee and Under-Spent Handling** appears at rank 8.
   - **Incorrect Handling of ETH and Token Transfers** appears at rank 2.

2. **Calculate the precision at each rank**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 8: \( P@8 = \frac{2}{8} = 0.25 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.25}{2} = 0.375 \)

**Output**:
```
0.375
```"
FeeSplitter.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";

/// @title Manage the fees between shareholders
/// @notice Receives fees collected by the NestedFactory, and splits the income among
/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).
contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Emitted when a payment is released
    /// @param to The address receiving the payment
    /// @param token The token transfered
    /// @param amount The amount paid
    event PaymentReleased(address to, address token, uint256 amount);

    /// @dev Emitted when a payment is released
    /// @param from The address sending the tokens
    /// @param token The token received
    /// @param amount The amount received
    event PaymentReceived(address from, address token, uint256 amount);

    /// @dev Represent a shareholder
    /// @param account Shareholders address that can receive income
    /// @param weight Determines share allocation
    struct Shareholder {
        address account;
        uint256 weight;
    }

    /// @dev Registers shares and amount release for a specific token or ETH
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    /// @dev Map of tokens with the tokenRecords
    mapping(address => TokenRecords) private tokenRecords;

    /// @dev All the shareholders (array)
    Shareholder[] private shareholders;

    /// @dev Royalties part weights when applicable
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        // Initial shareholders addresses and weights
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    /// @dev Receive ether after a WETH withdraw call
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.
    /// @param _account Account address to check the amount due for
    /// @param _token ERC20 payment token address (or ETH_ADDR)
    /// @return The total amount due for the requested currency
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    /// @notice Sets the weight assigned to the royalties part for the fee
    /// @param _weight The new royalties weight
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    /// @notice Sets a new list of shareholders
    /// @param _accounts Shareholders accounts list
    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    /// @param _token Payment token address
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    /// @notice Call releaseToken() for multiple tokens
    /// @param _tokens ERC20 tokens to release
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token
    /// @param _royaltiesTarget The account that can claim royalties
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    /// @notice Updates weight for a shareholder
    /// @param _accountIndex Account to change the weight of
    /// @param _weight The new weight
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    /// @notice Getter for the total shares held by shareholders.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total shares count
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    /// @notice Getter for the total amount of token already released.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total amount release to shareholders
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    /// @notice Getter for the amount of shares held by an account.
    /// @param _account Account the shares belong to
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The shares owned by the account
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    /// @notice Getter for the amount of Ether already released to a shareholders.
    /// @param _account The target account for this request
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The amount already released to this account
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    /// @notice Finds a shareholder and return its index
    /// @param _account Account to find
    /// @return The shareholder index in the storage array
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    /// @dev Transfers a fee to this contract
    /// @param _token Currency for the fee
    /// @param _amount Amount of token as fee
    /// @param _totalWeights Total weights to determine the share count to allocate
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    /// @dev Increase the shares of a shareholder
    /// @param _account The shareholder address
    /// @param _shares The shares of the holder
    /// @param _token The updated token
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}

",2615,277,"[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice.

Function `_sendFee()`

It is possible for duplicate shareholders to be added. These shareholders will get more than intended when _sendFee() is called.
Recommended Mitigation Steps

Ensure that the _accounts array is sorted in setShareholders().
for (uint256 i = 0; i < _accounts.length; i++) {
	if (i > 0) {
		require(_accounts[i - 1] < _accounts[i], ""FeeSplitter: ACCOUNTS_NOT_SORTED"");
	}
	_addShareholder(_accounts[i], _weights[i]);
}
  [M-04] FeeSplitter: Unbounded number of shareholders can cause DOS

Impact

There is no limit to the number of shareholders. It is therefore possible to set a large number of shareholders such that `_sendFees()` will run out of gas when adding shares to each shareholder. This will cause denial of service to all NestedFactory functions, especially the ones that will remove funds like withdraw() and destroy().
",2,,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";




contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    
    
    
    event PaymentReleased(address to, address token, uint256 amount);

    
    
    
    
    event PaymentReceived(address from, address token, uint256 amount);

    
    
    
    struct Shareholder {
        address account;
        uint256 weight;
    }

    
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    
    mapping(address => TokenRecords) private tokenRecords;

    
    Shareholder[] private shareholders;

    
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    
    
    
    
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    
    
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    
    
    
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    
    
    
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    
    
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    
    
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    
    
    
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    
    
    
    
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    
    
    
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    
    
    
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    
    
    
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    
    
    
    
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    
    
    
    
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    
    
    
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    
    
    
    
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    
    
    
    
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",1677,0,2,,"{'ReviewingTheCode': ""The contract 'FeeSplitter' is designed to manage and distribute fees among shareholders and handle royalties. It inherits from OpenZeppelin's Ownable and ReentrancyGuard contracts to provide ownership control and protection against reentrancy attacks. The contract uses SafeERC20 for safe token transfers and interacts with WETH (Wrapped Ether) for handling ETH transactions."", 'IdentifyingKeyComponents': {'ContractName': 'FeeSplitter', 'Purpose': 'To distribute fees among shareholders and handle royalties in a secure and efficient manner.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable', 'ReentrancyGuard'], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/access/Ownable.sol', '@openzeppelin/contracts/security/ReentrancyGuard.sol', '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol', './interfaces/external/IWETH.sol']}, 'StateVariables': [{'Name': 'ETH', 'Type': 'address', 'Purpose': 'Constant address representing Ether.'}, {'Name': 'tokenRecords', 'Type': 'mapping(address => TokenRecords)', 'Purpose': 'Stores token-specific records including total shares, total released, and individual shareholder details.'}, {'Name': 'shareholders', 'Type': 'Shareholder[]', 'Purpose': 'Array of shareholders with their respective weights.'}, {'Name': 'royaltiesWeight', 'Type': 'uint256', 'Purpose': 'Weight assigned to royalties.'}, {'Name': 'totalWeights', 'Type': 'uint256', 'Purpose': 'Total weights of all shareholders and royalties.'}, {'Name': 'weth', 'Type': 'address', 'Purpose': 'Address of the WETH contract.'}], 'FunctionsAndModifiers': [{'Name': 'getAmountDue', 'Visibility': 'public', 'Purpose': 'Calculates the amount due to a shareholder for a specific token.', 'Parameters': ['address _account', 'IERC20 _token'], 'Returns': ['uint256']}, {'Name': 'setRoyaltiesWeight', 'Visibility': 'public', 'Purpose': 'Sets the weight for royalties.', 'Parameters': ['uint256 _weight'], 'Returns': []}, {'Name': 'setShareholders', 'Visibility': 'public', 'Purpose': 'Sets the list of shareholders and their weights.', 'Parameters': ['address[] memory _accounts', 'uint256[] memory _weights'], 'Returns': []}, {'Name': 'releaseToken', 'Visibility': 'public', 'Purpose': 'Releases the due amount of a specific token to the caller.', 'Parameters': ['IERC20 _token'], 'Returns': []}, {'Name': 'releaseTokens', 'Visibility': 'external', 'Purpose': 'Releases the due amounts of multiple tokens to the caller.', 'Parameters': ['IERC20[] memory _tokens'], 'Returns': []}, {'Name': 'releaseETH', 'Visibility': 'external', 'Purpose': 'Releases the due amount of ETH to the caller.', 'Parameters': [], 'Returns': []}, {'Name': 'sendFees', 'Visibility': 'external', 'Purpose': 'Sends fees to the contract and distributes them among shareholders.', 'Parameters': ['IERC20 _token', 'uint256 _amount'], 'Returns': []}, {'Name': 'sendFeesWithRoyalties', 'Visibility': 'external', 'Purpose': 'Sends fees to the contract, distributes them among shareholders, and handles royalties.', 'Parameters': ['address _royaltiesTarget', 'IERC20 _token', 'uint256 _amount'], 'Returns': []}, {'Name': 'updateShareholder', 'Visibility': 'external', 'Purpose': 'Updates the weight of a specific shareholder.', 'Parameters': ['uint256 _accountIndex', 'uint256 _weight'], 'Returns': []}, {'Name': 'totalShares', 'Visibility': 'external', 'Purpose': 'Returns the total shares for a specific token.', 'Parameters': ['address _token'], 'Returns': ['uint256']}, {'Name': 'totalReleased', 'Visibility': 'external', 'Purpose': 'Returns the total released amount for a specific token.', 'Parameters': ['address _token'], 'Returns': ['uint256']}, {'Name': 'shares', 'Visibility': 'external', 'Purpose': 'Returns the shares of a specific account for a specific token.', 'Parameters': ['address _account', 'address _token'], 'Returns': ['uint256']}, {'Name': 'released', 'Visibility': 'external', 'Purpose': 'Returns the released amount of a specific account for a specific token.', 'Parameters': ['address _account', 'address _token'], 'Returns': ['uint256']}, {'Name': 'findShareholder', 'Visibility': 'external', 'Purpose': 'Finds the index of a shareholder in the shareholders array.', 'Parameters': ['address _account'], 'Returns': ['uint256']}, {'Name': '_sendFees', 'Visibility': 'private', 'Purpose': 'Internal function to send fees and distribute them among shareholders.', 'Parameters': ['IERC20 _token', 'uint256 _amount', 'uint256 _totalWeights'], 'Returns': []}, {'Name': '_addShares', 'Visibility': 'private', 'Purpose': 'Internal function to add shares to a specific account for a specific token.', 'Parameters': ['address _account', 'uint256 _shares', 'address _token'], 'Returns': []}, {'Name': '_releaseToken', 'Visibility': 'private', 'Purpose': 'Internal function to release the due amount of a specific token to a specific account.', 'Parameters': ['address _account', 'IERC20 _token'], 'Returns': ['uint256']}, {'Name': '_addShareholder', 'Visibility': 'private', 'Purpose': 'Internal function to add a new shareholder with a specific weight.', 'Parameters': ['address _account', 'uint256 _weight'], 'Returns': []}, {'Name': '_computeShareCount', 'Visibility': 'private', 'Purpose': 'Internal function to compute the share count based on the amount, weight, and total weights.', 'Parameters': ['uint256 _amount', 'uint256 _weight', 'uint256 _totalWeights'], 'Returns': ['uint256']}]}, 'ExternalInteractions': [""OpenZeppelin's IERC20, Ownable, ReentrancyGuard, and SafeERC20 contracts."", 'IWETH interface for WETH interactions.'], 'SpecialMechanisms': ['ReentrancyGuard for protection against reentrancy attacks.', 'SafeERC20 for safe token transfers.', 'Weight-based fee distribution among shareholders and royalties.'], 'Questions': ['How is the initial setup of shareholders and weights handled?', 'What is the rationale behind the constant ETH address?', 'Are there any potential edge cases in the fee distribution logic?', 'How is the WETH contract integrated and why is it necessary?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `releaseETH` Function', 'Severity': 'High', 'Description': 'The `releaseETH` function uses a low-level `call` to transfer ETH after withdrawing WETH, which could be exploited by a malicious contract to re-enter the function before state updates. Although marked as `nonReentrant`, the external call introduces a reentrancy risk.', 'Impact': ""An attacker could repeatedly call `releaseETH` to drain the contract's ETH balance."", 'Location': 'Function: `releaseETH`'}, {'Issue': 'Lack of Input Validation in `setShareholders` Function', 'Severity': 'Medium', 'Description': 'The `setShareholders` function does not validate the uniqueness of addresses in the `_accounts` array. Duplicate addresses could lead to incorrect weight distribution and unfair fund allocation.', 'Impact': 'Incorrect fee distribution, potential financial loss, or exploitation by malicious users.', 'Location': 'Function: `setShareholders`'}, {'Issue': 'Potential Division by Zero in `_computeShareCount` Function', 'Severity': 'Medium', 'Description': 'The `_computeShareCount` function divides by `_totalWeights` without checking if it is zero, which could cause a division-by-zero error and revert the transaction.', 'Impact': 'Transaction reversion, potential denial of service, or disruption of fee distribution.', 'Location': 'Function: `_computeShareCount`'}, {'Issue': 'Division Precision Loss or Incorrect Order in `_computeShareCount`', 'Severity': 'Medium', 'Description': ""The `_computeShareCount` function may suffer from precision loss due to Solidity's integer division or perform division before multiplication, leading to inaccurate share calculations."", 'Impact': 'Minor inaccuracies in fund distribution, potentially unfair allocations over time.', 'Location': 'Function: `_computeShareCount`'}, {'Issue': 'Potential Integer Overflow in `_computeShareCount` or `_addShares`', 'Severity': 'Medium', 'Description': 'Multiplication operations in `_computeShareCount` or addition in `_addShares` could overflow if inputs are large, though Solidity 0.8.x has built-in checks. Explicit validation is still recommended.', 'Impact': 'Incorrect share or weight calculations, leading to fund distribution errors.', 'Location': 'Functions: `_computeShareCount`, `_addShares`'}, {'Issue': 'Incorrect ETH Handling in `receive` Function', 'Severity': 'Medium', 'Description': 'The `receive` function restricts ETH deposits to only the WETH contract, which may not be intended and could lead to lost funds if ETH is sent from other sources.', 'Impact': 'Loss of ETH sent from non-WETH sources or unintended contract behavior.', 'Location': 'Function: `receive`'}, {'Issue': 'Potential Denial of Service in Iterative Functions', 'Severity': 'Medium', 'Description': 'Functions like `sendFees`, `sendFeesWithRoyalties`, or `findShareholder` iterate over the `shareholders` array, which could exceed gas limits if the array grows too large.', 'Impact': 'High gas costs or transaction failures, rendering the contract unusable for large shareholder sets.', 'Location': 'Functions: `sendFees`, `sendFeesWithRoyalties`, `findShareholder`'}, {'Issue': 'Missing Zero Address Checks', 'Severity': 'Low', 'Description': 'Functions like `_addShareholder` or `sendFeesWithRoyalties` lack checks for zero addresses, which could lead to funds being sent to invalid addresses or incorrect state updates.', 'Impact': 'Permanent loss of funds or unintended contract state.', 'Location': 'Functions: `_addShareholder`, `sendFeesWithRoyalties`'}, {'Issue': 'Incorrect ETH Address Constant', 'Severity': 'Low', 'Description': 'The contract uses a non-standard constant (`0xEeeeeE...`) to represent ETH, which could cause confusion or errors during interactions.', 'Impact': 'Developer confusion or integration issues.', 'Location': 'Variable: `ETH`'}, {'Issue': 'Lack of Event Emission in `_addShareholder`', 'Severity': 'Low', 'Description': 'The `_addShareholder` function does not emit events, reducing transparency for tracking shareholder changes.', 'Impact': 'Reduced auditability and off-chain monitoring capabilities.', 'Location': 'Function: `_addShareholder`'}, {'Issue': 'Unrestricted Access to `updateShareholder`', 'Severity': 'Low', 'Description': 'The `updateShareholder` function allows the owner to modify shareholder weights without validation, potentially enabling unfair manipulation.', 'Impact': 'Unintended weight changes, leading to incorrect fee distribution.', 'Location': 'Function: `updateShareholder`'}], 'IssueNumber': 32, 'OutputList': 11}",329.00220704078674,"### **Output**

---

**[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**

**Report Description**:  
The `_sendFee()` function in the `FeeSplitter` contract does not include a sanity check to prevent duplicate shareholders from being added. This oversight could lead to unintended behavior where duplicate shareholders receive more than their intended share of fees when `_sendFee()` is called. The recommended mitigation is to ensure the `_accounts` array is sorted and to add a check to prevent duplicates.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `setShareholders` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of missing input validation in the `setShareholders` function, specifically the lack of uniqueness checks for addresses in the `_accounts` array. This aligns with the reported issue, as both highlight the risk of duplicate shareholders leading to incorrect fee distribution.

---

**[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

**Report Description**:  
The `FeeSplitter` contract does not impose a limit on the number of shareholders. This could allow an attacker to set a large number of shareholders, causing the `_sendFees()` function to run out of gas during execution. This would result in a denial of service (DOS) for critical functions like `withdraw()` and `destroy()`, disrupting the contract's functionality.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service in Iterative Functions""**.

**Validation**:  
**Correct**. The response correctly identifies the risk of denial of service due to unbounded iterations over the `shareholders` array in functions like `sendFees`. This matches the reported issue, as both emphasize the potential for gas exhaustion and transaction failures when the array grows too large.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**
- **[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

--- 

### **Conclusion**  
The `response_list` effectively covers the issues reported in the `issue` list, accurately identifying the vulnerabilities and their impacts. Both issues are correctly matched and validated, demonstrating a strong alignment with Solidity best practices and security standards.","```
1. Lack of Input Validation in `setShareholders` Function
2. Potential Denial of Service in Iterative Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - `Lack of Input Validation in setShareholders Function` appears at rank 2.
   - `Potential Denial of Service in Iterative Functions` appears at rank 7.

2. **Calculate the precision at each rank**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 7: \( P@7 = \frac{2}{7} \approx 0.2857 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.2857}{2} = \frac{0.7857}{2} \approx 0.3929 \)

**Average Precision (AP)**: 0.3929"
